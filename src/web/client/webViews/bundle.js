(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseContainerRuntimeFactory = void 0;
const container_runtime_1 = require("@fluidframework/container-runtime");
const container_runtime_definitions_1 = require("@fluidframework/container-runtime-definitions");
const request_handler_1 = require("@fluidframework/request-handler");
const synthesize_1 = require("@fluidframework/synthesize");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
 * BaseContainerRuntimeFactory produces container runtimes with a given data store and service registry, as well as
 * given request handlers.  It can be subclassed to implement a first-time initialization procedure for the containers
 * it creates.
 */
class BaseContainerRuntimeFactory extends runtime_utils_1.RuntimeFactoryHelper {
    /**
     * @param registryEntries - The data store registry for containers produced
     * @param serviceRegistry - The service registry for containers produced
     * @param requestHandlers - Request handlers for containers produced
     * @param runtimeOptions - The runtime options passed to the ContainerRuntime when instantiating it
     */
    constructor(registryEntries, dependencyContainer, requestHandlers = [], runtimeOptions) {
        super();
        this.registryEntries = registryEntries;
        this.dependencyContainer = dependencyContainer;
        this.requestHandlers = requestHandlers;
        this.runtimeOptions = runtimeOptions;
        this.registry = new container_runtime_1.FluidDataStoreRegistry(registryEntries);
    }
    get IFluidDataStoreRegistry() { return this.registry; }
    async instantiateFirstTime(runtime) {
        await this.containerInitializingFirstTime(runtime);
        await this.containerHasInitialized(runtime);
    }
    async instantiateFromExisting(runtime) {
        await this.containerHasInitialized(runtime);
    }
    async preInitialize(context, existing) {
        const scope = context.scope;
        const dc = new synthesize_1.DependencyContainer(this.dependencyContainer, scope.IFluidDependencySynthesizer);
        scope.IFluidDependencySynthesizer = dc;
        const runtime = await container_runtime_1.ContainerRuntime.load(context, this.registryEntries, (0, request_handler_1.buildRuntimeRequestHandler)(...this.requestHandlers), this.runtimeOptions, scope, existing);
        // we register the runtime so developers of providers can use it in the factory pattern.
        dc.register(container_runtime_definitions_1.IContainerRuntime, runtime);
        return runtime;
    }
    /**
     * Subclasses may override containerInitializingFirstTime to perform any setup steps at the time the container
     * is created. This likely includes creating any initial data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerInitializingFirstTime(runtime) { }
    /**
     * Subclasses may override containerHasInitialized to perform any steps after the container has initialized.
     * This likely includes loading any data stores that are expected to be there at the outset.
     * @param runtime - The container runtime for the container being initialized
     */
    async containerHasInitialized(runtime) { }
}
exports.BaseContainerRuntimeFactory = BaseContainerRuntimeFactory;

},{"@fluidframework/container-runtime":68,"@fluidframework/container-runtime-definitions":55,"@fluidframework/request-handler":182,"@fluidframework/runtime-utils":213,"@fluidframework/synthesize":271}],2:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerRuntimeFactoryWithDefaultDataStore = void 0;
const request_handlers_1 = require("../request-handlers");
const baseContainerRuntimeFactory_1 = require("./baseContainerRuntimeFactory");
const defaultDataStoreId = "default";
/**
 * A ContainerRuntimeFactory that initializes Containers with a single default data store, which can be requested from
 * the container with an empty URL.
 *
 * This factory should be exposed as fluidExport off the entry point to your module.
 */
class ContainerRuntimeFactoryWithDefaultDataStore extends baseContainerRuntimeFactory_1.BaseContainerRuntimeFactory {
    constructor(defaultFactory, registryEntries, dependencyContainer, requestHandlers = [], runtimeOptions) {
        super(registryEntries, dependencyContainer, [
            (0, request_handlers_1.defaultRouteRequestHandler)(defaultDataStoreId),
            ...requestHandlers,
        ], runtimeOptions);
        this.defaultFactory = defaultFactory;
    }
    /**
     * {@inheritDoc BaseContainerRuntimeFactory.containerInitializingFirstTime}
     */
    async containerInitializingFirstTime(runtime) {
        const dataStore = await runtime.createDataStore(this.defaultFactory.type);
        await dataStore.trySetAlias(defaultDataStoreId);
    }
}
exports.ContainerRuntimeFactoryWithDefaultDataStore = ContainerRuntimeFactoryWithDefaultDataStore;
ContainerRuntimeFactoryWithDefaultDataStore.defaultDataStoreId = defaultDataStoreId;

},{"../request-handlers":13,"./baseContainerRuntimeFactory":1}],3:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./baseContainerRuntimeFactory"), exports);
__exportStar(require("./containerRuntimeFactoryWithDefaultDataStore"), exports);

},{"./baseContainerRuntimeFactory":1,"./containerRuntimeFactoryWithDefaultDataStore":2}],4:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateContainerServicesRequestHandler = exports.BaseContainerService = exports.serviceRoutePathRoot = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
// TODO: should this just be "s"?
exports.serviceRoutePathRoot = "_services";
/**
 * This class is a simple starter class for building a Container Service. It simply provides routing
 */
class BaseContainerService {
    constructor(runtime) {
        this.runtime = runtime;
    }
    get IFluidRouter() { return this; }
    async request(request) {
        return {
            status: 200,
            mimeType: "fluid/object",
            value: this,
        };
    }
}
exports.BaseContainerService = BaseContainerService;
/**
 * ContainerService Factory that will only create one instance of the service for the Container.
 */
class SingletonContainerServiceFactory {
    constructor(serviceFn) {
        this.serviceFn = serviceFn;
    }
    async getService(runtime) {
        if (!this.service) {
            this.service = this.serviceFn(runtime);
        }
        return this.service;
    }
}
/**
 * Given a collection of IContainerServices will produce a RequestHandler for them all
 * @param serviceRegistry - Collection of Container Services
 */
const generateContainerServicesRequestHandler = (serviceRegistry) => {
    const factories = new Map();
    new Map(serviceRegistry).forEach((fn, id) => {
        factories.set(id, new SingletonContainerServiceFactory(fn));
    });
    return async (request, runtime) => {
        if (request.pathParts[0] !== exports.serviceRoutePathRoot) {
            // If the request is not for a service we return undefined so the next handler can use it
            return undefined;
        }
        if (request.pathParts.length < 2) {
            // If there is not service to route to then return a failure
            return (0, runtime_utils_1.createResponseError)(400, "request did not specify a service to route to", request);
        }
        const factory = factories.get(request.pathParts[1]);
        if (!factory) {
            // If we can't find a registry entry then return
            return (0, runtime_utils_1.create404Response)(request);
        }
        const service = await factory.getService(runtime);
        const router = service.IFluidRouter;
        const subRequest = request.createSubRequest(2);
        if (router) {
            return router.request(subRequest);
        }
        if (!request.isLeaf(2)) {
            // If there is not terminating route but a sub-route was requested then we will fail.
            return (0, runtime_utils_1.createResponseError)(400, "request sub-url for service that doesn't support routing", request);
        }
        // Otherwise we will just return the service
        return {
            status: 200,
            mimeType: "fluid/object",
            value: service,
        };
    };
};
exports.generateContainerServicesRequestHandler = generateContainerServicesRequestHandler;

},{"@fluidframework/runtime-utils":213}],5:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./containerServices"), exports);

},{"./containerServices":4}],6:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataObjectFactory = void 0;
const map_1 = require("@fluidframework/map");
const datastore_1 = require("@fluidframework/datastore");
const pureDataObjectFactory_1 = require("./pureDataObjectFactory");
/**
 * DataObjectFactory is the IFluidDataStoreFactory for use with DataObjects.
 * It facilitates DataObject's features (such as its shared directory) by
 * ensuring relevant shared objects etc are available to the factory.
 *
 * @typeParam TObj - DataObject (concrete type)
 * @typeParam I - The input types for the DataObject
 */
class DataObjectFactory extends pureDataObjectFactory_1.PureDataObjectFactory {
    constructor(type, ctor, sharedObjects = [], optionalProviders, registryEntries, runtimeFactory = datastore_1.FluidDataStoreRuntime) {
        const mergedObjects = [...sharedObjects];
        if (!sharedObjects.find((factory) => factory.type === map_1.DirectoryFactory.Type)) {
            // User did not register for directory
            mergedObjects.push(map_1.SharedDirectory.getFactory());
        }
        // TODO: Remove SharedMap factory when compatibility with SharedMap DataObject is no longer needed in 0.10
        if (!sharedObjects.find((factory) => factory.type === map_1.MapFactory.Type)) {
            // User did not register for map
            mergedObjects.push(map_1.SharedMap.getFactory());
        }
        super(type, ctor, mergedObjects, optionalProviders, registryEntries, runtimeFactory);
    }
}
exports.DataObjectFactory = DataObjectFactory;

},{"./pureDataObjectFactory":8,"@fluidframework/datastore":93,"@fluidframework/map":137}],7:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./dataObjectFactory"), exports);
__exportStar(require("./pureDataObjectFactory"), exports);

},{"./dataObjectFactory":6,"./pureDataObjectFactory":8}],8:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PureDataObjectFactory = void 0;
const datastore_1 = require("@fluidframework/datastore");
const container_runtime_1 = require("@fluidframework/container-runtime");
const synthesize_1 = require("@fluidframework/synthesize");
const data_objects_1 = require("../data-objects");
/**
 * Proxy over PureDataObject
 * Does delayed creation & initialization of PureDataObject
*/
async function createDataObject(ctor, context, sharedObjectRegistry, optionalProviders, runtimeClassArg, existing, initProps) {
    // base
    let runtimeClass = runtimeClassArg;
    // request mixin in
    runtimeClass = (0, datastore_1.mixinRequestHandler)(async (request, runtimeArg) => (await data_objects_1.PureDataObject.getDataObject(runtimeArg)).request(request), runtimeClass);
    // Create a new runtime for our data store
    // The runtime is what Fluid uses to create DDS' and route to your data store
    const runtime = new runtimeClass(context, sharedObjectRegistry, existing);
    // Create object right away.
    // This allows object to register various callbacks with runtime before runtime
    // becomes globally available. But it's not full initialization - constructor can't
    // access DDSes or other services of runtime as objects are not fully initialized.
    // In order to use object, we need to go through full initialization by calling finishInitialization().
    const scope = context.scope;
    const dependencyContainer = new synthesize_1.DependencyContainer(scope.IFluidDependencySynthesizer);
    const providers = dependencyContainer.synthesize(optionalProviders, {});
    const instance = new ctor({ runtime, context, providers, initProps });
    // if it's a newly created object, we need to wait for it to finish initialization
    // as that results in creation of DDSes, before it gets attached, providing atomic
    // guarantee of creation.
    // WARNING: we can't do the same (yet) for already existing PureDataObject!
    // This will result in deadlock, as it tries to resolve internal handles, but any
    // handle resolution goes through root (container runtime), which can't route it back
    // to this data store, as it's still not initialized and not known to container runtime yet.
    // In the future, we should address it by using relative paths for handles and be able to resolve
    // local DDSes while data store is not fully initialized.
    if (!existing) {
        await instance.finishInitialization(existing);
    }
    return { instance, runtime };
}
/**
 * PureDataObjectFactory is a barebones IFluidDataStoreFactory for use with PureDataObject.
 * Consumers should typically use DataObjectFactory instead unless creating
 * another base data store factory.
 *
 * @typeParam TObj - DataObject (concrete type)
 * @typeParam I - The input types for the DataObject
 */
class PureDataObjectFactory {
    constructor(type, ctor, sharedObjects, optionalProviders, registryEntries, runtimeClass = datastore_1.FluidDataStoreRuntime) {
        this.type = type;
        this.ctor = ctor;
        this.optionalProviders = optionalProviders;
        this.runtimeClass = runtimeClass;
        if (this.type === "") {
            throw new Error("undefined type member");
        }
        if (registryEntries !== undefined) {
            this.registry = new container_runtime_1.FluidDataStoreRegistry(registryEntries);
        }
        this.sharedObjectRegistry = new Map(sharedObjects.map((ext) => [ext.type, ext]));
    }
    get IFluidDataStoreFactory() { return this; }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    /**
     * Convenience helper to get the data store's/factory's data store registry entry.
     * The return type hides the factory's generics, easing grouping of registry
     * entries that differ only in this way into the same array.
     * @returns The NamedFluidDataStoreRegistryEntry
     */
    get registryEntry() {
        return [this.type, Promise.resolve(this)];
    }
    /**
     * This is where we do data store setup.
     *
     * @param context - data store context used to load a data store runtime
     */
    async instantiateDataStore(context, existing) {
        const { runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, existing);
        return runtime;
    }
    /**
     * Creates a new instance of the object. Uses parent context's registry to build package path to this factory.
     * In other words, registry of context passed in has to contain this factory, with the name that matches
     * this factory's type.
     * It is intended to be used by data store objects that create sub-objects.
     * @param context - The context being used to create the runtime
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created data store.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createChildInstance(parentContext, initialState) {
        return this.createNonRootInstanceCore(parentContext.containerRuntime, [...parentContext.packagePath, this.type], initialState);
    }
    /**
     * Creates a new instance of the object. Uses peer context's registry and its package path to identify this factory.
     * In other words, registry of context passed in has to have this factory.
     * Intended to be used by data store objects that need to create peers (similar) instances of existing objects.
     * @param context - The component context being used to create the object
     * (the created object will have its own new context created as well)
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createPeerInstance(peerContext, initialState) {
        return this.createNonRootInstanceCore(peerContext.containerRuntime, peerContext.packagePath, initialState);
    }
    /**
     * Creates a new instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createInstance(runtime, initialState) {
        return this.createNonRootInstanceCore(runtime, [this.type], initialState);
    }
    /**
     * Creates a new root instance of the object. Uses container's registry to find this factory.
     * It's expected that only container owners would use this functionality, as only such developers
     * have knowledge of entries in container registry.
     * The name in this registry for such record should match type of this factory.
     * @param runtime - container runtime. It's registry is used to create an object.
     * @param initialState - The initial state to provide to the created component.
     * @returns an object created by this factory. Data store and objects created are not attached to container.
     * They get attached only when a handle to one of them is attached to already attached objects.
     */
    async createRootInstance(rootDataStoreId, runtime, initialState) {
        const context = runtime.createDetachedRootDataStore([this.type], rootDataStoreId);
        return this.createInstanceCore(context, initialState);
    }
    async createNonRootInstanceCore(containerRuntime, packagePath, initialState) {
        const context = containerRuntime.createDetachedDataStore(packagePath);
        return this.createInstanceCore(context, initialState);
    }
    async createInstanceCore(context, initialState) {
        const { instance, runtime } = await createDataObject(this.ctor, context, this.sharedObjectRegistry, this.optionalProviders, this.runtimeClass, false, // existing
        initialState);
        await context.attachRuntime(this, runtime);
        return instance;
    }
}
exports.PureDataObjectFactory = PureDataObjectFactory;

},{"../data-objects":10,"@fluidframework/container-runtime":68,"@fluidframework/datastore":93,"@fluidframework/synthesize":271}],9:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataObject = void 0;
const map_1 = require("@fluidframework/map");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const pureDataObject_1 = require("./pureDataObject");
/**
 * DataObject is a base data store that is primed with a root directory. It
 * ensures that it is created and ready before you can access it.
 *
 * Having a single root directory allows for easier development. Instead of creating
 * and registering channels with the runtime any new DDS that is set on the root
 * will automatically be registered.
 *
 * @typeParam I - The optional input types used to strongly type the data object
 */
class DataObject extends pureDataObject_1.PureDataObject {
    constructor() {
        super(...arguments);
        this.rootDirectoryId = "root";
    }
    /**
     * {@inheritDoc PureDataObject.request}
     */
    async request(request) {
        const requestParser = runtime_utils_1.RequestParser.create(request);
        const itemId = requestParser.pathParts[0];
        if (itemId === "bigBlobs") {
            const value = this.root.get(requestParser.pathParts.join("/"));
            if (value === undefined) {
                return (0, runtime_utils_1.create404Response)(requestParser);
            }
            return { mimeType: "fluid/object", status: 200, value };
        }
        else {
            return super.request(requestParser);
        }
    }
    /**
     * The root directory will either be ready or will return an error. If an error is thrown
     * the root has not been correctly created/set.
     */
    get root() {
        if (!this.internalRoot) {
            throw new Error(this.getUninitializedErrorString(`root`));
        }
        return this.internalRoot;
    }
    /**
     * Initializes internal objects and calls initialization overrides.
     * Caller is responsible for ensuring this is only invoked once.
     */
    async initializeInternal(existing) {
        if (!existing) {
            // Create a root directory and register it before calling initializingFirstTime
            this.internalRoot = map_1.SharedDirectory.create(this.runtime, this.rootDirectoryId);
            this.internalRoot.bindToContext();
        }
        else {
            // data store has a root directory so we just need to set it before calling initializingFromExisting
            this.internalRoot = await this.runtime.getChannel(this.rootDirectoryId);
            // This will actually be an ISharedMap if the channel was previously created by the older version of
            // DataObject which used a SharedMap.  Since SharedMap and SharedDirectory are compatible unless
            // SharedDirectory-only commands are used on SharedMap, this will mostly just work for compatibility.
            if (this.internalRoot.attributes.type === map_1.MapFactory.Type) {
                this.runtime.logger.send({
                    category: "generic",
                    eventName: "MapDataObject",
                    message: "Legacy document, SharedMap is masquerading as SharedDirectory in DataObject",
                });
            }
        }
        await super.initializeInternal(existing);
    }
    /**
     * Generates an error string indicating an item is uninitialized.
     * @param item - The name of the item that was uninitialized.
     */
    getUninitializedErrorString(item) {
        return `${item} must be initialized before being accessed.`;
    }
}
exports.DataObject = DataObject;

},{"./pureDataObject":11,"@fluidframework/map":137,"@fluidframework/runtime-utils":213}],10:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PureDataObject = exports.DataObject = void 0;
var dataObject_1 = require("./dataObject");
Object.defineProperty(exports, "DataObject", { enumerable: true, get: function () { return dataObject_1.DataObject; } });
var pureDataObject_1 = require("./pureDataObject");
Object.defineProperty(exports, "PureDataObject", { enumerable: true, get: function () { return pureDataObject_1.PureDataObject; } });

},{"./dataObject":9,"./pureDataObject":11}],11:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PureDataObject = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const datastore_1 = require("@fluidframework/datastore");
const request_handler_1 = require("@fluidframework/request-handler");
const container_services_1 = require("../container-services");
const request_handlers_1 = require("../request-handlers");
/**
 * This is a bare-bones base class that does basic setup and enables for factory on an initialize call.
 * You probably don't want to inherit from this data store directly unless
 * you are creating another base data store class
 *
 * @typeParam I - The optional input types used to strongly type the data object
 */
class PureDataObject extends common_utils_1.EventForwarder {
    constructor(props) {
        super();
        this._disposed = false;
        this.runtime = props.runtime;
        this.context = props.context;
        this.providers = props.providers;
        this.initProps = props.initProps;
        (0, common_utils_1.assert)(this.runtime._dataObject === undefined, 0x0bd /* "Object runtime already has DataObject!" */);
        this.runtime._dataObject = this;
        // Create a FluidObjectHandle with empty string as `path`. This is because reaching this PureDataObject is the
        // same as reaching its routeContext (FluidDataStoreRuntime) so the relative path to it from the
        // routeContext is empty.
        this.innerHandle = new datastore_1.FluidObjectHandle(this, "", this.runtime.objectsRoutingContext);
        // Container event handlers
        this.runtime.once("dispose", () => {
            this._disposed = true;
            this.dispose();
        });
    }
    get disposed() { return this._disposed; }
    get id() { return this.runtime.id; }
    get IFluidRouter() { return this; }
    get IFluidLoadable() { return this; }
    get IFluidHandle() { return this.innerHandle; }
    /**
     * Handle to a data store
     */
    get handle() { return this.innerHandle; }
    static async getDataObject(runtime) {
        const obj = runtime._dataObject;
        (0, common_utils_1.assert)(obj !== undefined, 0x0bc /* "Runtime has no DataObject!" */);
        await obj.finishInitialization(true);
        return obj;
    }
    // #region IFluidRouter
    /**
     * Return this object if someone requests it directly
     * We will return this object in two scenarios:
     *  1. the request url is a "/"
     *  2. the request url is empty
     */
    async request(req) {
        return (0, request_handlers_1.defaultFluidObjectRequestHandler)(this, req);
    }
    // #endregion IFluidRouter
    // #region IFluidLoadable
    // #endregion IFluidLoadable
    /**
     * Call this API to ensure PureDataObject is fully initialized.
     * Initialization happens on demand, only on as-needed bases.
     * In most cases you should allow factory/object to decide when to finish initialization.
     * But if you are supplying your own implementation of DataStoreRuntime factory and overriding some methods
     * and need a fully initialized object, then you can call this API to ensure object is fully initialized.
     */
    async finishInitialization(existing) {
        if (this.initializeP !== undefined) {
            return this.initializeP;
        }
        this.initializeP = this.initializeInternal(existing);
        return this.initializeP;
    }
    /**
     * Internal initialize implementation. Overwriting this will change the flow of the PureDataObject and should
     * generally not be done.
     *
     * Calls initializingFirstTime, initializingFromExisting, and hasInitialized. Caller is
     * responsible for ensuring this is only invoked once.
     */
    async initializeInternal(existing) {
        var _a;
        await this.preInitialize();
        if (existing) {
            (0, common_utils_1.assert)(this.initProps === undefined, 0x0be /* "Trying to initialize from existing while initProps is set!" */);
            await this.initializingFromExisting();
        }
        else {
            await this.initializingFirstTime((_a = this.context.createProps) !== null && _a !== void 0 ? _a : this.initProps);
        }
        await this.hasInitialized();
    }
    /**
     * Retrieve Fluid object using the handle get
     *
     * @param key - key that object (handle/id) is stored with in the directory
     * @param directory - directory containing the object
     * @param getObjectFromDirectory - optional callback for fetching object from the directory, allows users to
     * define custom types/getters for object retrieval
     */
    async getFluidObjectFromDirectory(key, directory, getObjectFromDirectory) {
        const handleMaybe = getObjectFromDirectory ? getObjectFromDirectory(key, directory) : directory.get(key);
        const handle = handleMaybe === null || handleMaybe === void 0 ? void 0 : handleMaybe.IFluidHandle;
        if (handle) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return handle.get();
        }
    }
    /**
     * Gets the service at a given id.
     * @param id - service id
     */
    async getService(id) {
        return (0, request_handler_1.handleFromLegacyUri)(`/${container_services_1.serviceRoutePathRoot}/${id}`, this.context.containerRuntime).get();
    }
    /**
     * Called every time the data store is initialized, before initializingFirstTime or
     * initializingFromExisting is called.
     */
    async preInitialize() { }
    /**
     * Called the first time the data store is initialized (new creations with a new
     * data store runtime)
     *
     * @param props - Optional props to be passed in on create
     */
    async initializingFirstTime(props) { }
    /**
     * Called every time but the first time the data store is initialized (creations
     * with an existing data store runtime)
     */
    async initializingFromExisting() { }
    /**
     * Called every time the data store is initialized after create or existing.
     */
    async hasInitialized() { }
    /**
     * Called when the host container closes and disposes itself
     */
    dispose() {
        super.dispose();
    }
}
exports.PureDataObject = PureDataObject;

},{"../container-services":5,"../request-handlers":13,"@fluidframework/common-utils":29,"@fluidframework/datastore":93,"@fluidframework/request-handler":182}],12:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The `aqueduct` package is a library for building Fluid objects and Fluid
 * containers within the Fluid Framework. Its goal is to provide a thin base
 * layer over the existing Fluid Framework interfaces that allows developers to
 * get started quickly.
 *
 * @remarks
 * About the package name: An Aqueduct is a way to transport water from a source
 * to another location. The package name was chosen because its purpose is to
 * facilitate using lower level constructs and therefore handle 'fluid' items
 * same as an aqueduct.
 *
 * @packageDocumentation
 */
__exportStar(require("./data-object-factories"), exports);
__exportStar(require("./data-objects"), exports);
__exportStar(require("./container-runtime-factories"), exports);
__exportStar(require("./container-services"), exports);
__exportStar(require("./request-handlers"), exports);
__exportStar(require("./utils"), exports);

},{"./container-runtime-factories":3,"./container-services":5,"./data-object-factories":7,"./data-objects":10,"./request-handlers":13,"./utils":17}],13:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./requestHandlers"), exports);

},{"./requestHandlers":14}],14:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultFluidObjectRequestHandler = exports.defaultRouteRequestHandler = exports.mountableViewRequestHandler = void 0;
const request_handler_1 = require("@fluidframework/request-handler");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
 * A mountable view is only required if the view needs to be mounted across a bundle boundary.  Mounting across
 * bundle boundaries breaks some frameworks, so the mountable view is used to ensure the mounting is done within
 * the same bundle as the view.  For example, React hooks don't work if mounted across bundles since there will
 * be two React instances, breaking the Rules of Hooks.  When cross-bundle mounting isn't required, the mountable
 * view isn't necessary.
 *
 * When a request is received with a mountableView: true header, this request handler will reissue the request
 * without the header, and respond with a mountable view of the given class using the response.
 * @param MountableViewClass - The type of mountable view to use when responding
 */
const mountableViewRequestHandler = (MountableViewClass, handlers) => {
    const nestedHandler = (0, request_handler_1.buildRuntimeRequestHandler)(...handlers);
    return async (request, runtime) => {
        var _a;
        const mountableView = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.mountableView) === true;
        let newRequest = request;
        if (mountableView) {
            // Reissue the request without the mountableView header.
            // We'll repack whatever the response is if we can.
            const headers = Object.assign({}, request.headers);
            delete headers.mountableView;
            newRequest = {
                url: request.url,
                headers,
            };
        }
        const response = await nestedHandler(newRequest, runtime);
        if (mountableView && response.status === 200 && MountableViewClass.canMount(response.value)) {
            return {
                status: 200,
                mimeType: "fluid/object",
                value: new MountableViewClass(response.value),
            };
        }
        return response;
    };
};
exports.mountableViewRequestHandler = mountableViewRequestHandler;
/**
 * Pipe through container request into internal request.
 * If request is empty and default url is provided, redirect request to such default url.
 * @param defaultRootId - optional default root data store ID to pass request in case request is empty.
 */
const defaultRouteRequestHandler = (defaultRootId) => {
    return async (request, runtime) => {
        const parser = runtime_utils_1.RequestParser.create(request);
        if (parser.pathParts.length === 0) {
            return runtime.IFluidHandleContext.resolveHandle({
                url: `/${defaultRootId}${parser.query}`,
                headers: request.headers
            });
        }
        return undefined; // continue search
    };
};
exports.defaultRouteRequestHandler = defaultRouteRequestHandler;
/**
 * Default request handler for a Fluid object that returns the object itself if:
 *  1. the request url is empty
 *  2. the request url is "/"
 *  3. the request url starts with "/" and is followed by a query param, such as /?key=value
 * Returns a 404 error for any other url.
 */
function defaultFluidObjectRequestHandler(fluidObject, request) {
    if (request.url === "" || request.url === "/" || request.url.startsWith("/?")) {
        return { mimeType: "fluid/object", status: 200, value: fluidObject };
    }
    else {
        return (0, runtime_utils_1.create404Response)(request);
    }
}
exports.defaultFluidObjectRequestHandler = defaultFluidObjectRequestHandler;

},{"@fluidframework/request-handler":182,"@fluidframework/runtime-utils":213}],15:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForAttach = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
async function waitForAttach(dataStoreRuntime) {
    if (dataStoreRuntime.attachState === container_definitions_1.AttachState.Attached) {
        return;
    }
    return new Promise((resolve) => {
        dataStoreRuntime.once("attached", () => {
            Promise.resolve().then(() => resolve()).catch(() => { });
        });
    });
}
exports.waitForAttach = waitForAttach;

},{"@fluidframework/container-definitions":50}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectFromContainer = exports.getObjectWithIdFromContainer = exports.getDefaultObjectFromContainer = void 0;
/**
 * Helper function for getting the default Fluid Object from a Container. This function only works for
 * Containers that support "/" request.
 *
 * T - defines the type you expect to be returned
 *
 * @param container - Container you're attempting to get the object from
 */
async function getDefaultObjectFromContainer(container) {
    const url = "/";
    const response = await container.request({ url });
    // Verify the response
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw new Error(`Unable to retrieve Fluid object at URL: "${url}"`);
    }
    else if (response.value === undefined) {
        throw new Error(`Empty response from URL: "${url}"`);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return response.value;
}
exports.getDefaultObjectFromContainer = getDefaultObjectFromContainer;
/**
 * Helper function for getting as Fluid Object from a Container given a Unique Id. This function only works for
 * Containers that support getting FluidObjects via request.
 *
 * T - defines the type you expect to be returned
 *
 * @param id - Unique id of the FluidObject
 * @param container - Container you're attempting to get the object from
 */
async function getObjectWithIdFromContainer(id, container) {
    const url = `/${id}`;
    const response = await container.request({ url });
    // Verify the response
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw new Error(`Unable to retrieve Fluid object with ID: "${id}" from URL: "${url}"`);
    }
    else if (response.value === undefined) {
        throw new Error(`Empty response for ID: "${id}" from URL: "${url}"`);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return response.value;
}
exports.getObjectWithIdFromContainer = getObjectWithIdFromContainer;
/**
 * Helper function for getting a Fluid Object from a Container given a path/url. This function only works for
 * Containers that support getting FluidObjects via request.
 *
 * T - defines the type you expect to be returned
 *
 * @param path - Unique path/url of the FluidObject
 * @param container - Container you're attempting to get the object from
 */
async function getObjectFromContainer(path, container) {
    const response = await container.request({ url: path });
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw new Error(`Unable to retrieve Fluid object with from URL: "${path}"`);
    }
    else if (response.value === undefined) {
        throw new Error(`Empty response for from URL: "${path}"`);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return response.value;
}
exports.getObjectFromContainer = getObjectFromContainer;

},{}],17:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./attachUtils"), exports);
__exportStar(require("./containerInteractions"), exports);

},{"./attachUtils":15,"./containerInteractions":16}],18:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.assert = void 0;
/**
 * A browser friendly version of the node assert library. Use this instead of the 'assert' package, which has a big
 * impact on bundle sizes.
 * @param condition - The condition that should be true, if the condition is false an error will be thrown.
 * @param message - The message to include in the error when the condition does not hold.
 *  A number should not be specificed manually. Run policy-check to get shortcode number assigned.
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(typeof message === "number" ? `0x${message.toString(16).padStart(3, "0")}` : message);
    }
}
exports.assert = assert;

},{}],19:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUtf8 = exports.fromUtf8ToBase64 = exports.fromBase64ToUtf8 = void 0;
const indexNode_1 = require("./indexNode");
const fromBase64ToUtf8 = (input) => indexNode_1.IsoBuffer.from(input, "base64").toString("utf-8");
exports.fromBase64ToUtf8 = fromBase64ToUtf8;
const fromUtf8ToBase64 = (input) => indexNode_1.IsoBuffer.from(input, "utf8").toString("base64");
exports.fromUtf8ToBase64 = fromUtf8ToBase64;
/**
 * Convenience function to convert unknown encoding to utf8 that avoids
 * buffer copies/encode ops when no conversion is needed
 * @param input - The source string to convert
 * @param encoding - The source string's encoding
 */
const toUtf8 = (input, encoding) => {
    switch (encoding) {
        case "utf8":
        case "utf-8":
            return input;
        default:
            return indexNode_1.IsoBuffer.from(input, encoding).toString();
    }
};
exports.toUtf8 = toUtf8;

},{"./indexNode":30}],20:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchManager = void 0;
/**
 * Manages a queue of work to be batch processed at next javascript turn of execution
 */
class BatchManager {
    /**
     * Creates an instance of BatchManager.
     * @param process - callback to process the work
     */
    constructor(process, maxBatchSize = 100) {
        this.process = process;
        this.maxBatchSize = maxBatchSize;
        this.pendingWork = new Map();
    }
    /**
     * Queue up a work item to be processed
     *
     * @param id - id of the batch to add the work item to
     * @param work - the work item to be added
     */
    add(id, work) {
        if (!this.pendingWork.has(id)) {
            this.pendingWork.set(id, []);
        }
        this.pendingWork.get(id)
            .push(work);
        if (this.pendingWork.get(id).length >= this.maxBatchSize) {
            if (this.pendingTimer !== undefined) {
                clearTimeout(this.pendingTimer);
            }
            this.pendingTimer = undefined;
            this.startWork();
        }
        else if (this.pendingTimer === undefined) {
            this.pendingTimer = setTimeout(() => {
                this.pendingTimer = undefined;
                this.startWork();
            }, 0);
        }
    }
    /**
     * Process all the pending work item synchronously now
     */
    drain() {
        this.startWork();
    }
    startWork() {
        // Clear the internal flags first to avoid issues in case any of the pending work calls back into
        // the batch manager. We could also do this with a second setImmediate call but avoiding in order
        // to process the work quicker.
        const pendingWork = this.pendingWork;
        this.pendingWork = new Map();
        // TODO log to influx how much pending work there is. We want to limit the size of a batch
        for (const [id, batch] of pendingWork) {
            this.process(id, batch);
        }
    }
}
exports.BatchManager = BatchManager;

},{}],21:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsoBuffer = exports.isArrayBuffer = exports.bufferToString = exports.stringToBuffer = exports.Uint8ArrayToString = void 0;
const base64js = __importStar(require("base64-js"));
const assert_1 = require("./assert");
/**
 * Converts a Uint8Array to a string of the provided encoding
 * Useful when the array might be an IsoBuffer
 * @param arr - The array to convert
 * @param encoding - Optional target encoding; only "utf8" and "base64" are
 * supported, with "utf8" being default
 * @returns The converted string
 */
function Uint8ArrayToString(arr, encoding) {
    switch (encoding) {
        case "base64": {
            return base64js.fromByteArray(arr);
        }
        case "utf8":
        case "utf-8":
        case undefined: {
            return new TextDecoder().decode(arr);
        }
        default: {
            throw new Error("invalid/unsupported encoding");
        }
    }
}
exports.Uint8ArrayToString = Uint8ArrayToString;
/**
 * Convert base64 or utf8 string to array buffer
 * @param encoding - input string's encoding
 */
const stringToBuffer = (input, encoding) => IsoBuffer.from(input, encoding).buffer;
exports.stringToBuffer = stringToBuffer;
/**
 * Convert binary blob to string format
 *
 * @param blob - the binary blob
 * @param encoding - output string's encoding
 * @returns the blob in string format
 */
const bufferToString = (blob, encoding) => IsoBuffer.from(blob).toString(encoding);
exports.bufferToString = bufferToString;
/**
 * Determines if an object is an array buffer
 * Will detect and reject TypedArrays, like Uint8Array.
 * Reason - they can be viewport into Array, they can be accepted, but caller has to deal with
 * math properly (i.e. take into account byteOffset at minimum).
 * For example, construction of new TypedArray can be in the form of new TypedArray(typedArray) or
 * new TypedArray(buffer, byteOffset, length), but passing TypedArray will result in fist path (and
 * ignoring byteOffice, length)
 * @param obj - The object to determine if it is an ArrayBuffer
 */
function isArrayBuffer(obj) {
    const maybe = obj;
    return obj instanceof ArrayBuffer
        || (typeof maybe === "object"
            && maybe !== null
            && typeof maybe.byteLength === "number"
            && typeof maybe.slice === "function"
            && maybe.byteOffset === undefined
            && maybe.buffer === undefined);
}
exports.isArrayBuffer = isArrayBuffer;
/**
 * Minimal implementation of Buffer for our usages in the browser environment.
 */
class IsoBuffer extends Uint8Array {
    /**
     * Convert the buffer to a string.
     * Only supports encoding the whole string (unlike the Node Buffer equivalent)
     * and only utf8 and base64 encodings
     * @param encoding
     */
    toString(encoding) {
        return Uint8ArrayToString(this, encoding);
    }
    /**
     * @param value - string | ArrayBuffer
     * @param encodingOrOffset - string | number
     * @param length - number
     */
    static from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
            return IsoBuffer.fromString(value, encodingOrOffset);
            // Capture any typed arrays, including Uint8Array (and thus - IsoBuffer!)
        }
        else if (value !== null && typeof value === "object" && isArrayBuffer(value.buffer)) {
            // Support currently for full array, no view ports! (though it can be added in future)
            assert_1.assert(value.byteOffset === 0, 0x000 /* "nonzero isobuffer byte offset" */);
            assert_1.assert(value.byteLength === value.buffer.byteLength, 0x001 /* "unexpected isobuffer byte length" */);
            return IsoBuffer.fromArrayBuffer(value.buffer, encodingOrOffset, length);
        }
        else if (isArrayBuffer(value)) {
            return IsoBuffer.fromArrayBuffer(value, encodingOrOffset, length);
        }
        else {
            throw new TypeError();
        }
    }
    static fromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
        const offset = byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0;
        const validLength = byteLength !== null && byteLength !== void 0 ? byteLength : arrayBuffer.byteLength - offset;
        if (offset < 0 ||
            offset > arrayBuffer.byteLength ||
            validLength < 0 ||
            validLength + offset > arrayBuffer.byteLength) {
            throw new RangeError();
        }
        return new IsoBuffer(arrayBuffer, offset, validLength);
    }
    static fromString(str, encoding) {
        switch (encoding) {
            case "base64": {
                const sanitizedString = this.sanitizeBase64(str);
                const encoded = base64js.toByteArray(sanitizedString);
                return new IsoBuffer(encoded.buffer);
            }
            case "utf8":
            case "utf-8":
            case undefined: {
                const encoded = new TextEncoder().encode(str);
                return new IsoBuffer(encoded.buffer);
            }
            default: {
                throw new Error("invalid/unsupported encoding");
            }
        }
    }
    static isBuffer(obj) {
        throw new Error("unimplemented");
    }
    /**
     * Sanitize a base64 string to provide to base64-js library.  base64-js
     * is not as tolerant of the same malformed base64 as Node's Buffer is.
     * @param str
     */
    static sanitizeBase64(str) {
        let sanitizedStr = str;
        // Remove everything after padding - Node buffer ignores everything
        // after any padding whereas base64-js does not
        sanitizedStr = sanitizedStr.split("=")[0];
        // Remove invalid characters - Node buffer strips invalid characters
        // whereas base64-js replaces them with "A"
        sanitizedStr = sanitizedStr.replace(/[^\w+-/]/g, "");
        // Check for missing padding - Node buffer tolerates missing padding
        // whereas base64-js does not
        if (sanitizedStr.length % 4 !== 0) {
            const paddingArray = ["", "===", "==", "="];
            sanitizedStr += paddingArray[sanitizedStr.length % 4];
        }
        return sanitizedStr;
    }
}
exports.IsoBuffer = IsoBuffer;

},{"./assert":18,"base64-js":343}],22:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Uint8ArrayToArrayBuffer = void 0;
/**
 * Convert Uint8Array array to ArrayBuffer
 * @param array - array to convert to ArrayBuffer
 */
function Uint8ArrayToArrayBuffer(array) {
    if (array.byteOffset === 0 && array.byteLength === array.buffer.byteLength) {
        return array.buffer;
    }
    return array.buffer.slice(array.byteOffset, array.byteOffset + array.byteLength);
}
exports.Uint8ArrayToArrayBuffer = Uint8ArrayToArrayBuffer;

},{}],23:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.delay = void 0;
/**
 * Returns a promise that resolves after timeMs
 * @param timeMs - time in milliseconds to wait
 */
const delay = async (timeMs) => new Promise((resolve) => setTimeout(() => resolve(), timeMs));
exports.delay = delay;

},{}],24:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.doIfNotDisposed = void 0;
function doIfNotDisposed(disposable, f) {
    return (...args) => {
        if (disposable.disposed) {
            throw new Error("Already disposed");
        }
        else {
            return f(...args);
        }
    };
}
exports.doIfNotDisposed = doIfNotDisposed;

},{}],25:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventForwarder = void 0;
const typedEventEmitter_1 = require("./typedEventEmitter");
/**
 * Base class used for forwarding events from a source EventEmitter.
 * This can be useful when all arbitrary listeners need to be removed,
 * but the primary source needs to stay intact.
 */
class EventForwarder extends typedEventEmitter_1.TypedEventEmitter {
    constructor(source) {
        super();
        this.isDisposed = false;
        this.forwardingEvents = new Map();
        if (source !== undefined) {
            // NewListener event is raised whenever someone starts listening to this events, so
            // we keep track of events being listened to, and start forwarding from the source
            // event emitter per event listened to on this
            const removeListenerHandler = (event) => this.unforwardEvent(source, event);
            const newListenerHandler = (event) => this.forwardEvent(source, event);
            this.on(EventForwarder.removeListenerEvent, removeListenerHandler);
            this.on(EventForwarder.newListenerEvent, newListenerHandler);
        }
    }
    static isEmitterEvent(event) {
        return event === EventForwarder.newListenerEvent || event === EventForwarder.removeListenerEvent;
    }
    get disposed() { return this.isDisposed; }
    dispose() {
        this.isDisposed = true;
        for (const listenerRemovers of this.forwardingEvents.values()) {
            for (const listenerRemover of listenerRemovers.values()) {
                try {
                    listenerRemover();
                }
                catch (_a) {
                    // Should be fine because of removeAllListeners below
                }
            }
        }
        this.removeAllListeners();
        this.forwardingEvents.clear();
    }
    forwardEvent(source, ...events) {
        for (const event of events) {
            if (source !== undefined && event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                let sources = this.forwardingEvents.get(event);
                if (sources === undefined) {
                    sources = new Map();
                    this.forwardingEvents.set(event, sources);
                }
                if (!sources.has(source)) {
                    const listener = (...args) => this.emit(event, ...args);
                    sources.set(source, () => source.off(event, listener));
                    source.on(event, listener);
                }
            }
        }
    }
    unforwardEvent(source, ...events) {
        for (const event of events) {
            if (event !== undefined && !EventForwarder.isEmitterEvent(event)) {
                const sources = this.forwardingEvents.get(event);
                if (sources === null || sources === void 0 ? void 0 : sources.has(source)) {
                    if (this.listenerCount(event) === 0) {
                        const listenerRemover = sources.get(source);
                        if (listenerRemover !== undefined) {
                            listenerRemover();
                        }
                        sources.delete(source);
                        if (sources.size === 0) {
                            this.forwardingEvents.delete(event);
                        }
                    }
                }
            }
        }
    }
}
exports.EventForwarder = EventForwarder;
EventForwarder.newListenerEvent = "newListener";
EventForwarder.removeListenerEvent = "removeListener";

},{"./typedEventEmitter":42}],26:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gitHashFile = exports.hashFile = void 0;
const base64js = __importStar(require("base64-js"));
const bufferBrowser_1 = require("./bufferBrowser");
async function digestBuffer(file, algorithm) {
    const hash = await crypto.subtle.digest(algorithm, file);
    return new Uint8Array(hash);
}
function encodeDigest(hashArray, encoding) {
    // eslint-disable-next-line default-case
    switch (encoding) {
        case "hex": {
            const hashHex = Array.prototype.map.call(hashArray, (byte) => {
                return byte.toString(16).padStart(2, "0");
            }).join("");
            return hashHex;
        }
        case "base64": {
            return base64js.fromByteArray(hashArray);
        }
    }
}
/**
 * Hash a file. Consistent within a session, but should not be persisted and
 * is not consistent with git.
 * If called under an insecure context for a browser, this will fallback to
 * using the node implementation.
 *
 * @param file - The contents of the file in a buffer
 * @param algorithm - The hash algorithm to use, artificially constrained by what is used internally
 * @param hashEncoding - The encoding of the returned hash, also artificially constrained
 * @returns The hash of the content of the buffer
 */
async function hashFile(file, algorithm = "SHA-1", hashEncoding = "hex") {
    // Handle insecure contexts (e.g. running with local services)
    // by deferring to Node version, which uses a hash polyfill
    // When packed, this chunk will show as "FluidFramework-HashFallback" separately
    // from the main chunk and will be of non-trivial size.  It will not be served
    // under normal circumstances.
    if (crypto.subtle === undefined) {
        return Promise.resolve().then(() => __importStar(require(
        /* webpackChunkName: "FluidFramework-HashFallback" */
        "./hashFileNode"))).then(async (m) => m.hashFile(file, algorithm, hashEncoding));
    }
    // This is split up this way to facilitate testing (see the test for more info)
    const hashArray = await digestBuffer(file, algorithm);
    return encodeDigest(hashArray, hashEncoding);
}
exports.hashFile = hashFile;
/**
 * Create a github hash (Github hashes the string with blob and size)
 * Must be called under secure context for browsers
 *
 * @param file - The contents of the file in a buffer
 * @returns The sha1 hash of the content of the buffer with the `blob` prefix and size
 */
async function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = `blob ${size.toString()}${String.fromCharCode(0)}`;
    const hashBuffer = bufferBrowser_1.IsoBuffer.from(filePrefix + file.toString());
    // hashFile uses sha1; if that changes this will need to change too
    return hashFile(hashBuffer);
}
exports.gitHashFile = gitHashFile;

},{"./bufferBrowser":21,"./hashFileNode":27,"base64-js":343}],27:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gitHashFile = exports.hashFile = void 0;
// eslint-disable-next-line import/no-internal-modules
const sha1_1 = __importDefault(require("sha.js/sha1"));
// eslint-disable-next-line import/no-internal-modules
const sha256_1 = __importDefault(require("sha.js/sha256"));
/**
 * Hash a file. Consistent within a session, but should not be persisted and
 * is not consistent with git.
 * If called under an insecure context for a browser, this will fallback to
 * using the node implementation.
 *
 * @param file - The contents of the file in a buffer
 * @param algorithm - The hash algorithm to use, artificially constrained by what is used internally
 * @param hashEncoding - The encoding of the returned hash, also artificially constrained
 * @returns The hash of the content of the buffer
 */
async function hashFile(file, algorithm = "SHA-1", hashEncoding = "hex") {
    let engine;
    // eslint-disable-next-line default-case
    switch (algorithm) {
        case "SHA-1": {
            engine = new sha1_1.default();
            break;
        }
        case "SHA-256": {
            engine = new sha256_1.default();
            break;
        }
    }
    return engine.update(file).digest(hashEncoding);
}
exports.hashFile = hashFile;
/**
 * Create a github hash (Github hashes the string with blob and size)
 * Must be called under secure context for browsers
 *
 * @param file - The contents of the file in a buffer
 * @returns The sha1 hash of the content of the buffer with the `blob` prefix and size
 */
async function gitHashFile(file) {
    const size = file.byteLength;
    const filePrefix = `blob ${size.toString()}${String.fromCharCode(0)}`;
    const engine = new sha1_1.default();
    return engine.update(filePrefix)
        .update(file)
        .digest("hex");
}
exports.gitHashFile = gitHashFile;

},{"sha.js/sha1":531,"sha.js/sha256":532}],28:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Heap = exports.NumberComparer = void 0;
/**
 * A comparer for numbers
 */
exports.NumberComparer = {
    /**
     * The compare function for numbers,
     * @returns difference of the two number
     */
    compare: (a, b) => a - b,
    /**
     * The minimum value of a javascript number, which is Number.MIN_VALUE
     */
    min: Number.MIN_VALUE,
};
/**
 * Ordered Heap data structure implementation
 */
class Heap {
    /**
     * Creates an instance of Heap with comparer
     * @param comp - a comparer that specify how elements are ordered
     */
    constructor(comp) {
        this.comp = comp;
        this.L = [{ value: comp.min, position: 0 }];
    }
    /**
     * Return the smallest element in the heap as determined by the order of the comparer
     *
     * @returns heap node containing the smallest element
     */
    peek() {
        return this.L[1];
    }
    /**
     * Get and remove the smallest element in the heap as determined by the order of the comparer
     *
     * @returns the smallest value in the heap
     */
    get() {
        this.swap(1, this.count());
        const x = this.L.pop();
        this.fixdown(1);
        return x.value;
    }
    /**
     * Add a value to the heap
     *
     * @param x - value to add
     * @returns the heap node that contains the value
     */
    add(x) {
        const node = { value: x, position: this.L.length };
        this.L.push(node);
        this.fixup(this.count());
        return node;
    }
    /**
     * Allows for heap to be updated after a node's value changes
     */
    update(node) {
        const k = node.position;
        if (this.isGreaterThanParent(k)) {
            this.fixup(k);
        }
        else {
            this.fixdown(k);
        }
    }
    /**
     * Removes the given node from the heap
     *
     * @param node - the node to remove from the heap
     */
    remove(node) {
        // Move the node we want to remove to the end of the array
        const position = node.position;
        this.swap(node.position, this.L.length - 1);
        this.L.splice(this.L.length - 1);
        // Update the swapped node assuming we didn't remove the end of the list
        if (position !== this.L.length) {
            this.update(this.L[position]);
        }
    }
    /**
     * Get the number of elements in the Heap
     *
     * @returns the number of elements in the Heap
     */
    count() {
        return this.L.length - 1;
    }
    fixup(pos) {
        let k = pos;
        while (this.isGreaterThanParent(k)) {
            const parent = k >> 1;
            this.swap(k, parent);
            k = parent;
        }
    }
    isGreaterThanParent(k) {
        return k > 1 && (this.comp.compare(this.L[k >> 1].value, this.L[k].value) > 0);
    }
    fixdown(pos) {
        let k = pos;
        while ((k << 1) <= this.count()) {
            let j = k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j].value, this.L[j + 1].value) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[k].value, this.L[j].value) <= 0) {
                break;
            }
            this.swap(k, j);
            k = j;
        }
    }
    swap(k, j) {
        const tmp = this.L[k];
        this.L[k] = this.L[j];
        this.L[k].position = k;
        this.L[j] = tmp;
        this.L[j].position = j;
    }
}
exports.Heap = Heap;

},{}],29:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./indexNode"), exports);
__exportStar(require("./base64Encoding"), exports);
__exportStar(require("./batchManager"), exports);
__exportStar(require("./disposal"), exports);
__exportStar(require("./eventForwarder"), exports);
__exportStar(require("./heap"), exports);
__exportStar(require("./logger"), exports);
__exportStar(require("./promiseCache"), exports);
__exportStar(require("./promises"), exports);
__exportStar(require("./rangeTracker"), exports);
__exportStar(require("./rateLimiter"), exports);
__exportStar(require("./safeParser"), exports);
__exportStar(require("./timer"), exports);
__exportStar(require("./trace"), exports);
__exportStar(require("./typedEventEmitter"), exports);
__exportStar(require("./unreachable"), exports);
__exportStar(require("./lazy"), exports);
__exportStar(require("./performanceIsomorphic"), exports);
__exportStar(require("./delay"), exports);
__exportStar(require("./bufferShared"), exports);

},{"./assert":18,"./base64Encoding":19,"./batchManager":20,"./bufferShared":22,"./delay":23,"./disposal":24,"./eventForwarder":25,"./heap":28,"./indexNode":30,"./lazy":31,"./logger":32,"./performanceIsomorphic":34,"./promiseCache":35,"./promises":36,"./rangeTracker":37,"./rateLimiter":38,"./safeParser":39,"./timer":40,"./trace":41,"./typedEventEmitter":42,"./unreachable":43}],30:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./bufferBrowser"), exports);
__exportStar(require("./hashFileBrowser"), exports);
__exportStar(require("./performanceBrowser"), exports);

},{"./bufferBrowser":21,"./hashFileBrowser":26,"./performanceBrowser":33}],31:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lazy = void 0;
/**
  * Helper class for lazy initialized values. Ensures the value is only generated once, and remain immutable
  */
class Lazy {
    /**
     * Instantiates an instance of Lazy<T>
     * @param valueGenerator - the function that will generate the value when value is accessed the first time
     */
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this._evaluated = false;
    }
    /**
     * Return true if the value as been generated, otherwise false
     */
    get evaluated() {
        return this._evaluated;
    }
    /**
     * Get the value. If this is the first call the value will be generated
     */
    get value() {
        if (!this._evaluated) {
            this._evaluated = true;
            this._value = this.valueGenerator();
        }
        return this._value;
    }
}
exports.Lazy = Lazy;

},{}],32:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractLogSafeErrorProperties = exports.TelemetryNullLogger = exports.BaseTelemetryNullLogger = void 0;
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class BaseTelemetryNullLogger {
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        return;
    }
}
exports.BaseTelemetryNullLogger = BaseTelemetryNullLogger;
/**
 * Null logger
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryNullLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
    }
    sendPerformanceEvent(event, error) {
    }
}
exports.TelemetryNullLogger = TelemetryNullLogger;
function extractLogSafeErrorProperties(error) {
    const isRegularObject = (value) => {
        return value !== null && !Array.isArray(value) && typeof value === "object";
    };
    const removeMessageFromStack = (stack, errorName) => {
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
exports.extractLogSafeErrorProperties = extractLogSafeErrorProperties;

},{}],33:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.performance = void 0;
exports.performance = window.performance;

},{}],34:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],35:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseCache = void 0;
/**
 * Handles garbage collection of expiring cache entries.
 * Not exported.
 */
class GarbageCollector {
    constructor(expiry, cleanup) {
        this.expiry = expiry;
        this.cleanup = cleanup;
        this.gcTimeouts = new Map();
    }
    /**
     * Schedule GC for the given key, as applicable
     */
    schedule(key) {
        if (this.expiry.policy !== "indefinite") {
            this.gcTimeouts.set(key, setTimeout(() => { this.cleanup(key); this.cancel(key); }, this.expiry.durationMs));
        }
    }
    /**
     * Cancel any pending GC for the given key
     */
    cancel(key) {
        const timeout = this.gcTimeouts.get(key);
        if (timeout !== undefined) {
            clearTimeout(timeout);
            this.gcTimeouts.delete(key);
        }
    }
    /**
     * Update any pending GC for the given key, as applicable
     */
    update(key) {
        // Cancel/reschedule new GC if the policy is sliding
        if (this.expiry.policy === "sliding") {
            this.cancel(key);
            this.schedule(key);
        }
    }
}
/**
* A specialized cache for async work, allowing you to safely cache the promised result of some async work
* without fear of running it multiple times or losing track of errors.
*/
class PromiseCache {
    /**
     * Create the PromiseCache with the given options, with the following defaults:
     *
     * expiry: indefinite, removeOnError: true for all errors
     */
    constructor({ expiry = { policy: "indefinite" }, removeOnError = () => true, } = {}) {
        this.cache = new Map();
        this.removeOnError = removeOnError;
        this.gc = new GarbageCollector(expiry, (key) => this.remove(key));
    }
    /**
     * Check if there's anything cached at the given key
     */
    has(key) {
        return this.cache.has(key);
    }
    /**
     * Get the Promise for the given key, or undefined if it's not found.
     * Extend expiry if applicable.
     */
    get(key) {
        if (this.has(key)) {
            this.gc.update(key);
        }
        return this.cache.get(key);
    }
    /**
     * Remove the Promise for the given key, returning true if it was found and removed
     */
    remove(key) {
        this.gc.cancel(key);
        return this.cache.delete(key);
    }
    /**
     * Try to add the result of the given asyncFn, without overwriting an existing cache entry at that key.
     * Returns a Promise for the added or existing async work being done at that key.
     * @param key - key name where to store the async work
     * @param asyncFn - the async work to do and store, if not already in progress under the given key
     */
    async addOrGet(key, asyncFn) {
        // NOTE: Do not await the Promise returned by asyncFn!
        // Let the caller do so once we return or after a subsequent call to get
        let promise = this.get(key);
        if (promise === undefined) {
            // Wrap in an async lambda in case asyncFn disabled @typescript-eslint/promise-function-async
            const safeAsyncFn = async () => asyncFn();
            // Start the async work and put the Promise in the cache
            promise = safeAsyncFn();
            this.cache.set(key, promise);
            // If asyncFn throws, we may remove the Promise from the cache
            promise.catch((error) => {
                if (this.removeOnError(error)) {
                    this.remove(key);
                }
            });
            this.gc.schedule(key);
        }
        return promise;
    }
    /**
     * Try to add the result of the given asyncFn, without overwriting an existing cache entry at that key.
     * Returns false if the cache already contained an entry at that key, and true otherwise.
     * @param key - key name where to store the async work
     * @param asyncFn - the async work to do and store, if not already in progress under the given key
     */
    add(key, asyncFn) {
        const alreadyPresent = this.has(key);
        // We are blindly adding the Promise to the cache here, which introduces a Promise in this scope.
        // Swallow Promise rejections here, since whoever gets this out of the cache to use it will await/catch.
        this.addOrGet(key, asyncFn)
            .catch(() => { });
        return !alreadyPresent;
    }
    /**
     * Try to add the given value, without overwriting an existing cache entry at that key.
     * Returns a Promise for the added or existing async work being done at that key.
     * @param key - key name where to store the async work
     * @param value - value to store
     */
    async addValueOrGet(key, value) {
        return this.addOrGet(key, async () => value);
    }
    /**
     * Try to add the given value, without overwriting an existing cache entry at that key.
     * Returns false if the cache already contained an entry at that key, and true otherwise.
     * @param key - key name where to store the value
     * @param value - value to store
     */
    addValue(key, value) {
        return this.add(key, async () => value);
    }
}
exports.PromiseCache = PromiseCache;

},{}],36:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyPromise = exports.Deferred = void 0;
/**
 * A deferred creates a promise and the ability to resolve or reject it
 */
class Deferred {
    constructor() {
        this.completed = false;
        this.p = new Promise((resolve, reject) => {
            this.res = resolve;
            this.rej = reject;
        });
    }
    /**
     * Returns whether the underlying promise has been completed
     */
    get isCompleted() {
        return this.completed;
    }
    /**
     * Retrieves the underlying promise for the deferred
     *
     * @returns the underlying promise
     */
    get promise() {
        return this.p;
    }
    /**
     * Resolves the promise
     *
     * @param value - the value to resolve the promise with
     */
    resolve(value) {
        if (this.res !== undefined) {
            this.completed = true;
            this.res(value);
        }
    }
    /**
     * Rejects the promise
     *
     * @param value - the value to reject the promise with
     */
    reject(error) {
        if (this.rej !== undefined) {
            this.completed = true;
            this.rej(error);
        }
    }
}
exports.Deferred = Deferred;
/**
 * A lazy evaluated promise. The execute function is delayed until
 * the promise is used, e.g. await, then, catch ...
 * The execute function is only called once.
 * All calls are then proxied to the promise returned by the execute method.
 */
class LazyPromise {
    constructor(execute) {
        this.execute = execute;
    }
    get [Symbol.toStringTag]() {
        return this.getPromise()[Symbol.toStringTag];
    }
    async then(onfulfilled, onrejected) {
        return this.getPromise().then(...arguments);
    }
    async catch(onrejected) {
        return this.getPromise().catch(...arguments);
    }
    async finally(onfinally) {
        return this.getPromise().finally(...arguments);
    }
    async getPromise() {
        if (this.result === undefined) {
            this.result = this.execute();
        }
        return this.result;
    }
}
exports.LazyPromise = LazyPromise;

},{}],37:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeTracker = void 0;
// eslint-disable-next-line import/no-internal-modules
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const assert_1 = require("./assert");
/**
 * Helper class that keeps track of the relation between two ranges in a 1:N fashion. Primary
 * is continuous and always maps to a single value in secondary above the base value. The range
 * defines an increasing step function.
 *
 * Used by deli to keep track of the branch map
 */
class RangeTracker {
    constructor(primary, secondary) {
        if (typeof primary === "number") {
            this.ranges = [{ length: 0, primary, secondary }];
            this.lastPrimary = primary;
            this.lastSecondary = secondary;
        }
        else {
            this.ranges = cloneDeep_1.default(primary.ranges);
            this.lastPrimary = primary.lastPrimary;
            this.lastSecondary = primary.lastSecondary;
        }
    }
    get base() {
        return this.ranges[0].primary;
    }
    /**
     * Getter for the last primary that was added
     *
     * @returns last primary that was added
     */
    get primaryHead() {
        return this.lastPrimary;
    }
    /**
     * Getter for the last secondary that was added
     *
     * @returns last secondary that was added
     */
    get secondaryHead() {
        return this.lastSecondary;
    }
    /**
     * Returns a serialized form of the RangeTracker
     */
    serialize() {
        return {
            lastPrimary: this.lastPrimary,
            lastSecondary: this.lastSecondary,
            ranges: cloneDeep_1.default(this.ranges),
        };
    }
    /**
     * Add a primary, secondary pair to the range
     *
     * @param primary - the primary number in the range
     * @param secondary - the secondary number in the range
     */
    add(primary, secondary) {
        // Both values must continuously be increasing - we won't always track the last value we saw so we do so
        // below to check invariants
        assert_1.assert(primary >= this.lastPrimary, 0x003 /* "Primary to add to range < last primary!" */);
        if (this.lastSecondary !== undefined) {
            assert_1.assert(secondary >= this.lastSecondary, 0x004 /* "Secondary to add to range < last secondary!" */);
        }
        this.lastPrimary = primary;
        this.lastSecondary = secondary;
        // Get quicker references to the head of the range
        const head = this.ranges[this.ranges.length - 1];
        const primaryHead = head.primary + head.length;
        const secondaryHead = head.secondary + head.length;
        // Same secondary indicates this is not a true inflection point - we can ignore it
        if (secondary === secondaryHead) {
            return;
        }
        // New secondary - need to update the ranges
        if (primary === primaryHead) {
            // Technically this code path has us supporting N:N ranges. But we simply overwrite duplicate values to
            // preserve 1:N since you can only lookup from the primary to a secondary
            if (head.length === 0) {
                // No range represented - we can simply update secondary with the overwritten value
                head.secondary = secondary;
            }
            else {
                // The values in the range before this one are valid - but we need to create a new one for this update
                head.length--;
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
        else {
            if (primaryHead + 1 === primary && secondaryHead + 1 === secondary) {
                // Extend the length if both increase by the same amount
                head.length++;
            }
            else {
                // Insert a new node
                this.ranges.push({ length: 0, primary, secondary });
            }
        }
    }
    /**
     * Get the closest range to the primary
     *
     * @param primary - the primary value to look for
     * @returns the closest range to the primary
     */
    get(primary) {
        assert_1.assert(primary >= this.ranges[0].primary, 0x005 /* "Target primary to retrieve < first range's primary!" */);
        // Find the first range where the starting position is greater than the primary. Our target range is
        // the one before it.
        let index = 1;
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert_1.assert(primary >= this.ranges[index - 1].primary, 0x006 /* "Target primary to retrieve < last range's primary!" */);
        // If the difference is within the stored range use it - otherwise add in the length - 1 as the highest
        // stored secondary value to use.
        const closestRange = this.ranges[index - 1];
        return Math.min(primary - closestRange.primary, closestRange.length) + closestRange.secondary;
    }
    /**
     * Update the range of primary
     *
     * @param primary - the primary value to update
     */
    updateBase(primary) {
        assert_1.assert(primary >= this.ranges[0].primary, 0x007 /* "Target primary to update < first range's primary!" */);
        // Walk the ranges looking for the first one that is greater than the primary. Primary is then within the
        // previous index by definition (since it's less than the current index's primary but greather than the
        // previous index's primary) and we know primary must be greater than the base.
        let index = 1;
        for (; index < this.ranges.length; index++) {
            if (primary < this.ranges[index].primary) {
                break;
            }
        }
        assert_1.assert(primary >= this.ranges[index - 1].primary, 0x008 /* "Target primary to update < last range's primary!" */);
        // Update the last range values
        const range = this.ranges[index - 1];
        const delta = primary - range.primary;
        range.secondary = range.secondary + Math.min(delta, range.length);
        range.length = Math.max(range.length - delta, 0);
        range.primary = primary;
        // And remove unnecessary ranges
        this.ranges = index - 1 > 0 ? this.ranges.slice(index - 1) : this.ranges;
        // Assert that the lowest value is now the input to this method
        assert_1.assert(primary === this.ranges[0].primary, 0x009 /* "After update, target primary is not first range's primary!" */);
    }
}
exports.RangeTracker = RangeTracker;

},{"./assert":18,"lodash/cloneDeep":502}],38:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimiter = void 0;
/**
 * A rate limiter to make sure that a client can only request help for one task within a time window.
 */
class RateLimiter {
    /**
     * Creates a rate limiter that keep track of the request it has made
     *
     * @param windowMSec - time in millisecond, use to filter out messages
     * for a clientId if the last request falls within this time window
     */
    constructor(windowMSec) {
        this.windowMSec = windowMSec;
        this.requestMap = new Map();
    }
    /**
     * Filter out the messages that had already been requested within the time window
     *
     * @param clientId - the clientId who want to send the message
     * @param messages - the message we want to send
     * @returns the message we approved to send that hasn't been sent recently
     */
    filter(clientId, messages) {
        const approvedList = [];
        const currentTime = Date.now();
        for (const message of messages) {
            const key = `${clientId}/${message}`;
            if (!this.requestMap.has(key)) {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
            else if (this.requestMap.get(key) + this.windowMSec > currentTime) {
                continue;
            }
            else {
                this.requestMap.set(key, currentTime);
                approvedList.push(message);
            }
        }
        return approvedList;
    }
}
exports.RateLimiter = RateLimiter;

},{}],39:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.safelyParseJSON = void 0;
/**
 * Wrapper for JSON.parse to translate all exception to return undefined
 *
 * @param json - the JSON string to parse
 * @returns the result JSON.parse is successful, undefined if exception happens
 */
function safelyParseJSON(json) {
    let parsed;
    try {
        parsed = JSON.parse(json);
    }
    catch (e) {
        //
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return parsed;
}
exports.safelyParseJSON = safelyParseJSON;

},{}],40:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseTimer = exports.Timer = void 0;
const assert_1 = require("./assert");
const promises_1 = require("./promises");
/**
 * This class is a thin wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the same
 * or similar handlers and timeouts.
 */
class Timer {
    constructor(defaultTimeout, defaultHandler, getCurrentTick = () => Date.now()) {
        this.defaultTimeout = defaultTimeout;
        this.defaultHandler = defaultHandler;
        this.getCurrentTick = getCurrentTick;
    }
    /**
     * Returns true if the timer is running.
     */
    get hasTimer() {
        return !!this.runningState;
    }
    /**
     * Calls setTimeout and tracks the resulting timeout.
     * @param ms - overrides default timeout in ms
     * @param handler - overrides default handler
     */
    start(ms = this.defaultTimeout, handler = this.defaultHandler) {
        this.startCore(ms, handler, ms);
    }
    /**
     * Calls clearTimeout on the underlying timeout if running.
     */
    clear() {
        if (!this.runningState) {
            return;
        }
        clearTimeout(this.runningState.timeout);
        this.runningState = undefined;
    }
    /**
     * Restarts the timer with the new handler and duration.
     * If a new handler is passed, the original handler may
     * never execute.
     * This is a potentially more efficient way to clear and start
     * a new timer.
     * @param ms - overrides previous or default timeout in ms
     * @param handler - overrides previous or default handler
     */
    restart(ms, handler) {
        var _a, _b;
        if (!this.runningState) {
            // If restart is called first, it behaves as a call to start
            this.start(ms, handler);
        }
        else {
            const duration = ms !== null && ms !== void 0 ? ms : this.runningState.intendedDuration;
            const handlerToUse = (_b = handler !== null && handler !== void 0 ? handler : (_a = this.runningState.restart) === null || _a === void 0 ? void 0 : _a.handler) !== null && _b !== void 0 ? _b : this.runningState.handler;
            const remainingTime = this.calculateRemainingTime(this.runningState);
            if (duration < remainingTime) {
                // If remaining time exceeds restart duration, do a hard restart.
                // The existing timeout time is too long.
                this.start(duration, handlerToUse);
            }
            else if (duration === remainingTime) {
                // The existing timeout time is perfect, just update handler and data.
                this.runningState.handler = handlerToUse;
                this.runningState.restart = undefined;
                this.runningState.intendedDuration = duration;
            }
            else {
                // If restart duration exceeds remaining time, set restart info.
                // Existing timeout will start a new timeout for remaining time.
                this.runningState.restart = {
                    startTick: this.getCurrentTick(),
                    duration,
                    handler: handlerToUse,
                };
            }
        }
    }
    startCore(duration, handler, intendedDuration) {
        this.clear();
        this.runningState = {
            startTick: this.getCurrentTick(),
            duration,
            intendedDuration,
            handler,
            timeout: setTimeout(() => this.handler(), duration),
        };
    }
    handler() {
        assert_1.assert(!!this.runningState, 0x00a /* "Running timer missing handler" */);
        const restart = this.runningState.restart;
        if (restart !== undefined) {
            // Restart with remaining time
            const remainingTime = this.calculateRemainingTime(restart);
            this.startCore(remainingTime, () => restart.handler(), restart.duration);
        }
        else {
            // Run clear first, in case the handler decides to start again
            const handler = this.runningState.handler;
            this.clear();
            handler();
        }
    }
    calculateRemainingTime(runningTimeout) {
        const elapsedTime = this.getCurrentTick() - runningTimeout.startTick;
        return runningTimeout.duration - elapsedTime;
    }
}
exports.Timer = Timer;
/**
 * This class is a wrapper over setTimeout and clearTimeout which
 * makes it simpler to keep track of recurring timeouts with the
 * same handlers and timeouts, while also providing a promise that
 * resolves when it times out.
 */
class PromiseTimer {
    constructor(defaultTimeout, defaultHandler) {
        this.timer = new Timer(defaultTimeout, () => this.wrapHandler(defaultHandler));
    }
    get hasTimer() {
        return this.timer.hasTimer;
    }
    async start(ms, handler) {
        this.clear();
        this.deferred = new promises_1.Deferred();
        this.timer.start(ms, handler ? () => this.wrapHandler(handler) : undefined);
        return this.deferred.promise;
    }
    clear() {
        this.timer.clear();
        if (this.deferred) {
            this.deferred.resolve({ timerResult: "cancel" });
            this.deferred = undefined;
        }
    }
    wrapHandler(handler) {
        handler();
        assert_1.assert(!!this.deferred, 0x00b /* "Handler executed without deferred" */);
        this.deferred.resolve({ timerResult: "timeout" });
        this.deferred = undefined;
    }
}
exports.PromiseTimer = PromiseTimer;

},{"./assert":18,"./promises":36}],41:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trace = void 0;
const indexNode_1 = require("./indexNode");
/**
 * Helper class for tracing performance of events
 * Time measurements are in milliseconds as a floating point with a decimal
 */
class Trace {
    constructor(startTick) {
        this.startTick = startTick;
        this.lastTick = startTick;
    }
    static start() {
        const startTick = indexNode_1.performance.now();
        return new Trace(startTick);
    }
    trace() {
        const tick = indexNode_1.performance.now();
        const event = {
            totalTimeElapsed: tick - this.startTick,
            duration: tick - this.lastTick,
            tick,
        };
        this.lastTick = tick;
        return event;
    }
}
exports.Trace = Trace;

},{"./indexNode":30}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedEventEmitter = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const events_1 = require("events");
/**
 * Event Emitter helper class the supports emitting typed events
 */
class TypedEventEmitter extends events_1.EventEmitter {
    constructor() {
        super();
        this.addListener = super.addListener.bind(this);
        this.on = super.on.bind(this);
        this.once = super.once.bind(this);
        this.prependListener = super.prependListener.bind(this);
        this.prependOnceListener = super.prependOnceListener.bind(this);
        this.removeListener = super.removeListener.bind(this);
        this.off = super.off.bind(this);
    }
}
exports.TypedEventEmitter = TypedEventEmitter;

},{"events":562}],43:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.unreachableCase = void 0;
/**
 * This function can be used to assert at compile time that a given value has type never.
 * One common usage is in the default case of a switch block,
 * to ensure that all cases are explicitly handled.
 */
function unreachableCase(_, message = "Unreachable Case") {
    throw new Error(message);
}
exports.unreachableCase = unreachableCase;

},{}],44:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],45:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFluidBrowserPackage = void 0;
const fluidPackage_1 = require("./fluidPackage");
/**
 * Determines if any object is an IFluidBrowserPackage
 * @param maybePkg - The object to check for compatibility with IFluidBrowserPackage
 */
const isFluidBrowserPackage = (maybePkg) => {
    var _a, _b, _c, _d, _e, _f;
    return (0, fluidPackage_1.isFluidPackage)(maybePkg)
        && typeof ((_c = (_b = (_a = maybePkg === null || maybePkg === void 0 ? void 0 : maybePkg.fluid) === null || _a === void 0 ? void 0 : _a.browser) === null || _b === void 0 ? void 0 : _b.umd) === null || _c === void 0 ? void 0 : _c.library) === "string"
        && Array.isArray((_f = (_e = (_d = maybePkg === null || maybePkg === void 0 ? void 0 : maybePkg.fluid) === null || _d === void 0 ? void 0 : _d.browser) === null || _e === void 0 ? void 0 : _e.umd) === null || _f === void 0 ? void 0 : _f.files);
};
exports.isFluidBrowserPackage = isFluidBrowserPackage;

},{"./fluidPackage":49}],46:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],47:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerErrorType = void 0;
/**
 * Different error types the Container may report out to the Host
 */
var ContainerErrorType;
(function (ContainerErrorType) {
    /**
     * Some error, most likely an exception caught by runtime and propagated to container as critical error
     */
    ContainerErrorType["genericError"] = "genericError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    ContainerErrorType["throttlingError"] = "throttlingError";
    /**
     * Data loss error detected by Container / DeltaManager. Likely points to storage issue.
     */
    ContainerErrorType["dataCorruptionError"] = "dataCorruptionError";
    /**
     * Error encountered when processing an operation. May correlate with data corruption.
     */
    ContainerErrorType["dataProcessingError"] = "dataProcessingError";
    /**
     * Error indicating an API is being used improperly resulting in an invalid operation.
     */
    ContainerErrorType["usageError"] = "usageError";
    /**
     * Error indicating an client session has expired. Currently this only happens when GC is allowed on a document and
     * aids in safely deleting unused objects.
     */
    ContainerErrorType["clientSessionExpiredError"] = "clientSessionExpiredError";
})(ContainerErrorType = exports.ContainerErrorType || (exports.ContainerErrorType = {}));

},{}],48:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],49:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IFluidCodeDetailsComparer = exports.isFluidCodeDetails = exports.isFluidPackage = void 0;
/**
 * Check if the package.json defines a Fluid package
 * @param pkg - the package json data to check if it is a Fluid package.
 */
const isFluidPackage = (pkg) => typeof pkg === "object"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.name) === "string"
    && typeof (pkg === null || pkg === void 0 ? void 0 : pkg.fluid) === "object";
exports.isFluidPackage = isFluidPackage;
const isFluidCodeDetails = (details) => {
    const maybeCodeDetails = details;
    return typeof maybeCodeDetails === "object"
        && (typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package) === "string" || (0, exports.isFluidPackage)(maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.package))
        && ((maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === undefined || typeof (maybeCodeDetails === null || maybeCodeDetails === void 0 ? void 0 : maybeCodeDetails.config) === "object");
};
exports.isFluidCodeDetails = isFluidCodeDetails;
exports.IFluidCodeDetailsComparer = "IFluidCodeDetailsComparer";

},{}],50:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This package contains the interfaces and types concerning the `Loader` and loading the `Container`.
 *
 * @packageDocumentation
 */
__exportStar(require("./audience"), exports);
__exportStar(require("./browserPackage"), exports);
__exportStar(require("./deltas"), exports);
__exportStar(require("./error"), exports);
__exportStar(require("./loader"), exports);
__exportStar(require("./fluidModule"), exports);
__exportStar(require("./fluidPackage"), exports);
__exportStar(require("./runtime"), exports);
__exportStar(require("./tokenProvider"), exports);

},{"./audience":44,"./browserPackage":45,"./deltas":46,"./error":47,"./fluidModule":48,"./fluidPackage":49,"./loader":51,"./runtime":52,"./tokenProvider":53}],51:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoaderHeader = void 0;
/**
 * Accepted header keys for requests coming to the Loader
 */
var LoaderHeader;
(function (LoaderHeader) {
    /**
     * Override the Loader's default caching behavior for this container.
     */
    LoaderHeader["cache"] = "fluid-cache";
    LoaderHeader["clientDetails"] = "fluid-client-details";
    /**
     * Start the container in a paused, unconnected state. Defaults to false
     */
    LoaderHeader["loadMode"] = "loadMode";
    LoaderHeader["reconnect"] = "fluid-reconnect";
    LoaderHeader["sequenceNumber"] = "fluid-sequence-number";
    /**
     * One of the following:
     * null or "null": use ops, no snapshots
     * undefined: fetch latest snapshot
     * otherwise, version sha to load snapshot
     */
    LoaderHeader["version"] = "version";
})(LoaderHeader = exports.LoaderHeader || (exports.LoaderHeader = {}));

},{}],52:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IRuntimeFactory = exports.BindState = exports.AttachState = void 0;
/**
 * The attachment state of some Fluid data (e.g. a container or data store), denoting whether it is uploaded to the
 * service.  The transition from detached to attached state is a one-way transition.
 */
var AttachState;
(function (AttachState) {
    /**
     * In detached state, the data is only present on the local client's machine.  It has not yet been uploaded
     * to the service.
     */
    AttachState["Detached"] = "Detached";
    /**
     * In attaching state, the data has started the upload to the service, but has not yet completed.
     */
    AttachState["Attaching"] = "Attaching";
    /**
     * In attached state, the data has completed upload to the service.  It can be accessed by other clients after
     * reaching attached state.
     */
    AttachState["Attached"] = "Attached";
})(AttachState = exports.AttachState || (exports.AttachState = {}));
// Represents the bind state of the entity.
var BindState;
(function (BindState) {
    BindState["NotBound"] = "NotBound";
    BindState["Binding"] = "Binding";
    BindState["Bound"] = "Bound";
})(BindState = exports.BindState || (exports.BindState = {}));
exports.IRuntimeFactory = "IRuntimeFactory";

},{}],53:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IFluidTokenProvider = void 0;
exports.IFluidTokenProvider = "IFluidTokenProvider";

},{}],54:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IContainerRuntime = void 0;
/**
 * @deprecated - This will be removed in a later release.
 */
exports.IContainerRuntime = "IContainerRuntime";

},{}],55:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./containerRuntime"), exports);

},{"./containerRuntime":54}],56:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindBatchTracker = exports.BatchTracker = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
class BatchTracker {
    constructor(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate, dateTimeProvider = () => common_utils_1.performance.now()) {
        this.batchEventEmitter = batchEventEmitter;
        this.trackedBatchCount = 0;
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "Batching");
        this.batchEventEmitter.on("batchBegin", (message) => {
            this.startBatchSequenceNumber = message.sequenceNumber;
            this.batchProcessingStartTimeStamp = dateTimeProvider();
            this.trackedBatchCount++;
        });
        this.batchEventEmitter.on("batchEnd", (error, message) => {
            (0, common_utils_1.assert)(this.startBatchSequenceNumber !== undefined && this.batchProcessingStartTimeStamp !== undefined, 0x2ba /* "batchBegin must fire before batchEnd" */);
            const length = message.sequenceNumber - this.startBatchSequenceNumber + 1;
            if (length >= batchLengthThreshold) {
                this.logger.sendErrorEvent({
                    eventName: "LengthTooBig",
                    length,
                    threshold: batchLengthThreshold,
                    batchEndSequenceNumber: message.sequenceNumber,
                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,
                    batchError: error !== undefined,
                });
            }
            if (this.trackedBatchCount % batchCountSamplingRate === 0) {
                this.logger.sendPerformanceEvent({
                    eventName: "Length",
                    length,
                    samplingRate: batchCountSamplingRate,
                    batchEndSequenceNumber: message.sequenceNumber,
                    duration: dateTimeProvider() - this.batchProcessingStartTimeStamp,
                });
            }
            this.startBatchSequenceNumber = undefined;
            this.batchProcessingStartTimeStamp = undefined;
        });
    }
}
exports.BatchTracker = BatchTracker;
/**
 * Track batch sizes in terms of op counts and processing times
 *
 * @param batchEventEmitter - event emitter which tracks the lifecycle of batch operations
 * @param logger - logger
 * @param batchLengthThreshold - threshold for the length of a batch when to send an error event
 * @param batchCountSamplingRate - rate for batches for which to send an event with its characteristics
 * @returns
 */
const BindBatchTracker = (batchEventEmitter, logger, batchLengthThreshold = 1000, batchCountSamplingRate = 1000) => new BatchTracker(batchEventEmitter, logger, batchLengthThreshold, batchCountSamplingRate);
exports.BindBatchTracker = BindBatchTracker;

},{"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],57:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobManager = exports.BlobHandle = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/**
 * This class represents blob (long string)
 * This object is used only when creating (writing) new blob and serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * DataObject.request() recognizes requests in the form of `/blobs/<id>`
 * and loads blob.
 */
class BlobHandle {
    constructor(path, routeContext, get) {
        this.path = path;
        this.routeContext = routeContext;
        this.get = get;
        this.attached = false;
        this.absolutePath = (0, runtime_utils_1.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.attached;
    }
    attachGraph() {
        this.attached = true;
    }
    bind(handle) {
        throw new Error("Cannot bind to blob handle");
    }
}
exports.BlobHandle = BlobHandle;
class BlobManager {
    constructor(routeContext, snapshot, getStorage, attachBlobCallback, 
    // To be called when a blob node is requested. blobPath is the path of the blob's node in GC's graph. It's
    // of the format `/<BlobManager.basePath>/<blobId>`.
    gcNodeUpdated, runtime, logger) {
        this.routeContext = routeContext;
        this.getStorage = getStorage;
        this.attachBlobCallback = attachBlobCallback;
        this.gcNodeUpdated = gcNodeUpdated;
        this.runtime = runtime;
        this.logger = logger;
        // uploaded blob IDs
        this.blobIds = new Set();
        // blobs for which upload is pending. maps to a promise that will resolve once the blob has been uploaded and a
        // BlobAttach op has round-tripped.
        this.pendingBlobIds = new Map();
        // blobs uploaded while detached; cleared upon attach
        this.detachedBlobIds = new Set();
        this.runtime.once("dispose", () => {
            for (const promise of this.pendingBlobIds.values()) {
                promise.reject(new Error("runtime disposed while blobAttach op in flight"));
            }
        });
        this.load(snapshot);
    }
    hasBlob(id) {
        return this.blobIds.has(id) || this.detachedBlobIds.has(id);
    }
    /**
     * For a blobId, returns its path in GC's graph. The node path is of the format `/<BlobManager.basePath>/<blobId>`
     * This path must match the path of the blob handle returned by the createBlob API because blobs are marked
     * referenced by storing these handles in a referenced DDS.
     */
    getBlobGCNodePath(blobId) {
        return `/${BlobManager.basePath}/${blobId}`;
    }
    async getBlob(blobId) {
        var _a, _b;
        const storageId = (_b = (_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.get(blobId)) !== null && _b !== void 0 ? _b : blobId;
        (0, common_utils_1.assert)(this.hasBlob(storageId), 0x11f /* "requesting unknown blobs" */);
        // When this blob is retrieved, let the container runtime know that the corresponding GC node got updated.
        this.gcNodeUpdated(this.getBlobGCNodePath(blobId));
        return new BlobHandle(`${BlobManager.basePath}/${storageId}`, this.routeContext, async () => telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, { eventName: "AttachmentReadBlob", id: storageId }, async () => {
            return this.getStorage().readBlob(storageId);
        }, { end: true, cancel: "error" }));
    }
    async createBlob(blob) {
        var _a, _b;
        if (this.runtime.attachState === container_definitions_1.AttachState.Attaching) {
            // blob upload is not supported in "Attaching" state
            this.logger.sendTelemetryEvent({ eventName: "CreateBlobWhileAttaching" });
            await new Promise((resolve) => this.runtime.once("attached", resolve));
        }
        if (!this.runtime.connected && this.runtime.attachState === container_definitions_1.AttachState.Attached) {
            // see https://github.com/microsoft/FluidFramework/issues/8246
            // Avoid getting storage if we are offline since it might be undefined. In the future we will return
            // handles immediately while offline
            await new Promise((resolve) => this.runtime.once("connected", resolve));
        }
        const response = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, { eventName: "createBlob" }, async () => this.getStorage().createBlob(blob), { end: true, cancel: "error" });
        const handle = new BlobHandle(`${BlobManager.basePath}/${response.id}`, this.routeContext, 
        // get() should go through BlobManager.getBlob() so handles created while detached can be redirected
        // to the correct storage id after they are uploaded
        async () => this.getBlob(response.id).then(async (h) => h.get()));
        if (this.runtime.attachState === container_definitions_1.AttachState.Detached) {
            this.detachedBlobIds.add(response.id);
            return handle;
        }
        // Note - server will de-dup blobs, so we might get existing blobId!
        if (this.pendingBlobIds.has(response.id)) {
            await ((_a = this.pendingBlobIds.get(response.id)) === null || _a === void 0 ? void 0 : _a.promise);
        }
        else if (!this.blobIds.has(response.id)) {
            this.pendingBlobIds.set(response.id, new common_utils_1.Deferred());
            // send blob attach op and wait until we see it to return the handle
            this.attachBlobCallback(response.id);
            await ((_b = this.pendingBlobIds.get(response.id)) === null || _b === void 0 ? void 0 : _b.promise);
        }
        return handle;
    }
    processBlobAttachOp(blobId, local) {
        if (local) {
            const pendingBlobP = this.pendingBlobIds.get(blobId);
            (0, common_utils_1.assert)(pendingBlobP !== undefined, 0x1f8 /* "local BlobAttach op with no pending blob" */);
            pendingBlobP.resolve();
            this.pendingBlobIds.delete(blobId);
        }
        this.blobIds.add(blobId);
    }
    /**
     * Reads blobs needed to load BlobManager from storage.
     */
    static async load(blobsTree, tryFetchBlob) {
        if (!blobsTree) {
            return {};
        }
        let redirectTable;
        const tableId = blobsTree.blobs[this.redirectTableBlobName];
        if (tableId) {
            redirectTable = await tryFetchBlob(tableId);
        }
        const ids = Object.entries(blobsTree.blobs)
            .filter(([k, _]) => k !== this.redirectTableBlobName).map(([_, v]) => v);
        return { ids, redirectTable };
    }
    /**
     * Load a set of previously attached blob IDs from a previous snapshot. Note
     * that BlobManager tracking and reporting attached blobs is a temporary
     * solution since storage expects attached blobs to be reported and any that
     * are not reported as attached may be GCed. In the future attached blob
     * IDs will be collected at summarization time, and runtime will not care
     * about the existence or specific formatting of this tree in returned
     * snapshots.
     *
     * @param blobsTree - Tree containing IDs of previously attached blobs. This
     * corresponds to snapshot() below. We look for the IDs in the blob entries
     * of the tree since the both the r11s and SPO drivers replace the
     * attachment types returned in snapshot() with blobs.
     */
    load(snapshot) {
        var _a, _b, _c;
        if (snapshot.ids) {
            const detached = this.runtime.attachState === container_definitions_1.AttachState.Detached;
            snapshot.ids.map((entry) => detached ? this.detachedBlobIds.add(entry) : this.blobIds.add(entry));
        }
        if (snapshot.redirectTable) {
            this.redirectTable = new Map(snapshot.redirectTable);
        }
        this.logger.sendTelemetryEvent({
            eventName: "AttachmentBlobsLoaded",
            count: (_b = (_a = snapshot.ids) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0,
            redirectTable: (_c = snapshot.redirectTable) === null || _c === void 0 ? void 0 : _c.length,
        });
    }
    /**
     * Generates data used for garbage collection. Each blob uploaded represents a node in the GC graph as it can be
     * individually referenced by storing its handle in a referenced DDS. Returns the list of blob ids as GC nodes.
     * @param fullGC - true to bypass optimizations and force full generation of GC data. BlobManager doesn't care
     * about this for now because the data is a simple list of blob ids.
     */
    getGCData(fullGC = false) {
        const gcData = { gcNodes: {} };
        this.blobIds.forEach((blobId) => {
            gcData.gcNodes[this.getBlobGCNodePath(blobId)] = [];
        });
        /**
         * For all blobs in the redirect table, the handle returned on creation is based off of the localId. So, these
         * nodes can be referenced by storing the localId handle. When that happens, the corresponding storageId node
         * must also be marked referenced. So, we add a route from the localId node to the storageId node.
         * Note that because of de-duping, there can be multiple localIds that all redirect to the same storageId or
         * a blob may be referenced via its storageId handle.
         */
        if (this.redirectTable !== undefined) {
            for (const [localId, storageId] of this.redirectTable) {
                // Add node for the localId and add a route to the storageId node. The storageId node will have been
                // added above when adding nodes for this.blobIds.
                gcData.gcNodes[this.getBlobGCNodePath(localId)] = [this.getBlobGCNodePath(storageId)];
            }
        }
        return gcData;
    }
    /**
     * When running GC in test mode, this is called to delete blobs that are unused.
     * @param unusedRoutes - These are the blob node ids that are unused and should be deleted.
     */
    deleteUnusedRoutes(unusedRoutes) {
        var _a;
        // The routes or blob node paths are in the same format as returned in getGCData -
        // `/<BlobManager.basePath>/<blobId>`.
        for (const route of unusedRoutes) {
            const pathParts = route.split("/");
            (0, common_utils_1.assert)(pathParts.length === 3 && pathParts[1] === BlobManager.basePath, 0x2d5 /* "Invalid blob node id in unused routes." */);
            const blobId = pathParts[2];
            // The unused blobId could be a localId. If so, remove it from the redirect table and continue. The
            // corresponding storageId may still be used either directly or via other localIds.
            if ((_a = this.redirectTable) === null || _a === void 0 ? void 0 : _a.has(blobId)) {
                this.redirectTable.delete(blobId);
                continue;
            }
            this.blobIds.delete(blobId);
        }
    }
    summarize(telemetryContext) {
        // If we have a redirect table it means the container is about to transition to "Attaching" state, so we need
        // to return an actual snapshot containing all the real storage IDs we know about.
        const attachingOrAttached = !!this.redirectTable || this.runtime.attachState !== container_definitions_1.AttachState.Detached;
        const blobIds = attachingOrAttached ? this.blobIds : this.detachedBlobIds;
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        blobIds.forEach((blobId) => {
            builder.addAttachment(blobId);
        });
        if (this.redirectTable && this.redirectTable.size > 0) {
            builder.addBlob(BlobManager.redirectTableBlobName, JSON.stringify(Array.from(this.redirectTable.entries())));
        }
        return builder.getSummaryTree();
    }
    setRedirectTable(table) {
        (0, common_utils_1.assert)(this.runtime.attachState === container_definitions_1.AttachState.Detached, 0x252 /* "redirect table can only be set in detached container" */);
        (0, common_utils_1.assert)(!this.redirectTable, 0x253 /* "redirect table already exists" */);
        for (const [localId, storageId] of table) {
            (0, common_utils_1.assert)(this.detachedBlobIds.delete(localId), 0x254 /* "unrecognized id in redirect table" */);
            this.blobIds.add(storageId);
        }
        (0, common_utils_1.assert)(this.detachedBlobIds.size === 0, 0x255 /* "detached blob id absent in redirect table" */);
        this.redirectTable = table;
    }
}
exports.BlobManager = BlobManager;
BlobManager.basePath = "_blobs";
BlobManager.redirectTableBlobName = ".redirectTable";

},{"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279}],58:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportOpPerfTelemetry = exports.latencyThreshold = void 0;
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * We report various latency-related errors when waiting for op roundtrip takes longer than that amout of time.
 */
exports.latencyThreshold = 5000;
class OpPerfTelemetry {
    constructor(clientId, deltaManager, logger) {
        this.clientId = clientId;
        this.deltaManager = deltaManager;
        this.pongCount = 0;
        this.msnTrackingTimestamp = 0;
        this.opProcessingTimes = {};
        // Performance Data to be reported for ops round trips and processing.
        this.opPerfData = {};
        this.firstConnection = true;
        this.bootTime = common_utils_1.performance.now();
        this.connectionStartTime = 0;
        this.gap = 0;
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "OpPerf");
        this.deltaManager.on("pong", (latency) => this.recordPingTime(latency));
        this.deltaManager.on("submitOp", (message) => this.beforeOpSubmit(message));
        this.deltaManager.on("op", (message) => this.afterProcessingOp(message));
        this.deltaManager.on("connect", (details, opsBehind) => {
            this.clientId = details.clientId;
            if (opsBehind !== undefined) {
                this.connectionOpSeqNumber = this.deltaManager.lastKnownSeqNumber;
                this.gap = opsBehind;
                this.connectionStartTime = common_utils_1.performance.now();
                // We might be already up-today. If so, report it right away.
                if (this.gap <= 0) {
                    this.reportGettingUpToDate();
                }
            }
        });
        this.deltaManager.on("disconnect", () => {
            this.sequenceNumberForMsnTracking = undefined;
            this.clientSequenceNumberForLatencyStatistics = undefined;
            this.opProcessingTimes = {};
            this.opPerfData = {};
            this.connectionOpSeqNumber = undefined;
            this.firstConnection = false;
            this.pongCount = 0;
        });
        this.deltaManager.outbound.on("push", (messages) => {
            for (const msg of messages) {
                if (msg.type === protocol_definitions_1.MessageType.Operation &&
                    this.clientSequenceNumberForLatencyStatistics === msg.clientSequenceNumber) {
                    (0, common_utils_1.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2c8 /* "outboundPushEventTime should be undefined" */);
                    (0, common_utils_1.assert)(this.opPerfData.durationNetwork === undefined, 0x2c9 /* "durationNetwork should be undefined" */);
                    this.opProcessingTimes.outboundPushEventTime = Date.now();
                    (0, common_utils_1.assert)(this.opPerfData.durationOutboundBatching === undefined, 0x2ca /* "durationOutboundBatching should be undefined" */);
                    (0, common_utils_1.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x2cb /* "submitOpEventTime should be undefined" */);
                    this.opPerfData.durationOutboundBatching = this.opProcessingTimes.outboundPushEventTime
                        - this.opProcessingTimes.submitOpEventTime;
                }
            }
        });
        this.deltaManager.inbound.on("push", (message) => {
            if (this.clientId === message.clientId &&
                message.type === protocol_definitions_1.MessageType.Operation &&
                this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber &&
                this.opProcessingTimes.outboundPushEventTime !== undefined) {
                this.opProcessingTimes.inboundPushEventTime = Date.now();
                this.opPerfData.durationNetwork = this.opProcessingTimes.inboundPushEventTime
                    - this.opProcessingTimes.outboundPushEventTime;
                this.opProcessingTimes.outboundPushEventTime = undefined;
                this.opPerfData.lengthInboundQueue = this.deltaManager.inbound.length;
            }
        });
        this.deltaManager.inbound.on("idle", (count, duration) => {
            // Do not want to log zero for sure.
            // We are more interested in aggregates, so logging only if we are processing some number of ops
            // Cut-off is arbitrary - can be increased or decreased based on amount of data collected and questions we
            // want to get answered
            // back-compat: Once 0.36 loader version saturates (count & duration args were added there),
            // we can remove typeof check.
            if (typeof count === "number" && count >= 100) {
                this.logger.sendPerformanceEvent({
                    eventName: "GetDeltas_OpProcessing",
                    count,
                    duration,
                });
            }
        });
    }
    reportGettingUpToDate() {
        this.connectionOpSeqNumber = undefined;
        this.logger.sendPerformanceEvent({
            eventName: "ConnectionSpeed",
            duration: common_utils_1.performance.now() - this.connectionStartTime,
            ops: this.gap,
            // track time to connect only for first connection.
            timeToConnect: this.firstConnection ?
                telemetry_utils_1.TelemetryLogger.formatTick(this.connectionStartTime - this.bootTime) :
                undefined,
            firstConnection: this.firstConnection,
        });
    }
    recordPingTime(latency) {
        this.pingLatency = latency;
        // logging one in every 1000 pongs, including the first time, if it is a "write" client.
        if (this.pongCount % 100 === 0 && this.deltaManager.active) {
            this.logger.sendPerformanceEvent({
                eventName: "DeltaLatency",
                duration: latency,
            });
        }
        this.pongCount++;
    }
    beforeOpSubmit(message) {
        // start with first client op and measure latency every 500 client ops
        if (this.clientSequenceNumberForLatencyStatistics === undefined &&
            message.clientSequenceNumber % 500 === 1) {
            (0, common_utils_1.assert)(this.opProcessingTimes.outboundPushEventTime === undefined, 0x2cc /* "OpTimeSittingInboundQueue should be undefined" */);
            (0, common_utils_1.assert)(this.opPerfData.durationNetwork === undefined, 0x2cd /* "durationNetwork should be undefined" */);
            this.opProcessingTimes.submitOpEventTime = Date.now();
            this.clientSequenceNumberForLatencyStatistics = message.clientSequenceNumber;
        }
    }
    afterProcessingOp(message) {
        const sequenceNumber = message.sequenceNumber;
        if (sequenceNumber === this.connectionOpSeqNumber) {
            this.reportGettingUpToDate();
        }
        // Record collab window max size after every 1000th op.
        if (this.sequenceNumberForMsnTracking === undefined && sequenceNumber % 1000 === 0) {
            this.sequenceNumberForMsnTracking = sequenceNumber;
            this.msnTrackingTimestamp = message.timestamp;
        }
        if (this.sequenceNumberForMsnTracking !== undefined &&
            message.minimumSequenceNumber >= this.sequenceNumberForMsnTracking) {
            (0, common_utils_1.assert)(this.msnTrackingTimestamp !== undefined, 0x2ce /* "msnTrackingTimestamp should not be undefined" */);
            this.logger.sendPerformanceEvent({
                eventName: "MsnStatistics",
                sequenceNumber,
                msnDistance: sequenceNumber - this.sequenceNumberForMsnTracking,
                duration: message.timestamp - this.msnTrackingTimestamp,
            });
            this.sequenceNumberForMsnTracking = undefined;
        }
        if (this.clientId === message.clientId &&
            this.clientSequenceNumberForLatencyStatistics === message.clientSequenceNumber) {
            (0, common_utils_1.assert)(this.opProcessingTimes.submitOpEventTime !== undefined, 0x120 /* "Undefined latency statistics (op send time)" */);
            const currentTime = Date.now();
            if (this.opProcessingTimes.inboundPushEventTime !== undefined) {
                this.opPerfData.durationInboundToProcessing = currentTime
                    - this.opProcessingTimes.inboundPushEventTime;
            }
            const duration = currentTime - this.opProcessingTimes.submitOpEventTime;
            // One of the core expectations for Fluid service is to be fast.
            // When it's not the case, we want to learn about it and be able to investigate, so
            // raise awareness.
            // This also helps identify cases where it's due to client behavior (sending too many ops)
            // that results in overwhelming ordering service and thus starting to see long latencies.
            // The threshold could be adjusted, but ideally it stays  workload-agnostic, as service
            // performance impacts all workloads relying on service.
            const category = duration > exports.latencyThreshold ? "error" : "performance";
            this.logger.sendPerformanceEvent(Object.assign({ eventName: "OpRoundtripTime", sequenceNumber, referenceSequenceNumber: message.referenceSequenceNumber, duration,
                category, pingLatency: this.pingLatency, msnDistance: this.deltaManager.lastSequenceNumber - this.deltaManager.minimumSequenceNumber }, this.opPerfData));
            this.clientSequenceNumberForLatencyStatistics = undefined;
            this.opPerfData = {};
        }
    }
}
function ReportOpPerfTelemetry(clientId, deltaManager, logger) {
    new OpPerfTelemetry(clientId, deltaManager, logger);
}
exports.ReportOpPerfTelemetry = ReportOpPerfTelemetry;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],59:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerFluidHandleContext = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
class ContainerFluidHandleContext {
    /**
     * Creates a new ContainerFluidHandleContext.
     * @param path - The path to this handle relative to the routeContext.
     * @param runtime - The IRuntime object this context represents.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(path, runtime, routeContext) {
        this.path = path;
        this.runtime = runtime;
        this.routeContext = routeContext;
        this.absolutePath = (0, runtime_utils_1.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandleContext() { return this; }
    attachGraph() {
        throw new Error("can't attach container runtime form within container!");
    }
    get isAttached() {
        return this.runtime.attachState !== container_definitions_1.AttachState.Detached;
    }
    async resolveHandle(request) {
        return this.runtime.resolveHandle(request);
    }
}
exports.ContainerFluidHandleContext = ContainerFluidHandleContext;

},{"@fluidframework/container-definitions":50,"@fluidframework/runtime-utils":213}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerRuntime = exports.getDeviceSpec = exports.agentSchedulerId = exports.ScheduleManager = exports.unpackRuntimeMessage = exports.isRuntimeMessage = exports.RuntimeMessage = exports.RuntimeHeaders = exports.DefaultSummaryConfiguration = exports.ContainerMessageType = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const garbage_collector_1 = require("@fluidframework/garbage-collector");
const uuid_1 = require("uuid");
const containerHandleContext_1 = require("./containerHandleContext");
const dataStoreRegistry_1 = require("./dataStoreRegistry");
const summarizer_1 = require("./summarizer");
const summaryManager_1 = require("./summaryManager");
const deltaScheduler_1 = require("./deltaScheduler");
const connectionTelemetry_1 = require("./connectionTelemetry");
const pendingStateManager_1 = require("./pendingStateManager");
const packageVersion_1 = require("./packageVersion");
const blobManager_1 = require("./blobManager");
const dataStores_1 = require("./dataStores");
const summaryFormat_1 = require("./summaryFormat");
const summaryCollection_1 = require("./summaryCollection");
const orderedClientElection_1 = require("./orderedClientElection");
const summarizerClientElection_1 = require("./summarizerClientElection");
const throttler_1 = require("./throttler");
const runWhileConnectedCoordinator_1 = require("./runWhileConnectedCoordinator");
const garbageCollection_1 = require("./garbageCollection");
const dataStore_1 = require("./dataStore");
const batchTracker_1 = require("./batchTracker");
const serializedSnapshotStorage_1 = require("./serializedSnapshotStorage");
const opTelemetry_1 = require("./opTelemetry");
var ContainerMessageType;
(function (ContainerMessageType) {
    // An op to be delivered to store
    ContainerMessageType["FluidDataStoreOp"] = "component";
    // Creates a new store
    ContainerMessageType["Attach"] = "attach";
    // Chunked operation.
    ContainerMessageType["ChunkedOp"] = "chunkedOp";
    // Signifies that a blob has been attached and should not be garbage collected by storage
    ContainerMessageType["BlobAttach"] = "blobAttach";
    // Ties our new clientId to our old one on reconnect
    ContainerMessageType["Rejoin"] = "rejoin";
    // Sets the alias of a root data store
    ContainerMessageType["Alias"] = "alias";
})(ContainerMessageType = exports.ContainerMessageType || (exports.ContainerMessageType = {}));
exports.DefaultSummaryConfiguration = {
    state: "enabled",
    idleTime: 5000 * 3,
    maxTime: 5000 * 12,
    maxOps: 100,
    minOpsForLastSummaryAttempt: 10,
    maxAckWaitTime: 6 * 10 * 1000,
    maxOpsSinceLastSummary: 7000,
    initialSummarizerDelayMs: 5000,
    summarizerClientElection: false,
};
/**
 * Accepted header keys for requests coming to the runtime.
 */
var RuntimeHeaders;
(function (RuntimeHeaders) {
    /** True to wait for a data store to be created and loaded before returning it. */
    RuntimeHeaders["wait"] = "wait";
    /**
     * True if the request is from an external app. Used for GC to handle scenarios where a data store
     * is deleted and requested via an external app.
     */
    RuntimeHeaders["externalRequest"] = "externalRequest";
    /** True if the request is coming from an IFluidHandle. */
    RuntimeHeaders["viaHandle"] = "viaHandle";
})(RuntimeHeaders = exports.RuntimeHeaders || (exports.RuntimeHeaders = {}));
const useDataStoreAliasingKey = "Fluid.ContainerRuntime.UseDataStoreAliasing";
const maxConsecutiveReconnectsKey = "Fluid.ContainerRuntime.MaxConsecutiveReconnects";
// Feature gate for the max op size. If the value is negative, chunking is enabled
// and all ops over 16k would be chunked. If the value is positive, all ops with
// a size strictly larger will be rejected and the container closed with an error.
const maxOpSizeInBytesKey = "Fluid.ContainerRuntime.MaxOpSizeInBytes";
// By default, we should reject any op larger than 768KB,
// in order to account for some extra overhead from serialization
// to not reach the 1MB limits in socket.io and Kafka.
const defaultMaxOpSizeInBytes = 768000;
// By default, the size of the contents for the incoming ops is tracked.
// However, in certain situations, this may incur a performance hit.
// The feature-gate below can be used to disable this feature.
const disableOpTrackingKey = "Fluid.ContainerRuntime.DisableOpTracking";
const defaultFlushMode = runtime_definitions_1.FlushMode.TurnBased;
var RuntimeMessage;
(function (RuntimeMessage) {
    RuntimeMessage["FluidDataStoreOp"] = "component";
    RuntimeMessage["Attach"] = "attach";
    RuntimeMessage["ChunkedOp"] = "chunkedOp";
    RuntimeMessage["BlobAttach"] = "blobAttach";
    RuntimeMessage["Rejoin"] = "rejoin";
    RuntimeMessage["Alias"] = "alias";
    RuntimeMessage["Operation"] = "op";
})(RuntimeMessage = exports.RuntimeMessage || (exports.RuntimeMessage = {}));
function isRuntimeMessage(message) {
    if (Object.values(RuntimeMessage).includes(message.type)) {
        return true;
    }
    return false;
}
exports.isRuntimeMessage = isRuntimeMessage;
function unpackRuntimeMessage(message) {
    if (message.type === protocol_definitions_1.MessageType.Operation) {
        // legacy op format?
        if (message.contents.address !== undefined && message.contents.type === undefined) {
            message.type = ContainerMessageType.FluidDataStoreOp;
        }
        else {
            // new format
            const innerContents = message.contents;
            (0, common_utils_1.assert)(innerContents.type !== undefined, 0x121 /* "Undefined inner contents type!" */);
            message.type = innerContents.type;
            message.contents = innerContents.contents;
        }
        (0, common_utils_1.assert)((0, driver_utils_1.isUnpackedRuntimeMessage)(message), 0x122 /* "Message to unpack is not proper runtime message" */);
    }
    else {
        // Legacy format, but it's already "unpacked",
        // i.e. message.type is actually ContainerMessageType.
        // Nothing to do in such case.
    }
    return message;
}
exports.unpackRuntimeMessage = unpackRuntimeMessage;
/**
 * This class controls pausing and resuming of inbound queue to ensure that we never
 * start processing ops in a batch IF we do not have all ops in the batch.
 */
class ScheduleManagerCore {
    constructor(deltaManager, logger) {
        this.deltaManager = deltaManager;
        this.logger = logger;
        this.localPaused = false;
        this.timePaused = 0;
        this.batchCount = 0;
        // Listen for delta manager sends and add batch metadata to messages
        this.deltaManager.on("prepareSend", (messages) => {
            if (messages.length === 0) {
                return;
            }
            // First message will have the batch flag set to true if doing a batched send
            const firstMessageMetadata = messages[0].metadata;
            if (!(firstMessageMetadata === null || firstMessageMetadata === void 0 ? void 0 : firstMessageMetadata.batch)) {
                return;
            }
            // If the batch contains only a single op, clear the batch flag.
            if (messages.length === 1) {
                delete firstMessageMetadata.batch;
                return;
            }
            // Set the batch flag to false on the last message to indicate the end of the send batch
            const lastMessage = messages[messages.length - 1];
            lastMessage.metadata = Object.assign(Object.assign({}, lastMessage.metadata), { batch: false });
        });
        // Listen for updates and peek at the inbound
        this.deltaManager.inbound.on("push", (message) => {
            this.trackPending(message);
        });
        // Start with baseline - empty inbound queue.
        (0, common_utils_1.assert)(!this.localPaused, 0x293 /* "initial state" */);
        const allPending = this.deltaManager.inbound.toArray();
        for (const pending of allPending) {
            this.trackPending(pending);
        }
        // We are intentionally directly listening to the "op" to inspect system ops as well.
        // If we do not observe system ops, we are likely to hit 0x296 assert when system ops
        // precedes start of incomplete batch.
        this.deltaManager.on("op", (message) => this.afterOpProcessing(message.sequenceNumber));
    }
    /**
     * The only public function in this class - called when we processed an op,
     * to make decision if op processing should be paused or not afer that.
     */
    afterOpProcessing(sequenceNumber) {
        (0, common_utils_1.assert)(!this.localPaused, 0x294 /* "can't have op processing paused if we are processing an op" */);
        // If the inbound queue is ever empty, nothing to do!
        if (this.deltaManager.inbound.length === 0) {
            (0, common_utils_1.assert)(this.pauseSequenceNumber === undefined, 0x295 /* "there should be no pending batch if we have no ops" */);
            return;
        }
        // The queue is
        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:
        //    - here (processing ops until reaching start of incomplete batch)
        //    - in trackPending(), when queue was empty and start of batch showed up.
        // 2. resumed when batch end comes in (in trackPending())
        // do we have incomplete batch to worry about?
        if (this.pauseSequenceNumber !== undefined) {
            (0, common_utils_1.assert)(sequenceNumber < this.pauseSequenceNumber, 0x296 /* "we should never start processing incomplete batch!" */);
            // If the next op is the start of incomplete batch, then we can't process it until it's fully in - pause!
            if (sequenceNumber + 1 === this.pauseSequenceNumber) {
                this.pauseQueue();
            }
        }
    }
    pauseQueue() {
        (0, common_utils_1.assert)(!this.localPaused, 0x297 /* "always called from resumed state" */);
        this.localPaused = true;
        this.timePaused = common_utils_1.performance.now();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.deltaManager.inbound.pause();
    }
    resumeQueue(startBatch, messageEndBatch) {
        const endBatch = messageEndBatch.sequenceNumber;
        const duration = this.localPaused ? (common_utils_1.performance.now() - this.timePaused) : undefined;
        this.batchCount++;
        if (this.batchCount % 1000 === 1) {
            this.logger.sendTelemetryEvent({
                eventName: "BatchStats",
                sequenceNumber: endBatch,
                length: endBatch - startBatch + 1,
                msnDistance: endBatch - messageEndBatch.minimumSequenceNumber,
                duration,
                batchCount: this.batchCount,
                interrupted: this.localPaused,
            });
        }
        // Return early if no change in value
        if (!this.localPaused) {
            return;
        }
        this.localPaused = false;
        // Random round number - we want to know when batch waiting paused op processing.
        if (duration !== undefined && duration > connectionTelemetry_1.latencyThreshold) {
            this.logger.sendErrorEvent({
                eventName: "MaxBatchWaitTimeExceeded",
                duration,
                sequenceNumber: endBatch,
                length: endBatch - startBatch,
            });
        }
        this.deltaManager.inbound.resume();
    }
    /**
     * Called for each incoming op (i.e. inbound "push" notification)
     */
    trackPending(message) {
        (0, common_utils_1.assert)(this.deltaManager.inbound.length !== 0, 0x298 /* "we have something in the queue that generates this event" */);
        (0, common_utils_1.assert)((this.currentBatchClientId === undefined) === (this.pauseSequenceNumber === undefined), 0x299 /* "non-synchronized state" */);
        const metadata = message.metadata;
        const batchMetadata = metadata === null || metadata === void 0 ? void 0 : metadata.batch;
        // Protocol messages are never part of a runtime batch of messages
        if (!(0, driver_utils_1.isUnpackedRuntimeMessage)(message)) {
            // Protocol messages should never show up in the middle of the batch!
            (0, common_utils_1.assert)(this.currentBatchClientId === undefined, 0x29a /* "System message in the middle of batch!" */);
            (0, common_utils_1.assert)(batchMetadata === undefined, 0x29b /* "system op in a batch?" */);
            (0, common_utils_1.assert)(!this.localPaused, 0x29c /* "we should be processing ops when there is no active batch" */);
            return;
        }
        if (this.currentBatchClientId === undefined && batchMetadata === undefined) {
            (0, common_utils_1.assert)(!this.localPaused, 0x29d /* "we should be processing ops when there is no active batch" */);
            return;
        }
        // If the client ID changes then we can move the pause point. If it stayed the same then we need to check.
        // If batchMetadata is not undefined then if it's true we've begun a new batch - if false we've ended
        // the previous one
        if (this.currentBatchClientId !== undefined || batchMetadata === false) {
            if (this.currentBatchClientId !== message.clientId) {
                // "Batch not closed, yet message from another client!"
                throw new container_utils_1.DataCorruptionError("OpBatchIncomplete", Object.assign({ runtimeVersion: packageVersion_1.pkgVersion, batchClientId: this.currentBatchClientId }, (0, container_utils_1.extractSafePropertiesFromMessage)(message)));
            }
        }
        // The queue is
        // 1. paused only when the next message to be processed is the beginning of a batch. Done in two places:
        //    - in afterOpProcessing() - processing ops until reaching start of incomplete batch
        //    - here (batchMetadata == false below), when queue was empty and start of batch showed up.
        // 2. resumed when batch end comes in (batchMetadata === true case below)
        if (batchMetadata) {
            (0, common_utils_1.assert)(this.currentBatchClientId === undefined, 0x29e /* "there can't be active batch" */);
            (0, common_utils_1.assert)(!this.localPaused, 0x29f /* "we should be processing ops when there is no active batch" */);
            this.pauseSequenceNumber = message.sequenceNumber;
            this.currentBatchClientId = message.clientId;
            // Start of the batch
            // Only pause processing if queue has no other ops!
            // If there are any other ops in the queue, processing will be stopped when they are processed!
            if (this.deltaManager.inbound.length === 1) {
                this.pauseQueue();
            }
        }
        else if (batchMetadata === false) {
            (0, common_utils_1.assert)(this.pauseSequenceNumber !== undefined, 0x2a0 /* "batch presence was validated above" */);
            // Batch is complete, we can process it!
            this.resumeQueue(this.pauseSequenceNumber, message);
            this.pauseSequenceNumber = undefined;
            this.currentBatchClientId = undefined;
        }
        else {
            // Continuation of current batch. Do nothing
            (0, common_utils_1.assert)(this.currentBatchClientId !== undefined, 0x2a1 /* "logic error" */);
        }
    }
}
/**
 * This class has the following responsibilities:
 * 1. It tracks batches as we process ops and raises "batchBegin" and "batchEnd" events.
 *    As part of it, it validates batch correctness (i.e. no system ops in the middle of batch)
 * 2. It creates instance of ScheduleManagerCore that ensures we never start processing ops from batch
 *    unless all ops of the batch are in.
 */
class ScheduleManager {
    constructor(deltaManager, emitter, logger) {
        this.deltaManager = deltaManager;
        this.emitter = emitter;
        this.logger = logger;
        this.hitError = false;
        this.deltaScheduler = new deltaScheduler_1.DeltaScheduler(this.deltaManager, telemetry_utils_1.ChildLogger.create(this.logger, "DeltaScheduler"));
        void new ScheduleManagerCore(deltaManager, logger);
    }
    beforeOpProcessing(message) {
        var _a;
        if (this.batchClientId !== message.clientId) {
            (0, common_utils_1.assert)(this.batchClientId === undefined, 0x2a2 /* "Batch is interrupted by other client op. Should be caught by trackPending()" */);
            // This could be the beginning of a new batch or an individual message.
            this.emitter.emit("batchBegin", message);
            this.deltaScheduler.batchBegin(message);
            const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
            if (batch) {
                this.batchClientId = message.clientId;
            }
            else {
                this.batchClientId = undefined;
            }
        }
    }
    afterOpProcessing(error, message) {
        var _a;
        // If this is no longer true, we need to revisit what we do where we set this.hitError.
        (0, common_utils_1.assert)(!this.hitError, 0x2a3 /* "container should be closed on any error" */);
        if (error) {
            // We assume here that loader will close container and stop processing all future ops.
            // This is implicit dependency. If this flow changes, this code might no longer be correct.
            this.hitError = true;
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", error, message);
            this.deltaScheduler.batchEnd(message);
            return;
        }
        const batch = (_a = message === null || message === void 0 ? void 0 : message.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // If no batchClientId has been set then we're in an individual batch. Else, if we get
        // batch end metadata, this is end of the current batch.
        if (this.batchClientId === undefined || batch === false) {
            this.batchClientId = undefined;
            this.emitter.emit("batchEnd", undefined, message);
            this.deltaScheduler.batchEnd(message);
            return;
        }
    }
}
exports.ScheduleManager = ScheduleManager;
/**
 * Legacy ID for the built-in AgentScheduler.  To minimize disruption while removing it, retaining this as a
 * special-case for document dirty state.  Ultimately we should have no special-cases from the
 * ContainerRuntime's perspective.
 */
exports.agentSchedulerId = "_scheduler";
// safely check navigator and get the hardware spec value
function getDeviceSpec() {
    try {
        if (typeof navigator === "object" && navigator !== null) {
            return {
                deviceMemory: navigator.deviceMemory,
                hardwareConcurrency: navigator.hardwareConcurrency,
            };
        }
    }
    catch (_a) {
    }
    return {};
}
exports.getDeviceSpec = getDeviceSpec;
/**
 * Represents the runtime of the container. Contains helper functions/state of the container.
 * It will define the store level mappings.
 */
class ContainerRuntime extends common_utils_1.TypedEventEmitter {
    constructor(context, registry, metadata, electedSummarizerData, chunks, dataStoreAliasMap, runtimeOptions, containerScope, logger, existing, blobManagerSnapshot, _storage, requestHandler, summaryConfiguration) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (summaryConfiguration === void 0) { summaryConfiguration = Object.assign(Object.assign({}, exports.DefaultSummaryConfiguration), (_a = runtimeOptions.summaryOptions) === null || _a === void 0 ? void 0 : _a.summaryConfigOverrides); }
        super();
        this.context = context;
        this.registry = registry;
        this.runtimeOptions = runtimeOptions;
        this.containerScope = containerScope;
        this.logger = logger;
        this._storage = _storage;
        this.requestHandler = requestHandler;
        this.summaryConfiguration = summaryConfiguration;
        this.defaultMaxConsecutiveReconnects = 15;
        this._orderSequentiallyCalls = 0;
        this.needsFlush = false;
        this.flushTrigger = false;
        this.savedOps = [];
        this.consecutiveReconnects = 0;
        this._disposed = false;
        this.emitDirtyDocumentEvent = true;
        this.defaultTelemetrySignalSampleCount = 100;
        this._perfSignalData = {
            signalsLost: 0,
            signalSequenceNumber: 0,
            signalTimestamp: 0,
            trackingSignalSequenceNumber: undefined,
        };
        this.summarizeOnDemand = (...args) => {
            if (this.clientDetails.type === summarizerClientElection_1.summarizerClientType) {
                return this.summarizer.summarizeOnDemand(...args);
            }
            else if (this.summaryManager !== undefined) {
                return this.summaryManager.summarizeOnDemand(...args);
            }
            else {
                // If we're not the summarizer, and we don't have a summaryManager, we expect that
                // disableSummaries is turned on. We are throwing instead of returning a failure here,
                // because it is a misuse of the API rather than an expected failure.
                throw new container_utils_1.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);
            }
        };
        this.enqueueSummarize = (...args) => {
            if (this.clientDetails.type === summarizerClientElection_1.summarizerClientType) {
                return this.summarizer.enqueueSummarize(...args);
            }
            else if (this.summaryManager !== undefined) {
                return this.summaryManager.enqueueSummarize(...args);
            }
            else {
                // If we're not the summarizer, and we don't have a summaryManager, we expect that
                // generateSummaries is turned off. We are throwing instead of returning a failure here,
                // because it is a misuse of the API rather than an expected failure.
                throw new container_utils_1.UsageError(`Can't summarize, disableSummaries: ${this.summariesDisabled}`);
            }
        };
        this.messageAtLastSummary = metadata === null || metadata === void 0 ? void 0 : metadata.message;
        // Default to false (enabled).
        this.disableIsolatedChannels = (_b = this.runtimeOptions.summaryOptions.disableIsolatedChannels) !== null && _b !== void 0 ? _b : false;
        this._connected = this.context.connected;
        this.chunkMap = new Map(chunks);
        this.handleContext = new containerHandleContext_1.ContainerFluidHandleContext("", this);
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(telemetry_utils_1.ChildLogger.create(this.logger, "ContainerRuntime"));
        this.summariesDisabled = this.isSummariesDisabled();
        this.heuristicsDisabled = this.isHeuristicsDisabled();
        this.summarizerClientElectionEnabled = this.isSummarizerClientElectionEnabled();
        this.maxOpsSinceLastSummary = this.getMaxOpsSinceLastSummary();
        this.initialSummarizerDelayMs = this.getInitialSummarizerDelayMs();
        this._aliasingEnabled =
            ((_c = this.mc.config.getBoolean(useDataStoreAliasingKey)) !== null && _c !== void 0 ? _c : false) ||
                ((_d = runtimeOptions.useDataStoreAliasing) !== null && _d !== void 0 ? _d : false);
        this._maxOpSizeInBytes = ((_e = this.mc.config.getNumber(maxOpSizeInBytesKey)) !== null && _e !== void 0 ? _e : defaultMaxOpSizeInBytes);
        this.maxConsecutiveReconnects =
            (_f = this.mc.config.getNumber(maxConsecutiveReconnectsKey)) !== null && _f !== void 0 ? _f : this.defaultMaxConsecutiveReconnects;
        this._flushMode = runtimeOptions.flushMode;
        const pendingRuntimeState = context.pendingLocalState;
        const baseSnapshot = (_g = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _g !== void 0 ? _g : context.baseSnapshot;
        this.garbageCollector = garbageCollection_1.GarbageCollector.create({
            runtime: this,
            gcOptions: this.runtimeOptions.gcOptions,
            baseSnapshot,
            baseLogger: this.mc.logger,
            existing,
            metadata,
            isSummarizerClient: this.context.clientDetails.type === summarizerClientElection_1.summarizerClientType,
            getNodePackagePath: async (nodePath) => this.getGCNodePackagePath(nodePath),
            getLastSummaryTimestampMs: () => { var _a; return (_a = this.messageAtLastSummary) === null || _a === void 0 ? void 0 : _a.timestamp; },
            readAndParseBlob: async (id) => (0, driver_utils_1.readAndParse)(this.storage, id),
        });
        const loadedFromSequenceNumber = this.deltaManager.initialSequenceNumber;
        this.summarizerNode = (0, runtime_utils_1.createRootSummarizerNodeWithGC)(telemetry_utils_1.ChildLogger.create(this.logger, "SummarizerNode"), 
        // Summarize function to call when summarize is called. Summarizer node always tracks summary state.
        async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext), 
        // Latest change sequence number, no changes since summary applied yet
        loadedFromSequenceNumber, 
        // Summary reference sequence number, undefined if no summary yet
        baseSnapshot ? loadedFromSequenceNumber : undefined, {
            // Must set to false to prevent sending summary handle which would be pointing to
            // a summary with an older protocol state.
            canReuseHandle: false,
            // Must set to true to throw on any data stores failure that was too severe to be handled.
            // We also are not decoding the base summaries at the root.
            throwOnFailure: true,
            // If GC should not run, let the summarizer node know so that it does not track GC state.
            gcDisabled: !this.garbageCollector.shouldRunGC,
        });
        if (baseSnapshot) {
            this.summarizerNode.loadBaseSummaryWithoutDifferential(baseSnapshot);
        }
        this.dataStores = new dataStores_1.DataStores((0, dataStores_1.getSummaryForDatastores)(baseSnapshot, metadata), this, (attachMsg) => this.submit(ContainerMessageType.Attach, attachMsg), (id, createParam) => (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, undefined, getGCDataFn, getBaseGCDetailsFn), (id) => this.summarizerNode.deleteChild(id), this.mc.logger, async () => this.garbageCollector.getBaseGCDetails(), (path, timestampMs, packagePath) => this.garbageCollector.nodeUpdated(path, "Changed", timestampMs, packagePath), new Map(dataStoreAliasMap), this.garbageCollector.writeDataAtRoot);
        this.blobManager = new blobManager_1.BlobManager(this.handleContext, blobManagerSnapshot, () => this.storage, (blobId) => this.submit(ContainerMessageType.BlobAttach, undefined, undefined, { blobId }), (blobPath) => this.garbageCollector.nodeUpdated(blobPath, "Loaded"), this, this.logger);
        this.scheduleManager = new ScheduleManager(context.deltaManager, this, telemetry_utils_1.ChildLogger.create(this.logger, "ScheduleManager"));
        this.deltaSender = this.deltaManager;
        this.pendingStateManager = new pendingStateManager_1.PendingStateManager({
            applyStashedOp: this.applyStashedOp.bind(this),
            clientId: () => this.clientId,
            close: this.closeFn,
            connected: () => this.connected,
            flush: this.flush.bind(this),
            flushMode: () => this.flushMode,
            reSubmit: this.reSubmit.bind(this),
            rollback: this.rollback.bind(this),
            setFlushMode: (mode) => this.setFlushMode(mode),
        }, this._flushMode, pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.pending);
        this.context.quorum.on("removeMember", (clientId) => {
            this.clearPartialChunks(clientId);
        });
        this.summaryCollection = new summaryCollection_1.SummaryCollection(this.deltaManager, this.logger);
        this.dirtyContainer = this.context.attachState !== container_definitions_1.AttachState.Attached
            || this.pendingStateManager.hasPendingMessages();
        this.context.updateDirtyContainerState(this.dirtyContainer);
        if (this.summariesDisabled) {
            this.mc.logger.sendTelemetryEvent({ eventName: "SummariesDisabled" });
        }
        else {
            const orderedClientLogger = telemetry_utils_1.ChildLogger.create(this.logger, "OrderedClientElection");
            const orderedClientCollection = new orderedClientElection_1.OrderedClientCollection(orderedClientLogger, this.context.deltaManager, this.context.quorum);
            const orderedClientElectionForSummarizer = new orderedClientElection_1.OrderedClientElection(orderedClientLogger, orderedClientCollection, electedSummarizerData !== null && electedSummarizerData !== void 0 ? electedSummarizerData : this.context.deltaManager.lastSequenceNumber, summarizerClientElection_1.SummarizerClientElection.isClientEligible);
            this.summarizerClientElection = new summarizerClientElection_1.SummarizerClientElection(orderedClientLogger, this.summaryCollection, orderedClientElectionForSummarizer, this.maxOpsSinceLastSummary, this.summarizerClientElectionEnabled);
            if (this.context.clientDetails.type === summarizerClientElection_1.summarizerClientType) {
                this._summarizer = new summarizer_1.Summarizer("/_summarizer", this /* ISummarizerRuntime */, () => this.summaryConfiguration, this /* ISummarizerInternalsProvider */, this.handleContext, this.summaryCollection, async (runtime) => runWhileConnectedCoordinator_1.RunWhileConnectedCoordinator.create(runtime));
            }
            else if (summarizerClientElection_1.SummarizerClientElection.clientDetailsPermitElection(this.context.clientDetails)) {
                // Only create a SummaryManager and SummarizerClientElection
                // if summaries are enabled and we are not the summarizer client.
                const defaultAction = () => {
                    if (this.summaryCollection.opsSinceLastAck > this.maxOpsSinceLastSummary) {
                        this.logger.sendErrorEvent({ eventName: "SummaryStatus:Behind" });
                        // unregister default to no log on every op after falling behind
                        // and register summary ack handler to re-register this handler
                        // after successful summary
                        this.summaryCollection.once(protocol_definitions_1.MessageType.SummaryAck, () => {
                            this.logger.sendTelemetryEvent({ eventName: "SummaryStatus:CaughtUp" });
                            // we've caught up, so re-register the default action to monitor for
                            // falling behind, and unregister ourself
                            this.summaryCollection.on("default", defaultAction);
                        });
                        this.summaryCollection.off("default", defaultAction);
                    }
                };
                this.summaryCollection.on("default", defaultAction);
                // Create the SummaryManager and mark the initial state
                this.summaryManager = new summaryManager_1.SummaryManager(this.summarizerClientElection, this, // IConnectedState
                this.summaryCollection, this.logger, this.formRequestSummarizerFn(this.context.loader), new throttler_1.Throttler(60 * 1000, // 60 sec delay window
                30 * 1000, // 30 sec max delay
                // throttling function increases exponentially (0ms, 40ms, 80ms, 160ms, etc)
                (0, throttler_1.formExponentialFn)({ coefficient: 20, initialDelay: 0 })), {
                    initialDelayMs: this.initialSummarizerDelayMs,
                }, this.heuristicsDisabled);
                this.summaryManager.start();
            }
        }
        this.deltaManager.on("readonly", (readonly) => {
            // we accumulate ops while being in read-only state.
            // once user gets write permissions and we have active connection, flush all pending ops.
            (0, common_utils_1.assert)(readonly === this.deltaManager.readOnlyInfo.readonly, 0x124 /* "inconsistent readonly property/event state" */);
            // We need to be very careful with when we (re)send pending ops, to ensure that we only send ops
            // when we either never send an op, or attempted to send it but we know for sure it was not
            // sequenced by server and will never be sequenced (i.e. was lost)
            // For loss of connection, we wait for our own "join" op and use it a a barrier to know all the
            // ops that made it from previous connection, before switching clientId and raising "connected" event
            // But with read-only permissions, if we transition between read-only and r/w states while on same
            // connection, then we have no good signal to tell us when it's safe to send ops we accumulated while
            // being in read-only state.
            // For that reason, we support getting to read-only state only when disconnected. This ensures that we
            // can rely on same safety mechanism and resend ops only when we establish new connection.
            // This is applicable for read-only permissions (event is raised before connection is properly registered),
            // but it's an extra requirement for Container.forceReadonly() API
            (0, common_utils_1.assert)(!readonly || !this.connected, 0x125 /* "Unsafe to transition to read-only state!" */);
            this.replayPendingStates();
        });
        // logging hardware telemetry
        logger.sendTelemetryEvent(Object.assign({ eventName: "DeviceSpec" }, getDeviceSpec()));
        let loadSummaryNumber;
        // Get the container creation metadata. For new container, we initialize these. For existing containers,
        // get the values from the metadata blob.
        if (existing) {
            this.createContainerMetadata = {
                createContainerRuntimeVersion: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerRuntimeVersion,
                createContainerTimestamp: metadata === null || metadata === void 0 ? void 0 : metadata.createContainerTimestamp,
            };
            // back-compat 0.59.3000 - Older document may either write summaryCount or not write it at all. If it does
            // not write it, initialize summaryNumber to 0.
            loadSummaryNumber = (_j = (_h = metadata === null || metadata === void 0 ? void 0 : metadata.summaryNumber) !== null && _h !== void 0 ? _h : metadata === null || metadata === void 0 ? void 0 : metadata.summaryCount) !== null && _j !== void 0 ? _j : 0;
        }
        else {
            this.createContainerMetadata = {
                createContainerRuntimeVersion: packageVersion_1.pkgVersion,
                createContainerTimestamp: Date.now(),
            };
            loadSummaryNumber = 0;
        }
        this.nextSummaryNumber = loadSummaryNumber + 1;
        this.logger.sendTelemetryEvent(Object.assign(Object.assign(Object.assign({ eventName: "ContainerLoadStats" }, this.createContainerMetadata), this.dataStores.containerLoadStats), { summaryNumber: loadSummaryNumber, summaryFormatVersion: metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion, disableIsolatedChannels: metadata === null || metadata === void 0 ? void 0 : metadata.disableIsolatedChannels, gcVersion: metadata === null || metadata === void 0 ? void 0 : metadata.gcFeature }));
        (0, connectionTelemetry_1.ReportOpPerfTelemetry)(this.context.clientId, this.deltaManager, this.logger);
        (0, batchTracker_1.BindBatchTracker)(this, this.logger);
        this.opTracker = new opTelemetry_1.OpTracker(this.deltaManager, this.mc.config.getBoolean(disableOpTrackingKey) === true);
    }
    get IContainerRuntime() { return this; }
    get IFluidRouter() { return this; }
    /**
     * Load the stores from a snapshot and returns the runtime.
     * @param context - Context of the container.
     * @param registryEntries - Mapping to the stores.
     * @param requestHandler - Request handlers for the container runtime
     * @param runtimeOptions - Additional options to be passed to the runtime
     * @param existing - (optional) When loading from an existing snapshot. Precedes context.existing if provided
     */
    static async load(context, registryEntries, requestHandler, runtimeOptions = {}, containerScope = context.scope, existing) {
        var _a, _b, _c;
        // If taggedLogger exists, use it. Otherwise, wrap the vanilla logger:
        // back-compat: Remove the TaggedLoggerAdapter fallback once all the host are using loader > 0.45
        const backCompatContext = context;
        const passLogger = (_a = backCompatContext.taggedLogger) !== null && _a !== void 0 ? _a : new telemetry_utils_1.TaggedLoggerAdapter(backCompatContext.logger);
        const logger = telemetry_utils_1.ChildLogger.create(passLogger, undefined, {
            all: {
                runtimeVersion: packageVersion_1.pkgVersion,
            },
        });
        const { summaryOptions = {}, gcOptions = {}, loadSequenceNumberVerification = "close", useDataStoreAliasing = false, flushMode = defaultFlushMode, enableOfflineLoad = false, } = runtimeOptions;
        const pendingRuntimeState = context.pendingLocalState;
        const baseSnapshot = (_b = pendingRuntimeState === null || pendingRuntimeState === void 0 ? void 0 : pendingRuntimeState.baseSnapshot) !== null && _b !== void 0 ? _b : context.baseSnapshot;
        const storage = !pendingRuntimeState ?
            context.storage :
            new serializedSnapshotStorage_1.SerializedSnapshotStorage(() => { return context.storage; }, pendingRuntimeState.snapshotBlobs);
        const registry = new dataStoreRegistry_1.FluidDataStoreRegistry(registryEntries);
        const tryFetchBlob = async (blobName) => {
            const blobId = baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.blobs[blobName];
            if (baseSnapshot && blobId) {
                // IContainerContext storage api return type still has undefined in 0.39 package version.
                // So once we release 0.40 container-defn package we can remove this check.
                (0, common_utils_1.assert)(storage !== undefined, 0x1f5 /* "Attached state should have storage" */);
                return (0, driver_utils_1.readAndParse)(storage, blobId);
            }
        };
        const [chunks, metadata, electedSummarizerData, aliases] = await Promise.all([
            tryFetchBlob(summaryFormat_1.chunksBlobName),
            tryFetchBlob(summaryFormat_1.metadataBlobName),
            tryFetchBlob(summaryFormat_1.electedSummarizerBlobName),
            tryFetchBlob(summaryFormat_1.aliasBlobName),
        ]);
        const loadExisting = existing === true || context.existing === true;
        // read snapshot blobs needed for BlobManager to load
        const blobManagerSnapshot = await blobManager_1.BlobManager.load(baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[summaryFormat_1.blobsTreeName], async (id) => {
            // IContainerContext storage api return type still has undefined in 0.39 package version.
            // So once we release 0.40 container-defn package we can remove this check.
            (0, common_utils_1.assert)(storage !== undefined, 0x256 /* "storage undefined in attached container" */);
            return (0, driver_utils_1.readAndParse)(storage, id);
        });
        // Verify summary runtime sequence number matches protocol sequence number.
        const runtimeSequenceNumber = (_c = metadata === null || metadata === void 0 ? void 0 : metadata.message) === null || _c === void 0 ? void 0 : _c.sequenceNumber;
        // When we load with pending state, we reuse an old snapshot so we don't expect these numbers to match
        if (!pendingRuntimeState && runtimeSequenceNumber !== undefined) {
            const protocolSequenceNumber = context.deltaManager.initialSequenceNumber;
            // Unless bypass is explicitly set, then take action when sequence numbers mismatch.
            if (loadSequenceNumberVerification !== "bypass" && runtimeSequenceNumber !== protocolSequenceNumber) {
                // "Load from summary, runtime metadata sequenceNumber !== initialSequenceNumber"
                const error = new container_utils_1.DataCorruptionError(
                // pre-0.58 error message: SummaryMetadataMismatch
                "Summary metadata mismatch", { runtimeVersion: packageVersion_1.pkgVersion, runtimeSequenceNumber, protocolSequenceNumber });
                if (loadSequenceNumberVerification === "log") {
                    logger.sendErrorEvent({ eventName: "SequenceNumberMismatch" }, error);
                }
                else {
                    context.closeFn(error);
                }
            }
        }
        const runtime = new ContainerRuntime(context, registry, metadata, electedSummarizerData, chunks !== null && chunks !== void 0 ? chunks : [], aliases !== null && aliases !== void 0 ? aliases : [], {
            summaryOptions,
            gcOptions,
            loadSequenceNumberVerification,
            useDataStoreAliasing,
            flushMode,
            enableOfflineLoad,
        }, containerScope, logger, loadExisting, blobManagerSnapshot, storage, requestHandler);
        if (pendingRuntimeState) {
            await runtime.processSavedOps(pendingRuntimeState);
            // delete these once runtime has seen them to save space
            pendingRuntimeState.savedOps = [];
        }
        await runtime.getSnapshotBlobs();
        return runtime;
    }
    get options() {
        return this.context.options;
    }
    get clientId() {
        return this.context.clientId;
    }
    get clientDetails() {
        return this.context.clientDetails;
    }
    get deltaManager() {
        return this.context.deltaManager;
    }
    get storage() {
        return this._storage;
    }
    get reSubmitFn() {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return this.reSubmit;
    }
    get closeFn() {
        return this.context.closeFn;
    }
    get flushMode() {
        return this._flushMode;
    }
    get scope() {
        return this.containerScope;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    get attachState() {
        return this.context.attachState;
    }
    get IFluidHandleContext() {
        return this.handleContext;
    }
    get connected() {
        return this._connected;
    }
    /** clientId of parent (non-summarizing) container that owns summarizer container */
    get summarizerClientId() {
        var _a;
        return (_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.electedClientId;
    }
    get disposed() { return this._disposed; }
    get summarizer() {
        (0, common_utils_1.assert)(this._summarizer !== undefined, 0x257 /* "This is not summarizing container" */);
        return this._summarizer;
    }
    isSummariesDisabled() {
        // back-compat: disableSummaries was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.disableSummaries === true) {
            return true;
        }
        return this.summaryConfiguration.state === "disabled";
    }
    isHeuristicsDisabled() {
        var _a;
        // back-compat: disableHeuristics was moved from ISummarizerOptions
        //   to ISummaryConfiguration in 0.60.
        if (((_a = this.runtimeOptions.summaryOptions.summarizerOptions) === null || _a === void 0 ? void 0 : _a.disableHeuristics) === true) {
            return true;
        }
        return this.summaryConfiguration.state === "disableHeuristics";
    }
    isSummarizerClientElectionEnabled() {
        var _a;
        if (this.mc.config.getBoolean("Fluid.ContainerRuntime.summarizerClientElection")) {
            return (_a = this.mc.config.getBoolean("Fluid.ContainerRuntime.summarizerClientElection")) !== null && _a !== void 0 ? _a : true;
        }
        // back-compat: summarizerClientElection was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.summarizerClientElection === true) {
            return true;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.summarizerClientElection === true;
        }
        else {
            return false;
        }
    }
    getMaxOpsSinceLastSummary() {
        // back-compat: maxOpsSinceLastSummary was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary !== undefined) {
            return this.runtimeOptions.summaryOptions.maxOpsSinceLastSummary;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.maxOpsSinceLastSummary;
        }
        else {
            return 0;
        }
    }
    getInitialSummarizerDelayMs() {
        // back-compat: initialSummarizerDelayMs was moved from ISummaryRuntimeOptions
        //   to ISummaryConfiguration in 0.60.
        if (this.runtimeOptions.summaryOptions.initialSummarizerDelayMs !== undefined) {
            return this.runtimeOptions.summaryOptions.initialSummarizerDelayMs;
        }
        if (this.summaryConfiguration.state !== "disabled") {
            return this.summaryConfiguration.initialSummarizerDelayMs;
        }
        else {
            return 0;
        }
    }
    dispose(error) {
        var _a;
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.logger.sendTelemetryEvent({
            eventName: "ContainerRuntimeDisposed",
            isDirty: this.isDirty,
            lastSequenceNumber: this.deltaManager.lastSequenceNumber,
            attachState: this.attachState,
        }, error);
        if (this.summaryManager !== undefined) {
            this.summaryManager.dispose();
        }
        this.garbageCollector.dispose();
        (_a = this._summarizer) === null || _a === void 0 ? void 0 : _a.dispose();
        this.dataStores.dispose();
        this.pendingStateManager.dispose();
        this.emit("dispose");
        this.removeAllListeners();
    }
    get IFluidTokenProvider() {
        var _a;
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.intelligence) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            return {
                intelligence: this.options.intelligence,
            };
        }
        return undefined;
    }
    /**
     * Notifies this object about the request made to the container.
     * @param request - Request made to the handler.
     */
    async request(request) {
        try {
            const parser = runtime_utils_1.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_summarizer" && parser.pathParts.length === 1) {
                if (this._summarizer !== undefined) {
                    return {
                        status: 200,
                        mimeType: "fluid/object",
                        value: this.summarizer,
                    };
                }
                return (0, runtime_utils_1.create404Response)(request);
            }
            if (this.requestHandler !== undefined) {
                return this.requestHandler(parser, this);
            }
            return (0, runtime_utils_1.create404Response)(request);
        }
        catch (error) {
            return (0, runtime_utils_1.exceptionToResponse)(error);
        }
    }
    /**
     * Resolves URI representing handle
     * @param request - Request made to the handler.
     */
    async resolveHandle(request) {
        try {
            const requestParser = runtime_utils_1.RequestParser.create(request);
            const id = requestParser.pathParts[0];
            if (id === "_channels") {
                return this.resolveHandle(requestParser.createSubRequest(1));
            }
            if (id === blobManager_1.BlobManager.basePath && requestParser.isLeaf(2)) {
                const handle = await this.blobManager.getBlob(requestParser.pathParts[1]);
                if (handle) {
                    return {
                        status: 200,
                        mimeType: "fluid/object",
                        value: handle.get(),
                    };
                }
                else {
                    return (0, runtime_utils_1.create404Response)(request);
                }
            }
            else if (requestParser.pathParts.length > 0) {
                const dataStore = await this.getDataStoreFromRequest(id, request);
                const subRequest = requestParser.createSubRequest(1);
                // We always expect createSubRequest to include a leading slash, but asserting here to protect against
                // unintentionally modifying the url if that changes.
                (0, common_utils_1.assert)(subRequest.url.startsWith("/"), 0x126 /* "Expected createSubRequest url to include a leading slash" */);
                return dataStore.IFluidRouter.request(subRequest);
            }
            return (0, runtime_utils_1.create404Response)(request);
        }
        catch (error) {
            return (0, runtime_utils_1.exceptionToResponse)(error);
        }
    }
    internalId(maybeAlias) {
        var _a;
        return (_a = this.dataStores.aliases().get(maybeAlias)) !== null && _a !== void 0 ? _a : maybeAlias;
    }
    async getDataStoreFromRequest(id, request) {
        var _a, _b, _c;
        const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[RuntimeHeaders.wait]) === "boolean"
            ? (_b = request.headers) === null || _b === void 0 ? void 0 : _b[RuntimeHeaders.wait]
            : true;
        const internalId = this.internalId(id);
        const dataStoreContext = await this.dataStores.getDataStore(internalId, wait);
        /**
         * If GC should run and this an external app request with "externalRequest" header, we need to return
         * an error if the data store being requested is marked as unreferenced as per the data store's base
         * GC data.
         *
         * This is a workaround to handle scenarios where a data store shared with an external app is deleted
         * and marked as unreferenced by GC. Returning an error will fail to load the data store for the app.
         */
        if (((_c = request.headers) === null || _c === void 0 ? void 0 : _c[RuntimeHeaders.externalRequest]) && this.garbageCollector.shouldRunGC) {
            // The data store is referenced if used routes in the base summary has a route to self.
            // Older documents may not have used routes in the summary. They are considered referenced.
            const usedRoutes = (await dataStoreContext.getBaseGCDetails()).usedRoutes;
            if (!(usedRoutes === undefined || usedRoutes.includes("") || usedRoutes.includes("/"))) {
                throw (0, runtime_utils_1.responseToException)((0, runtime_utils_1.create404Response)(request), request);
            }
        }
        const dataStoreChannel = await dataStoreContext.realize();
        // Remove query params, leading and trailing slashes from the url. This is done to make sure the format is
        // the same as GC nodes id.
        const urlWithoutQuery = (0, garbage_collector_1.trimLeadingAndTrailingSlashes)(request.url.split("?")[0]);
        this.garbageCollector.nodeUpdated(`/${urlWithoutQuery}`, "Loaded", undefined /* timestampMs */, dataStoreContext.packagePath, request === null || request === void 0 ? void 0 : request.headers);
        return dataStoreChannel;
    }
    /** Adds the container's metadata to the given summary tree. */
    addMetadataToSummary(summaryTree) {
        var _a;
        const metadata = Object.assign(Object.assign(Object.assign(Object.assign({}, this.createContainerMetadata), { 
            // back-compat 0.59.3000: This is renamed to summaryNumber. Can be removed when 0.59.3000 saturates.
            summaryCount: this.nextSummaryNumber, 
            // Increment the summary number for the next summary that will be generated.
            summaryNumber: this.nextSummaryNumber++, summaryFormatVersion: 1, disableIsolatedChannels: this.disableIsolatedChannels || undefined }), this.garbageCollector.getMetadata()), { 
            // The last message processed at the time of summary. If there are no new messages, use the message from the
            // last summary.
            message: (_a = (0, summaryFormat_1.extractSummaryMetadataMessage)(this.deltaManager.lastMessage)) !== null && _a !== void 0 ? _a : this.messageAtLastSummary });
        (0, runtime_utils_1.addBlobToSummary)(summaryTree, summaryFormat_1.metadataBlobName, JSON.stringify(metadata));
    }
    addContainerStateToSummary(summaryTree, fullTree, trackState, telemetryContext) {
        var _a;
        this.addMetadataToSummary(summaryTree);
        if (this.chunkMap.size > 0) {
            const content = JSON.stringify([...this.chunkMap]);
            (0, runtime_utils_1.addBlobToSummary)(summaryTree, summaryFormat_1.chunksBlobName, content);
        }
        const dataStoreAliases = this.dataStores.aliases();
        if (dataStoreAliases.size > 0) {
            (0, runtime_utils_1.addBlobToSummary)(summaryTree, summaryFormat_1.aliasBlobName, JSON.stringify([...dataStoreAliases]));
        }
        if (this.summarizerClientElection) {
            const electedSummarizerContent = JSON.stringify((_a = this.summarizerClientElection) === null || _a === void 0 ? void 0 : _a.serialize());
            (0, runtime_utils_1.addBlobToSummary)(summaryTree, summaryFormat_1.electedSummarizerBlobName, electedSummarizerContent);
        }
        const blobManagerSummary = this.blobManager.summarize();
        // Some storage (like git) doesn't allow empty tree, so we can omit it.
        // and the blob manager can handle the tree not existing when loading
        if (Object.keys(blobManagerSummary.summary.tree).length > 0) {
            (0, runtime_utils_1.addTreeToSummary)(summaryTree, summaryFormat_1.blobsTreeName, blobManagerSummary);
        }
        if (this.garbageCollector.writeDataAtRoot) {
            const gcSummary = this.garbageCollector.summarize(fullTree, trackState, telemetryContext);
            if (gcSummary !== undefined) {
                (0, runtime_utils_1.addSummarizeResultToSummary)(summaryTree, garbageCollection_1.gcTreeKey, gcSummary);
            }
        }
    }
    // Track how many times the container tries to reconnect with pending messages.
    // This happens when the connection state is changed and we reset the counter
    // when we are able to process a local op or when there are no pending messages.
    // If this counter reaches a max, it's a good indicator that the container
    // is not making progress and it is stuck in a retry loop.
    shouldContinueReconnecting() {
        if (this.maxConsecutiveReconnects <= 0) {
            // Feature disabled, we never stop reconnecting
            return true;
        }
        if (!this.pendingStateManager.hasPendingMessages()) {
            // If there are no pending messages, we can always reconnect
            this.resetReconnectCount();
            return true;
        }
        if (this.consecutiveReconnects === Math.floor(this.maxConsecutiveReconnects / 2)) {
            // If we're halfway through the max reconnects, send an event in order
            // to better identify false positives, if any. If the rate of this event
            // matches Container Close count below, we can safely cut down
            // maxConsecutiveReconnects to half.
            this.mc.logger.sendTelemetryEvent({
                eventName: "ReconnectsWithNoProgress",
                attempts: this.consecutiveReconnects,
                pendingMessages: this.pendingStateManager.pendingMessagesCount,
            });
        }
        return this.consecutiveReconnects < this.maxConsecutiveReconnects;
    }
    resetReconnectCount() {
        this.consecutiveReconnects = 0;
    }
    replayPendingStates() {
        // We need to be able to send ops to replay states
        if (!this.canSendOps()) {
            return;
        }
        // We need to temporary clear the dirty flags and disable
        // dirty state change events to detect whether replaying ops
        // has any effect.
        // Save the old state, reset to false, disable event emit
        const oldState = this.dirtyContainer;
        this.dirtyContainer = false;
        (0, common_utils_1.assert)(this.emitDirtyDocumentEvent, 0x127 /* "dirty document event not set on replay" */);
        this.emitDirtyDocumentEvent = false;
        let newState;
        try {
            // replay the ops
            this.pendingStateManager.replayPendingStates();
        }
        finally {
            // Save the new start and restore the old state, re-enable event emit
            newState = this.dirtyContainer;
            this.dirtyContainer = oldState;
            this.emitDirtyDocumentEvent = true;
        }
        // Officially transition from the old state to the new state.
        this.updateDocumentDirtyState(newState);
    }
    async applyStashedOp(type, op) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                return this.dataStores.applyStashedOp(op);
            case ContainerMessageType.Attach:
                return this.dataStores.applyStashedAttachOp(op);
            case ContainerMessageType.Alias:
            case ContainerMessageType.BlobAttach:
                return;
            case ContainerMessageType.ChunkedOp:
                throw new Error("chunkedOp not expected here");
            case ContainerMessageType.Rejoin:
                throw new Error("rejoin not expected here");
            default:
                (0, common_utils_1.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // There might be no change of state due to Container calling this API after loading runtime.
        const changeOfState = this._connected !== connected;
        const reconnection = changeOfState && connected;
        this._connected = connected;
        if (!connected) {
            this._perfSignalData.signalsLost = 0;
            this._perfSignalData.signalTimestamp = 0;
            this._perfSignalData.trackingSignalSequenceNumber = undefined;
        }
        if (reconnection) {
            this.consecutiveReconnects++;
            if (!this.shouldContinueReconnecting()) {
                this.closeFn(
                // pre-0.58 error message: MaxReconnectsWithNoProgress
                container_utils_1.DataProcessingError.create("Runtime detected too many reconnects with no progress syncing local ops", "setConnectionState", undefined, {
                    dataLoss: 1,
                    attempts: this.consecutiveReconnects,
                    pendingMessages: this.pendingStateManager.pendingMessagesCount,
                }));
                return;
            }
        }
        if (changeOfState) {
            this.replayPendingStates();
        }
        this.dataStores.setConnectionState(connected, clientId);
        (0, telemetry_utils_1.raiseConnectedEvent)(this.mc.logger, this, connected, clientId);
    }
    process(messageArg, local) {
        var _a, _b;
        this.verifyNotClosed();
        // If it's not message for runtime, bail out right away.
        if (!(0, driver_utils_1.isUnpackedRuntimeMessage)(messageArg)) {
            return;
        }
        if ((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {
            this.savedOps.push(messageArg);
        }
        // Do shallow copy of message, as methods below will modify it.
        // There might be multiple container instances receiving same message
        // We do not need to make deep copy, as each layer will just replace message.content itself,
        // but would not modify contents details
        let message = Object.assign({}, messageArg);
        // Surround the actual processing of the operation with messages to the schedule manager indicating
        // the beginning and end. This allows it to emit appropriate events and/or pause the processing of new
        // messages once a batch has been fully processed.
        this.scheduleManager.beforeOpProcessing(message);
        try {
            message = unpackRuntimeMessage(message);
            // Chunk processing must come first given that we will transform the message to the unchunked version
            // once all pieces are available
            message = this.processRemoteChunkedMessage(message);
            let localOpMetadata;
            if (local) {
                // Call the PendingStateManager to process local messages.
                // Do not process local chunked ops until all pieces are available.
                if (message.type !== ContainerMessageType.ChunkedOp) {
                    localOpMetadata = this.pendingStateManager.processPendingLocalMessage(message);
                }
            }
            // If there are no more pending messages after processing a local message,
            // the document is no longer dirty.
            if (!this.pendingStateManager.hasPendingMessages()) {
                this.updateDocumentDirtyState(false);
            }
            switch (message.type) {
                case ContainerMessageType.Attach:
                    this.dataStores.processAttachMessage(message, local);
                    break;
                case ContainerMessageType.Alias:
                    this.processAliasMessage(message, localOpMetadata, local);
                    break;
                case ContainerMessageType.FluidDataStoreOp:
                    this.dataStores.processFluidDataStoreOp(message, local, localOpMetadata);
                    break;
                case ContainerMessageType.BlobAttach:
                    (0, common_utils_1.assert)((_b = message === null || message === void 0 ? void 0 : message.metadata) === null || _b === void 0 ? void 0 : _b.blobId, 0x12a /* "Missing blob id on metadata" */);
                    this.blobManager.processBlobAttachOp(message.metadata.blobId, local);
                    break;
                default:
            }
            this.emit("op", message);
            this.scheduleManager.afterOpProcessing(undefined, message);
            if (local) {
                // If we have processed a local op, this means that the container is
                // making progress and we can reset the counter for how many times
                // we have consecutively replayed the pending states
                this.resetReconnectCount();
            }
        }
        catch (e) {
            this.scheduleManager.afterOpProcessing(e, message);
            throw e;
        }
    }
    processAliasMessage(message, localOpMetadata, local) {
        this.dataStores.processAliasMessage(message, localOpMetadata, local);
    }
    /**
     * Emits the Signal event and update the perf signal data.
     * @param clientSignalSequenceNumber - is the client signal sequence number to be uploaded.
     */
    sendSignalTelemetryEvent(clientSignalSequenceNumber) {
        const duration = Date.now() - this._perfSignalData.signalTimestamp;
        this.logger.sendPerformanceEvent({
            eventName: "SignalLatency",
            duration,
            signalsLost: this._perfSignalData.signalsLost,
        });
        this._perfSignalData.signalsLost = 0;
        this._perfSignalData.signalTimestamp = 0;
    }
    processSignal(message, local) {
        const envelope = message.content;
        const transformed = {
            clientId: message.clientId,
            content: envelope.contents.content,
            type: envelope.contents.type,
        };
        // Only collect signal telemetry for messages sent by the current client.
        if (message.clientId === this.clientId && this.connected) {
            // Check to see if the signal was lost.
            if (this._perfSignalData.trackingSignalSequenceNumber !== undefined &&
                envelope.clientSignalSequenceNumber > this._perfSignalData.trackingSignalSequenceNumber) {
                this._perfSignalData.signalsLost++;
                this._perfSignalData.trackingSignalSequenceNumber = undefined;
                this.logger.sendErrorEvent({
                    eventName: "SignalLost",
                    type: envelope.contents.type,
                    signalsLost: this._perfSignalData.signalsLost,
                    trackingSequenceNumber: this._perfSignalData.trackingSignalSequenceNumber,
                    clientSignalSequenceNumber: envelope.clientSignalSequenceNumber,
                });
            }
            else if (envelope.clientSignalSequenceNumber === this._perfSignalData.trackingSignalSequenceNumber) {
                this.sendSignalTelemetryEvent(envelope.clientSignalSequenceNumber);
                this._perfSignalData.trackingSignalSequenceNumber = undefined;
            }
        }
        if (envelope.address === undefined) {
            // No address indicates a container signal message.
            this.emit("signal", transformed, local);
            return;
        }
        this.dataStores.processSignal(envelope.address, transformed, local);
    }
    async getRootDataStore(id, wait = true) {
        const internalId = this.internalId(id);
        const context = await this.dataStores.getDataStore(internalId, wait);
        (0, common_utils_1.assert)(await context.isRoot(), 0x12b /* "did not get root data store" */);
        return context.realize();
    }
    setFlushMode(mode) {
        if (mode === this._flushMode) {
            return;
        }
        this.mc.logger.sendTelemetryEvent({
            eventName: "FlushMode Updated",
            old: this._flushMode,
            new: mode,
        });
        // Flush any pending batches if switching to immediate
        if (mode === runtime_definitions_1.FlushMode.Immediate) {
            this.flush();
        }
        this._flushMode = mode;
        // Let the PendingStateManager know that FlushMode has been updated.
        this.pendingStateManager.onFlushModeUpdated(mode);
    }
    flush() {
        (0, common_utils_1.assert)(this._orderSequentiallyCalls === 0, 0x24c /* "Cannot call `flush()` from `orderSequentially`'s callback" */);
        if (!this.deltaSender) {
            return;
        }
        // Let the PendingStateManager know that there was an attempt to flush messages.
        // Note that this should happen before the `this.needsFlush` check below because in the scenario where we are
        // not connected, `this.needsFlush` will be false but the PendingStateManager might have pending messages and
        // hence needs to track this.
        this.pendingStateManager.onFlush();
        // If flush has already been called then exit early
        if (!this.needsFlush) {
            return;
        }
        this.needsFlush = false;
        // Did we disconnect in the middle of turn-based batch?
        // If so, do nothing, as pending state manager will resubmit it correctly on reconnect.
        if (!this.canSendOps()) {
            return;
        }
        return this.deltaSender.flush();
    }
    orderSequentially(callback) {
        // If flush mode is already TurnBased we are either
        // nested in another orderSequentially, or
        // the app is flushing manually, in which
        // case this invocation doesn't own
        // flushing.
        if (this.flushMode === runtime_definitions_1.FlushMode.TurnBased) {
            this.trackOrderSequentiallyCalls(callback);
            return;
        }
        const savedFlushMode = this.flushMode;
        this.setFlushMode(runtime_definitions_1.FlushMode.TurnBased);
        try {
            this.trackOrderSequentiallyCalls(callback);
            this.flush();
        }
        finally {
            this.setFlushMode(savedFlushMode);
        }
    }
    trackOrderSequentiallyCalls(callback) {
        let checkpoint;
        if (this.mc.config.getBoolean("Fluid.ContainerRuntime.EnableRollback")) {
            checkpoint = this.pendingStateManager.checkpoint();
        }
        try {
            this._orderSequentiallyCalls++;
            callback();
        }
        catch (error) {
            if (checkpoint) {
                // This will throw and close the container if rollback fails
                checkpoint.rollback();
            }
            else {
                // pre-0.58 error message: orderSequentiallyCallbackException
                this.closeFn(new container_utils_1.GenericError("orderSequentially callback exception", error));
            }
            throw error; // throw the original error for the consumer of the runtime
        }
        finally {
            this._orderSequentiallyCalls--;
        }
    }
    async createDataStore(pkg) {
        const internalId = (0, uuid_1.v4)();
        return (0, dataStore_1.channelToDataStore)(await this._createDataStore(pkg, false /* isRoot */, internalId), internalId, this, this.dataStores, this.mc.logger);
    }
    /**
     * Creates a root datastore directly with a user generated id and attaches it to storage.
     * It is vulnerable to name collisions and should not be used.
     *
     * This method will be removed. See #6465.
     */
    async createRootDataStoreLegacy(pkg, rootDataStoreId) {
        const fluidDataStore = await this._createDataStore(pkg, true /* isRoot */, rootDataStoreId);
        // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For
        // older versions, we still have to call bindToContext.
        if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {
            fluidDataStore.makeVisibleAndAttachGraph();
        }
        else {
            fluidDataStore.bindToContext();
        }
        return fluidDataStore;
    }
    /**
     * @deprecated - will be removed in an upcoming release. See #9660.
     */
    async createRootDataStore(pkg, rootDataStoreId) {
        if (rootDataStoreId.includes("/")) {
            throw new container_utils_1.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);
        }
        return this._aliasingEnabled === true ?
            this.createAndAliasDataStore(pkg, rootDataStoreId) :
            this.createRootDataStoreLegacy(pkg, rootDataStoreId);
    }
    /**
     * Creates a data store then attempts to alias it.
     * If aliasing fails, it will raise an exception.
     *
     * This method will be removed. See #6465.
     *
     * @param pkg - Package name of the data store
     * @param alias - Alias to be assigned to the data store
     * @param props - Properties for the data store
     * @returns - An aliased data store which can can be found / loaded by alias.
     */
    async createAndAliasDataStore(pkg, alias, props) {
        const internalId = (0, uuid_1.v4)();
        const dataStore = await this._createDataStore(pkg, false /* isRoot */, internalId, props);
        const aliasedDataStore = (0, dataStore_1.channelToDataStore)(dataStore, internalId, this, this.dataStores, this.mc.logger);
        const result = await aliasedDataStore.trySetAlias(alias);
        if (result !== "Success") {
            throw new container_utils_1.GenericError("dataStoreAliasFailure", undefined /* error */, {
                alias: {
                    value: alias,
                    tag: telemetry_utils_1.TelemetryDataTag.UserData,
                },
                internalId: {
                    value: internalId,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
                aliasResult: result,
            });
        }
        return aliasedDataStore;
    }
    createDetachedRootDataStore(pkg, rootDataStoreId) {
        if (rootDataStoreId.includes("/")) {
            throw new container_utils_1.UsageError(`Id cannot contain slashes: '${rootDataStoreId}'`);
        }
        return this.dataStores.createDetachedDataStoreCore(pkg, true, rootDataStoreId);
    }
    createDetachedDataStore(pkg) {
        return this.dataStores.createDetachedDataStoreCore(pkg, false);
    }
    /**
     * Creates a possibly root datastore directly with a possibly user generated id and attaches it to storage.
     * It is vulnerable to name collisions if both aforementioned conditions are true, and should not be used.
     *
     * This method will be removed. See #6465.
     */
    async _createDataStoreWithPropsLegacy(pkg, props, id = (0, uuid_1.v4)(), isRoot = false) {
        const fluidDataStore = await this.dataStores._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props).realize();
        if (isRoot) {
            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.
            // For older versions, we still have to call bindToContext.
            if (fluidDataStore.makeVisibleAndAttachGraph !== undefined) {
                fluidDataStore.makeVisibleAndAttachGraph();
            }
            else {
                fluidDataStore.bindToContext();
            }
            this.logger.sendTelemetryEvent({
                eventName: "Root datastore with props",
                hasProps: props !== undefined,
            });
        }
        return (0, dataStore_1.channelToDataStore)(fluidDataStore, id, this, this.dataStores, this.mc.logger);
    }
    async _createDataStoreWithProps(pkg, props, id = (0, uuid_1.v4)(), isRoot = false) {
        return this._aliasingEnabled === true && isRoot ?
            this.createAndAliasDataStore(pkg, id, props) :
            this._createDataStoreWithPropsLegacy(pkg, props, id, isRoot);
    }
    async _createDataStore(pkg, isRoot, id = (0, uuid_1.v4)(), props) {
        return this.dataStores
            ._createFluidDataStoreContext(Array.isArray(pkg) ? pkg : [pkg], id, isRoot, props)
            .realize();
    }
    canSendOps() {
        return this.connected && !this.deltaManager.readOnlyInfo.readonly;
    }
    getQuorum() {
        return this.context.quorum;
    }
    getAudience() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.context.audience;
    }
    /**
     * Returns true of container is dirty, i.e. there are some pending local changes that
     * either were not sent out to delta stream or were not yet acknowledged.
     */
    get isDirty() {
        return this.dirtyContainer;
    }
    isContainerMessageDirtyable(type, contents) {
        // For legacy purposes, exclude the old built-in AgentScheduler from dirty consideration as a special-case.
        // Ultimately we should have no special-cases from the ContainerRuntime's perspective.
        if (type === ContainerMessageType.Attach) {
            const attachMessage = contents;
            if (attachMessage.id === exports.agentSchedulerId) {
                return false;
            }
        }
        else if (type === ContainerMessageType.FluidDataStoreOp) {
            const envelope = contents;
            if (envelope.address === exports.agentSchedulerId) {
                return false;
            }
        }
        return true;
    }
    createNewSignalEnvelope(address, type, content) {
        const newSequenceNumber = ++this._perfSignalData.signalSequenceNumber;
        const newEnvelope = {
            address,
            clientSignalSequenceNumber: newSequenceNumber,
            contents: { type, content },
        };
        // We should not track any signals in case we already have a tracking number.
        if (newSequenceNumber % this.defaultTelemetrySignalSampleCount === 1 &&
            this._perfSignalData.trackingSignalSequenceNumber === undefined) {
            this._perfSignalData.signalTimestamp = Date.now();
            this._perfSignalData.trackingSignalSequenceNumber = newSequenceNumber;
        }
        return newEnvelope;
    }
    /**
     * Submits the signal to be sent to other clients.
     * @param type - Type of the signal.
     * @param content - Content of the signal.
     */
    submitSignal(type, content) {
        this.verifyNotClosed();
        const envelope = this.createNewSignalEnvelope(undefined /* address */, type, content);
        return this.context.submitSignalFn(envelope);
    }
    submitDataStoreSignal(address, type, content) {
        const envelope = this.createNewSignalEnvelope(address, type, content);
        return this.context.submitSignalFn(envelope);
    }
    setAttachState(attachState) {
        if (attachState === container_definitions_1.AttachState.Attaching) {
            (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Attaching, 0x12d /* "Container Context should already be in attaching state" */);
        }
        else {
            (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Attached, 0x12e /* "Container Context should already be in attached state" */);
            this.emit("attached");
        }
        if (attachState === container_definitions_1.AttachState.Attached && !this.pendingStateManager.hasPendingMessages()) {
            this.updateDocumentDirtyState(false);
        }
        this.dataStores.setAttachState(attachState);
    }
    /**
     * Create a summary. Used when attaching or serializing a detached container.
     *
     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported
     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the
     * new storage IDs so requests can be redirected.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    createSummary(blobRedirectTable, telemetryContext) {
        if (blobRedirectTable) {
            this.blobManager.setRedirectTable(blobRedirectTable);
        }
        const summarizeResult = this.dataStores.createSummary(telemetryContext);
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0, summaryFormat_1.wrapSummaryInChannelsTree)(summarizeResult);
        }
        this.addContainerStateToSummary(summarizeResult, true /* fullTree */, false /* trackState */, telemetryContext);
        return summarizeResult.summary;
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.context.getAbsoluteUrl === undefined) {
            throw new Error("Driver does not implement getAbsoluteUrl");
        }
        if (this.attachState !== container_definitions_1.AttachState.Attached) {
            return undefined;
        }
        return this.context.getAbsoluteUrl(relativeUrl);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        const summarizeResult = await this.dataStores.summarize(fullTree, trackState, telemetryContext);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap data store summaries in .channels subtree.
            (0, summaryFormat_1.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [runtime_definitions_1.channelsTreeName];
        }
        this.addContainerStateToSummary(summarizeResult, fullTree, trackState, telemetryContext);
        return Object.assign(Object.assign({}, summarizeResult), { id: "", pathPartsForChildren });
    }
    /**
     * Returns a summary of the runtime at the current sequence number.
     */
    async summarize(options) {
        this.verifyNotClosed();
        const { fullTree = false, trackState = true, summaryLogger = this.mc.logger, runGC = this.garbageCollector.shouldRunGC, runSweep, fullGC, } = options;
        let gcStats;
        if (runGC) {
            gcStats = await this.collectGarbage({ logger: summaryLogger, runSweep, fullGC });
        }
        const telemetryContext = new runtime_utils_1.TelemetryContext();
        const { stats, summary } = await this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
        this.logger.sendTelemetryEvent({ eventName: "SummarizeTelemetry", details: telemetryContext.serialize() });
        (0, common_utils_1.assert)(summary.type === protocol_definitions_1.SummaryType.Tree, 0x12f /* "Container Runtime's summarize should always return a tree" */);
        return { stats, summary, gcStats };
    }
    /**
     * Implementation of IGarbageCollectionRuntime::updateStateBeforeGC.
     * Before GC runs, called by the garbage collector to update any pending GC state. This is mainly used to notify
     * the garbage collector of references detected since the last GC run. Most references are notified immediately
     * but there can be some for which async operation is required (such as detecting new root data stores).
     */
    async updateStateBeforeGC() {
        return this.dataStores.updateStateBeforeGC();
    }
    /**
     * Implementation of IGarbageCollectionRuntime::getGCData.
     * Generates and returns the GC data for this container.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC) {
        const builder = new garbage_collector_1.GCDataBuilder();
        const dsGCData = await this.dataStores.getGCData(fullGC);
        builder.addNodes(dsGCData.gcNodes);
        const blobsGCData = this.blobManager.getGCData(fullGC);
        builder.addNodes(blobsGCData.gcNodes);
        return builder.getGCData();
    }
    /**
     * Implementation of IGarbageCollectionRuntime::updateUsedRoutes.
     * After GC has run, called to notify this container's nodes of routes that are used in it.
     * @param usedRoutes - The routes that are used in all nodes in this Container.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes
     * unreferenced as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Update our summarizer node's used routes. Updating used routes in summarizer node before
        // summarizing is required and asserted by the the summarizer node. We are the root and are
        // always referenced, so the used routes is only self-route (empty string).
        this.summarizerNode.updateUsedRoutes([""]);
        const dataStoreUsedRoutes = [];
        for (const route of usedRoutes) {
            if (route.split("/")[1] !== blobManager_1.BlobManager.basePath) {
                dataStoreUsedRoutes.push(route);
            }
        }
        return this.dataStores.updateUsedRoutes(dataStoreUsedRoutes, gcTimestamp);
    }
    /**
     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing
     * scenarios with accessing deleted content.
     * @param unusedRoutes - The routes that are unused in all data stores in this Container.
     */
    deleteUnusedRoutes(unusedRoutes) {
        const blobManagerUnusedRoutes = [];
        const dataStoreUnusedRoutes = [];
        for (const route of unusedRoutes) {
            if (this.isBlobPath(route)) {
                blobManagerUnusedRoutes.push(route);
            }
            else {
                dataStoreUnusedRoutes.push(route);
            }
        }
        this.blobManager.deleteUnusedRoutes(blobManagerUnusedRoutes);
        this.dataStores.deleteUnusedRoutes(dataStoreUnusedRoutes);
    }
    /**
     * Returns a server generated referenced timestamp to be used to track unreferenced nodes by GC.
     */
    getCurrentReferenceTimestampMs() {
        var _a, _b, _c;
        // Use the timestamp of the last message seen by this client as that is server generated. If no messages have
        // been processed, use the timestamp of the message from the last summary.
        return (_b = (_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.timestamp) !== null && _b !== void 0 ? _b : (_c = this.messageAtLastSummary) === null || _c === void 0 ? void 0 : _c.timestamp;
    }
    /**
     * Returns the type of the GC node. Currently, there are nodes that belong to the root ("/"), data stores or
     * blob manager.
     */
    getNodeType(nodePath) {
        var _a;
        if (this.isBlobPath(nodePath)) {
            return garbageCollection_1.GCNodeType.Blob;
        }
        return (_a = this.dataStores.getGCNodeType(nodePath)) !== null && _a !== void 0 ? _a : garbageCollection_1.GCNodeType.Other;
    }
    /**
     * Called by GC to retrieve the package path of the node with the given path. The node should belong to a
     * data store or an attachment blob.
     */
    async getGCNodePackagePath(nodePath) {
        switch (this.getNodeType(nodePath)) {
            case garbageCollection_1.GCNodeType.Blob:
                return ["_blobs"];
            case garbageCollection_1.GCNodeType.DataStore:
            case garbageCollection_1.GCNodeType.SubDataStore:
                return this.dataStores.getDataStorePackagePath(nodePath);
            default:
                (0, common_utils_1.assert)(false, 0x2de /* "Package path requested for unsupported node type." */);
        }
    }
    /**
     * Returns whether a given path is for attachment blobs that are in the format - "/BlobManager.basePath/...".
     */
    isBlobPath(path) {
        const pathParts = path.split("/");
        if (pathParts.length < 2 || pathParts[1] !== blobManager_1.BlobManager.basePath) {
            return false;
        }
        return true;
    }
    /**
     * Runs garbage collection and updates the reference / used state of the nodes in the container.
     * @returns the statistics of the garbage collection run.
     */
    async collectGarbage(options) {
        return this.garbageCollector.collectGarbage(options);
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        this.garbageCollector.addedOutboundReference(srcHandle.absolutePath, outboundHandle.absolutePath);
    }
    /**
     * Generates the summary tree, uploads it to storage, and then submits the summarize op.
     * This is intended to be called by the summarizer, since it is the implementation of
     * ISummarizerInternalsProvider.submitSummary.
     * It takes care of state management at the container level, including pausing inbound
     * op processing, updating SummarizerNode state tracking, and garbage collection.
     * @param options - options controlling how the summary is generated or submitted
     */
    async submitSummary(options) {
        var _a, _b, _c;
        const { fullTree, refreshLatestAck, summaryLogger } = options;
        // The summary number for this summary. This will be updated during the summary process, so get it now and
        // use it for all events logged during this summary.
        const summaryNumber = this.nextSummaryNumber;
        const summaryNumberLogger = telemetry_utils_1.ChildLogger.create(summaryLogger, undefined, {
            all: { summaryNumber },
        });
        let latestSnapshotVersionId;
        if (refreshLatestAck) {
            const latestSnapshotInfo = await this.refreshLatestSummaryAckFromServer(telemetry_utils_1.ChildLogger.create(summaryNumberLogger, undefined, { all: { safeSummary: true } }));
            const latestSnapshotRefSeq = latestSnapshotInfo.latestSnapshotRefSeq;
            latestSnapshotVersionId = latestSnapshotInfo.latestSnapshotVersionId;
            if (latestSnapshotRefSeq > this.deltaManager.lastSequenceNumber) {
                // We need to catch up to the latest summary's reference sequence number before pausing.
                await telemetry_utils_1.PerformanceEvent.timedExecAsync(summaryNumberLogger, {
                    eventName: "WaitingForSeq",
                    lastSequenceNumber: this.deltaManager.lastSequenceNumber,
                    targetSequenceNumber: latestSnapshotRefSeq,
                    lastKnownSeqNumber: this.deltaManager.lastKnownSeqNumber,
                }, async () => waitForSeq(this.deltaManager, latestSnapshotRefSeq), { start: true, end: true, cancel: "error" });
            }
        }
        try {
            await this.deltaManager.inbound.pause();
            const summaryRefSeqNum = this.deltaManager.lastSequenceNumber;
            const minimumSequenceNumber = this.deltaManager.minimumSequenceNumber;
            const message = `Summary @${summaryRefSeqNum}:${this.deltaManager.minimumSequenceNumber}`;
            // We should be here is we haven't processed be here. If we are of if the last message's sequence number
            // doesn't match the last processed sequence number, log an error.
            if (summaryRefSeqNum !== ((_a = this.deltaManager.lastMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber)) {
                summaryNumberLogger.sendErrorEvent({
                    eventName: "LastSequenceMismatch",
                    error: message,
                });
            }
            this.summarizerNode.startSummary(summaryRefSeqNum, summaryNumberLogger);
            // Helper function to check whether we should still continue between each async step.
            const checkContinue = () => {
                // Do not check for loss of connectivity directly! Instead leave it up to
                // RunWhileConnectedCoordinator to control policy in a single place.
                // This will allow easier change of design if we chose to. For example, we may chose to allow
                // summarizer to reconnect in the future.
                // Also checking for cancellation is a must as summary process may be abandoned for other reasons,
                // like loss of connectivity for main (interactive) client.
                if (options.cancellationToken.cancelled) {
                    return { continue: false, error: "disconnected" };
                }
                // That said, we rely on submitSystemMessage() that today only works in connected state.
                // So if we fail here, it either means that RunWhileConnectedCoordinator does not work correctly,
                // OR that design changed and we need to remove this check and fix submitSystemMessage.
                (0, common_utils_1.assert)(this.connected, 0x258 /* "connected" */);
                // Ensure that lastSequenceNumber has not changed after pausing.
                // We need the summary op's reference sequence number to match our summary sequence number,
                // otherwise we'll get the wrong sequence number stamped on the summary's .protocol attributes.
                if (this.deltaManager.lastSequenceNumber !== summaryRefSeqNum) {
                    return {
                        continue: false,
                        // eslint-disable-next-line max-len
                        error: `lastSequenceNumber changed before uploading to storage. ${this.deltaManager.lastSequenceNumber} !== ${summaryRefSeqNum}`,
                    };
                }
                return { continue: true };
            };
            let continueResult = checkContinue();
            if (!continueResult.continue) {
                return {
                    stage: "base",
                    referenceSequenceNumber: summaryRefSeqNum,
                    minimumSequenceNumber,
                    error: continueResult.error,
                };
            }
            const trace = common_utils_1.Trace.start();
            let summarizeResult;
            // If the GC state needs to be reset, we need to force a full tree summary and update the unreferenced
            // state of all the nodes.
            const forcedFullTree = this.garbageCollector.summaryStateNeedsReset;
            try {
                summarizeResult = await this.summarize({
                    fullTree: fullTree || forcedFullTree,
                    trackState: true,
                    summaryLogger: summaryNumberLogger,
                    runGC: this.garbageCollector.shouldRunGC,
                });
            }
            catch (error) {
                return {
                    stage: "base",
                    referenceSequenceNumber: summaryRefSeqNum,
                    minimumSequenceNumber,
                    error,
                };
            }
            const { summary: summaryTree, stats: partialStats } = summarizeResult;
            // Now that we have generated the summary, update the message at last summary to the last message processed.
            this.messageAtLastSummary = this.deltaManager.lastMessage;
            // Counting dataStores and handles
            // Because handles are unchanged dataStores in the current logic,
            // summarized dataStore count is total dataStore count minus handle count
            const dataStoreTree = this.disableIsolatedChannels ? summaryTree : summaryTree.tree[runtime_definitions_1.channelsTreeName];
            (0, common_utils_1.assert)(dataStoreTree.type === protocol_definitions_1.SummaryType.Tree, 0x1fc /* "summary is not a tree" */);
            const handleCount = Object.values(dataStoreTree.tree).filter((value) => value.type === protocol_definitions_1.SummaryType.Handle).length;
            const gcSummaryTreeStats = summaryTree.tree[garbageCollection_1.gcTreeKey]
                ? (0, runtime_utils_1.calculateStats)(summaryTree.tree[garbageCollection_1.gcTreeKey])
                : undefined;
            const summaryStats = Object.assign({ dataStoreCount: this.dataStores.size, summarizedDataStoreCount: this.dataStores.size - handleCount, gcStateUpdatedDataStoreCount: (_b = summarizeResult.gcStats) === null || _b === void 0 ? void 0 : _b.updatedDataStoreCount, gcBlobNodeCount: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.blobNodeCount, gcTotalBlobsSize: gcSummaryTreeStats === null || gcSummaryTreeStats === void 0 ? void 0 : gcSummaryTreeStats.totalBlobSize, opsSizesSinceLastSummary: this.opTracker.opsSizeAccumulator, nonSystemOpsSinceLastSummary: this.opTracker.nonSystemOpCount, summaryNumber }, partialStats);
            const generateSummaryData = {
                referenceSequenceNumber: summaryRefSeqNum,
                minimumSequenceNumber,
                summaryTree,
                summaryStats,
                generateDuration: trace.trace().duration,
                forcedFullTree,
            };
            continueResult = checkContinue();
            if (!continueResult.continue) {
                return Object.assign(Object.assign({ stage: "generate" }, generateSummaryData), { error: continueResult.error });
            }
            // It may happen that the lastAck it not correct due to missing summaryAck in case of single commit
            // summary. So if the previous summarizer closes just after submitting the summary and before
            // submitting the summaryOp then we can't rely on summaryAck. So in case we have
            // latestSnapshotVersionId from storage and it does not match with the lastAck ackHandle, then use
            // the one fetched from storage as parent as that is the latest.
            const lastAck = this.summaryCollection.latestAck;
            let summaryContext;
            if ((lastAck === null || lastAck === void 0 ? void 0 : lastAck.summaryAck.contents.handle) !== latestSnapshotVersionId
                && latestSnapshotVersionId !== undefined) {
                summaryContext = {
                    proposalHandle: undefined,
                    ackHandle: latestSnapshotVersionId,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            else if (lastAck === undefined) {
                summaryContext = {
                    proposalHandle: undefined,
                    ackHandle: (_c = this.context.getLoadedFromVersion()) === null || _c === void 0 ? void 0 : _c.id,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            else {
                summaryContext = {
                    proposalHandle: lastAck.summaryOp.contents.handle,
                    ackHandle: lastAck.summaryAck.contents.handle,
                    referenceSequenceNumber: summaryRefSeqNum,
                };
            }
            let handle;
            try {
                handle = await this.storage.uploadSummaryWithContext(summarizeResult.summary, summaryContext);
            }
            catch (error) {
                return Object.assign(Object.assign({ stage: "generate" }, generateSummaryData), { error });
            }
            const parent = summaryContext.ackHandle;
            const summaryMessage = {
                handle,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                head: parent,
                message,
                parents: parent ? [parent] : [],
            };
            const uploadData = Object.assign(Object.assign({}, generateSummaryData), { handle, uploadDuration: trace.trace().duration });
            continueResult = checkContinue();
            if (!continueResult.continue) {
                return Object.assign(Object.assign({ stage: "upload" }, uploadData), { error: continueResult.error });
            }
            let clientSequenceNumber;
            try {
                clientSequenceNumber = this.submitSystemMessage(protocol_definitions_1.MessageType.Summarize, summaryMessage);
            }
            catch (error) {
                return Object.assign(Object.assign({ stage: "upload" }, uploadData), { error });
            }
            const submitData = Object.assign(Object.assign({ stage: "submit" }, uploadData), { clientSequenceNumber, submitOpDuration: trace.trace().duration });
            this.summarizerNode.completeSummary(handle);
            this.opTracker.reset();
            return submitData;
        }
        finally {
            // Cleanup wip summary in case of failure
            this.summarizerNode.clearSummary();
            // Restart the delta manager
            this.deltaManager.inbound.resume();
        }
    }
    processRemoteChunkedMessage(message) {
        if (message.type !== ContainerMessageType.ChunkedOp) {
            return message;
        }
        const clientId = message.clientId;
        const chunkedContent = message.contents;
        this.addChunk(clientId, chunkedContent);
        if (chunkedContent.chunkId === chunkedContent.totalChunks) {
            const newMessage = Object.assign({}, message);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const serializedContent = this.chunkMap.get(clientId).join("");
            newMessage.contents = JSON.parse(serializedContent);
            newMessage.type = chunkedContent.originalType;
            this.clearPartialChunks(clientId);
            return newMessage;
        }
        return message;
    }
    addChunk(clientId, chunkedContent) {
        let map = this.chunkMap.get(clientId);
        if (map === undefined) {
            map = [];
            this.chunkMap.set(clientId, map);
        }
        (0, common_utils_1.assert)(chunkedContent.chunkId === map.length + 1, 0x131 /* "Mismatch between new chunkId and expected chunkMap" */); // 1-based indexing
        map.push(chunkedContent.contents);
    }
    clearPartialChunks(clientId) {
        if (this.chunkMap.has(clientId)) {
            this.chunkMap.delete(clientId);
        }
    }
    updateDocumentDirtyState(dirty) {
        if (this.dirtyContainer === dirty) {
            return;
        }
        this.dirtyContainer = dirty;
        if (this.emitDirtyDocumentEvent) {
            this.emit(dirty ? "dirty" : "saved");
            this.context.updateDirtyContainerState(dirty);
        }
    }
    submitDataStoreOp(id, contents, localOpMetadata = undefined) {
        const envelope = {
            address: id,
            contents,
        };
        this.submit(ContainerMessageType.FluidDataStoreOp, envelope, localOpMetadata);
    }
    submitDataStoreAliasOp(contents, localOpMetadata) {
        const aliasMessage = contents;
        if (!(0, dataStore_1.isDataStoreAliasMessage)(aliasMessage)) {
            throw new container_utils_1.UsageError("malformedDataStoreAliasMessage");
        }
        this.submit(ContainerMessageType.Alias, contents, localOpMetadata);
    }
    async uploadBlob(blob) {
        this.verifyNotClosed();
        return this.blobManager.createBlob(blob);
    }
    submit(type, content, localOpMetadata = undefined, opMetadata = undefined) {
        this.verifyNotClosed();
        // There should be no ops in detached container state!
        (0, common_utils_1.assert)(this.attachState !== container_definitions_1.AttachState.Detached, 0x132 /* "sending ops in detached container" */);
        let clientSequenceNumber = -1;
        let opMetadataInternal = opMetadata;
        if (this.canSendOps()) {
            const serializedContent = JSON.stringify(content);
            const maxOpSize = this.context.deltaManager.maxMessageSize;
            // If in TurnBased flush mode we will trigger a flush at the next turn break
            if (this.flushMode === runtime_definitions_1.FlushMode.TurnBased && !this.needsFlush) {
                opMetadataInternal = Object.assign(Object.assign({}, opMetadata), { batch: true });
                this.needsFlush = true;
                // Use Promise.resolve().then() to queue a microtask to detect the end of the turn and force a flush.
                if (!this.flushTrigger) {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    Promise.resolve().then(() => {
                        this.flushTrigger = false;
                        this.flush();
                    });
                }
            }
            clientSequenceNumber = this.submitMaybeChunkedMessages(type, content, serializedContent, maxOpSize, this._flushMode === runtime_definitions_1.FlushMode.TurnBased, opMetadataInternal);
        }
        // Let the PendingStateManager know that a message was submitted.
        this.pendingStateManager.onSubmitMessage(type, clientSequenceNumber, this.deltaManager.lastSequenceNumber, content, localOpMetadata, opMetadataInternal);
        if (this.isContainerMessageDirtyable(type, content)) {
            this.updateDocumentDirtyState(true);
        }
    }
    submitMaybeChunkedMessages(type, content, serializedContent, serverMaxOpSize, batch, opMetadataInternal = undefined) {
        if (this._maxOpSizeInBytes >= 0) {
            // Chunking disabled
            if (!serializedContent || serializedContent.length <= this._maxOpSizeInBytes) {
                return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);
            }
            // When chunking is disabled, we ignore the server max message size
            // and if the content length is larger than the client configured message size
            // instead of splitting the content, we will fail by explicitly close the container
            this.closeFn(new container_utils_1.GenericError("OpTooLarge", 
            /* error */ undefined, {
                length: {
                    value: serializedContent.length,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
                limit: {
                    value: this._maxOpSizeInBytes,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
            }));
            return -1;
        }
        // Chunking enabled, fallback on the server's max message size
        // and split the content accordingly
        if (!serializedContent || serializedContent.length <= serverMaxOpSize) {
            return this.submitRuntimeMessage(type, content, batch, opMetadataInternal);
        }
        return this.submitChunkedMessage(type, serializedContent, serverMaxOpSize);
    }
    submitChunkedMessage(type, content, maxOpSize) {
        const contentLength = content.length;
        const chunkN = Math.floor((contentLength - 1) / maxOpSize) + 1;
        let offset = 0;
        let clientSequenceNumber = 0;
        for (let i = 1; i <= chunkN; i = i + 1) {
            const chunkedOp = {
                chunkId: i,
                contents: content.substr(offset, maxOpSize),
                originalType: type,
                totalChunks: chunkN,
            };
            offset += maxOpSize;
            clientSequenceNumber = this.submitRuntimeMessage(ContainerMessageType.ChunkedOp, chunkedOp, false);
        }
        return clientSequenceNumber;
    }
    submitSystemMessage(type, contents) {
        this.verifyNotClosed();
        (0, common_utils_1.assert)(this.connected, 0x133 /* "Container disconnected when trying to submit system message" */);
        // System message should not be sent in the middle of the batch.
        // That said, we can preserve existing behavior by not flushing existing buffer.
        // That might be not what caller hopes to get, but we can look deeper if telemetry tells us it's a problem.
        const middleOfBatch = this.flushMode === runtime_definitions_1.FlushMode.TurnBased && this.needsFlush;
        if (middleOfBatch) {
            this.mc.logger.sendErrorEvent({ eventName: "submitSystemMessageError", type });
        }
        return this.context.submitFn(type, contents, middleOfBatch);
    }
    submitRuntimeMessage(type, contents, batch, appData) {
        this.verifyNotClosed();
        (0, common_utils_1.assert)(this.connected, 0x259 /* "Container disconnected when trying to submit system message" */);
        const payload = { type, contents };
        return this.context.submitFn(protocol_definitions_1.MessageType.Operation, payload, batch, appData);
    }
    /**
     * Throw an error if the runtime is closed.  Methods that are expected to potentially
     * be called after dispose due to asynchrony should not call this.
     */
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Runtime is closed");
        }
    }
    /**
     * Finds the right store and asks it to resubmit the message. This typically happens when we
     * reconnect and there are pending messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata, opMetadata) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                // For Operations, call resubmitDataStoreOp which will find the right store
                // and trigger resubmission on it.
                this.dataStores.resubmitDataStoreOp(content, localOpMetadata);
                break;
            case ContainerMessageType.Attach:
            case ContainerMessageType.Alias:
                this.submit(type, content, localOpMetadata);
                break;
            case ContainerMessageType.ChunkedOp:
                throw new Error(`chunkedOp not expected here`);
            case ContainerMessageType.BlobAttach:
                this.submit(type, content, localOpMetadata, opMetadata);
                break;
            case ContainerMessageType.Rejoin:
                this.submit(type, content);
                break;
            default:
                (0, common_utils_1.unreachableCase)(type, `Unknown ContainerMessageType: ${type}`);
        }
    }
    rollback(type, content, localOpMetadata) {
        switch (type) {
            case ContainerMessageType.FluidDataStoreOp:
                // For operations, call rollbackDataStoreOp which will find the right store
                // and trigger rollback on it.
                this.dataStores.rollbackDataStoreOp(content, localOpMetadata);
                break;
            default:
                throw new Error(`Can't rollback ${type}`);
        }
    }
    /** Implementation of ISummarizerInternalsProvider.refreshLatestSummaryAck */
    async refreshLatestSummaryAck(proposalHandle, ackHandle, summaryRefSeq, summaryLogger) {
        const readAndParseBlob = async (id) => (0, driver_utils_1.readAndParse)(this.storage, id);
        const { snapshotTree } = await this.fetchSnapshotFromStorage(ackHandle, summaryLogger, {
            eventName: "RefreshLatestSummaryGetSnapshot",
            ackHandle,
            summaryRefSeq,
            fetchLatest: false,
        });
        const result = await this.summarizerNode.refreshLatestSummary(proposalHandle, summaryRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);
        // Notify the garbage collector so it can update its latest summary state.
        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);
    }
    /**
     * Fetches the latest snapshot from storage and uses it to refresh SummarizerNode's
     * internal state as it should be considered the latest summary ack.
     * @param summaryLogger - logger to use when fetching snapshot from storage
     * @returns downloaded snapshot's reference sequence number
     */
    async refreshLatestSummaryAckFromServer(summaryLogger) {
        const { snapshotTree, versionId } = await this.fetchSnapshotFromStorage(null, summaryLogger, {
            eventName: "RefreshLatestSummaryGetSnapshot",
            fetchLatest: true,
        });
        const readAndParseBlob = async (id) => (0, driver_utils_1.readAndParse)(this.storage, id);
        const latestSnapshotRefSeq = await (0, runtime_utils_1.seqFromTree)(snapshotTree, readAndParseBlob);
        const result = await this.summarizerNode.refreshLatestSummary(undefined, latestSnapshotRefSeq, async () => snapshotTree, readAndParseBlob, summaryLogger);
        // Notify the garbage collector so it can update its latest summary state.
        await this.garbageCollector.latestSummaryStateRefreshed(result, readAndParseBlob);
        return { latestSnapshotRefSeq, latestSnapshotVersionId: versionId };
    }
    async fetchSnapshotFromStorage(versionId, logger, event) {
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(logger, event, async (perfEvent) => {
            const stats = {};
            const trace = common_utils_1.Trace.start();
            const versions = await this.storage.getVersions(versionId, 1);
            (0, common_utils_1.assert)(!!versions && !!versions[0], 0x137 /* "Failed to get version from storage" */);
            stats.getVersionDuration = trace.trace().duration;
            const maybeSnapshot = await this.storage.getSnapshotTree(versions[0]);
            (0, common_utils_1.assert)(!!maybeSnapshot, 0x138 /* "Failed to get snapshot from storage" */);
            stats.getSnapshotDuration = trace.trace().duration;
            perfEvent.end(stats);
            return { snapshotTree: maybeSnapshot, versionId: versions[0].id };
        });
    }
    notifyAttaching(snapshot) {
        var _a;
        if ((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) {
            this.baseSnapshotBlobs = serializedSnapshotStorage_1.SerializedSnapshotStorage.serializeTreeWithBlobContents(snapshot);
        }
    }
    async getSnapshotBlobs() {
        var _a;
        if (!((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad) ||
            this.attachState !== container_definitions_1.AttachState.Attached || this.context.pendingLocalState) {
            return;
        }
        (0, common_utils_1.assert)(!!this.context.baseSnapshot, 0x2e5 /* "Must have a base snapshot" */);
        this.baseSnapshotBlobs = await serializedSnapshotStorage_1.SerializedSnapshotStorage.serializeTree(this.context.baseSnapshot, this.storage);
    }
    getPendingLocalState() {
        var _a;
        if (!((_a = this.mc.config.getBoolean("enableOfflineLoad")) !== null && _a !== void 0 ? _a : this.runtimeOptions.enableOfflineLoad)) {
            throw new container_utils_1.UsageError("can't get state when offline load disabled");
        }
        const previousPendingState = this.context.pendingLocalState;
        if (previousPendingState) {
            return {
                pending: this.pendingStateManager.getLocalState(),
                snapshotBlobs: previousPendingState.snapshotBlobs,
                baseSnapshot: previousPendingState.baseSnapshot,
                savedOps: this.savedOps,
            };
        }
        (0, common_utils_1.assert)(!!this.context.baseSnapshot, 0x2e6 /* "Must have a base snapshot" */);
        (0, common_utils_1.assert)(!!this.baseSnapshotBlobs, 0x2e7 /* "Must serialize base snapshot blobs before getting runtime state" */);
        return {
            pending: this.pendingStateManager.getLocalState(),
            snapshotBlobs: this.baseSnapshotBlobs,
            baseSnapshot: this.context.baseSnapshot,
            savedOps: this.savedOps,
        };
    }
    /**
     * * Forms a function that will request a Summarizer.
     * @param loaderRouter - the loader acting as an IFluidRouter
     * */
    formRequestSummarizerFn(loaderRouter) {
        return async () => {
            const request = {
                headers: {
                    [container_definitions_1.LoaderHeader.cache]: false,
                    [container_definitions_1.LoaderHeader.clientDetails]: {
                        capabilities: { interactive: false },
                        type: summarizerClientElection_1.summarizerClientType,
                    },
                    [driver_definitions_1.DriverHeader.summarizingClient]: true,
                    [container_definitions_1.LoaderHeader.reconnect]: false,
                },
                url: "/_summarizer",
            };
            const fluidObject = await (0, runtime_utils_1.requestFluidObject)(loaderRouter, request);
            const summarizer = fluidObject.ISummarizer;
            if (!summarizer) {
                throw new container_utils_1.UsageError("Fluid object does not implement ISummarizer");
            }
            return summarizer;
        };
    }
    async processSavedOps(state) {
        for (const op of state.savedOps) {
            this.process(op, false);
            await this.pendingStateManager.applyStashedOpsAt(op.sequenceNumber);
        }
        // we may not have seen every sequence number (because of system ops) so apply everything once we
        // don't have any more saved ops
        await this.pendingStateManager.applyStashedOpsAt();
    }
}
exports.ContainerRuntime = ContainerRuntime;
/**
 * Wait for a specific sequence number. Promise should resolve when we reach that number,
 * or reject if closed.
 */
const waitForSeq = async (deltaManager, targetSeq) => new Promise((resolve, reject) => {
    // TODO: remove cast to any when actual event is determined
    deltaManager.on("closed", reject);
    const handleOp = (message) => {
        if (message.sequenceNumber >= targetSeq) {
            resolve();
            deltaManager.off("op", handleOp);
        }
    };
    deltaManager.on("op", handleOp);
});

},{"./batchTracker":56,"./blobManager":57,"./connectionTelemetry":58,"./containerHandleContext":59,"./dataStore":61,"./dataStoreRegistry":64,"./dataStores":65,"./deltaScheduler":66,"./garbageCollection":67,"./opTelemetry":69,"./orderedClientElection":70,"./packageVersion":71,"./pendingStateManager":72,"./runWhileConnectedCoordinator":73,"./serializedSnapshotStorage":75,"./summarizer":76,"./summarizerClientElection":77,"./summaryCollection":81,"./summaryFormat":82,"./summaryManager":84,"./throttler":85,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110,"@fluidframework/garbage-collector":133,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279,"uuid":544}],61:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.channelToDataStore = exports.isDataStoreAliasMessage = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const container_utils_1 = require("@fluidframework/container-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/**
 * Type guard that returns true if the given alias message is actually an instance of
 * a class which implements {@link IDataStoreAliasMessage}
 * @param maybeDataStoreAliasMessage - message object to be validated
 * @returns True if the {@link IDataStoreAliasMessage} is fully implemented, false otherwise
 */
const isDataStoreAliasMessage = (maybeDataStoreAliasMessage) => {
    return typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.internalId) === "string"
        && typeof (maybeDataStoreAliasMessage === null || maybeDataStoreAliasMessage === void 0 ? void 0 : maybeDataStoreAliasMessage.alias) === "string";
};
exports.isDataStoreAliasMessage = isDataStoreAliasMessage;
const channelToDataStore = (fluidDataStoreChannel, internalId, runtime, datastores, logger) => new DataStore(fluidDataStoreChannel, internalId, runtime, datastores, logger);
exports.channelToDataStore = channelToDataStore;
var AliasState;
(function (AliasState) {
    AliasState["Aliased"] = "Aliased";
    AliasState["Aliasing"] = "Aliasing";
    AliasState["None"] = "None";
})(AliasState || (AliasState = {}));
class DataStore {
    constructor(fluidDataStoreChannel, internalId, runtime, datastores, logger) {
        this.fluidDataStoreChannel = fluidDataStoreChannel;
        this.internalId = internalId;
        this.runtime = runtime;
        this.datastores = datastores;
        this.logger = logger;
        this.aliasState = AliasState.None;
    }
    async trySetAlias(alias) {
        if (alias.includes("/")) {
            throw new container_utils_1.UsageError(`The alias cannot contain slashes: '${alias}'`);
        }
        switch (this.aliasState) {
            // If we're already aliasing, check if it's for the same value and return
            // the stored promise, otherwise return 'AlreadyAliased'
            case AliasState.Aliasing:
                (0, common_utils_1.assert)(this.aliasResult !== undefined, 0x316 /* There should be a cached promise of in-progress aliasing */);
                await this.aliasResult;
                return this.alias === alias ? "Success" : "AlreadyAliased";
            // If this datastore is already aliased, return true only if this
            // is a repeated call for the same alias
            case AliasState.Aliased:
                return this.alias === alias ? "Success" : "AlreadyAliased";
            // There is no current or past alias operation for this datastore,
            // it is safe to continue execution
            case AliasState.None: break;
            default: (0, common_utils_1.unreachableCase)(this.aliasState);
        }
        this.aliasState = AliasState.Aliasing;
        this.aliasResult = this.trySetAliasInternal(alias);
        return this.aliasResult;
    }
    async trySetAliasInternal(alias) {
        const message = {
            internalId: this.internalId,
            alias,
        };
        // back-compat 0.58.2000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel. For
        // older versions, we still have to call bindToContext.
        if (this.fluidDataStoreChannel.makeVisibleAndAttachGraph !== undefined) {
            this.fluidDataStoreChannel.makeVisibleAndAttachGraph();
        }
        else {
            this.fluidDataStoreChannel.bindToContext();
        }
        if (this.runtime.attachState === container_definitions_1.AttachState.Detached) {
            const localResult = this.datastores.processAliasMessageCore(message);
            // Explicitly lock-out future attempts of aliasing,
            // regardless of result
            this.aliasState = AliasState.Aliased;
            return localResult ? "Success" : "Conflict";
        }
        const aliased = await this.ackBasedPromise((resolve) => {
            this.runtime.submitDataStoreAliasOp(message, resolve);
        }).then((succeeded) => {
            // Explicitly Lock-out future attempts of aliasing,
            // regardless of result
            this.aliasState = AliasState.Aliased;
            if (succeeded) {
                this.alias = alias;
            }
            return succeeded;
        }).catch((error) => {
            this.logger.sendErrorEvent({
                eventName: "AliasingException",
                alias: {
                    value: alias,
                    tag: telemetry_utils_1.TelemetryDataTag.UserData,
                },
                internalId: {
                    value: this.internalId,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
            }, error);
            this.aliasState = AliasState.None;
            return false;
        });
        return aliased ? "Success" : "Conflict";
    }
    async request(request) {
        return this.fluidDataStoreChannel.request(request);
    }
    get IFluidRouter() { return this.fluidDataStoreChannel; }
    async ackBasedPromise(executor) {
        let rejectBecauseDispose;
        return new Promise((resolve, reject) => {
            rejectBecauseDispose =
                () => reject(new Error("ContainerRuntime disposed while this ack-based Promise was pending"));
            if (this.runtime.disposed) {
                rejectBecauseDispose();
                return;
            }
            this.runtime.on("dispose", rejectBecauseDispose);
            executor(resolve, reject);
        }).finally(() => {
            this.runtime.off("dispose", rejectBecauseDispose);
        });
    }
}

},{"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/telemetry-utils":279}],62:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalDetachedFluidDataStoreContext = exports.LocalFluidDataStoreContext = exports.LocalFluidDataStoreContextBase = exports.RemoteFluidDataStoreContext = exports.FluidDataStoreContext = exports.createAttributesBlob = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const summaryFormat_1 = require("./summaryFormat");
function createAttributes(pkg, isRootDataStore, disableIsolatedChannels) {
    const stringifiedPkg = JSON.stringify(pkg);
    return disableIsolatedChannels ? {
        pkg: stringifiedPkg,
        snapshotFormatVersion: "0.1",
        isRootDataStore,
    } : {
        pkg: stringifiedPkg,
        summaryFormatVersion: 2,
        isRootDataStore,
    };
}
function createAttributesBlob(pkg, isRootDataStore, disableIsolatedChannels) {
    const attributes = createAttributes(pkg, isRootDataStore, disableIsolatedChannels);
    return new protocol_base_1.BlobTreeEntry(summaryFormat_1.dataStoreAttributesBlobName, JSON.stringify(attributes));
}
exports.createAttributesBlob = createAttributesBlob;
/**
 * Represents the context for the store. This context is passed to the store runtime.
 */
class FluidDataStoreContext extends common_utils_1.TypedEventEmitter {
    constructor(props, existing, bindState, isLocalDataStore, makeLocallyVisibleFn) {
        super();
        this.existing = existing;
        this.bindState = bindState;
        this.isLocalDataStore = isLocalDataStore;
        this.makeLocallyVisibleFn = makeLocallyVisibleFn;
        this._disposed = false;
        this.detachedRuntimeCreation = false;
        this.loaded = false;
        this.pending = [];
        this._isInMemoryRoot = false;
        this._containerRuntime = props.runtime;
        this.id = props.id;
        this.storage = props.storage;
        this.scope = props.scope;
        this.writeGCDataAtRoot = props.writeGCDataAtRoot;
        this.disableIsolatedChannels = props.disableIsolatedChannels;
        this.pkg = props.pkg;
        // URIs use slashes as delimiters. Handles use URIs.
        // Thus having slashes in types almost guarantees trouble down the road!
        (0, common_utils_1.assert)(!this.id.includes("/"), 0x13a /* Data store ID contains slash */);
        this._attachState = this.containerRuntime.attachState !== container_definitions_1.AttachState.Detached && this.existing ?
            this.containerRuntime.attachState : container_definitions_1.AttachState.Detached;
        this.bindToContext = () => {
            (0, common_utils_1.assert)(this.bindState === container_definitions_1.BindState.NotBound, 0x13b /* "datastore context is already in bound state" */);
            this.bindState = container_definitions_1.BindState.Binding;
            (0, common_utils_1.assert)(this.channel !== undefined, 0x13c /* "undefined channel on datastore context" */);
            this.makeLocallyVisible();
            this.bindState = container_definitions_1.BindState.Bound;
        };
        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);
        this.summarizerNode = props.createSummarizerNodeFn(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => this.getBaseGCDetails());
        this.subLogger = telemetry_utils_1.ChildLogger.create(this.logger, "FluidDataStoreContext");
        this.thresholdOpsCounter = new telemetry_utils_1.ThresholdCounter(FluidDataStoreContext.pendingOpsCountThreshold, this.subLogger);
    }
    get packagePath() {
        (0, common_utils_1.assert)(this.pkg !== undefined, 0x139 /* "Undefined package path" */);
        return this.pkg;
    }
    get options() {
        return this._containerRuntime.options;
    }
    get clientId() {
        return this._containerRuntime.clientId;
    }
    get clientDetails() {
        return this._containerRuntime.clientDetails;
    }
    get logger() {
        return this._containerRuntime.logger;
    }
    get deltaManager() {
        return this._containerRuntime.deltaManager;
    }
    get connected() {
        return this._containerRuntime.connected;
    }
    get IFluidHandleContext() {
        return this._containerRuntime.IFluidHandleContext;
    }
    get containerRuntime() {
        return this._containerRuntime;
    }
    get isLoaded() {
        return this.loaded;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get disposed() { return this._disposed; }
    get attachState() {
        return this._attachState;
    }
    get IFluidDataStoreRegistry() {
        return this.registry;
    }
    /**
     * A datastore is considered as root if it
     * 1. is root in memory - see isInMemoryRoot
     * 2. is root as part of the base snapshot that the datastore loaded from
     * @returns whether a datastore is root
     */
    async isRoot() {
        return this.isInMemoryRoot() || (await this.getInitialSnapshotDetails()).isRootDataStore;
    }
    /**
     * There are 3 states where isInMemoryRoot needs to be true
     * 1. when a datastore becomes aliased. This can happen for both remote and local datastores
     * 2. when a datastore is created locally as root
     * 3. when a datastore is created locally as root and is rehydrated
     * @returns whether a datastore is root in memory
     */
    isInMemoryRoot() {
        return this._isInMemoryRoot;
    }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        // Dispose any pending runtime after it gets fulfilled
        // Errors are logged where this.channelDeferred is consumed/generated (realizeCore(), bindRuntime())
        if (this.channelDeferred) {
            this.channelDeferred.promise.then((runtime) => {
                runtime.dispose();
            }).catch((error) => { });
        }
    }
    rejectDeferredRealize(reason, packageName) {
        throw new telemetry_utils_1.LoggingError(reason, { packageName: { value: packageName, tag: telemetry_utils_1.TelemetryDataTag.PackageData } });
    }
    async realize() {
        (0, common_utils_1.assert)(!this.detachedRuntimeCreation, 0x13d /* "Detached runtime creation on realize()" */);
        if (!this.channelDeferred) {
            this.channelDeferred = new common_utils_1.Deferred();
            this.realizeCore(this.existing).catch((error) => {
                var _a;
                const errorWrapped = container_utils_1.DataProcessingError.wrapIfUnrecognized(error, "realizeFluidDataStoreContext");
                errorWrapped.addTelemetryProperties({ fluidDataStoreId: { value: this.id, tag: "PackageData" } });
                (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(errorWrapped);
                this.logger.sendErrorEvent({ eventName: "RealizeError" }, errorWrapped);
            });
        }
        return this.channelDeferred.promise;
    }
    async factoryFromPackagePath(packages) {
        (0, common_utils_1.assert)(this.pkg === packages, 0x13e /* "Unexpected package path" */);
        if (packages === undefined) {
            this.rejectDeferredRealize("packages is undefined");
        }
        let entry;
        let registry = this._containerRuntime.IFluidDataStoreRegistry;
        let lastPkg;
        for (const pkg of packages) {
            if (!registry) {
                this.rejectDeferredRealize("No registry for package", lastPkg);
            }
            lastPkg = pkg;
            entry = await registry.get(pkg);
            if (!entry) {
                this.rejectDeferredRealize("Registry does not contain entry for the package", pkg);
            }
            registry = entry.IFluidDataStoreRegistry;
        }
        const factory = entry === null || entry === void 0 ? void 0 : entry.IFluidDataStoreFactory;
        if (factory === undefined) {
            this.rejectDeferredRealize("Can't find factory for package", lastPkg);
        }
        return { factory, registry };
    }
    async realizeCore(existing) {
        const details = await this.getInitialSnapshotDetails();
        // Base snapshot is the baseline where pending ops are applied to.
        // It is important that this be in sync with the pending ops, and also
        // that it is set here, before bindRuntime is called.
        this._baseSnapshot = details.snapshot;
        const packages = details.pkg;
        const { factory, registry } = await this.factoryFromPackagePath(packages);
        (0, common_utils_1.assert)(this.registry === undefined, 0x13f /* "datastore context registry is already set" */);
        this.registry = registry;
        const channel = await factory.instantiateDataStore(this, existing);
        (0, common_utils_1.assert)(channel !== undefined, 0x140 /* "undefined channel on datastore context" */);
        this.bindRuntime(channel);
    }
    /**
     * Notifies this object about changes in the connection state.
     * @param value - New connection state.
     * @param clientId - ID of the client. It's old ID when in disconnected state and
     * it's new client ID when we are connecting or connected.
     */
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        // Connection events are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (0, common_utils_1.assert)(this.connected === connected, 0x141 /* "Unexpected connected state" */);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.channel.setConnectionState(connected, clientId);
    }
    process(messageArg, local, localOpMetadata) {
        var _a;
        this.verifyNotClosed();
        const innerContents = messageArg.contents;
        const message = Object.assign(Object.assign({}, messageArg), { type: innerContents.type, contents: innerContents.content });
        this.summarizerNode.recordChange(message);
        if (this.loaded) {
            return (_a = this.channel) === null || _a === void 0 ? void 0 : _a.process(message, local, localOpMetadata);
        }
        else {
            (0, common_utils_1.assert)(!local, 0x142 /* "local store channel is not loaded" */);
            (0, common_utils_1.assert)(this.pending !== undefined, 0x23d /* "pending is undefined" */);
            this.pending.push(message);
            this.thresholdOpsCounter.sendIfMultiple("StorePendingOps", this.pending.length);
        }
    }
    processSignal(message, local) {
        var _a;
        this.verifyNotClosed();
        // Signals are ignored if the store is not yet loaded
        if (!this.loaded) {
            return;
        }
        (_a = this.channel) === null || _a === void 0 ? void 0 : _a.processSignal(message, local);
    }
    getQuorum() {
        return this._containerRuntime.getQuorum();
    }
    getAudience() {
        return this._containerRuntime.getAudience();
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        await this.realize();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const summarizeResult = await this.channel.summarize(fullTree, trackState, telemetryContext);
        let pathPartsForChildren;
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0, summaryFormat_1.wrapSummaryInChannelsTree)(summarizeResult);
            pathPartsForChildren = [runtime_definitions_1.channelsTreeName];
        }
        // Add data store's attributes to the summary.
        const { pkg } = await this.getInitialSnapshotDetails();
        const isRoot = await this.isRoot();
        const attributes = createAttributes(pkg, isRoot, this.disableIsolatedChannels);
        (0, runtime_utils_1.addBlobToSummary)(summarizeResult, summaryFormat_1.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Add GC data to the summary if it's not written at the root.
        if (!this.writeGCDataAtRoot) {
            (0, runtime_utils_1.addBlobToSummary)(summarizeResult, runtime_definitions_1.gcBlobKey, JSON.stringify(this.summarizerNode.getGCSummaryDetails()));
        }
        // If we are not referenced, mark the summary tree as unreferenced. Also, update unreferenced blob
        // size in the summary stats with the blobs size of this data store.
        if (!this.summarizerNode.isReferenced()) {
            summarizeResult.summary.unreferenced = true;
            summarizeResult.stats.unreferencedBlobSize = summarizeResult.stats.totalBlobSize;
        }
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id, pathPartsForChildren });
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this data store
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document.
     * If there is no new data in this data store since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates data used for garbage collection. This is called when there is new data since last summary. It
     * realizes the data store and calls into each channel context to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        await this.realize();
        (0, common_utils_1.assert)(this.channel !== undefined, 0x143 /* "Channel should not be undefined when running GC" */);
        return this.channel.getGCData(fullGC);
    }
    /**
     * After GC has run, called to notify the data store of routes used in it. These are used for the following:
     * 1. To identify if this data store is being referenced in the document or not.
     * 2. To determine if it needs to re-summarize in case used routes changed since last summary.
     * 3. These are added to the summary generated by the data store.
     * 4. To notify child contexts of their used routes. This is done immediately if the data store is loaded. Else,
     *    it is done when realizing the data store.
     * 5. To update the timestamp when this data store or any children are marked as unreferenced.
     * @param usedRoutes - The routes that are used in this data store.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced
     * as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Update the used routes in this data store's summarizer node.
        this.summarizerNode.updateUsedRoutes(usedRoutes, gcTimestamp);
        /**
         * If the data store has not been realized yet, we need this used state to update the used state of the channel
         * when it realizes. It's safe to keep only the last used state because if something changes because of this GC
         * run, the data store will be immediately realized as part of the summary that follows GC. For example, if a
         * child's reference state changes, the gcTimestamp has to be used to update its unreferencedTimestamp. Since
         * it will result in a change in this data store's used routes, it will be realized to regenerate its summary.
         */
        this.lastUsedState = { usedRoutes, gcTimestamp };
        // If we are loaded, call the channel so it can update the used routes of the child contexts.
        // If we are not loaded, we will update this when we are realized.
        if (this.loaded) {
            this.updateChannelUsedRoutes();
        }
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        this._containerRuntime.addedGCOutboundReference(srcHandle, outboundHandle);
    }
    /**
     * Updates the used routes of the channel and its child contexts. The channel must be loaded before calling this.
     * It is called in these two scenarios:
     * 1. When the used routes of the data store is updated and the data store is loaded.
     * 2. When the data store is realized. This updates the channel's used routes as per last GC run.
     */
    updateChannelUsedRoutes() {
        (0, common_utils_1.assert)(this.loaded, 0x144 /* "Channel should be loaded when updating used routes" */);
        (0, common_utils_1.assert)(this.channel !== undefined, 0x145 /* "Channel should be present when data store is loaded" */);
        // If there is no lastUsedState, GC has not run up until this point.
        if (this.lastUsedState === undefined) {
            return;
        }
        // Remove the route to this data store, if it exists.
        const usedChannelRoutes = this.lastUsedState.usedRoutes.filter((id) => { return id !== "/" && id !== ""; });
        this.channel.updateUsedRoutes(usedChannelRoutes, this.lastUsedState.gcTimestamp);
    }
    /**
     * @deprecated 0.18.Should call request on the runtime directly
     */
    async request(request) {
        const runtime = await this.realize();
        return runtime.request(request);
    }
    submitMessage(type, content, localOpMetadata) {
        this.verifyNotClosed();
        (0, common_utils_1.assert)(!!this.channel, 0x146 /* "Channel must exist when submitting message" */);
        const fluidDataStoreContent = {
            content,
            type,
        };
        this._containerRuntime.submitDataStoreOp(this.id, fluidDataStoreContent, localOpMetadata);
    }
    /**
     * This is called from a SharedSummaryBlock that does not generate ops but only wants to be part of the summary.
     * It indicates that there is data in the object that needs to be summarized.
     * We will update the latestSequenceNumber of the summary tracker of this
     * store and of the object's channel.
     *
     * @param address - The address of the channel that is dirty.
     *
     */
    setChannelDirty(address) {
        this.verifyNotClosed();
        // Get the latest sequence number.
        const latestSequenceNumber = this.deltaManager.lastSequenceNumber;
        this.summarizerNode.invalidate(latestSequenceNumber);
        const channelSummarizerNode = this.summarizerNode.getChild(address);
        if (channelSummarizerNode) {
            channelSummarizerNode.invalidate(latestSequenceNumber); // TODO: lazy load problem?
        }
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        (0, common_utils_1.assert)(!!this.channel, 0x147 /* "Channel must exist on submitting signal" */);
        return this._containerRuntime.submitDataStoreSignal(this.id, type, content);
    }
    /**
     * This is called by the data store channel when it becomes locally visible indicating that it is ready to become
     * globally visible now.
     */
    makeLocallyVisible() {
        (0, common_utils_1.assert)(this.channel !== undefined, 0x2cf /* "undefined channel on datastore context" */);
        this.makeLocallyVisibleFn();
    }
    bindRuntime(channel) {
        var _a;
        if (this.channel) {
            throw new Error("Runtime already bound");
        }
        try {
            (0, common_utils_1.assert)(!this.detachedRuntimeCreation, 0x148 /* "Detached runtime creation on runtime bind" */);
            (0, common_utils_1.assert)(this.channelDeferred !== undefined, 0x149 /* "Undefined channel deferral" */);
            (0, common_utils_1.assert)(this.pkg !== undefined, 0x14a /* "Undefined package path" */);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pending = this.pending;
            // Apply all pending ops
            for (const op of pending) {
                channel.process(op, false, undefined /* localOpMetadata */);
            }
            this.thresholdOpsCounter.send("ProcessPendingOps", pending.length);
            this.pending = undefined;
            // And now mark the runtime active
            this.loaded = true;
            this.channel = channel;
            // Freeze the package path to ensure that someone doesn't modify it when it is
            // returned in packagePath().
            Object.freeze(this.pkg);
            /**
             * Update the used routes of the channel. If GC has run before this data store was realized, we will have
             * the used routes saved. So, this will ensure that all the child contexts have up-to-date used routes as
             * per the last time GC was run.
             * Also, this data store may have been realized during summarize. In that case, the child contexts need to
             * have their used routes updated to determine if its needs to summarize again and to add it to the summary.
             */
            this.updateChannelUsedRoutes();
            // And notify the pending promise it is now available
            this.channelDeferred.resolve(this.channel);
        }
        catch (error) {
            (_a = this.channelDeferred) === null || _a === void 0 ? void 0 : _a.reject(error);
            this.logger.sendErrorEvent({ eventName: "BindRuntimeError", fluidDataStoreId: { value: this.id, tag: "PackageData" } }, error);
        }
    }
    async getAbsoluteUrl(relativeUrl) {
        if (this.attachState !== container_definitions_1.AttachState.Attached) {
            return undefined;
        }
        return this._containerRuntime.getAbsoluteUrl(relativeUrl);
    }
    /**
     * @deprecated - Sets the datastore as root, for aliasing purposes: #7948
     * This method should not be used outside of the aliasing context.
     * It will be removed, as the source of truth for this flag will be the aliasing blob.
     */
    setInMemoryRoot() {
        this._isInMemoryRoot = true;
    }
    reSubmit(contents, localOpMetadata) {
        (0, common_utils_1.assert)(!!this.channel, 0x14b /* "Channel must exist when resubmitting ops" */);
        const innerContents = contents;
        this.channel.reSubmit(innerContents.type, innerContents.content, localOpMetadata);
    }
    rollback(contents, localOpMetadata) {
        if (!this.channel) {
            throw new Error("Channel must exist when rolling back ops");
        }
        if (!this.channel.rollback) {
            throw new Error("Channel doesn't support rollback");
        }
        const innerContents = contents;
        this.channel.rollback(innerContents.type, innerContents.content, localOpMetadata);
    }
    async applyStashedOp(contents) {
        if (!this.channel) {
            await this.realize();
        }
        (0, common_utils_1.assert)(!!this.channel, 0x14c /* "Channel must exist when rebasing ops" */);
        const innerContents = contents;
        return this.channel.applyStashedOp(innerContents.content);
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new Error("Context is closed");
        }
    }
    getCreateChildSummarizerNodeFn(id, createParam) {
        return (summarizeInternal, getGCDataFn, getBaseGCDetailsFn) => this.summarizerNode.createChild(summarizeInternal, id, createParam, 
        // DDS will not create failure summaries
        { throwOnFailure: true }, getGCDataFn, getBaseGCDetailsFn);
    }
    async uploadBlob(blob) {
        return this.containerRuntime.uploadBlob(blob);
    }
}
exports.FluidDataStoreContext = FluidDataStoreContext;
FluidDataStoreContext.pendingOpsCountThreshold = 1000;
class RemoteFluidDataStoreContext extends FluidDataStoreContext {
    constructor(props) {
        super(props, true /* existing */, container_definitions_1.BindState.Bound, false /* isLocalDataStore */, () => {
            throw new Error("Already attached");
        });
        this.initialSnapshotDetailsP = new common_utils_1.LazyPromise(async () => {
            var _a, _b;
            let tree;
            let isRootDataStore = true;
            if (typeof this.initSnapshotValue === "string") {
                const commit = (await this.storage.getVersions(this.initSnapshotValue, 1))[0];
                tree = (_a = await this.storage.getSnapshotTree(commit)) !== null && _a !== void 0 ? _a : undefined;
            }
            else {
                tree = this.initSnapshotValue;
            }
            const localReadAndParse = async (id) => (0, driver_utils_1.readAndParse)(this.storage, id);
            if (tree) {
                const loadedSummary = await this.summarizerNode.loadBaseSummary(tree, localReadAndParse);
                tree = loadedSummary.baseSummary;
                // Prepend outstanding ops to pending queue of ops to process.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.pending = loadedSummary.outstandingOps.concat(this.pending);
            }
            if (!!tree && tree.blobs[summaryFormat_1.dataStoreAttributesBlobName] !== undefined) {
                // Need to get through snapshot and use that to populate extraBlobs
                const attributes = await localReadAndParse(tree.blobs[summaryFormat_1.dataStoreAttributesBlobName]);
                let pkgFromSnapshot;
                // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
                // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
                const formatVersion = (0, summaryFormat_1.getAttributesFormatVersion)(attributes);
                if (formatVersion < 1) {
                    if (attributes.pkg.startsWith("[\"") && attributes.pkg.endsWith("\"]")) {
                        pkgFromSnapshot = JSON.parse(attributes.pkg);
                    }
                    else {
                        pkgFromSnapshot = [attributes.pkg];
                    }
                }
                else {
                    pkgFromSnapshot = JSON.parse(attributes.pkg);
                }
                this.pkg = pkgFromSnapshot;
                /**
                 * If there is no isRootDataStore in the attributes blob, set it to true. This will ensure that
                 * data stores in older documents are not garbage collected incorrectly. This may lead to additional
                 * roots in the document but they won't break.
                 */
                isRootDataStore = (_b = attributes.isRootDataStore) !== null && _b !== void 0 ? _b : true;
                if ((0, summaryFormat_1.hasIsolatedChannels)(attributes)) {
                    tree = tree.trees[runtime_definitions_1.channelsTreeName];
                    (0, common_utils_1.assert)(tree !== undefined, 0x1fe /* "isolated channels subtree should exist in remote datastore snapshot" */);
                }
            }
            return {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                pkg: this.pkg,
                isRootDataStore,
                snapshot: tree,
            };
        });
        this.initSnapshotValue = props.snapshotTree;
        this.baseGCDetailsP = new common_utils_1.LazyPromise(async () => {
            var _a;
            return (_a = (await props.getBaseGCDetails())) !== null && _a !== void 0 ? _a : {};
        });
    }
    async getInitialSnapshotDetails() {
        return this.initialSnapshotDetailsP;
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    async getInitialGCSummaryDetails() {
        return this.getBaseGCDetails();
    }
    async getBaseGCDetails() {
        return this.baseGCDetailsP;
    }
    generateAttachMessage() {
        throw new Error("Cannot attach remote store");
    }
}
exports.RemoteFluidDataStoreContext = RemoteFluidDataStoreContext;
/**
 * Base class for detached & attached context classes
 */
class LocalFluidDataStoreContextBase extends FluidDataStoreContext {
    constructor(props) {
        super(props, props.snapshotTree !== undefined ? true : false /* existing */, props.snapshotTree ? container_definitions_1.BindState.Bound : container_definitions_1.BindState.NotBound, true /* isLocalDataStore */, props.makeLocallyVisibleFn);
        this.snapshotTree = props.snapshotTree;
        if (props.isRootDataStore === true) {
            this.setInMemoryRoot();
        }
        this.createProps = props.createProps;
        this.attachListeners();
    }
    attachListeners() {
        this.once("attaching", () => {
            (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Detached, 0x14d /* "Should move from detached to attaching" */);
            this._attachState = container_definitions_1.AttachState.Attaching;
        });
        this.once("attached", () => {
            (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Attaching, 0x14e /* "Should move from attaching to attached" */);
            this._attachState = container_definitions_1.AttachState.Attached;
        });
    }
    generateAttachMessage() {
        (0, common_utils_1.assert)(this.channel !== undefined, 0x14f /* "There should be a channel when generating attach message" */);
        (0, common_utils_1.assert)(this.pkg !== undefined, 0x150 /* "pkg should be available in local data store context" */);
        const summarizeResult = this.channel.getAttachSummary();
        if (!this.disableIsolatedChannels) {
            // Wrap dds summaries in .channels subtree.
            (0, summaryFormat_1.wrapSummaryInChannelsTree)(summarizeResult);
        }
        // Add data store's attributes to the summary.
        const attributes = createAttributes(this.pkg, this.isInMemoryRoot(), this.disableIsolatedChannels);
        (0, runtime_utils_1.addBlobToSummary)(summarizeResult, summaryFormat_1.dataStoreAttributesBlobName, JSON.stringify(attributes));
        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
        const snapshot = (0, runtime_utils_1.convertSummaryTreeToITree)(summarizeResult.summary);
        const message = {
            id: this.id,
            snapshot,
            type: this.pkg[this.pkg.length - 1],
        };
        return message;
    }
    async getInitialSnapshotDetails() {
        var _a;
        let snapshot = this.snapshotTree;
        let attributes;
        let isRootDataStore = false;
        if (snapshot !== undefined) {
            // Get the dataStore attributes.
            // Note: storage can be undefined in special case while detached.
            attributes = await (0, summaryFormat_1.getFluidDataStoreAttributes)(this.storage, snapshot);
            if ((0, summaryFormat_1.hasIsolatedChannels)(attributes)) {
                snapshot = snapshot.trees[runtime_definitions_1.channelsTreeName];
                (0, common_utils_1.assert)(snapshot !== undefined, 0x1ff /* "isolated channels subtree should exist in local datastore snapshot" */);
            }
            if (this.pkg === undefined) {
                this.pkg = JSON.parse(attributes.pkg);
                // If there is no isRootDataStore in the attributes blob, set it to true. This ensures that data
                // stores in older documents are not garbage collected incorrectly. This may lead to additional
                // roots in the document but they won't break.
                if ((_a = attributes.isRootDataStore) !== null && _a !== void 0 ? _a : true) {
                    isRootDataStore = true;
                    this.setInMemoryRoot();
                }
            }
        }
        (0, common_utils_1.assert)(this.pkg !== undefined, 0x152 /* "pkg should be available in local data store" */);
        return {
            pkg: this.pkg,
            isRootDataStore,
            snapshot,
        };
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    async getInitialGCSummaryDetails() {
        // Local data store does not have initial summary.
        return {};
    }
    async getBaseGCDetails() {
        // Local data store does not have initial summary.
        return {};
    }
}
exports.LocalFluidDataStoreContextBase = LocalFluidDataStoreContextBase;
/**
 * context implementation for "attached" data store runtime.
 * Various workflows (snapshot creation, requests) result in .realize() being called
 * on context, resulting in instantiation and attachment of runtime.
 * Runtime is created using data store factory that is associated with this context.
 */
class LocalFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(props) {
        super(props);
    }
}
exports.LocalFluidDataStoreContext = LocalFluidDataStoreContext;
/**
 * Detached context. Data Store runtime will be attached to it by attachRuntime() call
 * Before attachment happens, this context is not associated with particular type of runtime
 * or factory, i.e. it's package path is undefined.
 * Attachment process provides all missing parts - package path, data store runtime, and data store factory
 */
class LocalDetachedFluidDataStoreContext extends LocalFluidDataStoreContextBase {
    constructor(props) {
        super(props);
        this.detachedRuntimeCreation = true;
    }
    async attachRuntime(registry, dataStoreChannel) {
        (0, common_utils_1.assert)(this.detachedRuntimeCreation, 0x154 /* "runtime creation is already attached" */);
        (0, common_utils_1.assert)(this.channelDeferred === undefined, 0x155 /* "channel deferral is already set" */);
        const factory = registry.IFluidDataStoreFactory;
        const entry = await this.factoryFromPackagePath(this.pkg);
        (0, common_utils_1.assert)(entry.factory === factory, 0x156 /* "Unexpected factory for package path" */);
        (0, common_utils_1.assert)(this.registry === undefined, 0x157 /* "datastore registry already attached" */);
        this.registry = entry.registry;
        this.detachedRuntimeCreation = false;
        this.channelDeferred = new common_utils_1.Deferred();
        super.bindRuntime(dataStoreChannel);
        if (await this.isRoot()) {
            // back-compat 0.59.1000 - makeVisibleAndAttachGraph was added in this version to IFluidDataStoreChannel.
            // For older versions, we still have to call bindToContext.
            if (dataStoreChannel.makeVisibleAndAttachGraph !== undefined) {
                dataStoreChannel.makeVisibleAndAttachGraph();
            }
            else {
                dataStoreChannel.bindToContext();
            }
        }
    }
    async getInitialSnapshotDetails() {
        if (this.detachedRuntimeCreation) {
            throw new Error("Detached Fluid Data Store context can't be realized! Please attach runtime first!");
        }
        return super.getInitialSnapshotDetails();
    }
}
exports.LocalDetachedFluidDataStoreContext = LocalDetachedFluidDataStoreContext;

},{"./summaryFormat":82,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-base":166,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279}],63:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataStoreContexts = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
class DataStoreContexts {
    constructor(baseLogger) {
        this.notBoundContexts = new Set();
        /** Attached and loaded context proxies */
        this._contexts = new Map();
        /**
         * List of pending context waiting either to be bound or to arrive from another client.
         * This covers the case where a local context has been created but not yet bound,
         * or the case where a client knows a store will exist and is waiting on its creation,
         * so that a caller may await the deferred's promise until such a time as the context is fully ready.
         * This is a superset of _contexts, since contexts remain here once the Deferred resolves.
         */
        this.deferredContexts = new Map();
        this.disposeOnce = new common_utils_1.Lazy(() => {
            // close/stop all store contexts
            for (const [fluidDataStoreId, contextD] of this.deferredContexts) {
                contextD.promise.then((context) => {
                    context.dispose();
                }).catch((contextError) => {
                    this._logger.sendErrorEvent({
                        eventName: "FluidDataStoreContextDisposeError",
                        fluidDataStoreId,
                    }, contextError);
                });
            }
        });
        this.dispose = () => this.disposeOnce.value;
        this._logger = telemetry_utils_1.ChildLogger.create(baseLogger);
    }
    [Symbol.iterator]() {
        return this._contexts.entries();
    }
    get size() {
        return this._contexts.size;
    }
    get disposed() { return this.disposeOnce.evaluated; }
    notBoundLength() {
        return this.notBoundContexts.size;
    }
    isNotBound(id) {
        return this.notBoundContexts.has(id);
    }
    has(id) {
        return this._contexts.has(id);
    }
    get(id) {
        return this._contexts.get(id);
    }
    delete(id) {
        this.deferredContexts.delete(id);
        this.notBoundContexts.delete(id);
        return this._contexts.delete(id);
    }
    /**
     * Return the unbound local context with the given id,
     * or undefined if it's not found or not unbound.
     */
    getUnbound(id) {
        const context = this._contexts.get(id);
        if (context === undefined || !this.notBoundContexts.has(id)) {
            return undefined;
        }
        return this._contexts.get(id);
    }
    /**
     * Add the given context, marking it as to-be-bound
     */
    addUnbound(context) {
        const id = context.id;
        (0, common_utils_1.assert)(!this._contexts.has(id), 0x158 /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        this.notBoundContexts.add(id);
        this.ensureDeferred(id);
    }
    /**
     * Get the context with the given id, once it exists locally and is attached.
     * e.g. If created locally, it must be bound, or if created remotely then it's fine as soon as it's sync'd in.
     * @param id - The id of the context to get
     * @param wait - If false, return undefined if the context isn't present and ready now. Otherwise, wait for it.
     */
    async getBoundOrRemoted(id, wait) {
        const deferredContext = this.ensureDeferred(id);
        if (!wait && !deferredContext.isCompleted) {
            return undefined;
        }
        return deferredContext.promise;
    }
    ensureDeferred(id) {
        const deferred = this.deferredContexts.get(id);
        if (deferred) {
            return deferred;
        }
        const newDeferred = new common_utils_1.Deferred();
        this.deferredContexts.set(id, newDeferred);
        return newDeferred;
    }
    /**
     * Update this context as bound
     */
    bind(id) {
        const removed = this.notBoundContexts.delete(id);
        (0, common_utils_1.assert)(removed, 0x159 /* "The given id was not found in notBoundContexts to delete" */);
        this.resolveDeferred(id);
    }
    /**
     * Triggers the deferred to resolve, indicating the context is not local-only
     * @param id - The id of the context to resolve to
     */
    resolveDeferred(id) {
        const context = this._contexts.get(id);
        (0, common_utils_1.assert)(!!context, 0x15a /* "Cannot find context to resolve to" */);
        (0, common_utils_1.assert)(!this.notBoundContexts.has(id), 0x15b /* "Expected this id to already be removed from notBoundContexts" */);
        const deferred = this.deferredContexts.get(id);
        (0, common_utils_1.assert)(!!deferred, 0x15c /* "Cannot find deferred to resolve" */);
        deferred.resolve(context);
    }
    /**
     * Add the given context, marking it as not local-only.
     * This could be because it's a local context that's been bound, or because it's a remote context.
     * @param context - The context to add
     */
    addBoundOrRemoted(context) {
        const id = context.id;
        (0, common_utils_1.assert)(!this._contexts.has(id), 0x15d /* "Creating store with existing ID" */);
        this._contexts.set(id, context);
        // Resolve the deferred immediately since this context is not unbound
        this.ensureDeferred(id);
        this.resolveDeferred(id);
    }
}
exports.DataStoreContexts = DataStoreContexts;

},{"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluidDataStoreRegistry = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const container_utils_1 = require("@fluidframework/container-utils");
class FluidDataStoreRegistry {
    constructor(namedEntries) {
        this.map = new Map();
        for (const entry of namedEntries) {
            if (this.map.has(entry[0])) {
                throw new container_utils_1.UsageError("Duplicate entry names exist");
            }
            this.map.set(entry[0], entry[1]);
        }
    }
    get IFluidDataStoreRegistry() { return this; }
    async get(name) {
        if (this.map.has(name)) {
            return this.map.get(name);
        }
        return undefined;
    }
}
exports.FluidDataStoreRegistry = FluidDataStoreRegistry;

},{"@fluidframework/container-utils":87}],65:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSummaryForDatastores = exports.DataStores = void 0;
const container_utils_1 = require("@fluidframework/container-utils");
const datastore_1 = require("@fluidframework/datastore");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const common_utils_1 = require("@fluidframework/common-utils");
const uuid_1 = require("uuid");
const garbage_collector_1 = require("@fluidframework/garbage-collector");
const dataStoreContexts_1 = require("./dataStoreContexts");
const dataStoreContext_1 = require("./dataStoreContext");
const summaryFormat_1 = require("./summaryFormat");
const dataStore_1 = require("./dataStore");
const garbageCollection_1 = require("./garbageCollection");
/**
 * This class encapsulates data store handling. Currently it is only used by the container runtime,
 * but eventually could be hosted on any channel once we formalize the channel api boundary.
 */
class DataStores {
    constructor(baseSnapshot, runtime, submitAttachFn, getCreateChildSummarizerNodeFn, deleteChildSummarizerNodeFn, baseLogger, getBaseGCDetails, gcNodeUpdated, aliasMap, writeGCDataAtRoot, contexts = new dataStoreContexts_1.DataStoreContexts(baseLogger)) {
        this.baseSnapshot = baseSnapshot;
        this.runtime = runtime;
        this.submitAttachFn = submitAttachFn;
        this.getCreateChildSummarizerNodeFn = getCreateChildSummarizerNodeFn;
        this.deleteChildSummarizerNodeFn = deleteChildSummarizerNodeFn;
        this.gcNodeUpdated = gcNodeUpdated;
        this.aliasMap = aliasMap;
        this.writeGCDataAtRoot = writeGCDataAtRoot;
        this.contexts = contexts;
        // Stores tracked by the Domain
        this.pendingAttach = new Map();
        // 0.24 back-compat attachingBeforeSummary
        this.attachOpFiredForDataStore = new Set();
        this.disposeOnce = new common_utils_1.Lazy(() => this.contexts.dispose());
        // Stores the ids of new data stores between two GC runs. This is used to notify the garbage collector of new
        // root data stores that are added.
        this.dataStoresSinceLastGC = [];
        this.dispose = () => this.disposeOnce.value;
        this.logger = telemetry_utils_1.ChildLogger.create(baseLogger);
        this.containerRuntimeHandle = new datastore_1.FluidObjectHandle(this.runtime, "/", this.runtime.IFluidHandleContext);
        const baseGCDetailsP = new common_utils_1.LazyPromise(async () => {
            return getBaseGCDetails();
        });
        // Returns the base GC details for the data store with the given id.
        const dataStoreBaseGCDetails = async (dataStoreId) => {
            const baseGCDetails = await baseGCDetailsP;
            return baseGCDetails.get(dataStoreId);
        };
        // Extract stores stored inside the snapshot
        const fluidDataStores = new Map();
        if (baseSnapshot) {
            for (const [key, value] of Object.entries(baseSnapshot.trees)) {
                fluidDataStores.set(key, value);
            }
        }
        let unreferencedDataStoreCount = 0;
        // Create a context for each of them
        for (const [key, value] of fluidDataStores) {
            let dataStoreContext;
            // counting number of unreferenced data stores
            if (value.unreferenced) {
                unreferencedDataStoreCount++;
            }
            // If we have a detached container, then create local data store contexts.
            if (this.runtime.attachState !== container_definitions_1.AttachState.Detached) {
                dataStoreContext = new dataStoreContext_1.RemoteFluidDataStoreContext({
                    id: key,
                    snapshotTree: value,
                    getBaseGCDetails: async () => dataStoreBaseGCDetails(key),
                    runtime: this.runtime,
                    storage: this.runtime.storage,
                    scope: this.runtime.scope,
                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: runtime_definitions_1.CreateSummarizerNodeSource.FromSummary }),
                    writeGCDataAtRoot: this.writeGCDataAtRoot,
                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,
                });
            }
            else {
                if (typeof value !== "object") {
                    throw new telemetry_utils_1.LoggingError("Snapshot should be there to load from!!");
                }
                const snapshotTree = value;
                dataStoreContext = new dataStoreContext_1.LocalFluidDataStoreContext({
                    id: key,
                    pkg: undefined,
                    runtime: this.runtime,
                    storage: this.runtime.storage,
                    scope: this.runtime.scope,
                    createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(key, { type: runtime_definitions_1.CreateSummarizerNodeSource.FromSummary }),
                    makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(key),
                    snapshotTree,
                    isRootDataStore: undefined,
                    writeGCDataAtRoot: this.writeGCDataAtRoot,
                    disableIsolatedChannels: this.runtime.disableIsolatedChannels,
                });
            }
            this.contexts.addBoundOrRemoted(dataStoreContext);
        }
        this.containerLoadStats = {
            containerLoadDataStoreCount: fluidDataStores.size,
            referencedDataStoreCount: fluidDataStores.size - unreferencedDataStoreCount,
        };
    }
    aliases() {
        return this.aliasMap;
    }
    processAttachMessage(message, local) {
        var _a, _b;
        const attachMessage = message.contents;
        this.dataStoresSinceLastGC.push(attachMessage.id);
        // The local object has already been attached
        if (local) {
            (0, common_utils_1.assert)(this.pendingAttach.has(attachMessage.id), 0x15e /* "Local object does not have matching attach message id" */);
            (_a = this.contexts.get(attachMessage.id)) === null || _a === void 0 ? void 0 : _a.emit("attached");
            this.pendingAttach.delete(attachMessage.id);
            return;
        }
        // If a non-local operation then go and create the object, otherwise mark it as officially attached.
        if (this.alreadyProcessed(attachMessage.id)) {
            // TODO: dataStoreId may require a different tag from PackageData #7488
            const error = new container_utils_1.DataCorruptionError(
            // pre-0.58 error message: duplicateDataStoreCreatedWithExistingId
            "Duplicate DataStore created with existing id", Object.assign(Object.assign({}, (0, container_utils_1.extractSafePropertiesFromMessage)(message)), { dataStoreId: {
                    value: attachMessage.id,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                } }));
            throw error;
        }
        const flatBlobs = new Map();
        let snapshotTree;
        if (attachMessage.snapshot) {
            snapshotTree = (0, driver_utils_1.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
        }
        // Include the type of attach message which is the pkg of the store to be
        // used by RemoteFluidDataStoreContext in case it is not in the snapshot.
        const pkg = [attachMessage.type];
        const remoteFluidDataStoreContext = new dataStoreContext_1.RemoteFluidDataStoreContext({
            id: attachMessage.id,
            snapshotTree,
            // New data stores begin with empty GC details since GC hasn't run on them yet.
            getBaseGCDetails: async () => { return {}; },
            runtime: this.runtime,
            storage: new driver_utils_1.BlobCacheStorageService(this.runtime.storage, flatBlobs),
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(attachMessage.id, {
                type: runtime_definitions_1.CreateSummarizerNodeSource.FromAttach,
                sequenceNumber: message.sequenceNumber,
                snapshot: (_b = attachMessage.snapshot) !== null && _b !== void 0 ? _b : {
                    entries: [(0, dataStoreContext_1.createAttributesBlob)(pkg, true /* isRootDataStore */, this.runtime.disableIsolatedChannels)],
                },
            }),
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
            pkg,
        });
        this.contexts.addBoundOrRemoted(remoteFluidDataStoreContext);
    }
    processAliasMessage(message, localOpMetadata, local) {
        const aliasMessage = message.contents;
        if (!(0, dataStore_1.isDataStoreAliasMessage)(aliasMessage)) {
            throw new container_utils_1.DataCorruptionError("malformedDataStoreAliasMessage", Object.assign({}, (0, container_utils_1.extractSafePropertiesFromMessage)(message)));
        }
        const resolve = localOpMetadata;
        const aliasResult = this.processAliasMessageCore(aliasMessage);
        if (local) {
            resolve(aliasResult);
        }
    }
    processAliasMessageCore(aliasMessage) {
        if (this.alreadyProcessed(aliasMessage.alias)) {
            return false;
        }
        const context = this.contexts.get(aliasMessage.internalId);
        if (context === undefined) {
            this.logger.sendErrorEvent({
                eventName: "AliasFluidDataStoreNotFound",
                fluidDataStoreId: aliasMessage.internalId,
            });
            return false;
        }
        const handle = new datastore_1.FluidObjectHandle(context, aliasMessage.internalId, this.runtime.IFluidHandleContext);
        this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);
        this.aliasMap.set(aliasMessage.alias, context.id);
        context.setInMemoryRoot();
        return true;
    }
    alreadyProcessed(id) {
        return this.aliasMap.get(id) !== undefined || this.contexts.get(id) !== undefined;
    }
    /**
     * Make the data stores locally visible in the container graph by moving the data store context from unbound to
     * bound list. This data store can now be reached from the root.
     * @param id - The id of the data store context to make visible.
     */
    makeDataStoreLocallyVisible(id) {
        const localContext = this.contexts.getUnbound(id);
        (0, common_utils_1.assert)(!!localContext, 0x15f /* "Could not find unbound context to bind" */);
        /**
         * If the container is not detached, it is globally visible to all clients. This data store should also be
         * globally visible. Move it to attaching state and send an "attach" op for it.
         * If the container is detached, this data store will be part of the summary that makes the container attached.
         */
        if (this.runtime.attachState !== container_definitions_1.AttachState.Detached) {
            localContext.emit("attaching");
            const message = localContext.generateAttachMessage();
            this.pendingAttach.set(id, message);
            this.submitAttachFn(message);
            this.attachOpFiredForDataStore.add(id);
        }
        this.contexts.bind(id);
    }
    createDetachedDataStoreCore(pkg, isRoot, id = (0, uuid_1.v4)()) {
        (0, common_utils_1.assert)(!id.includes("/"), 0x30c /* Id cannot contain slashes */);
        const context = new dataStoreContext_1.LocalDetachedFluidDataStoreContext({
            id,
            pkg,
            runtime: this.runtime,
            storage: this.runtime.storage,
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: runtime_definitions_1.CreateSummarizerNodeSource.Local }),
            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),
            snapshotTree: undefined,
            isRootDataStore: isRoot,
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
        });
        this.contexts.addUnbound(context);
        return context;
    }
    _createFluidDataStoreContext(pkg, id, isRoot, props) {
        (0, common_utils_1.assert)(!id.includes("/"), 0x30d /* Id cannot contain slashes */);
        const context = new dataStoreContext_1.LocalFluidDataStoreContext({
            id,
            pkg,
            runtime: this.runtime,
            storage: this.runtime.storage,
            scope: this.runtime.scope,
            createSummarizerNodeFn: this.getCreateChildSummarizerNodeFn(id, { type: runtime_definitions_1.CreateSummarizerNodeSource.Local }),
            makeLocallyVisibleFn: () => this.makeDataStoreLocallyVisible(id),
            snapshotTree: undefined,
            isRootDataStore: isRoot,
            writeGCDataAtRoot: this.writeGCDataAtRoot,
            disableIsolatedChannels: this.runtime.disableIsolatedChannels,
            createProps: props,
        });
        this.contexts.addUnbound(context);
        return context;
    }
    get disposed() { return this.disposeOnce.evaluated; }
    resubmitDataStoreOp(content, localOpMetadata) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!context, 0x160 /* "There should be a store context for the op" */);
        context.reSubmit(envelope.contents, localOpMetadata);
    }
    rollbackDataStoreOp(content, localOpMetadata) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!context, 0x2e8 /* "There should be a store context for the op" */);
        context.rollback(envelope.contents, localOpMetadata);
    }
    async applyStashedOp(content) {
        const envelope = content;
        const context = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!context, 0x161 /* "There should be a store context for the op" */);
        return context.applyStashedOp(envelope.contents);
    }
    async applyStashedAttachOp(message) {
        this.pendingAttach.set(message.id, message);
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        this.processAttachMessage({ contents: message }, false);
    }
    processFluidDataStoreOp(message, local, localMessageMetadata) {
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const context = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!context, 0x162 /* "There should be a store context for the op" */);
        context.process(transformed, local, localMessageMetadata);
        // Notify that a GC node for the data store changed. This is used to detect if a deleted data store is
        // being used.
        this.gcNodeUpdated(`/${envelope.address}`, message.timestamp, context.isLoaded ? context.packagePath : undefined);
    }
    async getDataStore(id, wait) {
        const context = await this.contexts.getBoundOrRemoted(id, wait);
        if (context === undefined) {
            // The requested data store does not exits. Throw a 404 response exception.
            const request = { url: id };
            throw (0, runtime_utils_1.responseToException)((0, runtime_utils_1.create404Response)(request), request);
        }
        return context;
    }
    processSignal(address, message, local) {
        const context = this.contexts.get(address);
        if (!context) {
            // Attach message may not have been processed yet
            (0, common_utils_1.assert)(!local, 0x163 /* "Missing datastore for local signal" */);
            this.logger.sendTelemetryEvent({
                eventName: "SignalFluidDataStoreNotFound",
                fluidDataStoreId: {
                    value: address,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
            });
            return;
        }
        context.processSignal(message, local);
    }
    setConnectionState(connected, clientId) {
        for (const [fluidDataStore, context] of this.contexts) {
            try {
                context.setConnectionState(connected, clientId);
            }
            catch (error) {
                this.logger.sendErrorEvent({
                    eventName: "SetConnectionStateError",
                    clientId,
                    fluidDataStore,
                }, error);
            }
        }
    }
    setAttachState(attachState) {
        let eventName;
        if (attachState === container_definitions_1.AttachState.Attaching) {
            eventName = "attaching";
        }
        else {
            eventName = "attached";
        }
        for (const [, context] of this.contexts) {
            // Fire only for bounded stores.
            if (!this.contexts.isNotBound(context.id)) {
                context.emit(eventName);
            }
        }
    }
    get size() {
        return this.contexts.size;
    }
    async summarize(fullTree, trackState, telemetryContext) {
        const summaryBuilder = new runtime_utils_1.SummaryTreeBuilder();
        // Iterate over each store and ask it to snapshot
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Summarizer works only with clients with no local changes!
            (0, common_utils_1.assert)(context.attachState !== container_definitions_1.AttachState.Attaching, 0x165 /* "Summarizer cannot work if client has local changes" */);
            return context.attachState === container_definitions_1.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);
            summaryBuilder.addWithStats(contextId, contextSummary);
        }));
        return summaryBuilder.getSummaryTree();
    }
    createSummary(telemetryContext) {
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        // Attaching graph of some stores can cause other stores to get bound too.
        // So keep taking summary until no new stores get bound.
        let notBoundContextsLength;
        do {
            const builderTree = builder.summary.tree;
            notBoundContextsLength = this.contexts.notBoundLength();
            // Iterate over each data store and ask it to snapshot
            Array.from(this.contexts)
                .filter(([key, _]) => 
            // Take summary of bounded data stores only, make sure we haven't summarized them already
            // and no attach op has been fired for that data store because for loader versions <= 0.24
            // we set attach state as "attaching" before taking createNew summary.
            !(this.contexts.isNotBound(key)
                || builderTree[key]
                || this.attachOpFiredForDataStore.has(key)))
                .map(([key, value]) => {
                let dataStoreSummary;
                if (value.isLoaded) {
                    const snapshot = value.generateAttachMessage().snapshot;
                    dataStoreSummary = (0, runtime_utils_1.convertToSummaryTree)(snapshot, true);
                }
                else {
                    // If this data store is not yet loaded, then there should be no changes in the snapshot from
                    // which it was created as it is detached container. So just use the previous snapshot.
                    (0, common_utils_1.assert)(!!this.baseSnapshot, 0x166 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    dataStoreSummary = (0, runtime_utils_1.convertSnapshotTreeToSummaryTree)(this.baseSnapshot.trees[key]);
                }
                builder.addWithStats(key, dataStoreSummary);
            });
        } while (notBoundContextsLength !== this.contexts.notBoundLength());
        return builder.getSummaryTree();
    }
    /**
     * Before GC runs, called by the garbage collector to update any pending GC state.
     * The garbage collector needs to know all outbound references that are added. Since root data stores are not
     * explicitly marked as referenced, notify GC of new root data stores that were added since the last GC run.
     */
    async updateStateBeforeGC() {
        for (const id of this.dataStoresSinceLastGC) {
            const context = this.contexts.get(id);
            (0, common_utils_1.assert)(context !== undefined, 0x2b6 /* Missing data store context */);
            if (await context.isRoot()) {
                // A root data store is basically a reference from the container runtime to the data store.
                const handle = new datastore_1.FluidObjectHandle(context, id, this.runtime.IFluidHandleContext);
                this.runtime.addedGCOutboundReference(this.containerRuntimeHandle, handle);
            }
        }
        this.dataStoresSinceLastGC = [];
    }
    /**
     * Generates data used for garbage collection. It does the following:
     * 1. Calls into each child data store context to get its GC data.
     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    identified as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new garbage_collector_1.GCDataBuilder();
        // Iterate over each store and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([_, context]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return context.attachState === container_definitions_1.AttachState.Attached;
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", await this.getOutboundRoutes());
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this Container's data stores of routes that are used in it.
     * @param usedRoutes - The routes that are used in all data stores in this Container.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node node becomes
     * unreferenced as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        var _a;
        // Get a map of data store ids to routes used in it.
        const usedDataStoreRoutes = (0, garbage_collector_1.unpackChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedDataStoreRoutes) {
            (0, common_utils_1.assert)(this.contexts.has(id), 0x167 /* "Used route does not belong to any known data store" */);
        }
        // Update the used routes in each data store. Used routes is empty for unused data stores.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedDataStoreRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);
        }
    }
    /**
     * When running GC in test mode, this is called to delete objects whose routes are unused. This enables testing
     * scenarios with accessing deleted content.
     * @param unusedRoutes - The routes that are unused in all data stores in this Container.
     */
    deleteUnusedRoutes(unusedRoutes) {
        for (const route of unusedRoutes) {
            const pathParts = route.split("/");
            // Delete data store only if its route (/datastoreId) is in unusedRoutes. We don't want to delete a data
            // store based on its DDS being unused.
            if (pathParts.length > 2) {
                continue;
            }
            const dataStoreId = pathParts[1];
            (0, common_utils_1.assert)(this.contexts.has(dataStoreId), 0x2d7 /* No data store with specified id */);
            // Delete the contexts of unused data stores.
            this.contexts.delete(dataStoreId);
            // Delete the summarizer node of the unused data stores.
            this.deleteChildSummarizerNodeFn(dataStoreId);
        }
    }
    /**
     * Returns the outbound routes of this channel. Only root data stores are considered referenced and their paths are
     * part of outbound routes.
     */
    async getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId, context] of this.contexts) {
            const isRootDataStore = await context.isRoot();
            if (isRootDataStore) {
                outboundRoutes.push(`/${contextId}`);
            }
        }
        return outboundRoutes;
    }
    /**
     * Called by GC to retrieve the package path of a data store node with the given path.
     */
    async getDataStorePackagePath(nodePath) {
        var _a;
        // If the node belongs to a data store, return its package path. For DDSes, we return the package path of the
        // data store that contains it.
        const context = this.contexts.get(nodePath.split("/")[1]);
        return (_a = (await (context === null || context === void 0 ? void 0 : context.getInitialSnapshotDetails()))) === null || _a === void 0 ? void 0 : _a.pkg;
    }
    /**
     * Called by GC to determine if a node is for a data store or for an object within a data store (for e.g. DDS).
     * @returns the GC node type if the node belongs to a data store or object within data store, undefined otherwise.
     */
    getGCNodeType(nodePath) {
        const pathParts = nodePath.split("/");
        if (!this.contexts.has(pathParts[1])) {
            return undefined;
        }
        // Data stores paths are of the format "/dataStoreId".
        // Sub data store paths are of the format "/dataStoreId/subPath/...".
        if (pathParts.length === 2) {
            return garbageCollection_1.GCNodeType.DataStore;
        }
        return garbageCollection_1.GCNodeType.SubDataStore;
    }
}
exports.DataStores = DataStores;
function getSummaryForDatastores(snapshot, metadata) {
    if (!snapshot) {
        return undefined;
    }
    if ((0, summaryFormat_1.rootHasIsolatedChannels)(metadata)) {
        const datastoresSnapshot = snapshot.trees[runtime_definitions_1.channelsTreeName];
        (0, common_utils_1.assert)(!!datastoresSnapshot, 0x168 /* Expected tree in snapshot not found */);
        return datastoresSnapshot;
    }
    else {
        // back-compat: strip out all non-datastore paths before giving to DataStores object.
        const datastoresTrees = {};
        for (const [key, value] of Object.entries(snapshot.trees)) {
            if (!summaryFormat_1.nonDataStorePaths.includes(key)) {
                datastoresTrees[key] = value;
            }
        }
        return Object.assign(Object.assign({}, snapshot), { trees: datastoresTrees });
    }
}
exports.getSummaryForDatastores = getSummaryForDatastores;

},{"./dataStore":61,"./dataStoreContext":62,"./dataStoreContexts":63,"./garbageCollection":67,"./summaryFormat":82,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/datastore":93,"@fluidframework/driver-utils":110,"@fluidframework/garbage-collector":133,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279,"uuid":544}],66:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaScheduler = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/**
 * DeltaScheduler is responsible for the scheduling of inbound delta queue in cases where there
 * is more than one op a particular run of the queue. It does not schedule if there is just one
 * op or just one batch in the run. It does the following two things:
 * 1. If the ops have been processed for more than a specific amount of time, it pauses the queue
 *    and calls setTimeout to schedule a resume of the queue. This ensures that we don't block
 *    the JS thread for a long time processing ops synchronously (for example, when catching up
 *    ops right after boot or catching up ops / delayed realizing data stores by summarizer).
 * 2. If we scheduled a particular run of the queue, it logs telemetry for the number of ops
 *    processed, the time and number of turns it took to process the ops.
 */
class DeltaScheduler {
    constructor(deltaManager, logger) {
        this.logger = logger;
        // The increase in time for processing ops after each turn.
        this.processingTimeIncrement = 10;
        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;
        // This keeps track of the number of times inbound queue has been scheduled. After a particular
        // count, we log telemetry for the number of ops processed, the time and number of turns it took
        // to process the ops.
        this.schedulingCount = 0;
        this.deltaManager = deltaManager;
        this.deltaManager.inbound.on("idle", () => { this.inboundQueueIdle(); });
    }
    batchBegin(message) {
        if (!this.processingStartTime) {
            this.processingStartTime = common_utils_1.performance.now();
        }
        if (this.schedulingLog === undefined && this.schedulingCount % 500 === 0) {
            // Every 500th time we are scheduling the inbound queue, we log telemetry for the
            // number of ops processed, the time and number of turns it took to process the ops.
            this.schedulingLog = {
                opsRemainingToProcess: 0,
                numberOfTurns: 1,
                totalProcessingTime: 0,
                numberOfBatchesProcessed: 0,
                firstSequenceNumber: message.sequenceNumber,
                lastSequenceNumber: message.sequenceNumber,
                startTime: common_utils_1.performance.now(),
            };
        }
    }
    batchEnd(message) {
        if (this.schedulingLog) {
            this.schedulingLog.numberOfBatchesProcessed++;
            this.schedulingLog.lastSequenceNumber = message.sequenceNumber;
            this.schedulingLog.opsRemainingToProcess = this.deltaManager.inbound.length;
        }
        if (this.shouldRunScheduler()) {
            const currentTime = common_utils_1.performance.now();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const elapsedTime = currentTime - this.processingStartTime;
            if (elapsedTime > this.currentAllowedProcessingTimeForTurn) {
                // We have processed ops for more than the total processing time. So, pause the
                // queue, yield the thread and schedule a resume.
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.deltaManager.inbound.pause();
                // Increase the total processing time. Keep doing this after each turn until all the ops have
                // been processed. This way we keep the responsiveness at the beginning while also making sure
                // that all the ops process fairly quickly.
                this.currentAllowedProcessingTimeForTurn += this.processingTimeIncrement;
                // If we are logging the telemetry this time, update the telemetry log object.
                if (this.schedulingLog) {
                    this.schedulingLog.numberOfTurns++;
                    this.schedulingLog.totalProcessingTime += elapsedTime;
                }
                setTimeout(() => {
                    if (this.schedulingLog) {
                        this.logger.sendTelemetryEvent({
                            eventName: "InboundOpsPartialProcessingTime",
                            duration: telemetry_utils_1.TelemetryLogger.formatTick(elapsedTime),
                            opsProcessed: this.schedulingLog.lastSequenceNumber -
                                this.schedulingLog.firstSequenceNumber + 1,
                            opsRemainingToProcess: this.deltaManager.inbound.length,
                            processingTime: telemetry_utils_1.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),
                            numberOfTurns: this.schedulingLog.numberOfTurns,
                            batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,
                            timeToResume: telemetry_utils_1.TelemetryLogger.formatTick(common_utils_1.performance.now() - currentTime),
                        });
                    }
                    this.deltaManager.inbound.resume();
                });
                this.processingStartTime = undefined;
            }
        }
    }
    inboundQueueIdle() {
        if (this.schedulingLog) {
            // Add the time taken for processing the final ops to the total processing time in the
            // telemetry log object.
            const currentTime = common_utils_1.performance.now();
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.schedulingLog.totalProcessingTime += currentTime - this.processingStartTime;
            this.logger.sendTelemetryEvent({
                eventName: "InboundOpsProcessingTime",
                opsRemainingToProcess: this.schedulingLog.opsRemainingToProcess,
                numberOfTurns: this.schedulingLog.numberOfTurns,
                processingTime: telemetry_utils_1.TelemetryLogger.formatTick(this.schedulingLog.totalProcessingTime),
                opsProcessed: this.schedulingLog.lastSequenceNumber - this.schedulingLog.firstSequenceNumber + 1,
                batchesProcessed: this.schedulingLog.numberOfBatchesProcessed,
                duration: telemetry_utils_1.TelemetryLogger.formatTick(currentTime - this.schedulingLog.startTime),
                schedulingCount: this.schedulingCount,
            });
            this.schedulingLog = undefined;
        }
        // If we scheduled this batch of the inbound queue, increment the counter that tracks the
        // number of times we have done this.
        this.schedulingCount++;
        // Reset the processing times.
        this.processingStartTime = undefined;
        this.currentAllowedProcessingTimeForTurn = DeltaScheduler.processingTime;
    }
    /**
     * This function tells whether we should run the scheduler.
     */
    shouldRunScheduler() {
        // If there are still ops in the queue after the one we are processing now, we should
        // run the scheduler.
        return this.deltaManager.inbound.length > 0;
    }
}
exports.DeltaScheduler = DeltaScheduler;
// The time for processing ops in a single turn.
DeltaScheduler.processingTime = 50;

},{"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],67:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GarbageCollector = exports.GCNodeType = exports.defaultSessionExpiryDurationMs = exports.oneDayMs = exports.trackGCStateKey = exports.disableSessionExpiryKey = exports.runSessionExpiryKey = exports.gcBlobPrefix = exports.gcTreeKey = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const garbage_collector_1 = require("@fluidframework/garbage-collector");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const containerRuntime_1 = require("./containerRuntime");
const dataStores_1 = require("./dataStores");
const summaryFormat_1 = require("./summaryFormat");
/** This is the current version of garbage collection. */
const GCVersion = 1;
// The key for the GC tree in summary.
exports.gcTreeKey = "gc";
// They prefix for GC blobs in the GC tree in summary.
exports.gcBlobPrefix = "__gc";
// Feature gate key to turn GC on / off.
const runGCKey = "Fluid.GarbageCollection.RunGC";
// Feature gate key to turn GC sweep on / off.
const runSweepKey = "Fluid.GarbageCollection.RunSweep";
// Feature gate key to turn GC test mode on / off.
const gcTestModeKey = "Fluid.GarbageCollection.GCTestMode";
// Feature gate key to write GC data at the root of the summary tree.
const writeAtRootKey = "Fluid.GarbageCollection.WriteDataAtRoot";
// Feature gate key to expire a session after a set period of time.
exports.runSessionExpiryKey = "Fluid.GarbageCollection.RunSessionExpiry";
// Feature gate key to disable expiring session after a set period of time, even if expiry value is present
exports.disableSessionExpiryKey = "Fluid.GarbageCollection.DisableSessionExpiry";
// Feature gate key to write the gc blob as a handle if the data is the same.
exports.trackGCStateKey = "Fluid.GarbageCollection.TrackGCState";
// Feature gate key to turn GC sweep log off.
const disableSweepLogKey = "Fluid.GarbageCollection.DisableSweepLog";
// One day in milliseconds.
exports.oneDayMs = 1 * 24 * 60 * 60 * 1000;
const defaultInactiveTimeoutMs = 7 * exports.oneDayMs; // 7 days
exports.defaultSessionExpiryDurationMs = 30 * exports.oneDayMs; // 30 days
/** The types of GC nodes in the GC reference graph. */
exports.GCNodeType = {
    // Nodes that are for data stores.
    DataStore: "DataStore",
    // Nodes that are within a data store. For example, DDS nodes.
    SubDataStore: "SubDataStore",
    // Nodes that are for attachment blobs, i.e., blobs uploaded via BlobManager.
    Blob: "Blob",
    // Nodes that are neither of the above. For example, root node.
    Other: "Other",
};
/** The state of node that is unreferenced. */
const UnreferencedState = {
    /** The node is active, i.e., it can become referenced again. */
    Active: "Active",
    /** The node is inactive, i.e., it should not become referenced. */
    Inactive: "Inactive",
    /** The node is ready to be deleted by the sweep phase. */
    SweepReady: "SweepReady",
};
/**
 * Helper class that tracks the state of an unreferenced node such as the time it was unreferenced and if it can
 * be deleted by the sweep phase.
 */
class UnreferencedStateTracker {
    constructor(unreferencedTimestampMs, 
    /** The time after which node transitions to Inactive state. */
    inactiveTimeoutMs, 
    /** The time after which node transitions to SweepReady state; undefined if session expiry is disabled. */
    sweepTimeoutMs, 
    /** The current reference timestamp; undefined if no ops have ever been processed which can happen in tests. */
    currentReferenceTimestampMs) {
        this.unreferencedTimestampMs = unreferencedTimestampMs;
        this.inactiveTimeoutMs = inactiveTimeoutMs;
        this.sweepTimeoutMs = sweepTimeoutMs;
        this._state = UnreferencedState.Active;
        // If there is no current reference timestamp, don't track the node's unreferenced state. This will happen
        // later when updateTracking is called with a reference timestamp.
        if (currentReferenceTimestampMs !== undefined) {
            this.updateTracking(currentReferenceTimestampMs);
        }
    }
    get state() {
        return this._state;
    }
    /* Updates the unreferenced state based on the provided timestamp. */
    updateTracking(currentReferenceTimestampMs) {
        const unreferencedDurationMs = currentReferenceTimestampMs - this.unreferencedTimestampMs;
        // If the node has been unreferenced for sweep timeout amount of time, update the state to SweepReady.
        if (this.sweepTimeoutMs !== undefined && unreferencedDurationMs >= this.sweepTimeoutMs) {
            this._state = UnreferencedState.SweepReady;
            this.clearTimers();
            return;
        }
        // If the node has been unreferenced for inactive timeoutMs amount of time, update the state to inactive.
        // Also, start a timer for the sweep timeout.
        if (unreferencedDurationMs >= this.inactiveTimeoutMs) {
            this._state = UnreferencedState.Inactive;
            this.clearTimers();
            if (this.sweepTimeoutMs !== undefined) {
                setLongTimeout(this.sweepTimeoutMs - unreferencedDurationMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });
            }
            return;
        }
        // The node is still active. Start the inactive timer for the remaining duration.
        const remainingDurationMs = this.inactiveTimeoutMs - unreferencedDurationMs;
        if (this.inactiveTimer === undefined) {
            const inactiveTimeoutHandler = () => {
                this._state = UnreferencedState.Inactive;
                // After the node becomes inactive, start the sweep timer after which the node will be ready for sweep.
                if (this.sweepTimeoutMs !== undefined) {
                    setLongTimeout(this.sweepTimeoutMs - this.inactiveTimeoutMs, () => { this._state = UnreferencedState.SweepReady; }, (timer) => { this.sweepTimer = timer; });
                }
            };
            this.inactiveTimer = new common_utils_1.Timer(remainingDurationMs, () => inactiveTimeoutHandler());
        }
        this.inactiveTimer.restart(remainingDurationMs);
    }
    clearTimers() {
        var _a;
        (_a = this.inactiveTimer) === null || _a === void 0 ? void 0 : _a.clear();
        if (this.sweepTimer !== undefined) {
            clearTimeout(this.sweepTimer);
        }
    }
    /** Stop tracking this node. Reset the unreferenced timers and state, if any. */
    stopTracking() {
        this.clearTimers();
        this._state = UnreferencedState.Active;
    }
}
/**
 * The garbage collector for the container runtime. It consolidates the garbage collection functionality and maintains
 * its state across summaries.
 *
 * Node - represented as nodeId, it's a node on the GC graph
 * Outbound Route - a path from one node to another node, think `nodeA` -\> `nodeB`
 * Graph - all nodes with their respective routes
 *             GC Graph
 *
 *               Node
 *        NodeId = "datastore1"
 *           /             \\
 *    OutboundRoute   OutboundRoute
 *         /                 \\
 *       Node               Node
 *  NodeId = "dds1"     NodeId = "dds2"
 */
class GarbageCollector {
    constructor(createParams) {
        var _a, _b, _c, _d, _e, _f, _g;
        /**
         * Tells whether the GC data should be written to the root of the summary tree.
         */
        this._writeDataAtRoot = true;
        /**
         * Tells whether the initial GC state needs to be reset. This can happen under 2 conditions:
         * 1. The base snapshot contains GC state but GC is disabled. This will happen the first time GC is disabled after
         *    it was enabled before. GC state needs to be removed from summary and all nodes should be marked referenced.
         * 2. The base snapshot does not have GC state but GC is enabled. This will happen the very first time GC runs on
         *    a document and the first time GC is enabled after is was disabled before.
         *
         * Note that the state needs reset only for the very first time summary is generated by this client. After that, the
         * state will be up-to-date and this flag will be reset.
        */
        this.initialStateNeedsReset = false;
        // The current GC version that this container is running.
        this.currentGCVersion = GCVersion;
        // Keeps a list of references (edges in the GC graph) between GC runs. Each entry has a node id and a list of
        // outbound routes from that node.
        this.newReferencesSinceLastRun = new Map();
        // Map of node ids to their unreferenced state tracker.
        this.unreferencedNodesState = new Map();
        // Keeps track of unreferenced events that are logged for a node. This is used to limit the log generation to one
        // per event per node.
        this.loggedUnreferencedEvents = new Set();
        // Queue for unreferenced events that should be logged the next time GC runs.
        this.pendingEventsQueue = [];
        // The number of times GC has successfully completed on this instance of GarbageCollector.
        this.completedRuns = 0;
        this.runtime = createParams.runtime;
        this.isSummarizerClient = createParams.isSummarizerClient;
        this.gcOptions = createParams.gcOptions;
        this.getNodePackagePath = createParams.getNodePackagePath;
        this.getLastSummaryTimestampMs = createParams.getLastSummaryTimestampMs;
        const baseSnapshot = createParams.baseSnapshot;
        const metadata = createParams.metadata;
        const readAndParseBlob = createParams.readAndParseBlob;
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(telemetry_utils_1.ChildLogger.create(createParams.baseLogger, "GarbageCollector", { all: { completedGCRuns: () => this.completedRuns } }));
        let prevSummaryGCVersion;
        /**
         * The following GC state is enabled during container creation and cannot be changed throughout its lifetime:
         * 1. Whether running GC mark phase is allowed or not.
         * 2. Whether running GC sweep phase is allowed or not.
         * 3. Whether GC session expiry is enabled or not.
         * For existing containers, we get this information from the metadata blob of its summary.
         */
        if (createParams.existing) {
            prevSummaryGCVersion = (0, summaryFormat_1.getGCVersion)(metadata);
            // Existing documents which did not have metadata blob or had GC disabled have version as 0. For all
            // other existing documents, GC is enabled.
            this.gcEnabled = prevSummaryGCVersion > 0;
            this.sweepEnabled = (_a = metadata === null || metadata === void 0 ? void 0 : metadata.sweepEnabled) !== null && _a !== void 0 ? _a : false;
            this.sessionExpiryTimeoutMs = metadata === null || metadata === void 0 ? void 0 : metadata.sessionExpiryTimeoutMs;
        }
        else {
            // Sweep should not be enabled without enabling GC mark phase. We could silently disable sweep in this
            // scenario but explicitly failing makes it clearer and promotes correct usage.
            if (this.gcOptions.sweepAllowed && this.gcOptions.gcAllowed === false) {
                throw new container_utils_1.UsageError("GC sweep phase cannot be enabled without enabling GC mark phase");
            }
            // For new documents, GC is enabled by default. It can be explicitly disabled by setting the gcAllowed
            // flag in GC options to false.
            this.gcEnabled = this.gcOptions.gcAllowed !== false;
            // The sweep phase has to be explicitly enabled by setting the sweepAllowed flag in GC options to true.
            this.sweepEnabled = this.gcOptions.sweepAllowed === true;
            // Set the Session Expiry only if the flag is enabled or the test option is set.
            if (this.mc.config.getBoolean(exports.runSessionExpiryKey) && this.gcEnabled) {
                this.sessionExpiryTimeoutMs = exports.defaultSessionExpiryDurationMs;
            }
        }
        // If session expiry is enabled, we need to close the container when the session expiry timeout expires.
        if (this.sessionExpiryTimeoutMs !== undefined && this.mc.config.getBoolean(exports.disableSessionExpiryKey) !== true) {
            // If Test Override config is set, override Session Expiry timeout.
            const overrideSessionExpiryTimeoutMs = this.mc.config.getNumber("Fluid.GarbageCollection.TestOverride.SessionExpiryMs");
            const timeoutMs = overrideSessionExpiryTimeoutMs !== null && overrideSessionExpiryTimeoutMs !== void 0 ? overrideSessionExpiryTimeoutMs : this.sessionExpiryTimeoutMs;
            setLongTimeout(timeoutMs, () => { this.runtime.closeFn(new container_utils_1.ClientSessionExpiredError(`Client session expired.`, timeoutMs)); }, (timer) => { this.sessionExpiryTimer = timer; });
            /**
             * Sweep timeout is the time after which unreferenced content can be swept.
             * Sweep timeout = session expiry timeout + snapshot cache expiry timeout + one day buffer. The buffer is
             * added to account for any clock skew. We use server timestamps throughout so the skew should be minimal
             * but make it one day to be safe.
             */
            if (createParams.snapshotCacheExpiryMs !== undefined) {
                this.sweepTimeoutMs = this.sessionExpiryTimeoutMs + createParams.snapshotCacheExpiryMs + exports.oneDayMs;
            }
        }
        // For existing document, the latest summary is the one that we loaded from. So, use its GC version as the
        // latest tracked GC version. For new documents, we will be writing the first summary with the current version.
        this.latestSummaryGCVersion = prevSummaryGCVersion !== null && prevSummaryGCVersion !== void 0 ? prevSummaryGCVersion : this.currentGCVersion;
        /**
         * Whether GC should run or not. The following conditions have to be met to run sweep:
         * 1. GC should be enabled for this container.
         * 2. GC should not be disabled via disableGC GC option.
         * These conditions can be overridden via runGCKey feature flag.
         */
        this.shouldRunGC = (_b = this.mc.config.getBoolean(runGCKey)) !== null && _b !== void 0 ? _b : (
        // GC must be enabled for the document.
        this.gcEnabled
            // GC must not be disabled via GC options.
            && !this.gcOptions.disableGC);
        /**
         * Whether sweep should run or not. The following conditions have to be met to run sweep:
         * 1. Overall GC or mark phase must be enabled (this.shouldRunGC).
         * 2. Sweep timeout should be available. Without this, we wouldn't know when an object should be deleted.
         * 3. Sweep should be enabled for this container (this.sweepEnabled). This can be overridden via runSweep
         *    feature flag.
         */
        this.shouldRunSweep = this.shouldRunGC
            && this.sweepTimeoutMs !== undefined
            && ((_c = this.mc.config.getBoolean(runSweepKey)) !== null && _c !== void 0 ? _c : this.sweepEnabled);
        this.trackGCState = this.mc.config.getBoolean(exports.trackGCStateKey) === true;
        // Override inactive timeout if test config or gc options to override it is set.
        this.inactiveTimeoutMs = (_e = (_d = this.mc.config.getNumber("Fluid.GarbageCollection.TestOverride.InactiveTimeoutMs")) !== null && _d !== void 0 ? _d : this.gcOptions.inactiveTimeoutMs) !== null && _e !== void 0 ? _e : defaultInactiveTimeoutMs;
        // Inactive timeout must be greater than sweep timeout since a node goes from active -> inactive -> sweep ready.
        if (this.sweepTimeoutMs !== undefined && this.inactiveTimeoutMs > this.sweepTimeoutMs) {
            throw new container_utils_1.UsageError("inactive timeout should not be greated than the sweep timeout");
        }
        // Whether we are running in test mode. In this mode, unreferenced nodes are immediately deleted.
        this.testMode = (_f = this.mc.config.getBoolean(gcTestModeKey)) !== null && _f !== void 0 ? _f : this.gcOptions.runGCInTestMode === true;
        // GC state is written into root of the summary tree by default. Can be overridden via feature flag for now.
        this._writeDataAtRoot = (_g = this.mc.config.getBoolean(writeAtRootKey)) !== null && _g !== void 0 ? _g : true;
        if (this._writeDataAtRoot) {
            // The GC state needs to be reset if the base snapshot contains GC tree and GC is disabled or it doesn't
            // contain GC tree and GC is enabled.
            const gcTreePresent = (baseSnapshot === null || baseSnapshot === void 0 ? void 0 : baseSnapshot.trees[exports.gcTreeKey]) !== undefined;
            this.initialStateNeedsReset = gcTreePresent !== this.shouldRunGC;
        }
        // Get the GC state from the GC blob in the base snapshot. Use LazyPromise because we only want to do
        // this once since it involves fetching blobs from storage which is expensive.
        const baseSummaryStateP = new common_utils_1.LazyPromise(async () => {
            var _a;
            if (baseSnapshot === undefined) {
                return undefined;
            }
            // For newer documents, GC data should be present in the GC tree in the root of the snapshot.
            const gcSnapshotTree = baseSnapshot.trees[exports.gcTreeKey];
            if (gcSnapshotTree !== undefined) {
                // If the GC tree is written at root, we should also do the same.
                this._writeDataAtRoot = true;
                const baseGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);
                if (this.trackGCState) {
                    this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(baseGCState));
                }
                return baseGCState;
            }
            // back-compat - Older documents will have the GC blobs in each data store's summary tree. Get them and
            // consolidate into IGarbageCollectionState format.
            // Add a node for the root node that is not present in older snapshot format.
            const gcState = { gcNodes: { "/": { outboundRoutes: [] } } };
            const dataStoreSnapshotTree = (0, dataStores_1.getSummaryForDatastores)(baseSnapshot, metadata);
            (0, common_utils_1.assert)(dataStoreSnapshotTree !== undefined, 0x2a8 /* "Expected data store snapshot tree in base snapshot" */);
            for (const [dsId, dsSnapshotTree] of Object.entries(dataStoreSnapshotTree.trees)) {
                const blobId = dsSnapshotTree.blobs[runtime_definitions_1.gcBlobKey];
                if (blobId === undefined) {
                    continue;
                }
                const gcSummaryDetails = await readAndParseBlob(blobId);
                // If there are no nodes for this data store, skip it.
                if (((_a = gcSummaryDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) === undefined) {
                    continue;
                }
                const dsRootId = `/${dsId}`;
                // Since we used to write GC data at data store level, we won't have an entry for the root ("/").
                // Construct that entry by adding root data store ids to its outbound routes.
                const initialSnapshotDetails = await readAndParseBlob(dsSnapshotTree.blobs[summaryFormat_1.dataStoreAttributesBlobName]);
                if (initialSnapshotDetails.isRootDataStore) {
                    gcState.gcNodes["/"].outboundRoutes.push(dsRootId);
                }
                for (const [id, outboundRoutes] of Object.entries(gcSummaryDetails.gcData.gcNodes)) {
                    // Prefix the data store id to the GC node ids to make them relative to the root from being
                    // relative to the data store. Similar to how its done in DataStore::getGCData.
                    const rootId = id === "/" ? dsRootId : `${dsRootId}${id}`;
                    gcState.gcNodes[rootId] = { outboundRoutes: Array.from(outboundRoutes) };
                }
                (0, common_utils_1.assert)(gcState.gcNodes[dsRootId] !== undefined, 0x2a9 /* GC nodes for data store not in GC blob */);
                gcState.gcNodes[dsRootId].unreferencedTimestampMs = gcSummaryDetails.unrefTimestamp;
            }
            // If there is only one node (root node just added above), either GC is disabled or we are loading from the
            // very first summary generated by detached container. In both cases, GC was not run - return undefined.
            return Object.keys(gcState.gcNodes).length === 1 ? undefined : gcState;
        });
        /**
         * Set up the initializer which initializes the base GC state from the base snapshot. Note that the reference
         * timestamp maybe from old ops which were not summarized and stored in the file. So, the unreferenced state
         * may be out of date. This is fine because the state is updated every time GC runs based on the time then.
         */
        this.initializeBaseStateP = new common_utils_1.LazyPromise(async () => {
            const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();
            const baseState = await baseSummaryStateP;
            if (baseState === undefined) {
                return;
            }
            const gcNodes = {};
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                if (nodeData.unreferencedTimestampMs !== undefined) {
                    this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(nodeData.unreferencedTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));
                }
                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);
            }
            this.previousGCDataFromLastRun = { gcNodes };
        });
        // Get the GC details for each node from the GC state in the base summary. This is returned in getBaseGCDetails
        // which the caller uses to initialize each node's GC state.
        this.baseGCDetailsP = new common_utils_1.LazyPromise(async () => {
            const baseState = await baseSummaryStateP;
            if (baseState === undefined) {
                return new Map();
            }
            const gcNodes = {};
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                gcNodes[nodeId] = Array.from(nodeData.outboundRoutes);
            }
            // Run GC on the nodes in the base summary to get the routes used in each node in the container.
            // This is an optimization for space (vs performance) wherein we don't need to store the used routes of
            // each node in the summary.
            const usedRoutes = (0, garbage_collector_1.runGarbageCollection)(gcNodes, ["/"]).referencedNodeIds;
            const baseGCDetailsMap = (0, garbage_collector_1.unpackChildNodesGCDetails)({ gcData: { gcNodes }, usedRoutes });
            // Currently, the nodes may write the GC data. So, we need to update it's base GC details with the
            // unreferenced timestamp. Once we start writing the GC data here, we won't need to do this anymore.
            for (const [nodeId, nodeData] of Object.entries(baseState.gcNodes)) {
                if (nodeData.unreferencedTimestampMs !== undefined) {
                    const dataStoreGCDetails = baseGCDetailsMap.get(nodeId.slice(1));
                    if (dataStoreGCDetails !== undefined) {
                        dataStoreGCDetails.unrefTimestamp = nodeData.unreferencedTimestampMs;
                    }
                }
            }
            return baseGCDetailsMap;
        });
        // Log all the GC options and the state determined by the garbage collector. This is interesting only for the
        // summarizer client since it is the only one that runs GC. It also helps keep the telemetry less noisy.
        const gcConfigProps = JSON.stringify(Object.assign({ gcEnabled: this.gcEnabled, sweepEnabled: this.sweepEnabled, runGC: this.shouldRunGC, runSweep: this.shouldRunSweep, writeAtRoot: this._writeDataAtRoot, testMode: this.testMode, sessionExpiry: this.sessionExpiryTimeoutMs, inactiveTimeout: this.inactiveTimeoutMs, existing: createParams.existing, trackGCState: this.trackGCState }, this.gcOptions));
        if (this.isSummarizerClient) {
            this.mc.logger.sendTelemetryEvent({
                eventName: "GarbageCollectorLoaded",
                gcConfigs: gcConfigProps,
            });
        }
        // Initialize the base state that is used to detect when inactive objects are used.
        if (this.shouldRunGC) {
            this.initializeBaseStateP.catch((error) => {
                const dpe = container_utils_1.DataProcessingError.wrapIfUnrecognized(error, "FailedToInitializeGC");
                dpe.addTelemetryProperties({ gcConfigs: gcConfigProps });
                throw dpe;
            });
        }
    }
    static create(createParams) {
        return new GarbageCollector(createParams);
    }
    /**
     * Tells whether the GC state needs to be reset in the next summary. We need to do this if:
     * 1. GC was enabled and is now disabled. The GC state needs to be removed and everything becomes referenced.
     * 2. GC was disabled and is now enabled. The GC state needs to be regenerated and added to summary.
     * 3. The GC version in the latest summary is different from the current GC version. This can happen if:
     *    3.1. The summary this client loaded with has data from a different GC version.
     *    3.2. This client's latest summary was updated from a snapshot that has a different GC version.
     */
    get summaryStateNeedsReset() {
        return this.initialStateNeedsReset ||
            (this.shouldRunGC && this.latestSummaryGCVersion !== this.currentGCVersion);
    }
    get writeDataAtRoot() {
        return this._writeDataAtRoot;
    }
    /**
     * Runs garbage collection and updates the reference / used state of the nodes in the container.
     * @returns the number of data stores that have been marked as unreferenced.
     */
    async collectGarbage(options) {
        const { fullGC = this.gcOptions.runFullGC === true || this.summaryStateNeedsReset, } = options;
        const logger = options.logger
            ? telemetry_utils_1.ChildLogger.create(options.logger, undefined, { all: { completedGCRuns: () => this.completedRuns } })
            : this.mc.logger;
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(logger, { eventName: "GarbageCollection" }, async (event) => {
            await this.runPreGCSteps();
            // Get the runtime's GC data and run GC on the reference graph in it.
            const gcData = await this.runtime.getGCData(fullGC);
            const gcResult = (0, garbage_collector_1.runGarbageCollection)(gcData.gcNodes, ["/"]);
            const gcStats = await this.runPostGCSteps(gcData, gcResult, logger);
            event.end(Object.assign({}, gcStats));
            this.completedRuns++;
            return gcStats;
        }, { end: true, cancel: "error" });
    }
    async runPreGCSteps() {
        // Ensure that base state has been initialized.
        await this.initializeBaseStateP;
        // Let the runtime update its pending state before GC runs.
        await this.runtime.updateStateBeforeGC();
    }
    async runPostGCSteps(gcData, gcResult, logger) {
        // Generate statistics from the current run. This is done before updating the current state because it
        // generates some of its data based on previous state of the system.
        const gcStats = this.generateStats(gcResult);
        // Update the state since the last GC run. There can be nodes that were referenced between the last and
        // the current run. We need to identify than and update their unreferenced state if needed.
        this.updateStateSinceLastRun(gcData, logger);
        // Update the current state and update the runtime of all routes or ids that used as per the GC run.
        const currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs();
        this.updateCurrentState(gcData, gcResult, currentReferenceTimestampMs);
        this.runtime.updateUsedRoutes(gcResult.referencedNodeIds, currentReferenceTimestampMs);
        // Log events for objects that are ready to be deleted by sweep. When we have sweep enabled, we will
        // delete these objects here instead.
        this.logSweepEvents(logger, currentReferenceTimestampMs);
        // If we are running in GC test mode, delete objects for unused routes. This enables testing scenarios
        // involving access to deleted data.
        if (this.testMode) {
            this.runtime.deleteUnusedRoutes(gcResult.deletedNodeIds);
        }
        // Log pending unreferenced events such as a node being used after inactive. This is done after GC runs and
        // updates its state so that we don't send false positives based on intermediate state. For example, we may get
        // reference to an unreferenced node from another unreferenced node which means the node wasn't revived.
        await this.logUnreferencedEvents(logger);
        return gcStats;
    }
    /**
     * Summarizes the GC data and returns it as a summary tree.
     * We current write the entire GC state in a single blob. This can be modified later to write multiple
     * blobs. All the blob keys should start with `gcBlobPrefix`.
     */
    summarize(fullTree, trackState, telemetryContext) {
        var _a;
        if (!this.shouldRunGC || this.previousGCDataFromLastRun === undefined) {
            return;
        }
        const gcState = { gcNodes: {} };
        for (const [nodeId, outboundRoutes] of Object.entries(this.previousGCDataFromLastRun.gcNodes)) {
            gcState.gcNodes[nodeId] = {
                outboundRoutes,
                unreferencedTimestampMs: (_a = this.unreferencedNodesState.get(nodeId)) === null || _a === void 0 ? void 0 : _a.unreferencedTimestampMs,
            };
        }
        const newSerializedSummaryState = JSON.stringify(generateSortedGCState(gcState));
        /**
         * As an optimization if the GC tree hasn't changed and we're tracking the gc state, return a tree handle
         * instead of returning the whole GC tree. If there are changes, then we want to return the whole tree.
         */
        if (this.trackGCState) {
            this.pendingSerializedSummaryState = newSerializedSummaryState;
            if (this.latestSerializedSummaryState !== undefined &&
                this.latestSerializedSummaryState === newSerializedSummaryState &&
                !fullTree &&
                trackState) {
                const stats = (0, runtime_utils_1.mergeStats)();
                stats.handleNodeCount++;
                return {
                    summary: {
                        type: protocol_definitions_1.SummaryType.Handle,
                        handle: `/${exports.gcTreeKey}`,
                        handleType: protocol_definitions_1.SummaryType.Tree,
                    },
                    stats,
                };
            }
        }
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        builder.addBlob(`${exports.gcBlobPrefix}_root`, newSerializedSummaryState);
        return builder.getSummaryTree();
    }
    getMetadata() {
        return {
            /**
             * If GC is enabled, the GC data is written using the current GC version and that is the gcFeature that goes
             * into the metadata blob. If GC is disabled, the gcFeature is 0.
             */
            gcFeature: this.gcEnabled ? this.currentGCVersion : 0,
            sessionExpiryTimeoutMs: this.sessionExpiryTimeoutMs,
            sweepEnabled: this.sweepEnabled,
        };
    }
    /**
     * Returns a map of node ids to their base GC details generated from the base summary. This is used by the caller
     * to initialize the GC state of the nodes.
     */
    async getBaseGCDetails() {
        return this.baseGCDetailsP;
    }
    /**
     * Called when the latest summary of the system has been refreshed. This will be used to update the state of the
     * latest summary tracked.
     */
    async latestSummaryStateRefreshed(result, readAndParseBlob) {
        if (!this.shouldRunGC || !result.latestSummaryUpdated) {
            return;
        }
        // If the summary was tracked by this client, it was the one that generated the summary in the first place.
        // Basically, it was written in the current GC version.
        if (result.wasSummaryTracked) {
            this.latestSummaryGCVersion = this.currentGCVersion;
            this.initialStateNeedsReset = false;
            if (this.trackGCState) {
                this.latestSerializedSummaryState = this.pendingSerializedSummaryState;
                this.pendingSerializedSummaryState = undefined;
            }
            return;
        }
        // If the summary was not tracked by this client, update latest GC version and blob from the snapshot in the
        // result as that is now the latest summary.
        const snapshot = result.snapshot;
        const metadataBlobId = snapshot.blobs[summaryFormat_1.metadataBlobName];
        if (metadataBlobId) {
            const metadata = await readAndParseBlob(metadataBlobId);
            this.latestSummaryGCVersion = (0, summaryFormat_1.getGCVersion)(metadata);
        }
        const gcSnapshotTree = snapshot.trees[exports.gcTreeKey];
        if (gcSnapshotTree !== undefined && this.trackGCState) {
            const latestGCState = await getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob);
            this.latestSerializedSummaryState = JSON.stringify(generateSortedGCState(latestGCState));
        }
        else {
            this.latestSerializedSummaryState = undefined;
        }
        this.pendingSerializedSummaryState = undefined;
    }
    /**
     * Called when a node with the given id is updated. If the node is inactive, log an error.
     * @param nodePath - The id of the node that changed.
     * @param reason - Whether the node was loaded or changed.
     * @param timestampMs - The timestamp when the node changed.
     * @param packagePath - The package path of the node. This may not be available if the node hasn't been loaded yet.
     * @param requestHeaders - If the node was loaded via request path, the headers in the request.
     */
    nodeUpdated(nodePath, reason, timestampMs, packagePath, requestHeaders) {
        if (!this.shouldRunGC) {
            return;
        }
        const nodeStateTracker = this.unreferencedNodesState.get(nodePath);
        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {
            this.inactiveNodeUsed(reason, nodePath, nodeStateTracker, undefined /* fromNodeId */, packagePath, timestampMs, requestHeaders);
        }
    }
    /**
     * Called when an outbound reference is added to a node. This is used to identify all nodes that have been
     * referenced between summaries so that their unreferenced timestamp can be reset.
     *
     * @param fromNodePath - The node from which the reference is added.
     * @param toNodePath - The node to which the reference is added.
     */
    addedOutboundReference(fromNodePath, toNodePath) {
        var _a;
        if (!this.shouldRunGC) {
            return;
        }
        const outboundRoutes = (_a = this.newReferencesSinceLastRun.get(fromNodePath)) !== null && _a !== void 0 ? _a : [];
        outboundRoutes.push(toNodePath);
        this.newReferencesSinceLastRun.set(fromNodePath, outboundRoutes);
        const nodeStateTracker = this.unreferencedNodesState.get(toNodePath);
        if (nodeStateTracker && nodeStateTracker.state !== UnreferencedState.Active) {
            this.inactiveNodeUsed("Revived", toNodePath, nodeStateTracker, fromNodePath);
        }
    }
    dispose() {
        if (this.sessionExpiryTimer !== undefined) {
            clearTimeout(this.sessionExpiryTimer);
            this.sessionExpiryTimer = undefined;
        }
    }
    /**
     * Updates the state of the system as per the current GC run. It does the following:
     * 1. Sets up the current GC state as per the gcData.
     * 2. Starts tracking for nodes that have become unreferenced in this run.
     * 3. Clears tracking for nodes that were unreferenced but became referenced in this run.
     * @param gcData - The data representing the reference graph on which GC is run.
     * @param gcResult - The result of the GC run on the gcData.
     * @param currentReferenceTimestampMs - The timestamp to be used for unreferenced nodes' timestamp.
     */
    updateCurrentState(gcData, gcResult, currentReferenceTimestampMs) {
        this.previousGCDataFromLastRun = (0, garbage_collector_1.cloneGCData)(gcData);
        this.newReferencesSinceLastRun.clear();
        // Iterate through the referenced nodes and stop tracking if they were unreferenced before.
        for (const nodeId of gcResult.referencedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker !== undefined) {
                // Stop tracking so as to clear out any running timers.
                nodeStateTracker.stopTracking();
                // Delete the node as we don't need to track it any more.
                this.unreferencedNodesState.delete(nodeId);
            }
        }
        /**
         * If there is no current reference time, skip tracking when a node becomes unreferenced. This would happen
         * if no ops have been processed ever and we still try to run GC. If so, there is nothing interesting to track
         * anyway.
         */
        if (currentReferenceTimestampMs === undefined) {
            return;
        }
        /**
         * If a node became unreferenced in this run, start tracking it.
         * If a node was already unreferenced, update its tracking information. Since the current reference time is
         * from the ops seen, this will ensure that we keep updating the unreferenced state as time moves forward.
         */
        for (const nodeId of gcResult.deletedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker === undefined) {
                this.unreferencedNodesState.set(nodeId, new UnreferencedStateTracker(currentReferenceTimestampMs, this.inactiveTimeoutMs, this.sweepTimeoutMs, currentReferenceTimestampMs));
            }
            else {
                nodeStateTracker.updateTracking(currentReferenceTimestampMs);
            }
        }
    }
    /**
     * Since GC runs periodically, the GC data that is generated only tells us the state of the world at that point in
     * time. It's possible that nodes transition from `unreferenced -> referenced -> unreferenced` between two runs. The
     * unreferenced timestamp of such nodes needs to be reset as they may have been accessed when they were referenced.
     *
     * This function identifies nodes that were referenced since last run and removes their unreferenced state, if any.
     * If these nodes are currently unreferenced, they will be assigned new unreferenced state by the current run.
     */
    updateStateSinceLastRun(currentGCData, logger) {
        // If we haven't run GC before there is nothing to do.
        if (this.previousGCDataFromLastRun === undefined) {
            return;
        }
        // Find any references that haven't been identified correctly.
        const missingExplicitReferences = this.findMissingExplicitReferences(currentGCData, this.previousGCDataFromLastRun, this.newReferencesSinceLastRun);
        if (this.writeDataAtRoot && missingExplicitReferences.length > 0) {
            missingExplicitReferences.forEach((missingExplicitReference) => {
                const event = {
                    eventName: "gcUnknownOutboundReferences",
                    gcNodeId: missingExplicitReference[0],
                    gcRoutes: JSON.stringify(missingExplicitReference[1]),
                };
                logger.sendPerformanceEvent(event);
            });
        }
        // No references were added since the last run so we don't have to update reference states of any unreferenced
        // nodes
        if (this.newReferencesSinceLastRun.size === 0) {
            return;
        }
        /**
         * Generate a super set of the GC data that contains the nodes and edges from last run, plus any new node and
         * edges that have been added since then. To do this, combine the GC data from the last run and the current
         * run, and then add the references since last run.
         *
         * Note on why we need to combine the data from previous run, current run and all references in between -
         * 1. We need data from last run because some of its references may have been deleted since then. If those
         *    references added new outbound references before getting deleted, we need to detect them.
         * 2. We need new outbound references since last run because some of them may have been deleted later. If those
         *    references added new outbound references before getting deleted, we need to detect them.
         * 3. We need data from the current run because currently we may not detect when DDSes are referenced:
         *    - We don't require DDSes handles to be stored in a referenced DDS. For this, we need GC at DDS level
         *      which is tracked by https://github.com/microsoft/FluidFramework/issues/8470.
         *    - A new data store may have "root" DDSes already created and we don't detect them today.
         */
        const gcDataSuperSet = (0, garbage_collector_1.concatGarbageCollectionData)(this.previousGCDataFromLastRun, currentGCData);
        this.newReferencesSinceLastRun.forEach((outboundRoutes, sourceNodeId) => {
            if (gcDataSuperSet.gcNodes[sourceNodeId] === undefined) {
                gcDataSuperSet.gcNodes[sourceNodeId] = outboundRoutes;
            }
            else {
                gcDataSuperSet.gcNodes[sourceNodeId].push(...outboundRoutes);
            }
        });
        /**
         * Run GC on the above reference graph to find all nodes that are referenced. For each one, if they are
         * unreferenced, stop tracking them and remove from unreferenced list.
         * Some of these nodes may be unreferenced now and if so, the current run will add unreferenced state for them.
         */
        const gcResult = (0, garbage_collector_1.runGarbageCollection)(gcDataSuperSet.gcNodes, ["/"]);
        for (const nodeId of gcResult.referencedNodeIds) {
            const nodeStateTracker = this.unreferencedNodesState.get(nodeId);
            if (nodeStateTracker !== undefined) {
                // Stop tracking so as to clear out any running timers.
                nodeStateTracker.stopTracking();
                // Delete the node as we don't need to track it any more.
                this.unreferencedNodesState.delete(nodeId);
            }
        }
    }
    /**
     * Finds all new references or outbound routes in the current graph that haven't been explicitly notified to GC.
     * The principle is that every new reference or outbound route must be notified to GC via the
     * addedOutboundReference method. It it hasn't, its a bug and we want to identify these scenarios.
     *
     * In more simple terms:
     * Missing Explicit References = Current References - Previous References - Explicitly Added References;
     *
     * @param currentGCData - The GC data (reference graph) from the current GC run.
     * @param previousGCData - The GC data (reference graph) from the previous GC run.
     * @param explicitReferences - New references added explicity between the previous and the current run.
     * @returns - a list of missing explicit references
     */
    findMissingExplicitReferences(currentGCData, previousGCData, explicitReferences) {
        (0, common_utils_1.assert)(previousGCData !== undefined, 0x2b7);
        const currentGraph = Object.entries(currentGCData.gcNodes);
        const missingExplicitReferences = [];
        currentGraph.forEach(([nodeId, currentOutboundRoutes]) => {
            var _a, _b;
            const previousRoutes = (_a = previousGCData.gcNodes[nodeId]) !== null && _a !== void 0 ? _a : [];
            const explicitRoutes = (_b = explicitReferences.get(nodeId)) !== null && _b !== void 0 ? _b : [];
            const missingExplicitRoutes = [];
            currentOutboundRoutes.forEach((route) => {
                const isBlobOrDataStoreRoute = this.runtime.getNodeType(route) === exports.GCNodeType.Blob ||
                    this.runtime.getNodeType(route) === exports.GCNodeType.DataStore;
                // Ignore implicitly added DDS routes to their parent datastores
                const notRouteFromDDSToParentDataStore = !nodeId.startsWith(route);
                if (isBlobOrDataStoreRoute &&
                    notRouteFromDDSToParentDataStore &&
                    (!previousRoutes.includes(route) && !explicitRoutes.includes(route))) {
                    missingExplicitRoutes.push(route);
                }
            });
            if (missingExplicitRoutes.length > 0) {
                missingExplicitReferences.push([nodeId, missingExplicitRoutes]);
            }
        });
        // Ideally missingExplicitReferences should always have a size 0
        return missingExplicitReferences;
    }
    /**
     * Generates the stats of a garbage collection run from the given results of the run.
     * @param gcResult - The result of a GC run.
     * @returns the GC stats of the GC run.
     */
    generateStats(gcResult) {
        const gcStats = {
            nodeCount: 0,
            dataStoreCount: 0,
            attachmentBlobCount: 0,
            unrefNodeCount: 0,
            unrefDataStoreCount: 0,
            unrefAttachmentBlobCount: 0,
            updatedNodeCount: 0,
            updatedDataStoreCount: 0,
            updatedAttachmentBlobCount: 0,
        };
        const updateNodeStats = (nodeId, referenced) => {
            gcStats.nodeCount++;
            // If there is no previous GC data, every node's state is generated and is considered as updated.
            // Otherwise, find out if any node went from referenced to unreferenced or vice-versa.
            const stateUpdated = this.previousGCDataFromLastRun === undefined ||
                this.unreferencedNodesState.has(nodeId) === referenced;
            if (stateUpdated) {
                gcStats.updatedNodeCount++;
            }
            if (!referenced) {
                gcStats.unrefNodeCount++;
            }
            if (this.runtime.getNodeType(nodeId) === exports.GCNodeType.DataStore) {
                gcStats.dataStoreCount++;
                if (stateUpdated) {
                    gcStats.updatedDataStoreCount++;
                }
                if (!referenced) {
                    gcStats.unrefDataStoreCount++;
                }
            }
            if (this.runtime.getNodeType(nodeId) === exports.GCNodeType.Blob) {
                gcStats.attachmentBlobCount++;
                if (stateUpdated) {
                    gcStats.updatedAttachmentBlobCount++;
                }
                if (!referenced) {
                    gcStats.unrefAttachmentBlobCount++;
                }
            }
        };
        for (const nodeId of gcResult.referencedNodeIds) {
            updateNodeStats(nodeId, true /* referenced */);
        }
        for (const nodeId of gcResult.deletedNodeIds) {
            updateNodeStats(nodeId, false /* referenced */);
        }
        return gcStats;
    }
    /**
     * For nodes that are ready to sweep, log an event for now. Until we start running sweep which deletes objects,
     * this will give us a view into how much deleted content a container has.
     */
    logSweepEvents(logger, currentReferenceTimestampMs) {
        if (this.mc.config.getBoolean(disableSweepLogKey) === true
            || currentReferenceTimestampMs === undefined
            || this.sweepTimeoutMs === undefined) {
            return;
        }
        this.unreferencedNodesState.forEach((nodeStateTracker, nodeId) => {
            if (nodeStateTracker.state !== UnreferencedState.SweepReady) {
                return;
            }
            const nodeType = this.runtime.getNodeType(nodeId);
            if (nodeType !== exports.GCNodeType.DataStore && nodeType !== exports.GCNodeType.Blob) {
                return;
            }
            // Log deleted event for each node only once to reduce noise in telemetry.
            const uniqueEventId = `Deleted-${nodeId}`;
            if (this.loggedUnreferencedEvents.has(uniqueEventId)) {
                return;
            }
            this.loggedUnreferencedEvents.add(uniqueEventId);
            logger.sendTelemetryEvent({
                eventName: "GCObjectDeleted",
                id: nodeId,
                type: nodeType,
                age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,
                timeout: this.sweepTimeoutMs,
                completedGCRuns: this.completedRuns,
                lastSummaryTime: this.getLastSummaryTimestampMs(),
            });
        });
    }
    /**
     * Called when an inactive node is used after. Queue up an event that will be logged next time GC runs.
     */
    inactiveNodeUsed(usageType, nodeId, nodeStateTracker, fromNodeId, packagePath, currentReferenceTimestampMs = this.runtime.getCurrentReferenceTimestampMs(), requestHeaders) {
        // If there is no reference timestamp to work with, no ops have been processed after creation. If so, skip
        // logging as nothing interesting would have happened worth logging.
        // If the node is active, skip logging.
        if (currentReferenceTimestampMs === undefined || nodeStateTracker.state === UnreferencedState.Active) {
            return;
        }
        // For non-summarizer clients, only log "Loaded" type events since these objects may not be loaded in the
        // summarizer clients if they are based off of user actions (such as scrolling to content for these objects).
        if (!this.isSummarizerClient && usageType !== "Loaded") {
            return;
        }
        // We only care about data stores and attachment blobs for this telemetry since GC only marks these objects
        // as unreferenced. Also, if an inactive DDS is used, the corresponding data store store will also be used.
        const nodeType = this.runtime.getNodeType(nodeId);
        if (nodeType !== exports.GCNodeType.DataStore && nodeType !== exports.GCNodeType.Blob) {
            return;
        }
        const state = nodeStateTracker.state;
        const uniqueEventId = `${state}-${nodeId}-${usageType}`;
        if (this.loggedUnreferencedEvents.has(uniqueEventId)) {
            return;
        }
        this.loggedUnreferencedEvents.add(uniqueEventId);
        const propsToLog = {
            id: nodeId,
            type: nodeType,
            unrefTime: nodeStateTracker.unreferencedTimestampMs,
            age: currentReferenceTimestampMs - nodeStateTracker.unreferencedTimestampMs,
            timeout: nodeStateTracker.state === UnreferencedState.Inactive
                ? this.inactiveTimeoutMs
                : this.sweepTimeoutMs,
            completedGCRuns: this.completedRuns,
            lastSummaryTime: this.getLastSummaryTimestampMs(),
            externalRequest: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[containerRuntime_1.RuntimeHeaders.externalRequest],
            viaHandle: requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders[containerRuntime_1.RuntimeHeaders.viaHandle],
            fromId: fromNodeId,
        };
        // For summarizer client, queue the event so it is logged the next time GC runs if the event is still valid.
        // For non-summarizer client, log the event now since GC won't run on it. This may result in false positives
        // but it's a good signal nonetheless and we can consume it with a grain of salt.
        if (this.isSummarizerClient) {
            this.pendingEventsQueue.push(Object.assign(Object.assign({}, propsToLog), { usageType, state }));
        }
        else {
            this.mc.logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: packagePath ? { value: packagePath.join("/"), tag: telemetry_utils_1.TelemetryDataTag.CodeArtifact } : undefined }));
        }
    }
    async logUnreferencedEvents(logger) {
        for (const eventProps of this.pendingEventsQueue) {
            const { usageType, state } = eventProps, propsToLog = __rest(eventProps, ["usageType", "state"]);
            /**
             * Revived event is logged only if the node is active. If the node is not active, the reference to it was
             * from another unreferenced node and this scenario is not interesting to log.
             * Loaded and Changed events are logged only if the node is not active. If the node is active, it was
             * revived and a Revived event will be logged for it.
             */
            const nodeStateTracker = this.unreferencedNodesState.get(eventProps.id);
            const active = nodeStateTracker === undefined || nodeStateTracker.state === UnreferencedState.Active;
            if ((usageType === "Revived") === active) {
                const pkg = await this.getNodePackagePath(eventProps.id);
                const fromPkg = eventProps.fromId ? await this.getNodePackagePath(eventProps.fromId) : undefined;
                logger.sendErrorEvent(Object.assign(Object.assign({}, propsToLog), { eventName: `${state}Object_${usageType}`, pkg: pkg ? { value: pkg.join("/"), tag: telemetry_utils_1.TelemetryDataTag.CodeArtifact } : undefined, fromPkg: fromPkg ? { value: fromPkg.join("/"), tag: telemetry_utils_1.TelemetryDataTag.CodeArtifact } : undefined }));
            }
        }
        this.pendingEventsQueue = [];
    }
}
exports.GarbageCollector = GarbageCollector;
/**
 * Gets the garbage collection state from the given snapshot tree. The GC state may be written into multiple blobs.
 * Merge the GC state from all such blobs and return the merged GC state.
 */
async function getGCStateFromSnapshot(gcSnapshotTree, readAndParseBlob) {
    let rootGCState = { gcNodes: {} };
    for (const key of Object.keys(gcSnapshotTree.blobs)) {
        // Skip blobs that do not start with the GC prefix.
        if (!key.startsWith(exports.gcBlobPrefix)) {
            continue;
        }
        const blobId = gcSnapshotTree.blobs[key];
        if (blobId === undefined) {
            continue;
        }
        const gcState = await readAndParseBlob(blobId);
        (0, common_utils_1.assert)(gcState !== undefined, 0x2ad /* "GC blob missing from snapshot" */);
        // Merge the GC state of this blob into the root GC state.
        rootGCState = (0, garbage_collector_1.concatGarbageCollectionStates)(rootGCState, gcState);
    }
    return rootGCState;
}
function generateSortedGCState(gcState) {
    const sortableArray = Object.entries(gcState.gcNodes);
    sortableArray.sort(([a], [b]) => a.localeCompare(b));
    const sortedGCState = { gcNodes: {} };
    for (const [nodeId, nodeData] of sortableArray) {
        nodeData.outboundRoutes.sort();
        sortedGCState.gcNodes[nodeId] = nodeData;
    }
    return sortedGCState;
}
/**
 * setLongTimeout is used for timeouts longer than setTimeout's ~24.8 day max
 * @param timeoutMs - the total time the timeout needs to last in ms
 * @param timeoutFn - the function to execute when the timer ends
 * @param setTimerFn - the function used to update your timer variable
 */
function setLongTimeout(timeoutMs, timeoutFn, setTimerFn) {
    // The setTimeout max is 24.8 days before looping occurs.
    const maxTimeout = 2147483647;
    let timer;
    if (timeoutMs > maxTimeout) {
        const newTimeoutMs = timeoutMs - maxTimeout;
        timer = setTimeout(() => setLongTimeout(newTimeoutMs, timeoutFn, setTimerFn), maxTimeout);
    }
    else {
        timer = setTimeout(() => timeoutFn(), timeoutMs);
    }
    setTimerFn(timer);
}

},{"./containerRuntime":60,"./dataStores":65,"./summaryFormat":82,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/garbage-collector":133,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279}],68:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.neverCancelledSummaryToken = exports.SummaryCollection = exports.ISummarizer = exports.Summarizer = exports.gcTreeKey = exports.gcBlobPrefix = exports.FluidDataStoreRegistry = exports.DeltaScheduler = exports.DefaultSummaryConfiguration = exports.RuntimeHeaders = exports.ContainerRuntime = exports.agentSchedulerId = exports.ScheduleManager = exports.unpackRuntimeMessage = exports.RuntimeMessage = exports.isRuntimeMessage = exports.ContainerMessageType = void 0;
var containerRuntime_1 = require("./containerRuntime");
Object.defineProperty(exports, "ContainerMessageType", { enumerable: true, get: function () { return containerRuntime_1.ContainerMessageType; } });
Object.defineProperty(exports, "isRuntimeMessage", { enumerable: true, get: function () { return containerRuntime_1.isRuntimeMessage; } });
Object.defineProperty(exports, "RuntimeMessage", { enumerable: true, get: function () { return containerRuntime_1.RuntimeMessage; } });
Object.defineProperty(exports, "unpackRuntimeMessage", { enumerable: true, get: function () { return containerRuntime_1.unpackRuntimeMessage; } });
Object.defineProperty(exports, "ScheduleManager", { enumerable: true, get: function () { return containerRuntime_1.ScheduleManager; } });
Object.defineProperty(exports, "agentSchedulerId", { enumerable: true, get: function () { return containerRuntime_1.agentSchedulerId; } });
Object.defineProperty(exports, "ContainerRuntime", { enumerable: true, get: function () { return containerRuntime_1.ContainerRuntime; } });
Object.defineProperty(exports, "RuntimeHeaders", { enumerable: true, get: function () { return containerRuntime_1.RuntimeHeaders; } });
Object.defineProperty(exports, "DefaultSummaryConfiguration", { enumerable: true, get: function () { return containerRuntime_1.DefaultSummaryConfiguration; } });
var deltaScheduler_1 = require("./deltaScheduler");
Object.defineProperty(exports, "DeltaScheduler", { enumerable: true, get: function () { return deltaScheduler_1.DeltaScheduler; } });
var dataStoreRegistry_1 = require("./dataStoreRegistry");
Object.defineProperty(exports, "FluidDataStoreRegistry", { enumerable: true, get: function () { return dataStoreRegistry_1.FluidDataStoreRegistry; } });
var garbageCollection_1 = require("./garbageCollection");
Object.defineProperty(exports, "gcBlobPrefix", { enumerable: true, get: function () { return garbageCollection_1.gcBlobPrefix; } });
Object.defineProperty(exports, "gcTreeKey", { enumerable: true, get: function () { return garbageCollection_1.gcTreeKey; } });
var summarizer_1 = require("./summarizer");
Object.defineProperty(exports, "Summarizer", { enumerable: true, get: function () { return summarizer_1.Summarizer; } });
var summarizerTypes_1 = require("./summarizerTypes");
Object.defineProperty(exports, "ISummarizer", { enumerable: true, get: function () { return summarizerTypes_1.ISummarizer; } });
var summaryCollection_1 = require("./summaryCollection");
Object.defineProperty(exports, "SummaryCollection", { enumerable: true, get: function () { return summaryCollection_1.SummaryCollection; } });
var runWhileConnectedCoordinator_1 = require("./runWhileConnectedCoordinator");
Object.defineProperty(exports, "neverCancelledSummaryToken", { enumerable: true, get: function () { return runWhileConnectedCoordinator_1.neverCancelledSummaryToken; } });

},{"./containerRuntime":60,"./dataStoreRegistry":64,"./deltaScheduler":66,"./garbageCollection":67,"./runWhileConnectedCoordinator":73,"./summarizer":76,"./summarizerTypes":80,"./summaryCollection":81}],69:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpTracker = void 0;
const driver_utils_1 = require("@fluidframework/driver-utils");
class OpTracker {
    constructor(deltaManager, disabled) {
        /**
         * Used for storing the message content size when
         * the message is pushed onto the inbound queue.
         */
        this.messageSize = new Map();
        this._nonSystemOpCount = 0;
        this._opsSizeAccumulator = 0;
        if (disabled) {
            return;
        }
        // Record the message content size when we receive it.
        // We should not log this value, as summarization can happen between the time the message
        // is received and until it is processed (the 'op' event).
        deltaManager.inbound.on("push", (message) => {
            var _a;
            // Some messages my already have string contents at this point,
            // so stringifying them again will add inaccurate overhead.
            const messageContent = typeof message.contents === "string" ?
                message.contents :
                (_a = JSON.stringify(message.contents)) !== null && _a !== void 0 ? _a : "";
            const messageData = OpTracker.messageHasData(message) ? message.data : "";
            this.messageSize[OpTracker.messageId(message)] = messageContent.length + messageData.length;
        });
        deltaManager.on("op", (message) => {
            var _a;
            this._nonSystemOpCount += !(0, driver_utils_1.isRuntimeMessage)(message) ? 0 : 1;
            const id = OpTracker.messageId(message);
            this._opsSizeAccumulator += (_a = this.messageSize[id]) !== null && _a !== void 0 ? _a : 0;
            this.messageSize.delete(id);
        });
    }
    get nonSystemOpCount() {
        return this._nonSystemOpCount;
    }
    get opsSizeAccumulator() {
        return this._opsSizeAccumulator;
    }
    static messageId(message) {
        return message.sequenceNumber;
    }
    static messageHasData(message) {
        return message.data !== undefined;
    }
    reset() {
        this._nonSystemOpCount = 0;
        this._opsSizeAccumulator = 0;
    }
}
exports.OpTracker = OpTracker;

},{"@fluidframework/driver-utils":110}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderedClientElection = exports.OrderedClientCollection = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const summarizerClientElection_1 = require("./summarizerClientElection");
/**
 * Tracks clients in the Quorum. It maintains their order using their join op
 * sequence numbers.
 * Internally, the collection of clients is maintained in a doubly-linked list,
 * with pointers to both the first and last nodes.
 * The first (root) node is a placeholder to simplify logic and reduce null checking.
 */
class OrderedClientCollection extends common_utils_1.TypedEventEmitter {
    constructor(logger, deltaManager, quorum) {
        super();
        /** Collection of ALL clients currently in the quorum, with client ids as keys. */
        this.clientMap = new Map();
        /** Placeholder head node of linked list, for simplified null checking. */
        this.rootNode = {
            sequenceNumber: -1,
            olderClient: undefined,
            youngerClient: undefined,
        };
        /** Pointer to end of linked list, for optimized client adds. */
        this._youngestClient = this.rootNode;
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "OrderedClientCollection");
        const members = quorum.getMembers();
        for (const [clientId, client] of members) {
            this.addClient(clientId, client);
        }
        quorum.on("addMember", (clientId, client) => {
            const newClient = this.addClient(clientId, client);
            this.emit("addClient", newClient, deltaManager.lastSequenceNumber);
        });
        quorum.on("removeMember", (clientId) => {
            const sequenceNumber = deltaManager.lastSequenceNumber;
            const removeClient = this.removeClient(clientId);
            if (removeClient === undefined) {
                this.logger.sendErrorEvent({ eventName: "ClientNotFound", clientId, sequenceNumber });
            }
            else {
                this.emit("removeClient", removeClient, sequenceNumber);
            }
        });
    }
    get count() {
        return this.clientMap.size;
    }
    get oldestClient() {
        return this.rootNode.youngerClient;
    }
    addClient(clientId, client) {
        // Normal case is adding the latest client, which will bypass loop.
        // Find where it belongs otherwise (maybe possible during initial load?).
        (0, common_utils_1.assert)(client.sequenceNumber > -1, 0x1f6 /* "Negative client sequence number not allowed" */);
        let currClient = this._youngestClient;
        while (currClient.sequenceNumber > client.sequenceNumber) {
            (0, common_utils_1.assert)(currClient.olderClient !== undefined, 0x1f7 /* "Previous client should always be defined" */);
            // Note: If adding a client older than the elected client, it will not be automatically elected.
            currClient = currClient.olderClient;
        }
        // Now currClient is the node right before where the new client node should be.
        const newClient = {
            clientId,
            sequenceNumber: client.sequenceNumber,
            client: Object.assign({}, client.client),
            olderClient: currClient,
            youngerClient: currClient.youngerClient,
        };
        // Update prev node to point to this new node.
        newClient.olderClient.youngerClient = newClient;
        if (newClient.youngerClient === undefined) {
            // Update linked list end pointer to youngest client.
            this._youngestClient = newClient;
        }
        else {
            // Update next node to point back to this new node.
            newClient.youngerClient.olderClient = newClient;
        }
        this.clientMap.set(clientId, newClient);
        return newClient;
    }
    removeClient(clientId) {
        const removeClient = this.clientMap.get(clientId);
        if (removeClient === undefined) {
            return;
        }
        // Update prev node to point to next node.
        removeClient.olderClient.youngerClient = removeClient.youngerClient;
        if (removeClient.youngerClient === undefined) {
            // Update linked list end pointer to youngest client.
            this._youngestClient = removeClient.olderClient;
        }
        else {
            // Update next node to point back to previous node.
            removeClient.youngerClient.olderClient = removeClient.olderClient;
        }
        this.clientMap.delete(clientId);
        return removeClient;
    }
    /** Returns an array of all clients being tracked in order from oldest to newest. */
    getAllClients() {
        const result = [];
        let currClient = this.rootNode;
        while (currClient.youngerClient !== undefined) {
            result.push(currClient.youngerClient);
            currClient = currClient.youngerClient;
        }
        return result;
    }
}
exports.OrderedClientCollection = OrderedClientCollection;
/**
 * Adapter for OrderedClientCollection, with the purpose of deterministically maintaining
 * a currently elected client, excluding ineligible clients, in a distributed fashion.
 * This can be true as long as incrementElectedClient and resetElectedClient calls
 * are called under the same conditions for all clients.
 */
class OrderedClientElection extends common_utils_1.TypedEventEmitter {
    constructor(logger, orderedClientCollection, 
    /** Serialized state from summary or current sequence number at time of load if new. */
    initialState, isEligibleFn) {
        super();
        this.orderedClientCollection = orderedClientCollection;
        this.isEligibleFn = isEligibleFn;
        this._eligibleCount = 0;
        let initialClient;
        let initialParent;
        for (const client of orderedClientCollection.getAllClients()) {
            this.addClient(client, 0);
            if (typeof initialState !== "number") {
                if (client.clientId === initialState.electedClientId) {
                    initialClient = client;
                    if (initialState.electedParentId === undefined &&
                        client.client.details.type !== summarizerClientElection_1.summarizerClientType) {
                        // If there was no elected parent in the serialized data, use this one.
                        initialParent = client;
                    }
                }
                if (client.clientId === initialState.electedParentId) {
                    initialParent = client;
                }
            }
        }
        orderedClientCollection.on("addClient", (client, seq) => this.addClient(client, seq));
        orderedClientCollection.on("removeClient", (client, seq) => this.removeClient(client, seq));
        if (typeof initialState === "number") {
            this._electionSequenceNumber = initialState;
        }
        else {
            // Override the initially elected client with the initial state.
            if ((initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId) !== initialState.electedClientId) {
                // Cannot find initially elected client, so elect undefined.
                logger.sendErrorEvent({
                    eventName: "InitialElectedClientNotFound",
                    electionSequenceNumber: initialState.electionSequenceNumber,
                    expectedClientId: initialState.electedClientId,
                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,
                    clientCount: orderedClientCollection.count,
                });
            }
            else if (initialClient !== undefined && !isEligibleFn(initialClient)) {
                // Initially elected client is ineligible, so elect next eligible client.
                initialClient = initialParent = this.findFirstEligibleParent(initialParent);
                logger.sendErrorEvent({
                    eventName: "InitialElectedClientIneligible",
                    electionSequenceNumber: initialState.electionSequenceNumber,
                    expectedClientId: initialState.electedClientId,
                    electedClientId: initialClient === null || initialClient === void 0 ? void 0 : initialClient.clientId,
                });
            }
            this._electedParent = initialParent;
            this._electedClient = initialClient;
            this._electionSequenceNumber = initialState.electionSequenceNumber;
        }
    }
    get eligibleCount() {
        return this._eligibleCount;
    }
    get electionSequenceNumber() {
        return this._electionSequenceNumber;
    }
    /**
     * OrderedClientCollection tracks electedClient and electedParent separately. This allows us to handle the case
     * where a new interactive parent client has been elected, but the summarizer is still doing work, so
     * a new summarizer should not yet be spawned. In this case, changing electedParent will cause SummaryManager
     * to stop the current summarizer, but a new summarizer will not be spawned until the old summarizer client has
     * left the quorum.
     *
     * Details:
     *
     * electedParent is the interactive client that has been elected to spawn a summarizer. It is typically the oldest
     * eligible interactive client in the quorum. Only the electedParent is permitted to spawn a summarizer.
     * Once elected, this client will remain the electedParent until it leaves the quorum or the summarizer that
     * it spawned stops producing summaries, at which point a new electedParent will be chosen.
     *
     * electedClient is the non-interactive summarizer client if one exists. If not, then electedClient is equal to
     * electedParent. If electedParent === electedClient, this is the signal for electedParent to spawn a new
     * electedClient. Once a summarizer client becomes electedClient, a new summarizer will not be spawned until
     * electedClient leaves the quorum.
     *
     * A typical sequence looks like this:
     * i. Begin by electing A. electedParent === A, electedClient === A.
     * ii. SummaryManager running on A spawns a summarizer client, A'. electedParent === A, electedClient === A'
     * iii. A' stops producing summaries. A new parent client, B, is elected. electedParent === B, electedClient === A'
     * iv. SummaryManager running on A detects the change to electedParent and tells the summarizer to stop, but A'
     *      is in mid-summarization. No new summarizer is spawned, as electedParent !== electedClient.
     * v. A' completes its summary, and the summarizer and backing client are torn down.
     * vi. A' leaves the quorum, and B takes its place as electedClient. electedParent === B, electedClient === B
     * vii. SummaryManager running on B spawns a summarizer client, B'. electedParent === B, electedClient === B'
     */
    get electedClient() {
        return this._electedClient;
    }
    get electedParent() {
        return this._electedParent;
    }
    /** Tries changing the elected client, raising an event if it is different.
     * Note that this function does no eligibility or suitability checks. If we get here, then
     * we will set _electedClient, and we will set _electedParent if this is an interactive client.
     */
    tryElectingClient(client, sequenceNumber) {
        let change = false;
        const isSummarizerClient = (client === null || client === void 0 ? void 0 : client.client.details.type) === summarizerClientElection_1.summarizerClientType;
        const prevClient = this._electedClient;
        if (this._electedClient !== client) {
            // Changing the elected client. Record the sequence number and note that we have to fire an event.
            this._electionSequenceNumber = sequenceNumber;
            this._electedClient = client;
            change = true;
        }
        if (this._electedParent !== client && !isSummarizerClient) {
            // Changing the elected parent as well.
            this._electedParent = client;
            change = true;
        }
        if (change) {
            this.emit("election", client, sequenceNumber, prevClient);
        }
    }
    tryElectingParent(client, sequenceNumber) {
        if (this._electedParent !== client) {
            this._electedParent = client;
            this.emit("election", this._electedClient, sequenceNumber, this._electedClient);
        }
    }
    /**
     * Helper function to find the first eligible parent client starting with the passed in client,
     * or undefined if none are eligible.
     * @param client - client to start checking
     * @returns oldest eligible client starting with passed in client or undefined if none.
     */
    findFirstEligibleParent(client) {
        let candidateClient = client;
        while (candidateClient !== undefined &&
            (!this.isEligibleFn(candidateClient) || candidateClient.client.details.type === summarizerClientElection_1.summarizerClientType)) {
            candidateClient = candidateClient.youngerClient;
        }
        return candidateClient;
    }
    /**
     * Updates tracking for when a new client is added to the collection.
     * Will automatically elect that new client if none is elected currently.
     * @param client - client added to the collection
     * @param sequenceNumber - sequence number when client was added
     */
    addClient(client, sequenceNumber) {
        var _a;
        if (this.isEligibleFn(client)) {
            this._eligibleCount++;
            const newClientIsSummarizer = client.client.details.type === summarizerClientElection_1.summarizerClientType;
            const electedClientIsSummarizer = ((_a = this._electedClient) === null || _a === void 0 ? void 0 : _a.client.details.type) === summarizerClientElection_1.summarizerClientType;
            // Note that we allow a summarizer client to supercede an interactive client as elected client.
            if (this._electedClient === undefined || (!electedClientIsSummarizer && newClientIsSummarizer)) {
                this.tryElectingClient(client, sequenceNumber);
            }
            else if (this._electedParent === undefined && !newClientIsSummarizer) {
                // This is an odd case. If the _electedClient is set, the _electedParent should be as well.
                this.tryElectingParent(client, sequenceNumber);
            }
        }
    }
    /**
     * Updates tracking for when an existing client is removed from the collection.
     * Will automatically elect next oldest client if currently elected is removed.
     * @param client - client removed from the collection
     * @param sequenceNumber - sequence number when client was removed
     */
    removeClient(client, sequenceNumber) {
        var _a, _b, _c, _d, _e;
        if (this.isEligibleFn(client)) {
            this._eligibleCount--;
            if (this._electedClient === client) {
                // Removing the _electedClient. There are 2 possible cases:
                if (this._electedParent !== client) {
                    // 1. The _electedClient is a summarizer that we've been allowing to finish its work.
                    // Let the _electedParent become the _electedClient so that it can start its own summarizer.
                    if (this._electedClient.client.details.type !== summarizerClientElection_1.summarizerClientType) {
                        throw new container_utils_1.UsageError("Elected client should be a summarizer client 1");
                    }
                    this.tryElectingClient(this._electedParent, sequenceNumber);
                }
                else {
                    // 2. The _electedClient is an interactive client that has left the quorum.
                    // Automatically shift to next oldest client.
                    const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
                    this.tryElectingClient(nextClient, sequenceNumber);
                }
            }
            else if (this._electedParent === client) {
                // Removing the _electedParent (but not _electedClient).
                // Shift to the next oldest parent, but do not replace the _electedClient,
                // which is a summarizer that is still doing work.
                if (((_c = this._electedClient) === null || _c === void 0 ? void 0 : _c.client.details.type) !== summarizerClientElection_1.summarizerClientType) {
                    throw new container_utils_1.UsageError("Elected client should be a summarizer client 2");
                }
                const nextParent = (_e = this.findFirstEligibleParent((_d = this._electedParent) === null || _d === void 0 ? void 0 : _d.youngerClient)) !== null && _e !== void 0 ? _e : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
                this.tryElectingParent(nextParent, sequenceNumber);
            }
        }
    }
    getAllEligibleClients() {
        return this.orderedClientCollection.getAllClients().filter(this.isEligibleFn);
    }
    /** Advance election to the next-oldest client. This is called if the current parent is leaving the quorum,
     * or if the current summarizer is not responsive and we want to stop it and spawn a new one.
     */
    incrementElectedClient(sequenceNumber) {
        var _a, _b;
        const nextClient = (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
        if (this._electedClient === undefined || this._electedClient === this._electedParent) {
            this.tryElectingClient(nextClient, sequenceNumber);
        }
        else {
            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.
            // Changing the _electedParent will stop the summarizer.
            this.tryElectingParent(nextClient, sequenceNumber);
        }
    }
    /** (Re-)start election with the oldest client in the quorum. This is called if we need to summarize
     * and no client has been elected.
     */
    resetElectedClient(sequenceNumber) {
        const firstClient = this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
        if (this._electedClient === undefined || this._electedClient === this._electedParent) {
            this.tryElectingClient(firstClient, sequenceNumber);
        }
        else {
            // The _electedClient is a summarizer and should not be replaced until it leaves the quorum.
            // Changing the _electedParent will stop the summarizer.
            this.tryElectingParent(firstClient, sequenceNumber);
        }
    }
    peekNextElectedClient() {
        var _a, _b;
        return (_b = this.findFirstEligibleParent((_a = this._electedParent) === null || _a === void 0 ? void 0 : _a.youngerClient)) !== null && _b !== void 0 ? _b : this.findFirstEligibleParent(this.orderedClientCollection.oldestClient);
    }
    serialize() {
        var _a, _b;
        return {
            electionSequenceNumber: this.electionSequenceNumber,
            electedClientId: (_a = this.electedClient) === null || _a === void 0 ? void 0 : _a.clientId,
            electedParentId: (_b = this.electedParent) === null || _b === void 0 ? void 0 : _b.clientId,
        };
    }
}
exports.OrderedClientElection = OrderedClientElection;

},{"./summarizerClientElection":77,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/telemetry-utils":279}],71:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/container-runtime";
exports.pkgVersion = "1.3.6";

},{}],72:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingStateManager = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const double_ended_queue_1 = __importDefault(require("double-ended-queue"));
/**
 * PendingStateManager is responsible for maintaining the messages that have not been sent or have not yet been
 * acknowledged by the server. It also maintains the batch information for both automatically and manually flushed
 * batches along with the messages.
 * When the Container reconnects, it replays the pending states, which includes setting the FlushMode, manual flushing
 * of messages and triggering resubmission of unacked ops.
 *
 * It verifies that all the ops are acked, are received in the right order and batch information is correct.
 */
class PendingStateManager {
    constructor(stateHandler, initialFlushMode, initialLocalState) {
        var _a;
        this.stateHandler = stateHandler;
        this.pendingStates = new double_ended_queue_1.default();
        this.disposeOnce = new common_utils_1.Lazy(() => {
            this.initialStates.clear();
            this.pendingStates.clear();
        });
        // Maintains the count of messages that are currently unacked.
        this._pendingMessagesCount = 0;
        // Indicates whether we are processing a batch.
        this.isProcessingBatch = false;
        this.dispose = () => this.disposeOnce.value;
        this.initialStates = new double_ended_queue_1.default((_a = initialLocalState === null || initialLocalState === void 0 ? void 0 : initialLocalState.pendingStates) !== null && _a !== void 0 ? _a : []);
        this.flushModeForNextMessage = initialFlushMode;
        this.onFlushModeUpdated(initialFlushMode);
    }
    get pendingMessagesCount() {
        return this._pendingMessagesCount;
    }
    /**
     * Called to check if there are any pending messages in the pending state queue.
     * @returns A boolean indicating whether there are messages or not.
     */
    hasPendingMessages() {
        return this._pendingMessagesCount !== 0 || !this.initialStates.isEmpty();
    }
    getLocalState() {
        (0, common_utils_1.assert)(this.initialStates.isEmpty(), 0x2e9 /* "Must call getLocalState() after applying initial states" */);
        if (this.hasPendingMessages()) {
            return {
                pendingStates: this.pendingStates.toArray().map(
                // delete localOpMetadata since it may not be serializable
                // and will be regenerated by applyStashedOp()
                (state) => state.type === "message" ? Object.assign(Object.assign({}, state), { localOpMetadata: undefined }) : state),
            };
        }
    }
    get disposed() { return this.disposeOnce.evaluated; }
    /**
     * Called when a message is submitted locally. Adds the message and the associated details to the pending state
     * queue.
     * @param type - The container message type.
     * @param clientSequenceNumber - The clientSequenceNumber associated with the message.
     * @param content - The message content.
     * @param localOpMetadata - The local metadata associated with the message.
     */
    onSubmitMessage(type, clientSequenceNumber, referenceSequenceNumber, content, localOpMetadata, opMetadata) {
        const pendingMessage = {
            type: "message",
            messageType: type,
            clientSequenceNumber,
            referenceSequenceNumber,
            content,
            localOpMetadata,
            opMetadata,
        };
        this.pendingStates.push(pendingMessage);
        this._pendingMessagesCount++;
    }
    /**
     * Called when the FlushMode is updated. Adds the FlushMode to the pending state queue.
     * @param flushMode - The flushMode that was updated.
     */
    onFlushModeUpdated(flushMode) {
        this.pendingStates.push({ type: "flushMode", flushMode });
    }
    /**
     * Called when flush() is called on the ContainerRuntime to manually flush messages.
     */
    onFlush() {
        // If the FlushMode is Immediate, we don't need to track an explicit flush call because every message is
        // automatically flushed. So, flush is a no-op.
        if (this.stateHandler.flushMode() === runtime_definitions_1.FlushMode.Immediate) {
            return;
        }
        // If the previous state is not a message, flush is a no-op.
        const previousState = this.pendingStates.peekBack();
        if ((previousState === null || previousState === void 0 ? void 0 : previousState.type) !== "message") {
            return;
        }
        // An explicit flush is interesting and is tracked only if there are messages sent in TurnBased mode.
        this.pendingStates.push({ type: "flush" });
    }
    /**
     * Applies stashed ops at their reference sequence number so they are ready to be ACKed or resubmitted
     * @param seqNum - Sequence number at which to apply ops. Will apply all ops if seqNum is undefined.
     */
    async applyStashedOpsAt(seqNum) {
        // apply stashed ops at sequence number
        while (!this.initialStates.isEmpty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const nextState = this.initialStates.peekFront();
            if (nextState.type === "message") {
                if (seqNum !== undefined) {
                    if (nextState.referenceSequenceNumber > seqNum) {
                        break; // nothing left to do at this sequence number
                    }
                    else if (nextState.referenceSequenceNumber < seqNum) {
                        throw new Error("loaded from snapshot too recent to apply stashed ops");
                    }
                }
                // applyStashedOp will cause the DDS to behave as if it has sent the op but not actually send it
                const localOpMetadata = await this.stateHandler.applyStashedOp(nextState.messageType, nextState.content);
                nextState.localOpMetadata = localOpMetadata;
            }
            // then we push onto pendingStates which will cause PendingStateManager to resubmit when we connect
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.pendingStates.push(this.initialStates.shift());
        }
    }
    /**
     * Processes a local message once its ack'd by the server. It verifies that there was no data corruption and that
     * the batch information was preserved for batch messages.
     * @param message - The message that got ack'd and needs to be processed.
     */
    processPendingLocalMessage(message) {
        // Pre-processing part - This may be the start of a batch.
        this.maybeProcessBatchBegin(message);
        // Get the next state from the pending queue and verify that it is of type "message".
        const pendingState = this.peekNextPendingState();
        (0, common_utils_1.assert)(pendingState.type === "message", 0x169 /* "No pending message found for this remote message" */);
        this.pendingStates.shift();
        // Processing part - Verify that there has been no data corruption.
        // The clientSequenceNumber of the incoming message must match that of the pending message.
        if (pendingState.clientSequenceNumber !== message.clientSequenceNumber) {
            // Close the container because this could indicate data corruption.
            const error = container_utils_1.DataProcessingError.create("pending local message clientSequenceNumber mismatch", "unexpectedAckReceived", message, { expectedClientSequenceNumber: pendingState.clientSequenceNumber });
            this.stateHandler.close(error);
            return;
        }
        this._pendingMessagesCount--;
        // Post-processing part - If we are processing a batch then this could be the last message in the batch.
        this.maybeProcessBatchEnd(message);
        return pendingState.localOpMetadata;
    }
    /**
     * This message could be the first message in batch. If so, set batch state marking the beginning of a batch.
     * @param message - The message that is being processed.
     */
    maybeProcessBatchBegin(message) {
        // Tracks the last FlushMode that was set before this message was sent.
        let pendingFlushMode;
        // Tracks whether a flush was called before this message was sent.
        let pendingFlush = false;
        /**
         * We are checking if the next message is the start of a batch. It can happen in the following scenarios:
         * 1. The FlushMode was set to TurnBased before this message was sent.
         * 2. The FlushMode was already TurnBased and a flush was called before this message was sent. This essentially
         *    means that the flush marked the end of a previous batch and beginning of a new batch.
         *
         * Keep reading pending states from the queue until we encounter a message. It's possible that the FlushMode was
         * updated a bunch of times without sending any messages.
         */
        let nextPendingState = this.peekNextPendingState();
        while (nextPendingState.type !== "message") {
            if (nextPendingState.type === "flushMode") {
                pendingFlushMode = nextPendingState.flushMode;
            }
            if (nextPendingState.type === "flush") {
                pendingFlush = true;
            }
            this.pendingStates.shift();
            nextPendingState = this.peekNextPendingState();
        }
        if (pendingFlushMode !== undefined) {
            this.flushModeForNextMessage = pendingFlushMode;
        }
        // If the FlushMode was set to Immediate before this message was sent, this message won't be a batch message
        // because in Immediate mode, every message is flushed individually.
        if (pendingFlushMode === runtime_definitions_1.FlushMode.Immediate) {
            return;
        }
        /**
         * This message is the first in a batch if before it was sent either the FlushMode was set to TurnBased or there
         * was an explicit flush call. Note that a flush call is tracked only in TurnBased mode and it indicates the end
         * of one batch and beginning of another.
         */
        if (pendingFlushMode === runtime_definitions_1.FlushMode.TurnBased || pendingFlush) {
            // We should not already be processing a batch and there should be no pending batch begin message.
            (0, common_utils_1.assert)(!this.isProcessingBatch && this.pendingBatchBeginMessage === undefined, 0x16b /* "The pending batch state indicates we are already processing a batch" */);
            // Set the pending batch state indicating we have started processing a batch.
            this.pendingBatchBeginMessage = message;
            this.isProcessingBatch = true;
        }
    }
    /**
     * This message could be the last message in batch. If so, clear batch state since the batch is complete.
     * @param message - The message that is being processed.
     */
    maybeProcessBatchEnd(message) {
        var _a, _b;
        if (!this.isProcessingBatch) {
            return;
        }
        const nextPendingState = this.peekNextPendingState();
        if (nextPendingState.type === "message") {
            return;
        }
        /**
         * We are in the middle of processing a batch. The batch ends when we see an explicit flush. We should never see
         * a FlushMode before flush. This is true because we track batches only when FlushMode is TurnBased and in this
         * mode, a batch ends either by calling flush or by changing the mode to Immediate which also triggers a flush.
         */
        (0, common_utils_1.assert)(nextPendingState.type !== "flushMode", 0x2bd /* "We should not see a pending FlushMode until we see a flush when processing a batch" */);
        // There should be a pending batch begin message.
        (0, common_utils_1.assert)(this.pendingBatchBeginMessage !== undefined, 0x16d /* "There is no pending batch begin message" */);
        // Get the batch begin metadata from the first message in the batch.
        const batchBeginMetadata = (_a = this.pendingBatchBeginMessage.metadata) === null || _a === void 0 ? void 0 : _a.batch;
        // There could be just a single message in the batch. If so, it should not have any batch metadata. If there
        // are multiple messages in the batch, verify that we got the correct batch begin and end metadata.
        if (this.pendingBatchBeginMessage === message) {
            (0, common_utils_1.assert)(batchBeginMetadata === undefined, 0x16e /* "Batch with single message should not have batch metadata" */);
        }
        else {
            // Get the batch metadata from the last message in the batch.
            const batchEndMetadata = (_b = message.metadata) === null || _b === void 0 ? void 0 : _b.batch;
            (0, common_utils_1.assert)(batchBeginMetadata === true, 0x16f /* "Did not receive batch begin metadata" */);
            (0, common_utils_1.assert)(batchEndMetadata === false, 0x170 /* "Did not receive batch end metadata" */);
        }
        // Clear the pending batch state now that we have processed the entire batch.
        this.pendingBatchBeginMessage = undefined;
        this.isProcessingBatch = false;
    }
    /**
     * Capture the pending state at this point
     */
    checkpoint() {
        const checkpointHead = this.pendingStates.peekBack();
        return {
            rollback: () => {
                try {
                    while (this.pendingStates.peekBack() !== checkpointHead) {
                        this.rollbackNextPendingState();
                    }
                }
                catch (err) {
                    const error = (0, telemetry_utils_1.wrapError)(err, (message) => {
                        return container_utils_1.DataProcessingError.create(`RollbackError: ${message}`, "checkpointRollback", undefined);
                    });
                    this.stateHandler.close(error);
                    throw error;
                }
            },
        };
    }
    /**
     * Returns the next pending state from the pending state queue.
     */
    peekNextPendingState() {
        const nextPendingState = this.pendingStates.peekFront();
        (0, common_utils_1.assert)(!!nextPendingState, 0x171 /* "No pending state found for the remote message" */);
        return nextPendingState;
    }
    /**
     * Undo the last pending state
     */
    rollbackNextPendingState() {
        const pendingStatesCount = this.pendingStates.length;
        if (pendingStatesCount === 0) {
            return;
        }
        this._pendingMessagesCount--;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const pendingState = this.pendingStates.pop();
        switch (pendingState.type) {
            case "message":
                this.stateHandler.rollback(pendingState.messageType, pendingState.content, pendingState.localOpMetadata);
                break;
            default:
                throw new Error(`Can't rollback state ${pendingState.type}`);
        }
    }
    /**
     * Called when the Container's connection state changes. If the Container gets connected, it replays all the pending
     * states in its queue. This includes setting the FlushMode and triggering resubmission of unacked ops.
     */
    replayPendingStates() {
        (0, common_utils_1.assert)(this.stateHandler.connected(), 0x172 /* "The connection state is not consistent with the runtime" */);
        // This assert suggests we are about to send same ops twice, which will result in data loss.
        (0, common_utils_1.assert)(this.clientId !== this.stateHandler.clientId(), 0x173 /* "replayPendingStates called twice for same clientId!" */);
        this.clientId = this.stateHandler.clientId();
        (0, common_utils_1.assert)(this.initialStates.isEmpty(), 0x174 /* "initial states should be empty before replaying pending" */);
        let pendingStatesCount = this.pendingStates.length;
        if (pendingStatesCount === 0) {
            return;
        }
        // Reset the pending message count because all these messages will be removed from the queue.
        this._pendingMessagesCount = 0;
        // Save the current FlushMode so that we can revert it back after replaying the states.
        const savedFlushMode = this.stateHandler.flushMode();
        // Set the flush mode for the next message. This step is important because the flush mode may have been changed
        // after the next pending message was sent.
        this.stateHandler.setFlushMode(this.flushModeForNextMessage);
        // Process exactly `pendingStatesCount` items in the queue as it represents the number of states that were
        // pending when we connected. This is important because the `reSubmitFn` might add more items in the queue
        // which must not be replayed.
        while (pendingStatesCount > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const pendingState = this.pendingStates.shift();
            switch (pendingState.type) {
                case "message":
                    this.stateHandler.reSubmit(pendingState.messageType, pendingState.content, pendingState.localOpMetadata, pendingState.opMetadata);
                    break;
                case "flushMode":
                    this.stateHandler.setFlushMode(pendingState.flushMode);
                    break;
                case "flush":
                    this.stateHandler.flush();
                    break;
                default:
                    break;
            }
            pendingStatesCount--;
        }
        // Revert the FlushMode.
        this.stateHandler.setFlushMode(savedFlushMode);
    }
}
exports.PendingStateManager = PendingStateManager;

},{"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/runtime-definitions":208,"@fluidframework/telemetry-utils":279,"double-ended-queue":348}],73:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunWhileConnectedCoordinator = exports.neverCancelledSummaryToken = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Can be useful in testing as well as in places where caller does not use cancellation.
 * This object implements ISummaryCancellationToken interface but cancellation is never leveraged.
 */
exports.neverCancelledSummaryToken = {
    cancelled: false,
    waitCancelled: new Promise(() => { }),
};
/**
 * Helper class to coordinate something that needs to run only while connected.
 * This provides promises that resolve as it starts or stops.  Stopping happens
 * when disconnected or if stop() is called.
 */
class RunWhileConnectedCoordinator {
    constructor(runtime) {
        this.runtime = runtime;
        this._cancelled = false;
        this.stopDeferred = new common_utils_1.Deferred();
    }
    get cancelled() {
        if (!this._cancelled) {
            (0, common_utils_1.assert)(this.runtime.deltaManager.active, 0x25d /* "We should never connect as 'read'" */);
            // This check can't be enabled in current design due to lastSummary flow, where
            // summarizer for closed container stays around and can produce one more summary.
            // Currently we solve the problem of overlapping summarizer by doing wait in
            // SummaryManager.createSummarizer()
            // Better solution would involve these steps:
            // 1. Summarizer selection logic should chose summarizing client (with clientType === "summarizer")
            // if such client exists.
            // 2. Summarizer should be updated about such changes (to update onBehalfOfClientId)
            //
            // assert(this.runtime.summarizerClientId === this.onBehalfOfClientId ||
            //    this.runtime.summarizerClientId === this.runtime.clientId, "onBehalfOfClientId");
        }
        return this._cancelled;
    }
    /**
     * Returns a promise that resolves once stopped either externally or by disconnect.
     */
    get waitCancelled() {
        return this.stopDeferred.promise;
    }
    static async create(runtime) {
        const obj = new RunWhileConnectedCoordinator(runtime);
        await obj.waitStart();
        return obj;
    }
    /**
     * Starts and waits for a promise which resolves when connected.
     * The promise will also resolve if stopped either externally or by disconnect.
     *
     * We only listen on disconnected event for clientType === "summarizer" container!
     * And only do it here - no other place should check it! That way we have only one place
     * that controls policy and it's easy to change policy in the future if we want to!
     * We do not listen for "main" (aka interactive) container disconnect here, as it's
     * responsibility of SummaryManager to decide if that's material or not. There are cases
     * like "lastSummary", or main client experiencing nacks / disconnects due to hitting limit
     * of non-summarized ops, where can make determination to continue with summary even if main
     * client is disconnected.
     */
    async waitStart() {
        if (this.runtime.disposed) {
            this.stop("summarizerClientDisconnected");
            return;
        }
        this.runtime.once("dispose", () => this.stop("summarizerClientDisconnected"));
        if (!this.runtime.connected) {
            const waitConnected = new Promise((resolve) => this.runtime.once("connected", resolve));
            await Promise.race([waitConnected, this.waitCancelled]);
        }
        this.runtime.once("disconnected", () => this.stop("summarizerClientDisconnected"));
    }
    /**
     * Stops running.
     */
    stop(reason) {
        if (!this._cancelled) {
            this._cancelled = true;
            this.stopDeferred.resolve(reason);
        }
    }
}
exports.RunWhileConnectedCoordinator = RunWhileConnectedCoordinator;

},{"@fluidframework/common-utils":29}],74:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RunningSummarizer = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const summarizerHeuristics_1 = require("./summarizerHeuristics");
const summaryGenerator_1 = require("./summaryGenerator");
const maxSummarizeAckWaitTime = 10 * 60 * 1000; // 10 minutes
/**
 * An instance of RunningSummarizer manages the heuristics for summarizing.
 * Until disposed, the instance of RunningSummarizer can assume that it is
 * in a state of running, meaning it is connected and initialized.  It keeps
 * track of summaries that it is generating as they are broadcast and acked/nacked.
 * This object is created and controlled by Summarizer object.
 */
class RunningSummarizer {
    constructor(baseLogger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {
        this.summaryWatcher = summaryWatcher;
        this.configuration = configuration;
        this.submitSummaryCallback = submitSummaryCallback;
        this.heuristicData = heuristicData;
        this.raiseSummarizingError = raiseSummarizingError;
        this.summaryCollection = summaryCollection;
        this.cancellationToken = cancellationToken;
        this.stopSummarizerCallback = stopSummarizerCallback;
        this.stopping = false;
        this._disposed = false;
        this.tryWhileSummarizing = false;
        this.summarizeCount = 0;
        this.totalSuccessfulAttempts = 0;
        /**
         * RunningSummarizer's logger includes the sequenced index of the current summary on each event.
         * If some other Summarizer code wants that event on their logs they can get it here,
         * but only if they're logging about that same summary.
         * @param summaryOpRefSeq - RefSeq number of the summary op, to ensure the log correlation will be correct
         */
        this.tryGetCorrelatedLogger = (summaryOpRefSeq) => this.heuristicData.lastAttempt.refSequenceNumber === summaryOpRefSeq
            ? this.logger
            : undefined;
        const telemetryProps = {
            summarizeCount: () => this.summarizeCount,
            summarizerSuccessfulAttempts: () => this.totalSuccessfulAttempts,
        };
        this.logger = telemetry_utils_1.ChildLogger.create(baseLogger, "Running", {
            all: telemetryProps,
        });
        if (configuration.state !== "disableHeuristics") {
            (0, common_utils_1.assert)(this.configuration.state === "enabled", 0x2ea /* "Configuration state should be enabled" */);
            this.heuristicRunner = new summarizerHeuristics_1.SummarizeHeuristicRunner(heuristicData, this.configuration, (reason) => this.trySummarize(reason), this.logger);
        }
        (0, common_utils_1.assert)(this.configuration.state !== "disabled", 0x2eb /* "Summary not supported with configuration disabled" */);
        // Cap the maximum amount of time client will wait for a summarize op ack to maxSummarizeAckWaitTime
        // configuration.maxAckWaitTime is composed from defaults, server values, and runtime overrides
        const maxAckWaitTime = Math.min(this.configuration.maxAckWaitTime, maxSummarizeAckWaitTime);
        this.pendingAckTimer = new common_utils_1.PromiseTimer(maxAckWaitTime, () => {
            // pre-0.58 error message: summaryAckWaitTimeout
            this.raiseSummarizingError("Pending summary ack not received in time");
            // Note: summarizeCount (from ChildLogger definition) may be 0,
            // since this code path is hit when RunningSummarizer first starts up,
            // before this instance has kicked off a new summarize run.
            this.logger.sendErrorEvent({
                eventName: "SummaryAckWaitTimeout",
                maxAckWaitTime,
                referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,
                summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,
                timePending: Date.now() - this.heuristicData.lastAttempt.summaryTime,
            });
        });
        // Set up pending ack timeout by op timestamp differences for previous summaries.
        summaryCollection.setPendingAckTimerTimeoutCallback(maxAckWaitTime, () => {
            if (this.pendingAckTimer.hasTimer) {
                this.logger.sendTelemetryEvent({
                    eventName: "MissingSummaryAckFoundByOps",
                    referenceSequenceNumber: this.heuristicData.lastAttempt.refSequenceNumber,
                    summarySequenceNumber: this.heuristicData.lastAttempt.summarySequenceNumber,
                });
                this.pendingAckTimer.clear();
            }
        });
        this.generator = new summaryGenerator_1.SummaryGenerator(this.pendingAckTimer, this.heuristicData, this.submitSummaryCallback, this.raiseSummarizingError, () => { this.totalSuccessfulAttempts++; }, this.summaryWatcher, this.logger);
    }
    static async start(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback) {
        var _a;
        const summarizer = new RunningSummarizer(logger, summaryWatcher, configuration, submitSummaryCallback, heuristicData, raiseSummarizingError, summaryCollection, cancellationToken, stopSummarizerCallback);
        await summarizer.waitStart();
        // Run the heuristics after starting
        (_a = summarizer.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
        return summarizer;
    }
    get disposed() { return this._disposed; }
    dispose() {
        var _a;
        this.summaryWatcher.dispose();
        (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.dispose();
        this.heuristicRunner = undefined;
        this.generator.dispose();
        this.pendingAckTimer.clear();
        this.disposeEnqueuedSummary();
        this._disposed = true;
        this.stopping = true;
    }
    handleSystemOp(op) {
        switch (op.type) {
            case protocol_definitions_1.MessageType.ClientLeave:
            case protocol_definitions_1.MessageType.ClientJoin:
            case protocol_definitions_1.MessageType.Propose: {
                // Synchronously handle quorum ops like regular ops
                this.handleOp(undefined, op);
                return;
            }
            default: {
                return;
            }
        }
    }
    handleOp(error, { sequenceNumber, type, clientId, contents }) {
        var _a;
        if (error !== undefined) {
            return;
        }
        this.heuristicData.lastOpSequenceNumber = sequenceNumber;
        // Check for enqueued on-demand summaries; Intentionally do nothing otherwise
        if (!this.tryRunEnqueuedSummary()) {
            (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
        }
    }
    async waitStop(allowLastSummary) {
        var _a;
        if (this.stopping) {
            return;
        }
        this.stopping = true;
        this.disposeEnqueuedSummary();
        // This will try to run lastSummary if needed.
        if (allowLastSummary && ((_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.shouldRunLastSummary())) {
            if (this.summarizingLock === undefined) {
                this.trySummarizeOnce(
                // summarizeProps
                { reason: "lastSummary" }, 
                // ISummarizeOptions, using defaults: { refreshLatestAck: false, fullTree: false }
                {});
            }
        }
        // Note that trySummarizeOnce() call above returns right away, without waiting.
        // So we need to wait for its completion, otherwise it would be destroyed right away.
        // That said, if summary lock was taken upfront, this wait might wait on  multiple retries to
        // submit summary. We should reconsider this flow and make summarizer move to exit faster.
        // This resolves when the current pending summary gets an ack or fails.
        await this.summarizingLock;
    }
    async waitStart() {
        // Wait no longer than ack timeout for all pending
        const waitStartResult = await (0, summaryGenerator_1.raceTimer)(this.summaryWatcher.waitFlushed(), this.pendingAckTimer.start());
        this.pendingAckTimer.clear();
        // Remove pending ack wait timeout by op timestamp comparison, because
        // it has race conditions with summaries submitted by this same client.
        this.summaryCollection.unsetPendingAckTimerTimeoutCallback();
        if (waitStartResult.result === "done" && waitStartResult.value !== undefined) {
            this.heuristicData.updateWithLastSummaryAckInfo({
                refSequenceNumber: waitStartResult.value.summaryOp.referenceSequenceNumber,
                // This will be the Summarizer starting point so only use timestamps from client's machine.
                summaryTime: Date.now(),
                summarySequenceNumber: waitStartResult.value.summaryOp.sequenceNumber,
            });
        }
    }
    /**
     * Blocks a new summarizer from running in case RefreshSummaryAck is being processed.
     * Assumes that caller checked upfront for lack of concurrent action (this.refreshSummaryAckLock)
     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.
     * Note: The refreshSummaryAckLock makes sure no summarizer gets enqueued or processed
     * until the refresh has completed. One can't rely uniquely on the summarizingLock as the
     * refreshLatestSummaryAck also happens during the time summarizingLock !== undefined.
     * Ex. Summarizer submits a summay + op and then waits for the Summary Ack to proceed
     * with the refreshLatestSummaryAck and complete the summary.
     * @param action - action to perform.
     * @returns - result of action.
     */
    async lockedRefreshSummaryAckAction(action) {
        (0, common_utils_1.assert)(this.refreshSummaryAckLock === undefined, "Refresh Summary Ack - Caller is responsible for checking lock");
        const refreshSummaryAckLock = new common_utils_1.Deferred();
        this.refreshSummaryAckLock = refreshSummaryAckLock.promise;
        return action().finally(() => {
            refreshSummaryAckLock.resolve();
            this.refreshSummaryAckLock = undefined;
        });
    }
    /**
     * Runs single summary action that prevents any other concurrent actions.
     * Assumes that caller checked upfront for lack of concurrent action (this.summarizingLock)
     * before calling this API. I.e. caller is responsible for either erroring out or waiting on this promise.
     * @param action - action to perform.
     * @returns - result of action.
     */
    async lockedSummaryAction(action) {
        (0, common_utils_1.assert)(this.summarizingLock === undefined, 0x25b /* "Caller is responsible for checking lock" */);
        const summarizingLock = new common_utils_1.Deferred();
        this.summarizingLock = summarizingLock.promise;
        this.summarizeCount++;
        // Make sure the RefreshLatestSummaryAck is not being executed.
        await this.refreshSummaryAckLock;
        return action().finally(() => {
            var _a;
            summarizingLock.resolve();
            this.summarizingLock = undefined;
            const retry = this.tryWhileSummarizing;
            this.tryWhileSummarizing = false;
            // After summarizing, we should check to see if we need to summarize again.
            // Rerun the heuristics and check for enqueued summaries.
            if (!this.stopping && !this.tryRunEnqueuedSummary() && retry) {
                (_a = this.heuristicRunner) === null || _a === void 0 ? void 0 : _a.run();
            }
        });
    }
    /**
     * Runs single summarize attempt
     * @param summarizeProps - props to log with each telemetry event associated with this attempt
     * @param options - summary options
     * @param cancellationToken - cancellation token to use to be able to cancel this summary, if needed
     * @param resultsBuilder - optional, result builder to use.
     * @returns ISummarizeResult - result of running a summary.
     */
    trySummarizeOnce(summarizeProps, options, cancellationToken = this.cancellationToken, resultsBuilder = new summaryGenerator_1.SummarizeResultBuilder()) {
        this.lockedSummaryAction(async () => {
            const summarizeResult = this.generator.summarize(summarizeProps, options, cancellationToken, resultsBuilder);
            // ensure we wait till the end of the process
            return summarizeResult.receivedSummaryAckOrNack;
        }).catch((error) => {
            // SummaryGenerator.summarize() does not throw exceptions - it converts them to failed result
            // on resultsBuilder
            // We do not care about exceptions on receivedSummaryAckOrNack - caller should check results
            // and take a appropriate action.
        });
        return resultsBuilder.build();
    }
    /** Heuristics summarize attempt. */
    trySummarize(reason, cancellationToken = this.cancellationToken) {
        if (this.summarizingLock !== undefined) {
            // lockedSummaryAction() will retry heuristic-based summary at the end of current attempt
            // if it's still needed
            this.tryWhileSummarizing = true;
            return;
        }
        this.lockedSummaryAction(async () => {
            const attempts = [
                { refreshLatestAck: false, fullTree: false },
                { refreshLatestAck: true, fullTree: false },
                { refreshLatestAck: true, fullTree: false, delaySeconds: 2 * 60 },
                { refreshLatestAck: true, fullTree: true, delaySeconds: 10 * 60 },
            ];
            let overrideDelaySeconds;
            let summaryAttempts = 0;
            let summaryAttemptsPerPhase = 0;
            let lastResult;
            for (let summaryAttemptPhase = 0; summaryAttemptPhase < attempts.length;) {
                if (this.cancellationToken.cancelled) {
                    return;
                }
                // We only want to attempt 1 summary when reason is "lastSummary"
                if (++summaryAttempts > 1 && reason === "lastSummary") {
                    return;
                }
                summaryAttemptsPerPhase++;
                const _a = attempts[summaryAttemptPhase], { delaySeconds: regularDelaySeconds = 0 } = _a, options = __rest(_a, ["delaySeconds"]);
                const delaySeconds = overrideDelaySeconds !== null && overrideDelaySeconds !== void 0 ? overrideDelaySeconds : regularDelaySeconds;
                const summarizeProps = Object.assign({ reason,
                    summaryAttempts,
                    summaryAttemptsPerPhase, summaryAttemptPhase: summaryAttemptPhase + 1 }, options);
                if (delaySeconds > 0) {
                    this.logger.sendPerformanceEvent(Object.assign({ eventName: "SummarizeAttemptDelay", duration: delaySeconds, summaryNackDelay: overrideDelaySeconds !== undefined }, summarizeProps));
                    await (0, common_utils_1.delay)(delaySeconds * 1000);
                }
                // Make sure the refresh Summary Ack is not being executed.
                await this.refreshSummaryAckLock;
                // Note: no need to account for cancellationToken.waitCancelled here, as
                // this is accounted SummaryGenerator.summarizeCore that controls receivedSummaryAckOrNack.
                const resultSummarize = this.generator.summarize(summarizeProps, options, cancellationToken);
                const result = await resultSummarize.receivedSummaryAckOrNack;
                if (result.success) {
                    return;
                }
                // Check for retryDelay that can come from summaryNack or upload summary flow.
                // Retry the same step only once per retryAfter response.
                overrideDelaySeconds = result.retryAfterSeconds;
                if (overrideDelaySeconds === undefined || summaryAttemptsPerPhase > 1) {
                    summaryAttemptPhase++;
                    summaryAttemptsPerPhase = 0;
                }
                lastResult = result;
            }
            // If all attempts failed, log error (with last attempt info) and close the summarizer container
            this.logger.sendErrorEvent({
                eventName: "FailToSummarize",
                reason,
                message: lastResult === null || lastResult === void 0 ? void 0 : lastResult.message,
            }, lastResult === null || lastResult === void 0 ? void 0 : lastResult.error);
            this.stopSummarizerCallback("failToSummarize");
        }).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "UnexpectedSummarizeError" }, error);
        });
    }
    /** {@inheritdoc (ISummarizer:interface).summarizeOnDemand} */
    summarizeOnDemand(resultsBuilder = new summaryGenerator_1.SummarizeResultBuilder(), _a) {
        var { reason } = _a, options = __rest(_a, ["reason"]);
        if (this.stopping) {
            resultsBuilder.fail("RunningSummarizer stopped or disposed", undefined);
            return resultsBuilder.build();
        }
        // Check for concurrent summary attempts. If one is found,
        // return a promise that caller can await before trying again.
        if (this.summarizingLock !== undefined) {
            // The heuristics are blocking concurrent summarize attempts.
            throw new container_utils_1.UsageError("Attempted to run an already-running summarizer on demand");
        }
        const result = this.trySummarizeOnce({ reason: `onDemand/${reason}` }, options, this.cancellationToken, resultsBuilder);
        return result;
    }
    /** {@inheritdoc (ISummarizer:interface).enqueueSummarize} */
    enqueueSummarize(_a) {
        var { reason, afterSequenceNumber = 0, override = false } = _a, options = __rest(_a, ["reason", "afterSequenceNumber", "override"]);
        const onDemandReason = `enqueue;${reason}`;
        let overridden = false;
        if (this.enqueuedSummary !== undefined) {
            if (!override) {
                return { alreadyEnqueued: true };
            }
            // Override existing enqueued summarize attempt.
            this.enqueuedSummary.resultsBuilder.fail("Aborted; overridden by another enqueue summarize attempt", undefined);
            this.enqueuedSummary = undefined;
            overridden = true;
        }
        this.enqueuedSummary = {
            reason: onDemandReason,
            afterSequenceNumber,
            options,
            resultsBuilder: new summaryGenerator_1.SummarizeResultBuilder(),
        };
        const results = this.enqueuedSummary.resultsBuilder.build();
        this.tryRunEnqueuedSummary();
        return overridden ? Object.assign(Object.assign({}, results), { alreadyEnqueued: true, overridden: true }) : results;
    }
    tryRunEnqueuedSummary() {
        if (this.stopping) {
            this.disposeEnqueuedSummary();
            return false;
        }
        if (this.enqueuedSummary === undefined
            || this.heuristicData.lastOpSequenceNumber < this.enqueuedSummary.afterSequenceNumber
            || this.summarizingLock !== undefined) {
            // If no enqueued summary is ready or a summary is already in progress, take no action.
            return false;
        }
        const { reason, resultsBuilder, options } = this.enqueuedSummary;
        // Set to undefined first, so that subsequent enqueue attempt while summarize will occur later.
        this.enqueuedSummary = undefined;
        this.trySummarizeOnce({ reason: `enqueuedSummary/${reason}` }, options, this.cancellationToken, resultsBuilder);
        return true;
    }
    disposeEnqueuedSummary() {
        if (this.enqueuedSummary !== undefined) {
            this.enqueuedSummary.resultsBuilder.fail("RunningSummarizer stopped or disposed", undefined);
            this.enqueuedSummary = undefined;
        }
    }
}
exports.RunningSummarizer = RunningSummarizer;

},{"./summarizerHeuristics":79,"./summaryGenerator":83,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],75:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerializedSnapshotStorage = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * A storage wrapper that can serialize blobs from a snapshot tree and then use them to rehydrate.
 * Used in offline load/attached dehydration to save snapshot blobs that are still needed but may have been deleted.
 */
class SerializedSnapshotStorage {
    constructor(storageGetter, blobs) {
        this.storageGetter = storageGetter;
        this.blobs = blobs;
    }
    static async serializeTree(snapshot, storage) {
        const blobs = {};
        await this.serializeTreeCore(snapshot, blobs, storage);
        return blobs;
    }
    static async serializeTreeCore(tree, blobs, storage) {
        const treePs = [];
        for (const subTree of Object.values(tree.trees)) {
            treePs.push(this.serializeTreeCore(subTree, blobs, storage));
        }
        for (const id of Object.values(tree.blobs)) {
            const blob = await storage.readBlob(id);
            // ArrayBufferLike will not survive JSON.stringify()
            blobs[id] = (0, common_utils_1.bufferToString)(blob, "utf8");
        }
        return Promise.all(treePs);
    }
    static serializeTreeWithBlobContents(snapshot) {
        const blobs = {};
        this.serializeTreeWithBlobContentsCore(snapshot, blobs);
        return blobs;
    }
    static serializeTreeWithBlobContentsCore(tree, blobs) {
        for (const subTree of Object.values(tree.trees)) {
            this.serializeTreeWithBlobContentsCore(subTree, blobs);
        }
        for (const id of Object.values(tree.blobs)) {
            const blob = tree.blobsContents[id];
            (0, common_utils_1.assert)(!!blob, 0x2ec /* "Blob must be present in blobsContents" */);
            // ArrayBufferLike will not survive JSON.stringify()
            blobs[id] = (0, common_utils_1.bufferToString)(blob, "utf8");
        }
    }
    get storage() {
        // avoid calling it until we need it since it will be undefined if we're not connected
        // and we shouldn't need it in this case anyway
        if (this._storage) {
            return this._storage;
        }
        this._storage = this.storageGetter();
        return this._storage;
    }
    get repositoryUrl() { return this.storage.repositoryUrl; }
    /**
     * Reads the object with the given ID, returns content in arrayBufferLike
     */
    async readBlob(id) {
        if (this.blobs[id] !== undefined) {
            return (0, common_utils_1.stringToBuffer)(this.blobs[id], "utf8");
        }
        return this.storage.readBlob(id);
    }
    /**
     * Returns the snapshot tree.
     */
    // eslint-disable-next-line @rushstack/no-new-null
    async getSnapshotTree(version) {
        return this.storage.getSnapshotTree(version);
    }
    /**
     * Retrieves all versions of the document starting at the specified versionId - or null if from the head
     */
    // eslint-disable-next-line @rushstack/no-new-null
    async getVersions(versionId, count) {
        return this.storage.getVersions(versionId, count);
    }
    /**
     * Creates a blob out of the given buffer
     */
    async createBlob(file) {
        return this.storage.createBlob(file);
    }
    /**
     * Uploads a summary tree to storage using the given context for reference of previous summary handle.
     * The ISummaryHandles in the uploaded tree should have paths to indicate which summary object they are
     * referencing from the previously acked summary.
     * Returns the uploaded summary handle.
     */
    async uploadSummaryWithContext(summary, context) {
        return this.storage.uploadSummaryWithContext(summary, context);
    }
    /**
     * Retrieves the commit that matches the packfile handle. If the packfile has already been committed and the
     * server has deleted it this call may result in a broken promise.
     */
    async downloadSummary(handle) {
        return this.storage.downloadSummary(handle);
    }
}
exports.SerializedSnapshotStorage = SerializedSnapshotStorage;

},{"@fluidframework/common-utils":29}],76:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Summarizer = exports.createSummarizingWarning = exports.SummarizingWarning = void 0;
const events_1 = require("events");
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const summarizerClientElection_1 = require("./summarizerClientElection");
const summarizerHandle_1 = require("./summarizerHandle");
const runningSummarizer_1 = require("./runningSummarizer");
const summarizerHeuristics_1 = require("./summarizerHeuristics");
const summaryGenerator_1 = require("./summaryGenerator");
const summarizingError = "summarizingError";
class SummarizingWarning extends telemetry_utils_1.LoggingError {
    constructor(errorMessage, logged = false) {
        super(errorMessage);
        this.logged = logged;
        this.errorType = summarizingError;
        this.canRetry = true;
    }
    static wrap(error, logged = false, logger) {
        const newErrorFn = (errMsg) => new SummarizingWarning(errMsg, logged);
        return (0, telemetry_utils_1.wrapErrorAndLog)(error, newErrorFn, logger);
    }
}
exports.SummarizingWarning = SummarizingWarning;
const createSummarizingWarning = (errorMessage, logged) => new SummarizingWarning(errorMessage, logged);
exports.createSummarizingWarning = createSummarizingWarning;
/**
 * Summarizer is responsible for coordinating when to generate and send summaries.
 * It is the main entry point for summary work.
 * It is created only by summarizing container (i.e. one with clientType === "summarizer")
 */
class Summarizer extends events_1.EventEmitter {
    constructor(url, 
    /** Reference to runtime that created this object.
     * i.e. runtime with clientType === "summarizer"
     */
    runtime, configurationGetter, 
    /** Represents an object that can generate summary.
     * In practical terms, it's same runtime (this.runtime) with clientType === "summarizer".
    */
    internalsProvider, handleContext, summaryCollection, runCoordinatorCreateFn) {
        super();
        this.runtime = runtime;
        this.configurationGetter = configurationGetter;
        this.internalsProvider = internalsProvider;
        this.summaryCollection = summaryCollection;
        this.runCoordinatorCreateFn = runCoordinatorCreateFn;
        this._disposed = false;
        this.starting = false;
        this.stopDeferred = new common_utils_1.Deferred();
        this.summarizeOnDemand = (...args) => {
            var _a;
            try {
                if (this._disposed || ((_a = this.runningSummarizer) === null || _a === void 0 ? void 0 : _a.disposed)) {
                    throw new container_utils_1.UsageError("Summarizer is already disposed.");
                }
                if (this.runtime.summarizerClientId !== undefined &&
                    this.runtime.summarizerClientId !== this.runtime.clientId) {
                    // If there is an elected summarizer, and it's not this one, don't allow on-demand summary.
                    // This is to prevent the on-demand summary and heuristic-based summary from stepping on
                    // each other.
                    throw new container_utils_1.UsageError("On-demand summary attempted while an elected summarizer is present");
                }
                const builder = new summaryGenerator_1.SummarizeResultBuilder();
                if (this.runningSummarizer) {
                    // Summarizer is already running. Go ahead and start.
                    return this.runningSummarizer.summarizeOnDemand(builder, ...args);
                }
                // Summarizer isn't running, so we need to start it, which is an async operation.
                // Manage the promise related to creating the cancellation token here.
                // The promises related to starting, summarizing,
                // and submitting are communicated to the caller through the results builder.
                const coordinatorCreateP = this.runCoordinatorCreateFn(this.runtime);
                coordinatorCreateP.then((runCoordinator) => {
                    // Successully created the cancellation token. Start the summarizer.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const startP = this.start(this.runtime.clientId, runCoordinator);
                    startP.then(async (runningSummarizer) => {
                        // Successfully started the summarizer. Run it.
                        runningSummarizer.summarizeOnDemand(builder, ...args);
                        // Wait for a command to stop or loss of connectivity before tearing down the summarizer and client.
                        const stopReason = await Promise.race([this.stopDeferred.promise, runCoordinator.waitCancelled]);
                        await runningSummarizer.waitStop(false);
                        runCoordinator.stop(stopReason);
                        this.close();
                    }).catch((reason) => {
                        builder.fail("Failed to start summarizer", reason);
                    });
                }).catch((reason) => {
                    builder.fail("Failed to create cancellation token", reason);
                });
                return builder.build();
            }
            catch (error) {
                throw SummarizingWarning.wrap(error, false /* logged */, this.logger);
            }
        };
        this.enqueueSummarize = (...args) => {
            if (this._disposed || this.runningSummarizer === undefined || this.runningSummarizer.disposed) {
                throw new container_utils_1.UsageError("Summarizer is not running or already disposed.");
            }
            return this.runningSummarizer.enqueueSummarize(...args);
        };
        this.logger = telemetry_utils_1.ChildLogger.create(this.runtime.logger, "Summarizer");
        this.innerHandle = new summarizerHandle_1.SummarizerHandle(this, url, handleContext);
    }
    get IFluidLoadable() { return this; }
    get ISummarizer() { return this; }
    get handle() { return this.innerHandle; }
    /**
     * Creates a Summarizer and its underlying client.
     * Note that different implementations of ILoader will handle the URL differently.
     * ILoader provided by a ContainerRuntime is a RelativeLoader, which will treat URL's
     * starting with "/" as relative to the Container. The general ILoader
     * interface will expect an absolute URL and will not handle "/".
     * @param loader - the loader that resolves the request
     * @param url - the URL used to resolve the container
     */
    static async create(loader, url) {
        const request = {
            headers: {
                [container_definitions_1.LoaderHeader.cache]: false,
                [container_definitions_1.LoaderHeader.clientDetails]: {
                    capabilities: { interactive: false },
                    type: summarizerClientElection_1.summarizerClientType,
                },
                [driver_definitions_1.DriverHeader.summarizingClient]: true,
                [container_definitions_1.LoaderHeader.reconnect]: false,
            },
            url,
        };
        const resolvedContainer = await loader.resolve(request);
        const fluidObject = await (0, runtime_utils_1.requestFluidObject)(resolvedContainer, { url: "_summarizer" });
        if (fluidObject.ISummarizer === undefined) {
            throw new container_utils_1.UsageError("Fluid object does not implement ISummarizer");
        }
        return fluidObject.ISummarizer;
    }
    async run(onBehalfOf) {
        try {
            return await this.runCore(onBehalfOf);
        }
        catch (error) {
            this.stop("summarizerException");
            throw SummarizingWarning.wrap(error, false /* logged */, this.logger);
        }
        finally {
            this.close();
        }
    }
    /**
     * Stops the summarizer from running.  This will complete
     * the run promise, and also close the container.
     * @param reason - reason code for stopping
     */
    stop(reason) {
        this.stopDeferred.resolve(reason);
    }
    close() {
        // This will result in "summarizerClientDisconnected" stop reason recorded in telemetry,
        // unless stop() was called earlier
        this.dispose();
        this.runtime.closeFn();
    }
    async runCore(onBehalfOf) {
        const runCoordinator = await this.runCoordinatorCreateFn(this.runtime);
        // Wait for either external signal to cancel, or loss of connectivity.
        const stopP = Promise.race([runCoordinator.waitCancelled, this.stopDeferred.promise]);
        void stopP.then((reason) => {
            this.logger.sendTelemetryEvent({
                eventName: "StoppingSummarizer",
                onBehalfOf,
                reason,
            });
        });
        if (runCoordinator.cancelled) {
            return runCoordinator.waitCancelled;
        }
        const runningSummarizer = await this.start(onBehalfOf, runCoordinator);
        // Wait for either external signal to cancel, or loss of connectivity.
        const stopReason = await stopP;
        // There are two possible approaches here:
        // 1. Propagate cancellation from this.stopDeferred to runCoordinator. This will ensure that we move to the exit
        //    faster, including breaking out of the RunningSummarizer.trySummarize() faster.
        //    We could create new coordinator and pass it to waitStop() -> trySummarizeOnce("lastSummary") flow.
        //    The con of this approach is that we might cancel active summary, and lastSummary will fail because it
        //    did not wait for ack/nack from previous summary. Plus we disregard any 429 kind of info from service
        //    that way (i.e. trySummarize() loop might have been waiting for 5 min because storage told us so).
        //    In general, it's more wasted resources.
        // 2. We can not do it and make waitStop() do last summary only if there was no active summary. This ensures
        //    that client behaves properly (from server POV) and we do not waste resources. But, it may mean we wait
        //    substantially longer for trySummarize() retries to play out and thus this summary loop may run into
        //    conflict with new summarizer client starting on different client.
        // As of now, #2 is implemented. It's more forward looking, as issue #7279 suggests changing design for new
        // summarizer client to not be created until current summarizer fully moves to exit, and that would reduce
        // cons of #2 substantially.
        // Cleanup after running
        await runningSummarizer.waitStop(!runCoordinator.cancelled && Summarizer.stopReasonCanRunLastSummary(stopReason));
        // Propagate reason and ensure that if someone is waiting for cancellation token, they are moving to exit
        runCoordinator.stop(stopReason);
        return stopReason;
    }
    /**
     * Should we try to run a last summary for the given stop reason?
     * Currently only allows "parentNotConnected"
     * @param stopReason - SummarizerStopReason
     * @returns - true if the stop reason can run a last summary
     */
    static stopReasonCanRunLastSummary(stopReason) {
        return stopReason === "parentNotConnected";
    }
    /**
     * Put the summarizer in a started state, including creating and initializing the RunningSummarizer.
     * The start request can come either from the SummaryManager (in the auto-summarize case) or from the user
     * (in the on-demand case).
     * @param onBehalfOf - ID of the client that requested that the summarizer start
     * @param runCoordinator - cancellation token
     * @param newConfig - Summary configuration to override the existing config when invoking the RunningSummarizer.
     * @returns - Promise that is fulfilled when the RunningSummarizer is ready
     */
    async start(onBehalfOf, runCoordinator) {
        if (this.runningSummarizer) {
            if (this.runningSummarizer.disposed) {
                throw new container_utils_1.UsageError("Starting a disposed summarizer");
            }
            return this.runningSummarizer;
        }
        if (this.starting) {
            throw new container_utils_1.UsageError("Attempting to start a summarizer that is already starting");
        }
        this.starting = true;
        // Initialize values and first ack (time is not exact)
        this.logger.sendTelemetryEvent({
            eventName: "RunningSummarizer",
            onBehalfOf,
            initSummarySeqNumber: this.runtime.deltaManager.initialSequenceNumber,
            config: JSON.stringify(this.configurationGetter()),
        });
        // Summarizing container ID (with clientType === "summarizer")
        const clientId = this.runtime.clientId;
        if (clientId === undefined) {
            throw new container_utils_1.UsageError("clientId should be defined if connected.");
        }
        const runningSummarizer = await runningSummarizer_1.RunningSummarizer.start(this.logger, this.summaryCollection.createWatcher(clientId), this.configurationGetter(), async (...args) => this.internalsProvider.submitSummary(...args), // submitSummaryCallback
        new summarizerHeuristics_1.SummarizeHeuristicData(this.runtime.deltaManager.lastSequenceNumber, {
            refSequenceNumber: this.runtime.deltaManager.initialSequenceNumber,
            summaryTime: Date.now(),
        }), (errorMessage) => {
            if (!this._disposed) {
                this.logger.sendErrorEvent({ eventName: "summarizingError" }, (0, exports.createSummarizingWarning)(errorMessage, true));
            }
        }, this.summaryCollection, runCoordinator /* cancellationToken */, (reason) => runCoordinator.stop(reason));
        this.runningSummarizer = runningSummarizer;
        this.starting = false;
        // Handle summary acks
        // Note: no exceptions are thrown from handleSummaryAcks handler as it handles all exceptions
        this.handleSummaryAcks().catch((error) => {
            this.logger.sendErrorEvent({ eventName: "HandleSummaryAckFatalError" }, error);
        });
        // Listen for ops
        this.systemOpListener = (op) => runningSummarizer.handleSystemOp(op);
        this.runtime.deltaManager.inbound.on("op", this.systemOpListener);
        this.opListener = (error, op) => runningSummarizer.handleOp(error, op);
        this.runtime.on("batchEnd", this.opListener);
        return runningSummarizer;
    }
    /**
     * Disposes of resources after running.  This cleanup will
     * clear any outstanding timers and reset some of the state
     * properties.
     * Called by ContainerRuntime when it is disposed, as well as at the end the run().
     */
    dispose() {
        // Given that the call can come from own ContainerRuntime, ensure that we stop all the processes.
        this.stop("summarizerClientDisconnected");
        this._disposed = true;
        if (this.runningSummarizer) {
            this.runningSummarizer.dispose();
            this.runningSummarizer = undefined;
        }
        if (this.systemOpListener) {
            this.runtime.deltaManager.inbound.off("op", this.systemOpListener);
        }
        if (this.opListener) {
            this.runtime.removeListener("batchEnd", this.opListener);
        }
    }
    async handleSummaryAcks() {
        var _a, _b, _c, _d, _e;
        let refSequenceNumber = this.runtime.deltaManager.initialSequenceNumber;
        let ack;
        while (this.runningSummarizer) {
            const summaryLogger = (_a = this.runningSummarizer.tryGetCorrelatedLogger(refSequenceNumber)) !== null && _a !== void 0 ? _a : this.logger;
            try {
                // Initialize ack with undefined if exception happens inside of waitSummaryAck on second iteration,
                // we record undefined, not previous handles.
                ack = undefined;
                ack = await this.summaryCollection.waitSummaryAck(refSequenceNumber);
                refSequenceNumber = ack.summaryOp.referenceSequenceNumber;
                const summaryOpHandle = ack.summaryOp.contents.handle;
                const summaryAckHandle = ack.summaryAck.contents.handle;
                // Make sure we block any summarizer from being executed/enqueued while
                // executing the refreshLatestSummaryAck.
                // https://dev.azure.com/fluidframework/internal/_workitems/edit/779
                await this.runningSummarizer.lockedRefreshSummaryAckAction(async () => this.internalsProvider.refreshLatestSummaryAck(summaryOpHandle, summaryAckHandle, refSequenceNumber, summaryLogger).catch(async (error) => {
                    // If the error is 404, so maybe the fetched version no longer exists on server. We just
                    // ignore this error in that case, as that means we will have another summaryAck for the
                    // latest version with which we will refresh the state. However in case of single commit
                    // summary, we might me missing a summary ack, so in that case we are still fine as the
                    // code in `submitSummary` function in container runtime, will refresh the latest state
                    // by calling `refreshLatestSummaryAckFromServer` and we will be fine.
                    if ((0, telemetry_utils_1.isFluidError)(error)
                        && error.errorType === driver_definitions_1.DriverErrorType.fileNotFoundOrAccessDeniedError) {
                        summaryLogger.sendTelemetryEvent({
                            eventName: "HandleSummaryAckErrorIgnored",
                            referenceSequenceNumber: refSequenceNumber,
                            proposalHandle: summaryOpHandle,
                            ackHandle: summaryAckHandle,
                        }, error);
                    }
                    else {
                        throw error;
                    }
                }));
            }
            catch (error) {
                summaryLogger.sendErrorEvent({
                    eventName: "HandleSummaryAckError",
                    referenceSequenceNumber: refSequenceNumber,
                    handle: (_c = (_b = ack === null || ack === void 0 ? void 0 : ack.summaryOp) === null || _b === void 0 ? void 0 : _b.contents) === null || _c === void 0 ? void 0 : _c.handle,
                    ackHandle: (_e = (_d = ack === null || ack === void 0 ? void 0 : ack.summaryAck) === null || _d === void 0 ? void 0 : _d.contents) === null || _e === void 0 ? void 0 : _e.handle,
                }, error);
            }
            refSequenceNumber++;
        }
    }
}
exports.Summarizer = Summarizer;

},{"./runningSummarizer":74,"./summarizerClientElection":77,"./summarizerHandle":78,"./summarizerHeuristics":79,"./summaryGenerator":83,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-definitions":100,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279,"events":562}],77:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummarizerClientElection = exports.summarizerClientType = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
exports.summarizerClientType = "summarizer";
/**
 * This class encapsulates logic around tracking the elected summarizer client.
 * It will handle updating the elected client when a summary ack hasn't been seen
 * for some configured number of ops.
 */
class SummarizerClientElection extends common_utils_1.TypedEventEmitter {
    constructor(logger, summaryCollection, clientElection, maxOpsSinceLastSummary, electionEnabled) {
        super();
        this.logger = logger;
        this.summaryCollection = summaryCollection;
        this.clientElection = clientElection;
        this.maxOpsSinceLastSummary = maxOpsSinceLastSummary;
        this.electionEnabled = electionEnabled;
        /**
         * Used to prevent excess logging by recording the sequence number that we last reported at,
         * and making sure we don't report another event to telemetry. If things work as intended,
         * this is not needed, otherwise it could report an event on every op in worst case scenario.
         */
        this.lastReportedSeq = 0;
        // On every inbound op, if enough ops pass without seeing a summary ack (per elected client),
        // elect a new client and log to telemetry.
        this.summaryCollection.on("default", ({ sequenceNumber }) => {
            var _a, _b, _c;
            const electedClientId = this.electedClientId;
            if (electedClientId === undefined) {
                // Reset election if no elected client, but eligible clients are connected.
                // This should be uncommon, but is possible if the initial state of the
                // ordered client election contains an undefined client id or one not found
                // in the quorum (the latter would already log an error).
                if (this.clientElection.eligibleCount > 0) {
                    this.clientElection.resetElectedClient(sequenceNumber);
                }
                return;
            }
            let electionSequenceNumber = this.clientElection.electionSequenceNumber;
            const opsWithoutSummary = sequenceNumber - ((_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber);
            if (opsWithoutSummary > this.maxOpsSinceLastSummary) {
                // Log and elect a new summarizer client.
                const opsSinceLastReport = sequenceNumber - this.lastReportedSeq;
                if (opsSinceLastReport > this.maxOpsSinceLastSummary) {
                    this.logger.sendErrorEvent({
                        eventName: "ElectedClientNotSummarizing",
                        electedClientId,
                        lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,
                        electionSequenceNumber,
                        nextElectedClientId: (_b = this.clientElection.peekNextElectedClient()) === null || _b === void 0 ? void 0 : _b.clientId,
                        electionEnabled: this.electionEnabled,
                    });
                    this.lastReportedSeq = sequenceNumber;
                }
                if (this.electionEnabled) {
                    const previousParentId = this.electedParentId;
                    this.clientElection.incrementElectedClient(sequenceNumber);
                    // Verify that state incremented as expected. This should be reliable,
                    // since all of OrderedClientElection is synchronous.
                    electionSequenceNumber = this.clientElection.electionSequenceNumber;
                    if (sequenceNumber > ((_c = this.lastSummaryAckSeqForClient) !== null && _c !== void 0 ? _c : electionSequenceNumber)) {
                        if (opsSinceLastReport > this.maxOpsSinceLastSummary) {
                            this.logger.sendErrorEvent({
                                eventName: "UnexpectedElectionSequenceNumber",
                                // Expected to be undefined
                                lastSummaryAckSeqForClient: this.lastSummaryAckSeqForClient,
                                // Expected to be same as op sequenceNumber
                                electionSequenceNumber,
                                sequenceNumber,
                                previousClientId: electedClientId,
                                previousParentId,
                                electedParentId: this.electedParentId,
                                electedClientId: this.electedClientId,
                                opsSinceLastReport,
                                maxOpsSinceLastSummary,
                            });
                        }
                    }
                }
            }
        });
        // When a summary ack comes in, reset our op seq counter.
        this.summaryCollection.on(protocol_definitions_1.MessageType.SummaryAck, (op) => {
            this.lastSummaryAckSeqForClient = op.sequenceNumber;
        });
        // Use oldest client election for unanimously and deterministically deciding
        // which client should summarize.
        this.clientElection.on("election", (client, sequenceNumber) => {
            this.lastSummaryAckSeqForClient = undefined;
            if (client === undefined && this.clientElection.eligibleCount > 0) {
                // If no client is valid for election, reset to the oldest again.
                // Also make extra sure not to get stuck in an infinite loop here:
                // If there are no eligible clients, just wait until a client joins
                // and will be auto-elected.
                this.clientElection.resetElectedClient(sequenceNumber);
            }
            // Election can trigger a change in SummaryManager state.
            this.emit("electedSummarizerChanged");
        });
    }
    get electedClientId() {
        var _a;
        return (_a = this.clientElection.electedClient) === null || _a === void 0 ? void 0 : _a.clientId;
    }
    get electedParentId() {
        var _a;
        return (_a = this.clientElection.electedParent) === null || _a === void 0 ? void 0 : _a.clientId;
    }
    serialize() {
        var _a;
        const { electedClientId, electedParentId, electionSequenceNumber } = this.clientElection.serialize();
        return {
            electedClientId,
            electedParentId,
            electionSequenceNumber: (_a = this.lastSummaryAckSeqForClient) !== null && _a !== void 0 ? _a : electionSequenceNumber,
        };
    }
    static isClientEligible(client) {
        const details = client.client.details;
        if (details === undefined) {
            // Very old clients back-compat
            return true;
        }
        return SummarizerClientElection.clientDetailsPermitElection(details);
    }
}
exports.SummarizerClientElection = SummarizerClientElection;
SummarizerClientElection.clientDetailsPermitElection = (details) => details.capabilities.interactive || details.type === exports.summarizerClientType;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummarizerHandle = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const datastore_1 = require("@fluidframework/datastore");
// TODO #2425 Expose Summarizer handle as FluidObjectHandle w/ tests
class SummarizerHandle extends datastore_1.FluidObjectHandle {
    async get() {
        throw Error("Do not try to get a summarizer object from the handle. Reference it directly.");
    }
    attach() {
        return;
    }
    bind(handle) {
        return;
    }
}
exports.SummarizerHandle = SummarizerHandle;

},{"@fluidframework/datastore":93}],79:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummarizeHeuristicRunner = exports.SummarizeHeuristicData = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/** Simple implementation of class for tracking summarize heuristic data. */
class SummarizeHeuristicData {
    constructor(lastOpSequenceNumber, 
    /** Baseline attempt data used for comparisons with subsequent attempts/calculations. */
    attemptBaseline) {
        this.lastOpSequenceNumber = lastOpSequenceNumber;
        this._lastAttempt = attemptBaseline;
        this._lastSuccessfulSummary = Object.assign({}, attemptBaseline);
    }
    get lastAttempt() {
        return this._lastAttempt;
    }
    get lastSuccessfulSummary() {
        return this._lastSuccessfulSummary;
    }
    updateWithLastSummaryAckInfo(lastSummary) {
        this._lastAttempt = lastSummary;
        this._lastSuccessfulSummary = Object.assign({}, lastSummary);
    }
    recordAttempt(refSequenceNumber) {
        this._lastAttempt = {
            refSequenceNumber: refSequenceNumber !== null && refSequenceNumber !== void 0 ? refSequenceNumber : this.lastOpSequenceNumber,
            summaryTime: Date.now(),
        };
    }
    markLastAttemptAsSuccessful() {
        this._lastSuccessfulSummary = Object.assign({}, this.lastAttempt);
    }
}
exports.SummarizeHeuristicData = SummarizeHeuristicData;
/**
 * This class contains the heuristics for when to summarize.
 */
class SummarizeHeuristicRunner {
    constructor(heuristicData, configuration, trySummarize, logger) {
        this.heuristicData = heuristicData;
        this.configuration = configuration;
        this.trySummarize = trySummarize;
        this.logger = logger;
        this.idleTimer = new common_utils_1.Timer(this.configuration.idleTime, () => this.trySummarize("idle"));
        this.minOpsForLastSummaryAttempt = this.configuration.minOpsForLastSummaryAttempt;
    }
    get opsSinceLastAck() {
        return this.heuristicData.lastOpSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;
    }
    run() {
        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;
        const opsSinceLastAck = this.opsSinceLastAck;
        if (timeSinceLastSummary > this.configuration.maxTime) {
            this.idleTimer.clear();
            this.trySummarize("maxTime");
        }
        else if (opsSinceLastAck > this.configuration.maxOps) {
            this.idleTimer.clear();
            this.trySummarize("maxOps");
        }
        else {
            this.idleTimer.restart();
        }
    }
    shouldRunLastSummary() {
        const opsSinceLastAck = this.opsSinceLastAck;
        const minOpsForLastSummaryAttempt = this.minOpsForLastSummaryAttempt;
        this.logger.sendTelemetryEvent({
            eventName: "ShouldRunLastSummary",
            opsSinceLastAck,
            minOpsForLastSummaryAttempt,
        });
        return opsSinceLastAck >= minOpsForLastSummaryAttempt;
    }
    dispose() {
        this.idleTimer.clear();
    }
}
exports.SummarizeHeuristicRunner = SummarizeHeuristicRunner;

},{"@fluidframework/common-utils":29}],80:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ISummarizer = void 0;
/**
 * @deprecated - This will be removed in a later release.
 */
exports.ISummarizer = "ISummarizer";

},{}],81:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryCollection = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
var SummaryState;
(function (SummaryState) {
    SummaryState[SummaryState["Local"] = 0] = "Local";
    SummaryState[SummaryState["Broadcast"] = 1] = "Broadcast";
    SummaryState[SummaryState["Acked"] = 2] = "Acked";
    SummaryState[SummaryState["Nacked"] = -1] = "Nacked";
})(SummaryState || (SummaryState = {}));
class Summary {
    constructor(clientId, clientSequenceNumber) {
        this.clientId = clientId;
        this.clientSequenceNumber = clientSequenceNumber;
        this.state = SummaryState.Local;
        this.defSummaryOp = new common_utils_1.Deferred();
        this.defSummaryAck = new common_utils_1.Deferred();
    }
    static createLocal(clientId, clientSequenceNumber) {
        return new Summary(clientId, clientSequenceNumber);
    }
    static createFromOp(op) {
        const summary = new Summary(op.clientId, op.clientSequenceNumber);
        summary.broadcast(op);
        return summary;
    }
    get summaryOp() { return this._summaryOp; }
    get summaryAckNack() { return this._summaryAckNack; }
    hasBeenAcked() {
        return this.state === SummaryState.Acked;
    }
    broadcast(op) {
        (0, common_utils_1.assert)(this.state === SummaryState.Local, 0x175 /* "Can only broadcast if summarizer starts in local state" */);
        this._summaryOp = op;
        this.defSummaryOp.resolve();
        this.state = SummaryState.Broadcast;
        return true;
    }
    ackNack(op) {
        (0, common_utils_1.assert)(this.state === SummaryState.Broadcast, 0x176 /* "Can only ack/nack if summarizer is in broadcasting state" */);
        this._summaryAckNack = op;
        this.defSummaryAck.resolve();
        this.state = op.type === protocol_definitions_1.MessageType.SummaryAck ? SummaryState.Acked : SummaryState.Nacked;
        return true;
    }
    async waitBroadcast() {
        await this.defSummaryOp.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryOp;
    }
    async waitAckNack() {
        await this.defSummaryAck.promise;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._summaryAckNack;
    }
}
/**
 * This class watches summaries created by a specific client.
 * It should be created and managed from a SummaryCollection.
 */
class ClientSummaryWatcher {
    constructor(clientId, summaryCollection) {
        this.clientId = clientId;
        this.summaryCollection = summaryCollection;
        // key: clientSeqNum
        this.localSummaries = new Map();
        this._disposed = false;
    }
    get disposed() { return this._disposed; }
    /**
     * Watches for a specific sent summary op.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    watchSummary(clientSequenceNumber) {
        let summary = this.localSummaries.get(clientSequenceNumber);
        if (!summary) {
            summary = Summary.createLocal(this.clientId, clientSequenceNumber);
            this.localSummaries.set(summary.clientSequenceNumber, summary);
        }
        return summary;
    }
    /**
     * Waits until all of the pending summaries in the underlying SummaryCollection
     * are acked/nacked.
     */
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    waitFlushed() {
        return this.summaryCollection.waitFlushed();
    }
    /**
     * Gets a watched summary or returns undefined if not watched.
     * @param clientSequenceNumber - client sequence number of sent summary op
     */
    tryGetSummary(clientSequenceNumber) {
        return this.localSummaries.get(clientSequenceNumber);
    }
    /**
     * Starts watching a summary made by this client.
     * @param summary - summary to start watching
     */
    setSummary(summary) {
        this.localSummaries.set(summary.clientSequenceNumber, summary);
    }
    dispose() {
        this.summaryCollection.removeWatcher(this.clientId);
        this._disposed = true;
    }
}
/**
 * Data structure that looks at the op stream to track summaries as they
 * are broadcast, acked and nacked.
 * It provides functionality for watching specific summaries.
 */
class SummaryCollection extends common_utils_1.TypedEventEmitter {
    constructor(deltaManager, logger) {
        super();
        this.deltaManager = deltaManager;
        this.logger = logger;
        // key: clientId
        this.summaryWatchers = new Map();
        // key: summarySeqNum
        this.pendingSummaries = new Map();
        this.refreshWaitNextAck = new common_utils_1.Deferred();
        this.deltaManager.on("op", (op) => this.handleOp(op));
    }
    get latestAck() { return this.lastAck; }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    get opsSinceLastAck() {
        var _a, _b;
        return this.deltaManager.lastSequenceNumber -
            ((_b = (_a = this.lastAck) === null || _a === void 0 ? void 0 : _a.summaryAck.sequenceNumber) !== null && _b !== void 0 ? _b : this.deltaManager.initialSequenceNumber);
    }
    addOpListener(listener) {
        this.deltaManager.on("op", listener);
    }
    removeOpListener(listener) {
        this.deltaManager.off("op", listener);
    }
    /**
     * Creates and returns a summary watcher for a specific client.
     * This will allow for local sent summaries to be better tracked.
     * @param clientId - client id for watcher
     */
    createWatcher(clientId) {
        const watcher = new ClientSummaryWatcher(clientId, this);
        this.summaryWatchers.set(clientId, watcher);
        return watcher;
    }
    removeWatcher(clientId) {
        this.summaryWatchers.delete(clientId);
    }
    setPendingAckTimerTimeoutCallback(maxAckWaitTime, timeoutCallback) {
        this.maxAckWaitTime = maxAckWaitTime;
        this.pendingAckTimerTimeoutCallback = timeoutCallback;
    }
    unsetPendingAckTimerTimeoutCallback() {
        this.maxAckWaitTime = undefined;
        this.pendingAckTimerTimeoutCallback = undefined;
    }
    /**
     * Returns a promise that resolves once all pending summary ops
     * have been acked or nacked.
     */
    async waitFlushed() {
        while (this.pendingSummaries.size > 0) {
            // eslint-disable-next-line @typescript-eslint/promise-function-async
            const promises = Array.from(this.pendingSummaries, ([, summary]) => summary.waitAckNack());
            await Promise.all(promises);
        }
        return this.lastAck;
    }
    /**
     * Returns a promise that resolves once a summary is acked that has a reference
     * sequence number greater than or equal to the passed in sequence number.
     * @param referenceSequenceNumber - reference sequence number to wait for
     * @returns The latest acked summary
     */
    async waitSummaryAck(referenceSequenceNumber) {
        while (!this.lastAck || this.lastAck.summaryOp.referenceSequenceNumber < referenceSequenceNumber) {
            await this.refreshWaitNextAck.promise;
        }
        return this.lastAck;
    }
    /**
     * Handler for ops; only handles ops relating to summaries.
     * @param op - op message to handle
     */
    handleOp(op) {
        var _a;
        switch (op.type) {
            case protocol_definitions_1.MessageType.Summarize: {
                this.handleSummaryOp(op);
                return;
            }
            case protocol_definitions_1.MessageType.SummaryAck: {
                this.handleSummaryAck(op);
                return;
            }
            case protocol_definitions_1.MessageType.SummaryNack: {
                this.handleSummaryNack(op);
                return;
            }
            default: {
                // If the difference between timestamp of current op and last summary op is greater than
                // the maxAckWaitTime, then we need to inform summarizer to not wait and summarize
                // immediately as we have already waited for maxAckWaitTime.
                const lastOpTimestamp = op.timestamp;
                if (this.lastSummaryTimestamp !== undefined &&
                    this.maxAckWaitTime !== undefined &&
                    lastOpTimestamp - this.lastSummaryTimestamp >= this.maxAckWaitTime) {
                    (_a = this.pendingAckTimerTimeoutCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                this.emit("default", op);
                return;
            }
        }
    }
    handleSummaryOp(op) {
        let summary;
        // Check if summary already being watched, broadcast if so
        const watcher = this.summaryWatchers.get(op.clientId);
        if (watcher) {
            summary = watcher.tryGetSummary(op.clientSequenceNumber);
            if (summary) {
                summary.broadcast(op);
            }
        }
        // If not watched, create from op
        if (!summary) {
            summary = Summary.createFromOp(op);
            if (watcher) {
                watcher.setSummary(summary);
            }
        }
        this.pendingSummaries.set(op.sequenceNumber, summary);
        this.lastSummaryTimestamp = op.timestamp;
        this.emit(protocol_definitions_1.MessageType.Summarize, op);
    }
    handleSummaryAck(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (!summary || summary.summaryOp === undefined) {
            // Summary ack without an op should be rare. We could fetch the
            // reference sequence number from the snapshot, but instead we
            // will not emit this ack. It should be the case that the summary
            // op that this ack is for is earlier than this file was loaded
            // from. i.e. initialSequenceNumber > summarySequenceNumber.
            // We really don't care about it for now, since it is older than
            // the one we loaded from.
            if (seq >= this.deltaManager.initialSequenceNumber) {
                // Potential causes for it to be later than our initialSequenceNumber
                // are that the summaryOp was nacked then acked, double-acked, or
                // the summarySequenceNumber is incorrect.
                this.logger.sendErrorEvent({
                    eventName: "SummaryAckWithoutOp",
                    sequenceNumber: op.sequenceNumber,
                    summarySequenceNumber: seq,
                    initialSequenceNumber: this.deltaManager.initialSequenceNumber,
                });
            }
            return;
        }
        summary.ackNack(op);
        this.pendingSummaries.delete(seq);
        // Track latest ack
        if (!this.lastAck || seq > this.lastAck.summaryAck.contents.summaryProposal.summarySequenceNumber) {
            this.lastAck = {
                summaryOp: summary.summaryOp,
                summaryAck: op,
            };
            this.refreshWaitNextAck.resolve();
            this.refreshWaitNextAck = new common_utils_1.Deferred();
            this.emit(protocol_definitions_1.MessageType.SummaryAck, op);
        }
    }
    handleSummaryNack(op) {
        const seq = op.contents.summaryProposal.summarySequenceNumber;
        const summary = this.pendingSummaries.get(seq);
        if (summary) {
            summary.ackNack(op);
            this.pendingSummaries.delete(seq);
            this.emit(protocol_definitions_1.MessageType.SummaryNack, op);
        }
    }
}
exports.SummaryCollection = SummaryCollection;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174}],82:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFluidDataStoreAttributes = exports.wrapSummaryInChannelsTree = exports.dataStoreAttributesBlobName = exports.nonDataStorePaths = exports.protocolTreeName = exports.getGCVersion = exports.rootHasIsolatedChannels = exports.blobsTreeName = exports.electedSummarizerBlobName = exports.chunksBlobName = exports.metadataBlobName = exports.aliasBlobName = exports.getMetadataFormatVersion = exports.extractSummaryMetadataMessage = exports.hasIsolatedChannels = exports.getAttributesFormatVersion = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const garbageCollection_1 = require("./garbageCollection");
function getAttributesFormatVersion(attributes) {
    if (attributes.summaryFormatVersion) {
        /**
         * Version 2+: Introduces .channels trees for isolation of
         * channel trees from data store objects.
         */
        return attributes.summaryFormatVersion;
    }
    else if (attributes.snapshotFormatVersion === "0.1") {
        /**
         * Version 1: from this version the pkg within the data store
         * attributes blob is a JSON array rather than a string.
         */
        return 1;
    }
    /**
     * Version 0: format version is missing from summary.
     * This indicates it is an older version.
     */
    return 0;
}
exports.getAttributesFormatVersion = getAttributesFormatVersion;
function hasIsolatedChannels(attributes) {
    return !!attributes.summaryFormatVersion && !attributes.disableIsolatedChannels;
}
exports.hasIsolatedChannels = hasIsolatedChannels;
/**
 * Extracts the properties from an ISequencedDocumentMessage as defined by ISummaryMetadataMessage. This message is
 * added to the metadata blob in summary.
 */
const extractSummaryMetadataMessage = (message) => message === undefined ? undefined : {
    clientId: message.clientId,
    clientSequenceNumber: message.clientSequenceNumber,
    minimumSequenceNumber: message.minimumSequenceNumber,
    referenceSequenceNumber: message.referenceSequenceNumber,
    sequenceNumber: message.sequenceNumber,
    timestamp: message.timestamp,
    type: message.type,
};
exports.extractSummaryMetadataMessage = extractSummaryMetadataMessage;
function getMetadataFormatVersion(metadata) {
    var _a;
    /**
     * Version 2+: Introduces runtime sequence number for data verification.
     *
     * Version 1+: Introduces .metadata blob and .channels trees for isolation of
     * data store trees from container-level objects.
     * Also introduces enableGC option stored in the summary.
     *
     * Version 0: metadata blob missing; format version is missing from summary.
     * This indicates it is an older version.
     */
    return (_a = metadata === null || metadata === void 0 ? void 0 : metadata.summaryFormatVersion) !== null && _a !== void 0 ? _a : 0;
}
exports.getMetadataFormatVersion = getMetadataFormatVersion;
exports.aliasBlobName = ".aliases";
exports.metadataBlobName = ".metadata";
exports.chunksBlobName = ".chunks";
exports.electedSummarizerBlobName = ".electedSummarizer";
exports.blobsTreeName = ".blobs";
function rootHasIsolatedChannels(metadata) {
    return !!metadata && !metadata.disableIsolatedChannels;
}
exports.rootHasIsolatedChannels = rootHasIsolatedChannels;
function getGCVersion(metadata) {
    var _a;
    if (!metadata) {
        // Force to 0/disallowed in prior versions
        return 0;
    }
    return (_a = metadata.gcFeature) !== null && _a !== void 0 ? _a : 0;
}
exports.getGCVersion = getGCVersion;
exports.protocolTreeName = ".protocol";
/**
 * List of tree IDs at the container level which are reserved.
 * This is for older versions of summaries that do not yet have an
 * isolated data stores namespace. Without the namespace, this must
 * be used to prevent name collisions with data store IDs.
 */
exports.nonDataStorePaths = [exports.protocolTreeName, ".logTail", ".serviceProtocol", exports.blobsTreeName, garbageCollection_1.gcTreeKey];
exports.dataStoreAttributesBlobName = ".component";
/**
 * Modifies summary tree and stats to put tree under .channels tree.
 *
 * @param summarizeResult - Summary tree and stats to modify
 *
 * @example
 * Converts from:
 * ```typescript
 * {
 *     type: SummaryType.Tree,
 *     tree: { a: {...}, b: {...}, c: {...} },
 * }
 * ```
 *
 * to:
 *
 * ```typescript
 * {
 *     type: SummaryType.Tree,
 *     tree: {
 *         ".channels": {
 *             type: SummaryType.Tree,
 *             tree: { a: {...}, b: {...}, c: {...} }
 *         },
 *     },
 * }
 * ```
 * And adds +1 to treeNodeCount in stats.
 */
function wrapSummaryInChannelsTree(summarizeResult) {
    summarizeResult.summary = {
        type: protocol_definitions_1.SummaryType.Tree,
        tree: { [runtime_definitions_1.channelsTreeName]: summarizeResult.summary },
    };
    summarizeResult.stats.treeNodeCount++;
}
exports.wrapSummaryInChannelsTree = wrapSummaryInChannelsTree;
async function getFluidDataStoreAttributes(storage, snapshot) {
    const attributes = await (0, driver_utils_1.readAndParse)(storage, snapshot.blobs[exports.dataStoreAttributesBlobName]);
    // Use the snapshotFormatVersion to determine how the pkg is encoded in the snapshot.
    // For snapshotFormatVersion = "0.1" (1) or above, pkg is jsonified, otherwise it is just a string.
    // However the feature of loading a detached container from snapshot, is added when the
    // snapshotFormatVersion is at least "0.1" (1), so we don't expect it to be anything else.
    const formatVersion = getAttributesFormatVersion(attributes);
    (0, common_utils_1.assert)(formatVersion > 0, 0x1d5 /* Invalid snapshot format version */);
    return attributes;
}
exports.getFluidDataStoreAttributes = getFluidDataStoreAttributes;

},{"./garbageCollection":67,"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208}],83:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryGenerator = exports.SummarizeResultBuilder = exports.raceTimer = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
/** Helper function to wait for a promise or PromiseTimer to elapse. */
async function raceTimer(promise, timer, cancellationToken) {
    const promises = [
        promise.then((value) => ({ result: "done", value })),
        timer.then(({ timerResult: result }) => ({ result })),
    ];
    if (cancellationToken !== undefined) {
        promises.push(cancellationToken.waitCancelled.then(() => ({ result: "cancelled" })));
    }
    return Promise.race(promises);
}
exports.raceTimer = raceTimer;
// Send some telemetry if generate summary takes too long
const maxSummarizeTimeoutTime = 20000; // 20 sec
const maxSummarizeTimeoutCount = 5; // Double and resend 5 times
const summarizeErrors = {
    /**
     * Error encountered while generating the summary tree, uploading
     * it to storage, or submitting the op. It could be a result of
     * the client becoming disconnected while generating or an actual error.
     */
    submitSummaryFailure: "Error while generating, uploading, or submitting summary",
    /**
     * The summaryAckWaitTimeout time has elapsed before receiving the summarize op
     * sent by this summarize attempt. It is expected to be broadcast quickly.
     */
    summaryOpWaitTimeout: "Timeout while waiting for summarize op broadcast",
    /**
     * The summaryAckWaitTimeout time has elapsed before receiving either a
     * summaryAck or summaryNack op from the server in response to this
     * summarize attempt. It is expected that the server should respond.
     */
    summaryAckWaitTimeout: "Timeout while waiting for summaryAck/summaryNack op",
    /**
     * The server responded with a summaryNack op, thus rejecting this
     * summarize attempt.
     */
    summaryNack: "Server rejected summary via summaryNack op",
    disconnect: "Summary cancelled due to summarizer or main client disconnect",
};
class SummarizeResultBuilder {
    constructor() {
        this.summarySubmitted = new common_utils_1.Deferred();
        this.summaryOpBroadcasted = new common_utils_1.Deferred();
        this.receivedSummaryAckOrNack = new common_utils_1.Deferred();
    }
    fail(message, error, nackSummaryResult, retryAfterSeconds) {
        (0, common_utils_1.assert)(!this.receivedSummaryAckOrNack.isCompleted, 0x25e /* "no reason to call fail if all promises have been completed" */);
        const result = { success: false, message, data: undefined, error, retryAfterSeconds };
        this.summarySubmitted.resolve(result);
        this.summaryOpBroadcasted.resolve(result);
        this.receivedSummaryAckOrNack.resolve(Object.assign(Object.assign({}, result), { data: nackSummaryResult }));
    }
    build() {
        return {
            summarySubmitted: this.summarySubmitted.promise,
            summaryOpBroadcasted: this.summaryOpBroadcasted.promise,
            receivedSummaryAckOrNack: this.receivedSummaryAckOrNack.promise,
        };
    }
}
exports.SummarizeResultBuilder = SummarizeResultBuilder;
/**
 * This class generates and tracks a summary attempt.
 */
class SummaryGenerator {
    constructor(pendingAckTimer, heuristicData, submitSummaryCallback, raiseSummarizingError, successfulSummaryCallback, summaryWatcher, logger) {
        this.pendingAckTimer = pendingAckTimer;
        this.heuristicData = heuristicData;
        this.submitSummaryCallback = submitSummaryCallback;
        this.raiseSummarizingError = raiseSummarizingError;
        this.successfulSummaryCallback = successfulSummaryCallback;
        this.summaryWatcher = summaryWatcher;
        this.logger = logger;
        this.summarizeTimer = new common_utils_1.Timer(maxSummarizeTimeoutTime, () => this.summarizeTimerHandler(maxSummarizeTimeoutTime, 1));
    }
    /**
     * Generates summary and listens for broadcast and ack/nack.
     * Returns true for ack, false for nack, and undefined for failure or timeout.
     * @param reason - reason for summarizing
     * @param options - refreshLatestAck to fetch summary ack info from server,
     * fullTree to generate tree without any summary handles even if unchanged
     */
    summarize(summarizeProps, options, cancellationToken, resultsBuilder = new SummarizeResultBuilder()) {
        this.summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken)
            .catch((error) => {
            const message = "UnexpectedSummarizeError";
            this.logger.sendErrorEvent(Object.assign({ eventName: message }, summarizeProps), error);
            resultsBuilder.fail(message, error);
        });
        return resultsBuilder.build();
    }
    async summarizeCore(summarizeProps, options, resultsBuilder, cancellationToken) {
        const { refreshLatestAck, fullTree } = options;
        const logger = telemetry_utils_1.ChildLogger.create(this.logger, undefined, { all: summarizeProps });
        // Note: timeSinceLastAttempt and timeSinceLastSummary for the
        // first summary are basically the time since the summarizer was loaded.
        const timeSinceLastAttempt = Date.now() - this.heuristicData.lastAttempt.summaryTime;
        const timeSinceLastSummary = Date.now() - this.heuristicData.lastSuccessfulSummary.summaryTime;
        let summarizeTelemetryProps = {
            fullTree,
            timeSinceLastAttempt,
            timeSinceLastSummary,
        };
        const summarizeEvent = telemetry_utils_1.PerformanceEvent.start(logger, Object.assign({ eventName: "Summarize", refreshLatestAck }, summarizeTelemetryProps));
        // Helper functions to report failures and return.
        const getFailMessage = (errorCode) => `${errorCode}: ${summarizeErrors[errorCode]}`;
        const fail = (errorCode, error, properties, nackSummaryResult) => {
            this.raiseSummarizingError(summarizeErrors[errorCode]);
            // UploadSummary may fail with 429 and retryAfter - respect that
            // Summary Nack also can have retryAfter, it's parsed below and comes as a property.
            const retryAfterSeconds = (0, driver_utils_1.getRetryDelaySecondsFromError)(error);
            // Report any failure as an error unless it was due to cancellation (like "disconnected" error)
            // If failure happened on upload, we may not yet realized that socket disconnected, so check
            // offlineError too.
            const category = cancellationToken.cancelled || (error === null || error === void 0 ? void 0 : error.errorType) === driver_definitions_1.DriverErrorType.offlineError ?
                "generic" : "error";
            summarizeEvent.cancel(Object.assign(Object.assign({}, properties), { reason: errorCode, category,
                retryAfterSeconds }), error);
            resultsBuilder.fail(getFailMessage(errorCode), error, nackSummaryResult, retryAfterSeconds);
        };
        // Wait to generate and send summary
        this.summarizeTimer.start();
        // Use record type to prevent unexpected value types
        let summaryData;
        try {
            summaryData = await this.submitSummaryCallback({
                fullTree,
                refreshLatestAck,
                summaryLogger: logger,
                cancellationToken,
            });
            // Cumulatively add telemetry properties based on how far generateSummary went.
            const referenceSequenceNumber = summaryData.referenceSequenceNumber;
            const opsSinceLastSummary = referenceSequenceNumber - this.heuristicData.lastSuccessfulSummary.refSequenceNumber;
            summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { referenceSequenceNumber, minimumSequenceNumber: summaryData.minimumSequenceNumber, opsSinceLastAttempt: referenceSequenceNumber - this.heuristicData.lastAttempt.refSequenceNumber, opsSinceLastSummary });
            if (summaryData.stage !== "base") {
                summarizeTelemetryProps = Object.assign(Object.assign(Object.assign({}, summarizeTelemetryProps), summaryData.summaryStats), { generateDuration: summaryData.generateDuration });
                if (summaryData.stage !== "generate") {
                    summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: summaryData.handle, uploadDuration: summaryData.uploadDuration });
                    if (summaryData.stage !== "upload") {
                        summarizeTelemetryProps = Object.assign(Object.assign({}, summarizeTelemetryProps), { clientSequenceNumber: summaryData.clientSequenceNumber });
                    }
                }
            }
            if (summaryData.stage !== "submit") {
                return fail("submitSummaryFailure", summaryData.error, summarizeTelemetryProps);
            }
            /**
             * With incremental summaries, if the full tree was not summarized, only data stores that changed should
             * be summarized. A data store is considered changed if either or both of the following is true:
             * - It has received an op.
             * - Its reference state changed, i.e., it went from referenced to unreferenced or vice-versa.
             *
             * In the extreme case, every op can be for a different data store and each op can result in the reference
             * state change of multiple data stores. So, the total number of data stores that are summarized should not
             * exceed the number of ops since last summary + number of data store whose reference state changed.
             */
            if (!fullTree && !summaryData.forcedFullTree) {
                const { summarizedDataStoreCount, gcStateUpdatedDataStoreCount = 0 } = summaryData.summaryStats;
                if (summarizedDataStoreCount > gcStateUpdatedDataStoreCount + opsSinceLastSummary) {
                    logger.sendErrorEvent({
                        eventName: "IncrementalSummaryViolation",
                        summarizedDataStoreCount,
                        gcStateUpdatedDataStoreCount,
                        opsSinceLastSummary,
                    });
                }
            }
            // Log event here on summary success only, as Summarize_cancel duplicates failure logging.
            summarizeEvent.reportEvent("generate", Object.assign({}, summarizeTelemetryProps));
            resultsBuilder.summarySubmitted.resolve({ success: true, data: summaryData });
        }
        catch (error) {
            return fail("submitSummaryFailure", error);
        }
        finally {
            this.heuristicData.recordAttempt(summaryData === null || summaryData === void 0 ? void 0 : summaryData.referenceSequenceNumber);
            this.summarizeTimer.clear();
        }
        try {
            const pendingTimeoutP = this.pendingAckTimer.start();
            const summary = this.summaryWatcher.watchSummary(summaryData.clientSequenceNumber);
            // Wait for broadcast
            const waitBroadcastResult = await raceTimer(summary.waitBroadcast(), pendingTimeoutP, cancellationToken);
            if (waitBroadcastResult.result === "cancelled") {
                return fail("disconnect");
            }
            if (waitBroadcastResult.result !== "done") {
                return fail("summaryOpWaitTimeout");
            }
            const summarizeOp = waitBroadcastResult.value;
            const broadcastDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;
            resultsBuilder.summaryOpBroadcasted.resolve({
                success: true,
                data: { summarizeOp, broadcastDuration },
            });
            this.heuristicData.lastAttempt.summarySequenceNumber = summarizeOp.sequenceNumber;
            logger.sendTelemetryEvent({
                eventName: "Summarize_Op",
                duration: broadcastDuration,
                referenceSequenceNumber: summarizeOp.referenceSequenceNumber,
                summarySequenceNumber: summarizeOp.sequenceNumber,
                handle: summarizeOp.contents.handle,
            });
            // Wait for ack/nack
            const waitAckNackResult = await raceTimer(summary.waitAckNack(), pendingTimeoutP, cancellationToken);
            if (waitAckNackResult.result === "cancelled") {
                return fail("disconnect");
            }
            if (waitAckNackResult.result !== "done") {
                return fail("summaryAckWaitTimeout");
            }
            const ackNackOp = waitAckNackResult.value;
            this.pendingAckTimer.clear();
            // Update for success/failure
            const ackNackDuration = Date.now() - this.heuristicData.lastAttempt.summaryTime;
            // adding new properties
            summarizeTelemetryProps = Object.assign({ ackWaitDuration: ackNackDuration, ackNackSequenceNumber: ackNackOp.sequenceNumber, summarySequenceNumber: ackNackOp.contents.summaryProposal.summarySequenceNumber }, summarizeTelemetryProps);
            if (ackNackOp.type === protocol_definitions_1.MessageType.SummaryAck) {
                this.heuristicData.markLastAttemptAsSuccessful();
                this.successfulSummaryCallback();
                summarizeEvent.end(Object.assign(Object.assign({}, summarizeTelemetryProps), { handle: ackNackOp.contents.handle }));
                resultsBuilder.receivedSummaryAckOrNack.resolve({ success: true, data: {
                        summaryAckOp: ackNackOp,
                        ackNackDuration,
                    } });
            }
            else {
                // Check for retryDelay in summaryNack response.
                (0, common_utils_1.assert)(ackNackOp.type === protocol_definitions_1.MessageType.SummaryNack, 0x274 /* "type check" */);
                const summaryNack = ackNackOp.contents;
                const message = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.message;
                const retryAfterSeconds = summaryNack === null || summaryNack === void 0 ? void 0 : summaryNack.retryAfter;
                // pre-0.58 error message prefix: summaryNack
                const error = new telemetry_utils_1.LoggingError(`Received summaryNack: ${message}`, { retryAfterSeconds });
                (0, common_utils_1.assert)((0, driver_utils_1.getRetryDelaySecondsFromError)(error) === retryAfterSeconds, 0x25f /* "retryAfterSeconds" */);
                // This will only set resultsBuilder.receivedSummaryAckOrNack, as other promises are already set.
                return fail("summaryNack", error, Object.assign(Object.assign({}, summarizeTelemetryProps), { nackRetryAfter: retryAfterSeconds }), { summaryNackOp: ackNackOp, ackNackDuration });
            }
        }
        finally {
            this.pendingAckTimer.clear();
        }
    }
    summarizeTimerHandler(time, count) {
        this.logger.sendPerformanceEvent({
            eventName: "SummarizeTimeout",
            timeoutTime: time,
            timeoutCount: count,
        });
        if (count < maxSummarizeTimeoutCount) {
            // Double and start a new timer
            const nextTime = time * 2;
            this.summarizeTimer.start(nextTime, () => this.summarizeTimerHandler(nextTime, count + 1));
        }
    }
    dispose() {
        this.summarizeTimer.clear();
    }
}
exports.SummaryGenerator = SummaryGenerator;

},{"@fluidframework/common-utils":29,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],84:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryManager = exports.SummaryManagerState = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const defaultInitialDelayMs = 5000;
const defaultOpsToBypassInitialDelay = 4000;
var SummaryManagerState;
(function (SummaryManagerState) {
    SummaryManagerState[SummaryManagerState["Off"] = 0] = "Off";
    SummaryManagerState[SummaryManagerState["Starting"] = 1] = "Starting";
    SummaryManagerState[SummaryManagerState["Running"] = 2] = "Running";
    SummaryManagerState[SummaryManagerState["Stopping"] = 3] = "Stopping";
})(SummaryManagerState = exports.SummaryManagerState || (exports.SummaryManagerState = {}));
/**
 * SummaryManager is created by parent container (i.e. interactive container with clientType !== "summarizer") only.
 * It observes changes in calculated summarizer and reacts to changes by either creating summarizer client or
 * stopping existing summarizer client.
 */
class SummaryManager {
    constructor(clientElection, connectedState, summaryCollection, parentLogger, 
    /** Creates summarizer by asking interactive container to spawn summarizing container and
     * get back its Summarizer instance. */
    requestSummarizerFn, startThrottler, { initialDelayMs = defaultInitialDelayMs, opsToBypassInitialDelay = defaultOpsToBypassInitialDelay, } = {}, disableHeuristics) {
        this.clientElection = clientElection;
        this.connectedState = connectedState;
        this.summaryCollection = summaryCollection;
        this.requestSummarizerFn = requestSummarizerFn;
        this.startThrottler = startThrottler;
        this.disableHeuristics = disableHeuristics;
        this.state = SummaryManagerState.Off;
        this._disposed = false;
        this.handleConnected = (clientId) => {
            this.latestClientId = clientId;
            // If we have a summarizer, it should have been either cancelled on disconnected by now.
            // But because of lastSummary process, it can still hang around, so there is not much we can
            // check or assert.
            this.refreshSummarizer();
        };
        this.handleDisconnected = () => {
            this.refreshSummarizer();
        };
        this.refreshSummarizer = () => {
            // Transition states depending on shouldSummarize, which is a calculated property
            // that is only true if this client is connected and is the elected summarizer.
            const shouldSummarizeState = this.getShouldSummarizeState();
            switch (this.state) {
                case SummaryManagerState.Off: {
                    if (shouldSummarizeState.shouldSummarize) {
                        this.startSummarization();
                    }
                    return;
                }
                case SummaryManagerState.Starting: {
                    // Cannot take any action until summarizer is created
                    // state transition will occur after creation
                    return;
                }
                case SummaryManagerState.Running: {
                    if (shouldSummarizeState.shouldSummarize === false) {
                        this.stop(shouldSummarizeState.stopReason);
                    }
                    return;
                }
                case SummaryManagerState.Stopping: {
                    // Cannot take any action until running summarizer finishes
                    // state transition will occur after it stops
                    return;
                }
                default: {
                    return;
                }
            }
        };
        this.summarizeOnDemand = (...args) => {
            if (this.summarizer === undefined) {
                throw Error("No running summarizer client");
                // TODO: could spawn a summarizer client temporarily.
            }
            return this.summarizer.summarizeOnDemand(...args);
        };
        this.enqueueSummarize = (...args) => {
            if (this.summarizer === undefined) {
                throw Error("No running summarizer client");
                // TODO: could spawn a summarizer client temporarily.
            }
            return this.summarizer.enqueueSummarize(...args);
        };
        this.logger = telemetry_utils_1.ChildLogger.create(parentLogger, "SummaryManager", { all: { clientId: () => this.latestClientId } });
        this.connectedState.on("connected", this.handleConnected);
        this.connectedState.on("disconnected", this.handleDisconnected);
        this.latestClientId = this.connectedState.clientId;
        this.opsToBypassInitialDelay = opsToBypassInitialDelay;
        this.initialDelayMs = initialDelayMs;
    }
    get disposed() {
        return this._disposed;
    }
    get currentState() { return this.state; }
    /**
     * Until start is called, the SummaryManager won't begin attempting to start summarization.  This ensures there's
     * a window between construction and starting where the caller can attach listeners.
     */
    start() {
        this.clientElection.on("electedSummarizerChanged", this.refreshSummarizer);
        this.refreshSummarizer();
    }
    getShouldSummarizeState() {
        // Note that if we're in the Running state, the electedClient may be a summarizer client, so we can't
        // enforce connectedState.clientId === clientElection.electedClientId. But once we're Running, we should
        // only transition to Stopping when the electedParentId changes. Stopping the summarizer without
        // changing the electedParent will just cause us to transition to Starting again.
        if (this.connectedState.clientId !== this.clientElection.electedParentId ||
            (this.state !== SummaryManagerState.Running &&
                this.connectedState.clientId !== this.clientElection.electedClientId)) {
            return { shouldSummarize: false, stopReason: "parentShouldNotSummarize" };
        }
        else if (!this.connectedState.connected) {
            return { shouldSummarize: false, stopReason: "parentNotConnected" };
        }
        else if (this.disposed) {
            (0, common_utils_1.assert)(false, 0x260 /* "Disposed should mean disconnected!" */);
        }
        else {
            return { shouldSummarize: true };
        }
    }
    startSummarization() {
        (0, common_utils_1.assert)(this.state === SummaryManagerState.Off, 0x261 /* "Expected: off" */);
        this.state = SummaryManagerState.Starting;
        (0, common_utils_1.assert)(this.summarizer === undefined, 0x262 /* "Old summarizer is still working!" */);
        this.delayBeforeCreatingSummarizer().then(async (startWithInitialDelay) => {
            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore
            // but only if creation was delayed. If it was not, then we want to ensure we always create
            // a summarizer to kick off lastSummary. Without that, we would not be able to summarize and get
            // document out of broken state if it has too many ops and ordering service keeps nacking main
            // container (and thus it goes into cycle of reconnects)
            if (startWithInitialDelay && this.getShouldSummarizeState().shouldSummarize === false) {
                return "early exit";
            }
            // We transition to Running before requesting the summarizer, because after requesting we can't predict
            // when the electedClient will be replaced with the new summarizer client.
            // The alternative would be to let connectedState.clientId !== clientElection.electedClientId when
            // state === Starting || state === Running.
            (0, common_utils_1.assert)(this.state === SummaryManagerState.Starting, 0x263 /* "Expected: starting" */);
            this.state = SummaryManagerState.Running;
            const summarizer = await this.requestSummarizerFn();
            this.summarizer = summarizer;
            // Re-validate that it need to be running. Due to asynchrony, it may be not the case anymore
            const shouldSummarizeState = this.getShouldSummarizeState();
            if (shouldSummarizeState.shouldSummarize === false) {
                this.state = SummaryManagerState.Starting;
                summarizer.stop(shouldSummarizeState.stopReason);
                return "early exit after starting summarizer";
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const clientId = this.latestClientId;
            return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, { eventName: "RunningSummarizer", attempt: this.startThrottler.numAttempts }, async () => summarizer.run(clientId, this.disableHeuristics));
        }).then((reason) => {
            this.logger.sendTelemetryEvent({
                eventName: "EndingSummarizer",
                reason,
            });
        }).catch((error) => {
            this.logger.sendTelemetryEvent({
                eventName: "EndingSummarizer",
                reason: "exception",
            }, error);
            // Most of exceptions happen due to container being closed while loading it, due to
            // summarizer container loosing connection while load.
            // Not worth reporting such errors as errors. That said, we might miss some real errors if
            // we ignore blindly, so try to narrow signature we are looking for - skip logging
            // error only if this client should no longer be a summarizer (which in practice
            // means it also lost connection), and error happened on load (we do not have summarizer).
            // We could annotate the error raised in Container.load where the container closed during load with no error
            // and check for that case here, but that does not seem to be necessary.
            if (this.getShouldSummarizeState().shouldSummarize || this.summarizer !== undefined) {
                // Report any failure as an error unless it was due to cancellation (like "disconnected" error)
                // If failure happened on container load, we may not yet realized that socket disconnected, so check
                // offlineError.
                const category = (error === null || error === void 0 ? void 0 : error.errorType) === driver_definitions_1.DriverErrorType.offlineError ? "generic" : "error";
                this.logger.sendTelemetryEvent({
                    eventName: "SummarizerException",
                    category,
                }, error);
            }
        }).finally(() => {
            var _a;
            (0, common_utils_1.assert)(this.state !== SummaryManagerState.Off, 0x264 /* "Expected: Not Off" */);
            this.state = SummaryManagerState.Off;
            (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.close();
            this.summarizer = undefined;
            if (this.getShouldSummarizeState().shouldSummarize) {
                this.startSummarization();
            }
        });
    }
    stop(reason) {
        var _a;
        if (!SummaryManager.isStartingOrRunning(this.state)) {
            return;
        }
        this.state = SummaryManagerState.Stopping;
        // Stopping the running summarizer client should trigger a change
        // in states when the running summarizer closes
        (_a = this.summarizer) === null || _a === void 0 ? void 0 : _a.stop(reason);
    }
    /**
     * Implements initial delay before creating summarizer
     * @returns true, if creation is delayed due to heuristics (not many ops to summarize).
     *          False if summarizer should start immediately due to too many unsummarized ops.
     */
    async delayBeforeCreatingSummarizer() {
        // throttle creation of new summarizer containers to prevent spamming the server with websocket connections
        let delayMs = this.startThrottler.getDelay();
        // We have been elected the summarizer. Some day we may be able to summarize with a live document but for
        // now we play it safe and launch a second copy.
        this.logger.sendTelemetryEvent({
            eventName: "CreatingSummarizer",
            throttlerDelay: delayMs,
            initialDelay: this.initialDelayMs,
            startThrottlerMaxDelayMs: this.startThrottler.maxDelayMs,
            opsSinceLastAck: this.summaryCollection.opsSinceLastAck,
            opsToBypassInitialDelay: this.opsToBypassInitialDelay,
        });
        // This delay helps ensure that last summarizer that might be left from previous client
        // has enough time to complete its last summary and thus new summarizer not conflict with previous one.
        // If, however, there are too many unsummarized ops, try to resolve it as quickly as possible, with
        // understanding that we may see nacks because of such quick action.
        // A better design would be for summarizer election logic to always select current summarizer as
        // summarizing client (i.e. clientType === "summarizer" can be elected) to ensure that nobody else can
        // summarizer while it finishes its work and moves to exit.
        // It also helps with pure boot scenario (single client) to offset expensive work a bit out from
        // critical boot sequence.
        let startWithInitialDelay = false;
        if (this.summaryCollection.opsSinceLastAck < this.opsToBypassInitialDelay) {
            startWithInitialDelay = true;
            delayMs = Math.max(delayMs, this.initialDelayMs);
        }
        if (delayMs > 0) {
            let timer;
            let resolveOpPromiseFn;
            // Create a listener that will break the delay if we've exceeded the initial delay ops count.
            const opsListenerFn = () => {
                if (this.summaryCollection.opsSinceLastAck >= this.opsToBypassInitialDelay) {
                    clearTimeout(timer);
                    resolveOpPromiseFn();
                }
            };
            // Create a Promise that will resolve when the delay expires.
            const delayPromise = new Promise((resolve) => {
                timer = setTimeout(() => resolve(), delayMs);
            });
            // Create a Promise that will resolve if the ops count passes the threshold.
            const opPromise = new Promise((resolve) => { resolveOpPromiseFn = resolve; });
            this.summaryCollection.addOpListener(opsListenerFn);
            await Promise.race([delayPromise, opPromise]);
            this.summaryCollection.removeOpListener(opsListenerFn);
        }
        return startWithInitialDelay;
    }
    dispose() {
        this.clientElection.off("electedSummarizerChanged", this.refreshSummarizer);
        this.connectedState.off("connected", this.handleConnected);
        this.connectedState.off("disconnected", this.handleDisconnected);
        this._disposed = true;
    }
}
exports.SummaryManager = SummaryManager;
SummaryManager.isStartingOrRunning = (state) => state === SummaryManagerState.Starting || state === SummaryManagerState.Running;

},{"@fluidframework/common-utils":29,"@fluidframework/driver-definitions":100,"@fluidframework/telemetry-utils":279}],85:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.formLinearFnWithAttemptOffset = exports.formLinearFn = exports.formExponentialFnWithAttemptOffset = exports.formExponentialFn = exports.Throttler = void 0;
/**
 * Used to give increasing delay times for throttling a single functionality.
 * Delay is based on previous attempts within specified time window, subtracting delay time.
 */
class Throttler {
    constructor(
    /** Width of sliding delay window in milliseconds. */
    delayWindowMs, 
    /** Maximum delay allowed in milliseconds. */
    maxDelayMs, 
    /**
     * Delay function used to calculate what the delay should be.
     * The input is the number of attempts that occurred within the sliding window.
     * The result is the calculated delay in milliseconds.
     */
    delayFn) {
        this.delayWindowMs = delayWindowMs;
        this.maxDelayMs = maxDelayMs;
        this.delayFn = delayFn;
        this.startTimes = [];
    }
    get numAttempts() {
        return this.startTimes.length;
    }
    /**
     * Gets all attempt start times after compensating for the delay times
     * by adding the delay times to the actual times.
     */
    getAttempts() {
        return [...this.startTimes];
    }
    /**
     * Latest attempt time after compensating for the delay time itself
     * by adding the delay time to the actual time.
     */
    get latestAttemptTime() {
        return this.startTimes.length > 0 ? this.startTimes[this.startTimes.length - 1] : undefined;
    }
    getDelay() {
        const now = Date.now();
        const latestAttemptTime = this.latestAttemptTime;
        if (latestAttemptTime !== undefined) {
            // If getDelay was called sooner than the most recent delay,
            // subtract the remaining time, since we previously added it.
            const earlyMs = latestAttemptTime - now;
            if (earlyMs > 0) {
                this.startTimes = this.startTimes.map((t) => t - earlyMs);
            }
        }
        // Remove all attempts that have already fallen out of the window.
        this.startTimes = this.startTimes.filter((t) => (now - t) < this.delayWindowMs);
        // Compute delay, but do not exceed the specified max delay.
        const delayMs = Math.min(this.delayFn(this.startTimes.length), this.maxDelayMs);
        // Record this attempt start time.
        this.startTimes.push(now);
        // Account for the delay time, by effectively removing it from the delay window.
        this.startTimes = this.startTimes.map((t) => t + delayMs);
        if (delayMs === this.maxDelayMs) {
            // We hit max delay, so adding more won't affect anything.
            // Shift off oldest time to stop this array from growing forever.
            this.startTimes.shift();
        }
        return delayMs;
    }
}
exports.Throttler = Throttler;
/**
 * Helper function to generate simple exponential throttle functions.
 * f(n) = [coefficient] x ([multiplier]^n) + [flatOffset]
 * where n = number of attempts, and f(n) = delay time in milliseconds.
 * If not provided, coefficient will default to 1, multiplier to 2,
 * minimum delay to 0, and the offset to 0, yielding:
 * 0 ms, 2 ms, 4 ms, 8 ms, ..., 2^n ms
 * where M = multiplier; an exponential back-off.
 * Use initialDelay to decide what should happen when numAttempts is 0,
 * leave it undefined to not special case.
 */
const formExponentialFn = ({ multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => (numAttempts) => Math.max(0, numAttempts <= 0 && initialDelay !== undefined
    ? initialDelay
    : coefficient * (Math.pow(multiplier, numAttempts)) + offset);
exports.formExponentialFn = formExponentialFn;
/** f(n) = C x (B^(n+A)) + F = (C x B^A) x B^n + F */
const formExponentialFnWithAttemptOffset = (attemptOffset, { multiplier = 2, coefficient = 1, offset = 0, initialDelay = undefined, } = {}) => (0, exports.formExponentialFn)({
    multiplier,
    coefficient: coefficient * Math.pow(multiplier, attemptOffset),
    offset,
    initialDelay,
});
exports.formExponentialFnWithAttemptOffset = formExponentialFnWithAttemptOffset;
/**
 * Helper function to generate simple linear throttle functions.
 * f(n) = [coefficient] x n + [flatOffset]
 * where n = number of attempts, and f(n) = delay time in milliseconds.
 * If not provided, coefficient will default to 1, and offset to 0, yielding:
 * 0 ms, 1 ms, 2 ms, 3 ms, ..., n ms delays; a linear back-off.
 */
const formLinearFn = ({ coefficient = 1, offset = 0, } = {}) => (numAttempts) => Math.max(0, coefficient * numAttempts + offset);
exports.formLinearFn = formLinearFn;
/** f(n) = C x (n+A) + F = C x n + (C x A + F) */
const formLinearFnWithAttemptOffset = (attemptOffset, { coefficient = 1, offset = 0, } = {}) => (0, exports.formLinearFn)({
    coefficient,
    offset: coefficient * attemptOffset + offset,
});
exports.formLinearFnWithAttemptOffset = formLinearFnWithAttemptOffset;

},{}],86:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSafePropertiesFromMessage = exports.DataProcessingError = exports.DataCorruptionError = exports.ClientSessionExpiredError = exports.UsageError = exports.ThrottlingWarning = exports.GenericError = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/**
 * Generic wrapper for an unrecognized/uncategorized error object
 */
class GenericError extends telemetry_utils_1.LoggingError {
    /**
     * Create a new GenericError
     * @param message - Error message
     * @param error - inner error object
     * @param props - Telemetry props to include when the error is logged
     */
    constructor(message, error, props) {
        // Don't try to log the inner error
        super(message, props, new Set(["error"]));
        this.error = error;
        this.errorType = container_definitions_1.ContainerErrorType.genericError;
    }
}
exports.GenericError = GenericError;
/**
 * Warning emitted when requests to storage are being throttled.
 */
class ThrottlingWarning extends telemetry_utils_1.LoggingError {
    constructor(message, retryAfterSeconds, props) {
        super(message, props);
        this.retryAfterSeconds = retryAfterSeconds;
        this.errorType = container_definitions_1.ContainerErrorType.throttlingError;
    }
    /**
     * Wrap the given error as a ThrottlingWarning
     * Only preserves the error message, and applies the given retry after to the new warning object
     */
    static wrap(error, retryAfterSeconds, logger) {
        const newErrorFn = (errMsg) => new ThrottlingWarning(errMsg, retryAfterSeconds);
        return (0, telemetry_utils_1.wrapErrorAndLog)(error, newErrorFn, logger);
    }
}
exports.ThrottlingWarning = ThrottlingWarning;
/** Error indicating an API is being used improperly resulting in an invalid operation. */
class UsageError extends telemetry_utils_1.LoggingError {
    constructor(message) {
        super(message, { usageError: true });
        // TODO: implement IUsageError once available
        this.errorType = "usageError";
    }
}
exports.UsageError = UsageError;
/** Error indicating that a client's session has reached its time limit and is closed. */
class ClientSessionExpiredError extends telemetry_utils_1.LoggingError {
    constructor(message, expiryMs) {
        super(message, { timeoutMs: expiryMs });
        this.expiryMs = expiryMs;
        this.errorType = container_definitions_1.ContainerErrorType.clientSessionExpiredError;
    }
}
exports.ClientSessionExpiredError = ClientSessionExpiredError;
/**
 * DataCorruptionError indicates that we encountered definitive evidence that the data at rest
 * backing this container is corrupted, and this container would never be expected to load properly again
 */
class DataCorruptionError extends telemetry_utils_1.LoggingError {
    constructor(message, props) {
        super(message, Object.assign(Object.assign({}, props), { dataProcessingError: 1 }));
        this.errorType = container_definitions_1.ContainerErrorType.dataCorruptionError;
        this.canRetry = false;
    }
}
exports.DataCorruptionError = DataCorruptionError;
/**
 * DataProcessingError indicates we hit a fatal error while processing incoming data from the Fluid Service.
 * The error will often originate in the dataStore or DDS implementation that is responding to incoming changes.
 * This differs from DataCorruptionError in that this may be a transient error that will not repro in another
 * client or session.
 */
class DataProcessingError extends telemetry_utils_1.LoggingError {
    constructor(errorMessage) {
        super(errorMessage);
        this.errorType = container_definitions_1.ContainerErrorType.dataProcessingError;
        this.canRetry = false;
    }
    /** Create a new DataProcessingError detected and raised with the FF code */
    static create(errorMessage, dataProcessingCodepath, sequencedMessage, props = {}) {
        const dataProcessingError = DataProcessingError.wrapIfUnrecognized(errorMessage, dataProcessingCodepath, sequencedMessage);
        dataProcessingError.addTelemetryProperties(props);
        return dataProcessingError;
    }
    /**
     * Wrap the given error in a DataProcessingError, unless the error is already of a known type.
     * In either case, the error will have some relevant properties added for telemetry
     * We wrap conditionally since known error types represent well-understood failure modes, and ideally
     * one day we will move away from throwing these errors but rather we'll return them.
     * But an unrecognized error needs to be classified as DataProcessingError.
     * @param originalError - error to be converted
     * @param dataProcessingCodepath - which codepath failed while processing data
     * @param sequencedMessage - Sequenced message to include info about via telemetry props
     * @returns Either a new DataProcessingError, or (if wrapping is deemed unnecessary) the given error
     */
    static wrapIfUnrecognized(originalError, dataProcessingCodepath, sequencedMessage) {
        const props = Object.assign({ dataProcessingError: 1, dataProcessingCodepath }, (sequencedMessage === undefined ? undefined : (0, exports.extractSafePropertiesFromMessage)(sequencedMessage)));
        const normalizedError = (0, telemetry_utils_1.normalizeError)(originalError, { props });
        if (!(0, telemetry_utils_1.isExternalError)(normalizedError)) {
            return normalizedError;
        }
        // Create a new DataProcessingError to wrap this external error
        const dataProcessingError = (0, telemetry_utils_1.wrapError)(normalizedError, (message) => new DataProcessingError(message));
        // Copy over the props above and any others added to this error since first being normalized
        dataProcessingError.addTelemetryProperties(normalizedError.getTelemetryProperties());
        return dataProcessingError;
    }
}
exports.DataProcessingError = DataProcessingError;
const extractSafePropertiesFromMessage = (message) => ({
    messageClientId: message.clientId,
    messageSequenceNumber: message.sequenceNumber,
    messageClientSequenceNumber: message.clientSequenceNumber,
    messageReferenceSequenceNumber: message.referenceSequenceNumber,
    messageMinimumSequenceNumber: message.minimumSequenceNumber,
    messageTimestamp: message.timestamp,
});
exports.extractSafePropertiesFromMessage = extractSafePropertiesFromMessage;

},{"@fluidframework/container-definitions":50,"@fluidframework/telemetry-utils":279}],87:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./error"), exports);

},{"./error":86}],88:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.summarizeChannelAsync = exports.summarizeChannel = exports.createServiceEndpoints = exports.attributesBlobKey = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const channelDeltaConnection_1 = require("./channelDeltaConnection");
const channelStorageService_1 = require("./channelStorageService");
exports.attributesBlobKey = ".attributes";
function createServiceEndpoints(id, connected, submitFn, dirtyFn, addedGCOutboundReferenceFn, storageService, logger, tree, extraBlobs) {
    const deltaConnection = new channelDeltaConnection_1.ChannelDeltaConnection(id, connected, (message, localOpMetadata) => submitFn(message, localOpMetadata), dirtyFn, addedGCOutboundReferenceFn);
    const objectStorage = new channelStorageService_1.ChannelStorageService(tree, storageService, logger, extraBlobs);
    return {
        deltaConnection,
        objectStorage,
    };
}
exports.createServiceEndpoints = createServiceEndpoints;
function summarizeChannel(channel, fullTree = false, trackState = false, telemetryContext) {
    const summarizeResult = channel.getAttachSummary(fullTree, trackState, telemetryContext);
    // Add the channel attributes to the returned result.
    (0, runtime_utils_1.addBlobToSummary)(summarizeResult, exports.attributesBlobKey, JSON.stringify(channel.attributes));
    return summarizeResult;
}
exports.summarizeChannel = summarizeChannel;
async function summarizeChannelAsync(channel, fullTree = false, trackState = false, telemetryContext) {
    const summarizeResult = await channel.summarize(fullTree, trackState, telemetryContext);
    // Add the channel attributes to the returned result.
    (0, runtime_utils_1.addBlobToSummary)(summarizeResult, exports.attributesBlobKey, JSON.stringify(channel.attributes));
    return summarizeResult;
}
exports.summarizeChannelAsync = summarizeChannelAsync;

},{"./channelDeltaConnection":89,"./channelStorageService":90,"@fluidframework/runtime-utils":213}],89:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelDeltaConnection = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
class ChannelDeltaConnection {
    constructor(objectId, _connected, submit, dirty, addedGCOutboundReference) {
        this.objectId = objectId;
        this._connected = _connected;
        this.submit = submit;
        this.dirty = dirty;
        this.addedGCOutboundReference = addedGCOutboundReference;
    }
    get handler() {
        (0, common_utils_1.assert)(!!this._handler, 0x177 /* "Missing delta handler" */);
        return this._handler;
    }
    get connected() {
        return this._connected;
    }
    attach(handler) {
        (0, common_utils_1.assert)(this._handler === undefined, 0x178 /* "Missing delta handler on attach" */);
        this._handler = handler;
    }
    setConnectionState(connected) {
        this._connected = connected;
        this.handler.setConnectionState(connected);
    }
    process(message, local, localOpMetadata) {
        try {
            // catches as data processing error whether or not they come from async pending queues
            this.handler.process(message, local, localOpMetadata);
        }
        catch (error) {
            throw container_utils_1.DataProcessingError.wrapIfUnrecognized(error, "channelDeltaConnectionFailedToProcessMessage", message);
        }
    }
    reSubmit(content, localOpMetadata) {
        this.handler.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        if (this.handler.rollback === undefined) {
            throw new Error("Handler doesn't support rollback");
        }
        this.handler.rollback(content, localOpMetadata);
    }
    applyStashedOp(message) {
        return this.handler.applyStashedOp(message);
    }
}
exports.ChannelDeltaConnection = ChannelDeltaConnection;

},{"@fluidframework/common-utils":29,"@fluidframework/container-utils":87}],90:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelStorageService = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
class ChannelStorageService {
    constructor(tree, storage, logger, extraBlobs) {
        this.tree = tree;
        this.storage = storage;
        this.logger = logger;
        this.extraBlobs = extraBlobs;
        this.flattenedTree = {};
        // Create a map from paths to blobs
        if (tree !== undefined) {
            ChannelStorageService.flattenTree("", tree, this.flattenedTree);
        }
    }
    static flattenTree(base, tree, results) {
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const path in tree.trees) {
            ChannelStorageService.flattenTree(`${base}${path}/`, tree.trees[path], results);
        }
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const blob in tree.blobs) {
            results[`${base}${blob}`] = tree.blobs[blob];
        }
    }
    async contains(path) {
        return this.flattenedTree[path] !== undefined;
    }
    async readBlob(path) {
        const id = await this.getIdForPath(path);
        const blob = this.extraBlobs !== undefined
            ? this.extraBlobs.get(id)
            : undefined;
        if (blob !== undefined) {
            return blob;
        }
        const blobP = this.storage.readBlob(id);
        blobP.catch((error) => this.logger.sendErrorEvent({ eventName: "ChannelStorageBlobError" }, error));
        return blobP;
    }
    async list(path) {
        var _a;
        let tree = this.tree;
        const pathParts = (0, runtime_utils_1.getNormalizedObjectStoragePathParts)(path);
        while (tree !== undefined && pathParts.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const part = pathParts.shift();
            tree = tree.trees[part];
        }
        if (tree === undefined || pathParts.length !== 0) {
            throw new Error("path does not exist");
        }
        return Object.keys((_a = tree === null || tree === void 0 ? void 0 : tree.blobs) !== null && _a !== void 0 ? _a : {});
    }
    async getIdForPath(path) {
        return this.flattenedTree[path];
    }
}
exports.ChannelStorageService = ChannelStorageService;

},{"@fluidframework/runtime-utils":213}],91:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mixinSummaryHandler = exports.mixinRequestHandler = exports.FluidDataStoreRuntime = exports.DataStoreMessageType = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
const container_utils_1 = require("@fluidframework/container-utils");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const garbage_collector_1 = require("@fluidframework/garbage-collector");
const uuid_1 = require("uuid");
const channelContext_1 = require("./channelContext");
const localChannelContext_1 = require("./localChannelContext");
const remoteChannelContext_1 = require("./remoteChannelContext");
var DataStoreMessageType;
(function (DataStoreMessageType) {
    // Creates a new channel
    DataStoreMessageType["Attach"] = "attach";
    DataStoreMessageType["ChannelOp"] = "op";
})(DataStoreMessageType = exports.DataStoreMessageType || (exports.DataStoreMessageType = {}));
/**
 * Base data store class
 */
class FluidDataStoreRuntime extends common_utils_1.TypedEventEmitter {
    constructor(dataStoreContext, sharedObjectRegistry, existing) {
        super();
        this.dataStoreContext = dataStoreContext;
        this.sharedObjectRegistry = sharedObjectRegistry;
        this._disposed = false;
        this.contexts = new Map();
        this.contextsDeferred = new Map();
        this.pendingAttach = new Map();
        this.deferredAttached = new common_utils_1.Deferred();
        this.localChannelContextQueue = new Map();
        this.notBoundedChannelContextSet = new Set();
        // A list of handles that are bound when the data store is not visible. We have to make them visible when the data
        // store becomes visible.
        this.pendingHandlesToMakeVisible = new Set();
        (0, common_utils_1.assert)(!dataStoreContext.id.includes("/"), 0x30e /* Id cannot contain slashes. DataStoreContext should have validated this. */);
        this.logger = telemetry_utils_1.ChildLogger.create(dataStoreContext.logger, "FluidDataStoreRuntime", { all: { dataStoreId: (0, uuid_1.v4)() } });
        this.id = dataStoreContext.id;
        this.options = dataStoreContext.options;
        this.deltaManager = dataStoreContext.deltaManager;
        this.quorum = dataStoreContext.getQuorum();
        this.audience = dataStoreContext.getAudience();
        const tree = dataStoreContext.baseSnapshot;
        this.channelsBaseGCDetails = new common_utils_1.LazyPromise(async () => {
            var _a, _b, _c;
            const baseGCDetails = await ((_c = (_b = (_a = this.dataStoreContext).getBaseGCDetails) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : this.dataStoreContext.getInitialGCSummaryDetails());
            return (0, garbage_collector_1.unpackChildNodesGCDetails)(baseGCDetails);
        });
        // Must always receive the data store type inside of the attributes
        if ((tree === null || tree === void 0 ? void 0 : tree.trees) !== undefined) {
            Object.keys(tree.trees).forEach((path) => {
                // Issue #4414
                if (path === "_search") {
                    return;
                }
                let channelContext;
                // If already exists on storage, then create a remote channel. However, if it is case of rehydrating a
                // container from snapshot where we load detached container from a snapshot, isLocalDataStore would be
                // true. In this case create a RehydratedLocalChannelContext.
                if (dataStoreContext.isLocalDataStore) {
                    channelContext = new localChannelContext_1.RehydratedLocalChannelContext(path, this.sharedObjectRegistry, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), tree.trees[path]);
                    // This is the case of rehydrating a detached container from snapshot. Now due to delay loading of
                    // data store, if the data store is loaded after the container is attached, then we missed making
                    // the channel visible. So do it now. Otherwise, add it to local channel context queue, so
                    // that it can be make it visible later with the data store.
                    if (dataStoreContext.attachState !== container_definitions_1.AttachState.Detached) {
                        channelContext.makeVisible();
                    }
                    else {
                        this.localChannelContextQueue.set(path, channelContext);
                    }
                }
                else {
                    channelContext = new remoteChannelContext_1.RemoteChannelContext(this, dataStoreContext, dataStoreContext.storage, (content, localOpMetadata) => this.submitChannelOp(path, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), path, tree.trees[path], this.sharedObjectRegistry, undefined /* extraBlobs */, this.dataStoreContext.getCreateChildSummarizerNodeFn(path, { type: runtime_definitions_1.CreateSummarizerNodeSource.FromSummary }), async () => this.getChannelBaseGCDetails(path));
                }
                const deferred = new common_utils_1.Deferred();
                deferred.resolve(channelContext);
                this.contexts.set(path, channelContext);
                this.contextsDeferred.set(path, deferred);
            });
        }
        this.attachListener();
        // If exists on storage or loaded from a snapshot, it should already be bound.
        this.bindState = existing ? container_definitions_1.BindState.Bound : container_definitions_1.BindState.NotBound;
        this._attachState = dataStoreContext.attachState;
        /**
         * If existing flag is false, this is a new data store and is not visible. The existing flag can be true in two
         * conditions:
         * 1. It's a local data store that is created when a detached container is rehydrated. In this case, the data
         *    store is locally visible because the snapshot it is loaded from contains locally visible data stores only.
         * 2. It's a remote data store that is created when an attached container is loaded is loaded from snapshot or
         *    when an attach op comes in. In both these cases, the data store is already globally visible.
         */
        if (existing) {
            this.visibilityState = dataStoreContext.attachState === container_definitions_1.AttachState.Detached
                ? runtime_definitions_1.VisibilityState.LocallyVisible : runtime_definitions_1.VisibilityState.GloballyVisible;
        }
        else {
            this.visibilityState = runtime_definitions_1.VisibilityState.NotVisible;
        }
        // If it's existing we know it has been attached.
        if (existing) {
            this.deferredAttached.resolve();
        }
    }
    /**
     * Loads the data store runtime
     * @param context - The data store context
     * @param sharedObjectRegistry - The registry of shared objects used by this data store
     * @param existing - If loading from an existing file.
     */
    static load(context, sharedObjectRegistry, existing) {
        return new FluidDataStoreRuntime(context, sharedObjectRegistry, existing);
    }
    get IFluidRouter() { return this; }
    get connected() {
        return this.dataStoreContext.connected;
    }
    get clientId() {
        return this.dataStoreContext.clientId;
    }
    get clientDetails() {
        return this.dataStoreContext.clientDetails;
    }
    get isAttached() {
        return this.attachState !== container_definitions_1.AttachState.Detached;
    }
    get attachState() {
        return this._attachState;
    }
    get absolutePath() {
        return (0, runtime_utils_1.generateHandleContextPath)(this.id, this.routeContext);
    }
    get routeContext() {
        return this.dataStoreContext.IFluidHandleContext;
    }
    get IFluidHandleContext() { return this; }
    get rootRoutingContext() { return this; }
    get channelsRoutingContext() { return this; }
    get objectsRoutingContext() { return this; }
    get disposed() { return this._disposed; }
    dispose() {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.emit("dispose");
        this.removeAllListeners();
    }
    async resolveHandle(request) {
        return this.request(request);
    }
    async request(request) {
        try {
            const parser = runtime_utils_1.RequestParser.create(request);
            const id = parser.pathParts[0];
            if (id === "_channels" || id === "_custom") {
                return this.request(parser.createSubRequest(1));
            }
            // Check for a data type reference first
            if (this.contextsDeferred.has(id) && parser.isLeaf(1)) {
                try {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const value = await this.contextsDeferred.get(id).promise;
                    const channel = await value.getChannel();
                    return { mimeType: "fluid/object", status: 200, value: channel };
                }
                catch (error) {
                    this.logger.sendErrorEvent({ eventName: "GetChannelFailedInRequest" }, error);
                    return (0, runtime_utils_1.createResponseError)(500, `Failed to get Channel: ${error}`, request);
                }
            }
            // Otherwise defer to an attached request handler
            return (0, runtime_utils_1.create404Response)(request);
        }
        catch (error) {
            return (0, runtime_utils_1.exceptionToResponse)(error);
        }
    }
    async getChannel(id) {
        this.verifyNotClosed();
        // TODO we don't assume any channels (even root) in the runtime. If you request a channel that doesn't exist
        // we will never resolve the promise. May want a flag to getChannel that doesn't wait for the promise if
        // it doesn't exist
        if (!this.contextsDeferred.has(id)) {
            this.contextsDeferred.set(id, new common_utils_1.Deferred());
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const context = await this.contextsDeferred.get(id).promise;
        const channel = await context.getChannel();
        return channel;
    }
    createChannel(id = (0, uuid_1.v4)(), type) {
        if (id.includes("/")) {
            throw new container_utils_1.UsageError(`Id cannot contain slashes: ${id}`);
        }
        this.verifyNotClosed();
        (0, common_utils_1.assert)(!this.contexts.has(id), 0x179 /* "createChannel() with existing ID" */);
        this.notBoundedChannelContextSet.add(id);
        const context = new localChannelContext_1.LocalChannelContext(id, this.sharedObjectRegistry, type, this, this.dataStoreContext, this.dataStoreContext.storage, this.logger, (content, localOpMetadata) => this.submitChannelOp(id, content, localOpMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle));
        this.contexts.set(id, context);
        if (this.contextsDeferred.has(id)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.contextsDeferred.get(id).resolve(context);
        }
        else {
            const deferred = new common_utils_1.Deferred();
            deferred.resolve(context);
            this.contextsDeferred.set(id, deferred);
        }
        (0, common_utils_1.assert)(!!context.channel, 0x17a /* "Channel should be loaded when created!!" */);
        return context.channel;
    }
    /**
     * Binds a channel with the runtime. If the runtime is attached we will attach the channel right away.
     * If the runtime is not attached we will defer the attach until the runtime attaches.
     * @param channel - channel to be registered.
     */
    bindChannel(channel) {
        (0, common_utils_1.assert)(this.notBoundedChannelContextSet.has(channel.id), 0x17b /* "Channel to be binded should be in not bounded set" */);
        this.notBoundedChannelContextSet.delete(channel.id);
        // If our data store is attached, then attach the channel.
        if (this.isAttached) {
            this.attachChannel(channel);
            return;
        }
        /**
         * If this channel is already waiting to be made visible, do nothing. This can happen during attachGraph() when
         * a channel's graph is attached. It calls bindToContext on the shared object which will end up back here.
         */
        if (this.pendingHandlesToMakeVisible.has(channel.handle)) {
            return;
        }
        this.bind(channel.handle);
        // If our data store is local then add the channel to the queue
        if (!this.localChannelContextQueue.has(channel.id)) {
            this.localChannelContextQueue.set(channel.id, this.contexts.get(channel.id));
        }
    }
    /**
     * This function is called when a data store becomes root. It does the following:
     * 1. Marks the data store locally visible in the container.
     * 2. Attaches the graph of all the handles bound to it.
     * 3. Calls into the data store context to mark it visible in the container too. If the container is globally
     *    visible, it will mark us globally visible. Otherwise, it will mark us globally visible when it becomes
     *    globally visible.
     */
    makeVisibleAndAttachGraph() {
        if (this.visibilityState !== runtime_definitions_1.VisibilityState.NotVisible) {
            return;
        }
        this.visibilityState = runtime_definitions_1.VisibilityState.LocallyVisible;
        this.pendingHandlesToMakeVisible.forEach((handle) => {
            handle.attachGraph();
        });
        this.pendingHandlesToMakeVisible.clear();
        this.bindToContext();
    }
    /**
     * This function is called when a handle to this data store is added to a visible DDS.
     */
    attachGraph() {
        this.makeVisibleAndAttachGraph();
    }
    /**
     * Binds this runtime to the container
     * This includes the following:
     * 1. Sending an Attach op that includes all existing state
     * 2. Attaching the graph if the data store becomes attached.
     */
    bindToContext() {
        if (this.bindState !== container_definitions_1.BindState.NotBound) {
            return;
        }
        this.bindState = container_definitions_1.BindState.Binding;
        this.dataStoreContext.bindToContext();
        this.bindState = container_definitions_1.BindState.Bound;
    }
    bind(handle) {
        // If visible, attach the incoming handle's graph. Else, this will be done when we become visible.
        if (this.visibilityState !== runtime_definitions_1.VisibilityState.NotVisible) {
            handle.attachGraph();
            return;
        }
        this.pendingHandlesToMakeVisible.add(handle);
    }
    setConnectionState(connected, clientId) {
        this.verifyNotClosed();
        for (const [, object] of this.contexts) {
            object.setConnectionState(connected, clientId);
        }
        (0, telemetry_utils_1.raiseConnectedEvent)(this.logger, this, connected, clientId);
    }
    getQuorum() {
        return this.quorum;
    }
    getAudience() {
        return this.audience;
    }
    async uploadBlob(blob) {
        this.verifyNotClosed();
        return this.dataStoreContext.uploadBlob(blob);
    }
    process(message, local, localOpMetadata) {
        this.verifyNotClosed();
        try {
            // catches as data processing error whether or not they come from async pending queues
            switch (message.type) {
                case DataStoreMessageType.Attach: {
                    const attachMessage = message.contents;
                    const id = attachMessage.id;
                    // If a non-local operation then go and create the object
                    // Otherwise mark it as officially attached.
                    if (local) {
                        (0, common_utils_1.assert)(this.pendingAttach.has(id), 0x17c /* "Unexpected attach (local) channel OP" */);
                        this.pendingAttach.delete(id);
                    }
                    else {
                        (0, common_utils_1.assert)(!this.contexts.has(id), 0x17d);
                        const flatBlobs = new Map();
                        const snapshotTree = (0, driver_utils_1.buildSnapshotTree)(attachMessage.snapshot.entries, flatBlobs);
                        const remoteChannelContext = new remoteChannelContext_1.RemoteChannelContext(this, this.dataStoreContext, this.dataStoreContext.storage, (content, localContentMetadata) => this.submitChannelOp(id, content, localContentMetadata), (address) => this.setChannelDirty(address), (srcHandle, outboundHandle) => this.addedGCOutboundReference(srcHandle, outboundHandle), id, snapshotTree, this.sharedObjectRegistry, flatBlobs, this.dataStoreContext.getCreateChildSummarizerNodeFn(id, {
                            type: runtime_definitions_1.CreateSummarizerNodeSource.FromAttach,
                            sequenceNumber: message.sequenceNumber,
                            snapshot: attachMessage.snapshot,
                        }), async () => this.getChannelBaseGCDetails(id), attachMessage.type);
                        this.contexts.set(id, remoteChannelContext);
                        if (this.contextsDeferred.has(id)) {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            this.contextsDeferred.get(id).resolve(remoteChannelContext);
                        }
                        else {
                            const deferred = new common_utils_1.Deferred();
                            deferred.resolve(remoteChannelContext);
                            this.contextsDeferred.set(id, deferred);
                        }
                    }
                    break;
                }
                case DataStoreMessageType.ChannelOp:
                    this.processChannelOp(message, local, localOpMetadata);
                    break;
                default:
            }
            this.emit("op", message);
        }
        catch (error) {
            throw container_utils_1.DataProcessingError.wrapIfUnrecognized(error, "fluidDataStoreRuntimeFailedToProcessMessage", message);
        }
    }
    processSignal(message, local) {
        this.emit("signal", message, local);
    }
    isChannelAttached(id) {
        return (
        // Added in createChannel
        // Removed when bindChannel is called
        !this.notBoundedChannelContextSet.has(id)
            // Added in bindChannel only if this is not attached yet
            // Removed when this is attached by calling attachGraph
            && !this.localChannelContextQueue.has(id)
            // Added in attachChannel called by bindChannel
            // Removed when attach op is broadcast
            && !this.pendingAttach.has(id));
    }
    /**
     * Returns the outbound routes of this channel. Currently, all contexts in this channel are considered
     * referenced and are hence outbound. This will change when we have root and non-root channel contexts.
     * The only root contexts will be considered as referenced.
     */
    getOutboundRoutes() {
        const outboundRoutes = [];
        for (const [contextId] of this.contexts) {
            outboundRoutes.push(`${this.absolutePath}/${contextId}`);
        }
        return outboundRoutes;
    }
    /**
     * Updates the GC nodes of this channel. It does the following:
     * - Adds a back route to self to all its child GC nodes.
     * - Adds a node for this channel.
     * @param builder - The builder that contains the GC nodes for this channel's children.
     */
    updateGCNodes(builder) {
        // Add a back route to self in each child's GC nodes. If any child is referenced, then its parent should
        // be considered referenced as well.
        builder.addRouteToAllNodes(this.absolutePath);
        // Get the outbound routes and add a GC node for this channel.
        builder.addNode("/", this.getOutboundRoutes());
    }
    /**
     * Generates data used for garbage collection. This includes a list of GC nodes that represent this channel
     * including any of its child channel contexts. Each node has a set of outbound routes to other GC nodes in the
     * document. It does the following:
     * 1. Calls into each child context to get its GC data.
     * 2. Prefixes the child context's id to the GC nodes in the child's GC data. This makes sure that the node can be
     *    identified as belonging to the child.
     * 3. Adds a GC node for this channel to the nodes received from the children. All these nodes together represent
     *    the GC data of this channel.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        const builder = new garbage_collector_1.GCDataBuilder();
        // Iterate over each channel context and get their GC data.
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            // Get GC data only for attached contexts. Detached contexts are not connected in the GC reference
            // graph so any references they might have won't be connected as well.
            return this.isChannelAttached(contextId);
        }).map(async ([contextId, context]) => {
            const contextGCData = await context.getGCData(fullGC);
            // Prefix the child's id to the ids of its GC nodes so they can be identified as belonging to the child.
            // This also gradually builds the id of each node to be a path from the root.
            builder.prefixAndAddNodes(contextId, contextGCData.gcNodes);
        }));
        this.updateGCNodes(builder);
        return builder.getGCData();
    }
    /**
     * After GC has run, called to notify this channel of routes that are used in it. It calls the child contexts to
     * update their used routes.
     * @param usedRoutes - The routes that are used in all contexts in this channel.
     * @param gcTimestamp - The time when GC was run that generated these used routes. If any node becomes unreferenced
     * as part of this GC run, this should be used to update the time when it happens.
     */
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        var _a;
        // Get a map of channel ids to routes used in it.
        const usedContextRoutes = (0, garbage_collector_1.unpackChildNodesUsedRoutes)(usedRoutes);
        // Verify that the used routes are correct.
        for (const [id] of usedContextRoutes) {
            (0, common_utils_1.assert)(this.contexts.has(id), 0x17e /* "Used route does not belong to any known context" */);
        }
        // Update the used routes in each context. Used routes is empty for unused context.
        for (const [contextId, context] of this.contexts) {
            context.updateUsedRoutes((_a = usedContextRoutes.get(contextId)) !== null && _a !== void 0 ? _a : [], gcTimestamp);
        }
    }
    /**
     * Called when a new outbound reference is added to another node. This is used by garbage collection to identify
     * all references added in the system.
     * @param srcHandle - The handle of the node that added the reference.
     * @param outboundHandle - The handle of the outbound node that is referenced.
     */
    addedGCOutboundReference(srcHandle, outboundHandle) {
        var _a, _b;
        (_b = (_a = this.dataStoreContext).addedGCOutboundReference) === null || _b === void 0 ? void 0 : _b.call(_a, srcHandle, outboundHandle);
    }
    /**
     * Returns the base GC details for the channel with the given id. This is used to initialize its GC state.
     * @param channelId - The id of the channel context that is asked for the initial GC details.
     * @returns the requested channel's base GC details.
     */
    async getChannelBaseGCDetails(channelId) {
        var _a;
        let channelBaseGCDetails = (await this.channelsBaseGCDetails).get(channelId);
        if (channelBaseGCDetails === undefined) {
            channelBaseGCDetails = {};
        }
        else if (((_a = channelBaseGCDetails.gcData) === null || _a === void 0 ? void 0 : _a.gcNodes) !== undefined) {
            // Note: if the child channel has an explicit handle route to its parent, it will be removed here and
            // expected to be added back by the parent when getGCData is called.
            (0, garbage_collector_1.removeRouteFromAllNodes)(channelBaseGCDetails.gcData.gcNodes, this.absolutePath);
        }
        // Currently, channel context's are always considered used. So, it there are no used routes for it, we still
        // need to mark it as used. Add self-route (empty string) to the channel context's used routes.
        if (channelBaseGCDetails.usedRoutes === undefined || channelBaseGCDetails.usedRoutes.length === 0) {
            channelBaseGCDetails.usedRoutes = [""];
        }
        return channelBaseGCDetails;
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        const summaryBuilder = new runtime_utils_1.SummaryTreeBuilder();
        // Iterate over each data store and ask it to summarize
        await Promise.all(Array.from(this.contexts)
            .filter(([contextId, _]) => {
            const isAttached = this.isChannelAttached(contextId);
            // We are not expecting local dds! Summary may not capture local state.
            (0, common_utils_1.assert)(isAttached, 0x17f /* "Not expecting detached channels during summarize" */);
            // If the object is registered - and we have received the sequenced op creating the object
            // (i.e. it has a base mapping) - then we go ahead and summarize
            return isAttached;
        }).map(async ([contextId, context]) => {
            const contextSummary = await context.summarize(fullTree, trackState, telemetryContext);
            summaryBuilder.addWithStats(contextId, contextSummary);
        }));
        return summaryBuilder.getSummaryTree();
    }
    getAttachSummary(telemetryContext) {
        /**
         * back-compat 0.59.1000 - getAttachSummary() is called when making a data store globally visible (previously
         * attaching state). Ideally, attachGraph() should have already be called making it locally visible. However,
         * before visibility state was added, this may not have been the case and getAttachSummary() could be called:
         * 1) Before attaching the data store - When a detached container is attached.
         * 2) After attaching the data store - When a data store is created and bound in an attached container.
         *
         * The basic idea is that all local object should become locally visible before they are globally visible.
         */
        this.attachGraph();
        /**
         * This assert cannot be added now due to back-compat. To be uncommented when the following issue is fixed -
         * https://github.com/microsoft/FluidFramework/issues/9688.
         *
         * assert(this.visibilityState === VisibilityState.LocallyVisible,
         *   "The data store should be locally visible when generating attach summary",
         * );
         */
        const summaryBuilder = new runtime_utils_1.SummaryTreeBuilder();
        // Craft the .attributes file for each shared object
        for (const [contextId, context] of this.contexts) {
            if (!(context instanceof localChannelContext_1.LocalChannelContextBase)) {
                throw new telemetry_utils_1.LoggingError("Should only be called with local channel handles");
            }
            if (!this.notBoundedChannelContextSet.has(contextId)) {
                let summaryTree;
                if (context.isLoaded) {
                    const contextSummary = context.getAttachSummary(telemetryContext);
                    (0, common_utils_1.assert)(contextSummary.summary.type === protocol_definitions_1.SummaryType.Tree, 0x180 /* "getAttachSummary should always return a tree" */);
                    summaryTree = { stats: contextSummary.stats, summary: contextSummary.summary };
                }
                else {
                    // If this channel is not yet loaded, then there should be no changes in the snapshot from which
                    // it was created as it is detached container. So just use the previous snapshot.
                    (0, common_utils_1.assert)(!!this.dataStoreContext.baseSnapshot, 0x181 /* "BaseSnapshot should be there as detached container loaded from snapshot" */);
                    summaryTree = (0, runtime_utils_1.convertSnapshotTreeToSummaryTree)(this.dataStoreContext.baseSnapshot.trees[contextId]);
                }
                summaryBuilder.addWithStats(contextId, summaryTree);
            }
        }
        return summaryBuilder.getSummaryTree();
    }
    submitMessage(type, content, localOpMetadata) {
        this.submit(type, content, localOpMetadata);
    }
    submitSignal(type, content) {
        this.verifyNotClosed();
        return this.dataStoreContext.submitSignal(type, content);
    }
    /**
     * Will return when the data store is attached.
     */
    async waitAttached() {
        return this.deferredAttached.promise;
    }
    /**
     * Attach channel should only be called after the data store has been attached
     */
    attachChannel(channel) {
        this.verifyNotClosed();
        // If this handle is already attached no need to attach again.
        if (channel.handle.isAttached) {
            return;
        }
        channel.handle.attachGraph();
        (0, common_utils_1.assert)(this.isAttached, 0x182 /* "Data store should be attached to attach the channel." */);
        (0, common_utils_1.assert)(this.visibilityState === runtime_definitions_1.VisibilityState.GloballyVisible, 0x2d0 /* "Data store should be globally visible to attach channels." */);
        const summarizeResult = (0, channelContext_1.summarizeChannel)(channel, true /* fullTree */, false /* trackState */);
        // Attach message needs the summary in ITree format. Convert the ISummaryTree into an ITree.
        const snapshot = (0, runtime_utils_1.convertSummaryTreeToITree)(summarizeResult.summary);
        const message = {
            id: channel.id,
            snapshot,
            type: channel.attributes.type,
        };
        this.pendingAttach.set(channel.id, message);
        this.submit(DataStoreMessageType.Attach, message);
        const context = this.contexts.get(channel.id);
        context.makeVisible();
    }
    submitChannelOp(address, contents, localOpMetadata) {
        const envelope = { address, contents };
        this.submit(DataStoreMessageType.ChannelOp, envelope, localOpMetadata);
    }
    submit(type, content, localOpMetadata = undefined) {
        this.verifyNotClosed();
        this.dataStoreContext.submitMessage(type, content, localOpMetadata);
    }
    /**
     * For messages of type MessageType.Operation, finds the right channel and asks it to resubmit the message.
     * For all other messages, just submit it again.
     * This typically happens when we reconnect and there are unacked messages.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(type, content, localOpMetadata) {
        this.verifyNotClosed();
        switch (type) {
            case DataStoreMessageType.ChannelOp:
                {
                    // For Operations, find the right channel and trigger resubmission on it.
                    const envelope = content;
                    const channelContext = this.contexts.get(envelope.address);
                    (0, common_utils_1.assert)(!!channelContext, 0x183 /* "There should be a channel context for the op" */);
                    channelContext.reSubmit(envelope.contents, localOpMetadata);
                    break;
                }
            case DataStoreMessageType.Attach:
                // For Attach messages, just submit them again.
                this.submit(type, content, localOpMetadata);
                break;
            default:
                (0, common_utils_1.unreachableCase)(type);
        }
    }
    /**
     * Revert a local op.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    rollback(type, content, localOpMetadata) {
        this.verifyNotClosed();
        switch (type) {
            case DataStoreMessageType.ChannelOp:
                {
                    // For Operations, find the right channel and trigger resubmission on it.
                    const envelope = content;
                    const channelContext = this.contexts.get(envelope.address);
                    (0, common_utils_1.assert)(!!channelContext, 0x2ed /* "There should be a channel context for the op" */);
                    channelContext.rollback(envelope.contents, localOpMetadata);
                    break;
                }
            default:
                throw new telemetry_utils_1.LoggingError(`Can't rollback ${type} message`);
        }
    }
    async applyStashedOp(content) {
        const envelope = content;
        const channelContext = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!channelContext, 0x184 /* "There should be a channel context for the op" */);
        await channelContext.getChannel();
        return channelContext.applyStashedOp(envelope.contents);
    }
    setChannelDirty(address) {
        this.verifyNotClosed();
        this.dataStoreContext.setChannelDirty(address);
    }
    processChannelOp(message, local, localOpMetadata) {
        this.verifyNotClosed();
        const envelope = message.contents;
        const transformed = Object.assign(Object.assign({}, message), { contents: envelope.contents });
        const channelContext = this.contexts.get(envelope.address);
        (0, common_utils_1.assert)(!!channelContext, 0x185 /* "Channel not found" */);
        channelContext.processOp(transformed, local, localOpMetadata);
        return channelContext;
    }
    attachListener() {
        this.setMaxListeners(Number.MAX_SAFE_INTEGER);
        this.dataStoreContext.once("attaching", () => {
            /**
             * back-compat 0.59.1000 - Ideally, attachGraph() should have already been called making the data store
             * locally visible. However, before visibility state was added, this may not have been the case and data
             * store can move to "attaching" state in 2 scenarios:
             * 1) Before attachGraph() is called - When a data store is created and bound in an attached container.
             * 2) After attachGraph() is called - When a detached container is attached.
             *
             * The basic idea is that all local object should become locally visible before they are globally visible.
             */
            this.attachGraph();
            this._attachState = container_definitions_1.AttachState.Attaching;
            (0, common_utils_1.assert)(this.visibilityState === runtime_definitions_1.VisibilityState.LocallyVisible, 0x2d1 /* "Data store should be locally visible before it can become globally visible." */);
            // Mark the data store globally visible and make its child channels visible as well.
            this.visibilityState = runtime_definitions_1.VisibilityState.GloballyVisible;
            this.localChannelContextQueue.forEach((channel) => {
                channel.makeVisible();
            });
            this.localChannelContextQueue.clear();
            // This promise resolution will be moved to attached event once we fix the scheduler.
            this.deferredAttached.resolve();
            this.emit("attaching");
        });
        this.dataStoreContext.once("attached", () => {
            (0, common_utils_1.assert)(this.visibilityState === runtime_definitions_1.VisibilityState.GloballyVisible, 0x2d2 /* "Data store should be globally visible when its attached." */);
            this._attachState = container_definitions_1.AttachState.Attached;
            this.emit("attached");
        });
    }
    verifyNotClosed() {
        if (this._disposed) {
            throw new telemetry_utils_1.LoggingError("Runtime is closed");
        }
    }
}
exports.FluidDataStoreRuntime = FluidDataStoreRuntime;
/**
 * Mixin class that adds request handler to FluidDataStoreRuntime
 * Request handler is only called when data store can't resolve request, i.e. for custom requests.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 * @param requestHandler - request handler to mix in
 */
const mixinRequestHandler = (requestHandler, Base = FluidDataStoreRuntime) => class RuntimeWithRequestHandler extends Base {
    async request(request) {
        const response = await super.request(request);
        if (response.status === 404) {
            return requestHandler(request, this);
        }
        return response;
    }
};
exports.mixinRequestHandler = mixinRequestHandler;
/**
 * Mixin class that adds await for DataObject to finish initialization before we proceed to summary.
 * @param handler - handler that returns info about blob to be added to summary.
 * Or undefined not to add anything to summary.
 * @param Base - base class, inherits from FluidDataStoreRuntime
 */
const mixinSummaryHandler = (handler, Base = FluidDataStoreRuntime) => class RuntimeWithSummarizerHandler extends Base {
    addBlob(summary, path, content) {
        const firstName = path.shift();
        if (firstName === undefined) {
            throw new telemetry_utils_1.LoggingError("Path can't be empty");
        }
        let blob = {
            type: protocol_definitions_1.SummaryType.Blob,
            content,
        };
        summary.stats.blobNodeCount++;
        summary.stats.totalBlobSize += content.length;
        for (const name of path.reverse()) {
            blob = {
                type: protocol_definitions_1.SummaryType.Tree,
                tree: { [name]: blob },
            };
            summary.stats.treeNodeCount++;
        }
        summary.summary.tree[firstName] = blob;
    }
    async summarize(...args) {
        const summary = await super.summarize(...args);
        const content = await handler(this);
        if (content !== undefined) {
            this.addBlob(summary, content.path, content.content);
        }
        return summary;
    }
};
exports.mixinSummaryHandler = mixinSummaryHandler;

},{"./channelContext":88,"./localChannelContext":94,"./remoteChannelContext":95,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/garbage-collector":133,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279,"uuid":544}],92:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluidObjectHandle = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
class FluidObjectHandle {
    /**
     * Creates a new FluidObjectHandle.
     * @param value - The FluidObject object this handle is for.
     * @param path - The path to this handle relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        this.value = value;
        this.path = path;
        this.routeContext = routeContext;
        this.pendingHandlesToMakeVisible = new Set();
        // Tracks whether this handle is locally visible in the container.
        this.locallyVisible = false;
        this.absolutePath = (0, runtime_utils_1.generateHandleContextPath)(path, this.routeContext);
    }
    get IFluidHandle() { return this; }
    get isAttached() {
        return this.routeContext.isAttached;
    }
    /**
     * Tells whether the object of this handle is visible in the container locally or globally.
     */
    get visible() {
        /**
         * If the object of this handle is attached, it is visible in the container. Ideally, checking local visibility
         * should be enough for a handle. However, there are scenarios where the object becomes locally visible but the
         * handle does not know this - This will happen is attachGraph is never called on the handle. Couple of examples
         * where this can happen:
         * 1. Handles to DDS other than the default handle won't know if the DDS becomes visible after the handle was
         *    created.
         * 2. Handles to root data stores will never know that it was visible because the handle will not be stores in
         *    another DDS and so, attachGraph will never be called on it.
         */
        return this.isAttached || this.locallyVisible;
    }
    async get() {
        return this.value;
    }
    attachGraph() {
        if (this.visible) {
            return;
        }
        this.locallyVisible = true;
        this.pendingHandlesToMakeVisible.forEach((handle) => {
            handle.attachGraph();
        });
        this.pendingHandlesToMakeVisible.clear();
        this.routeContext.attachGraph();
    }
    bind(handle) {
        // If this handle is visible, attach the graph of the incoming handle as well.
        if (this.visible) {
            handle.attachGraph();
            return;
        }
        this.pendingHandlesToMakeVisible.add(handle);
    }
}
exports.FluidObjectHandle = FluidObjectHandle;

},{"@fluidframework/runtime-utils":213}],93:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./dataStoreRuntime"), exports);
__exportStar(require("./fluidHandle"), exports);

},{"./dataStoreRuntime":91,"./fluidHandle":92}],94:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalChannelContext = exports.RehydratedLocalChannelContext = exports.LocalChannelContextBase = void 0;
// eslint-disable-next-line import/no-internal-modules
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const driver_utils_1 = require("@fluidframework/driver-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const common_utils_1 = require("@fluidframework/common-utils");
const channelContext_1 = require("./channelContext");
/**
 * Channel context for a locally created channel
 */
class LocalChannelContextBase {
    constructor(id, registry, runtime, servicesGetter) {
        this.id = id;
        this.registry = registry;
        this.runtime = runtime;
        this.servicesGetter = servicesGetter;
        this.globallyVisible = false;
        this.pending = [];
        (0, common_utils_1.assert)(!this.id.includes("/"), 0x30f /* Channel context ID cannot contain slashes */);
    }
    async getChannel() {
        (0, common_utils_1.assert)(this.channel !== undefined, 0x207 /* "Channel should be defined" */);
        return this.channel;
    }
    get isLoaded() {
        return this.channel !== undefined;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet globallyVisible or loaded
        if (this.globallyVisible && this.isLoaded) {
            this.servicesGetter().value.deltaConnection.setConnectionState(connected);
        }
    }
    processOp(message, local, localOpMetadata) {
        (0, common_utils_1.assert)(this.globallyVisible, 0x2d3 /* "Local channel must be globally visible when processing op" */);
        // A local channel may not be loaded in case where we rehydrate the container from a snapshot because of
        // delay loading. So after the container is attached and some other client joins which start generating
        // ops for this channel. So not loaded local channel can still receive ops and we store them to process later.
        if (this.isLoaded) {
            this.servicesGetter().value.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0, common_utils_1.assert)(local === false, 0x189 /* "Should always be remote because a local dds shouldn't generate ops before loading" */);
            this.pending.push(message);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0, common_utils_1.assert)(this.isLoaded, 0x18a /* "Channel should be loaded to resubmit ops" */);
        (0, common_utils_1.assert)(this.globallyVisible, 0x2d4 /* "Local channel must be globally visible when resubmitting op" */);
        this.servicesGetter().value.deltaConnection.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        (0, common_utils_1.assert)(this.isLoaded, 0x2ee /* "Channel should be loaded to rollback ops" */);
        (0, common_utils_1.assert)(this.globallyVisible, 0x2ef /* "Local channel must be globally visible when rolling back op" */);
        this.servicesGetter().value.deltaConnection.rollback(content, localOpMetadata);
    }
    applyStashedOp() {
        throw new Error("no stashed ops on local channel");
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = false, telemetryContext) {
        (0, common_utils_1.assert)(this.isLoaded && this.channel !== undefined, 0x18c /* "Channel should be loaded to summarize" */);
        return (0, channelContext_1.summarizeChannelAsync)(this.channel, fullTree, trackState, telemetryContext);
    }
    getAttachSummary(telemetryContext) {
        (0, common_utils_1.assert)(this.isLoaded && this.channel !== undefined, 0x18d /* "Channel should be loaded to take snapshot" */);
        return (0, channelContext_1.summarizeChannel)(this.channel, true /* fullTree */, false /* trackState */, telemetryContext);
    }
    makeVisible() {
        if (this.globallyVisible) {
            throw new Error("Channel is already globally visible");
        }
        if (this.isLoaded) {
            (0, common_utils_1.assert)(!!this.channel, 0x192 /* "Channel should be there if loaded!!" */);
            this.channel.connect(this.servicesGetter().value);
        }
        this.globallyVisible = true;
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document. This should be called only after
     * the context has loaded.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0, common_utils_1.assert)(this.isLoaded && this.channel !== undefined, 0x193 /* "Channel should be loaded to run GC" */);
        return this.channel.getGCData(fullGC);
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        /**
         * Currently, DDSes are always considered referenced and are not garbage collected.
         * Once we have GC at DDS level, this channel context's used routes will be updated as per the passed
         * value. See - https://github.com/microsoft/FluidFramework/issues/4611
         */
    }
}
exports.LocalChannelContextBase = LocalChannelContextBase;
class RehydratedLocalChannelContext extends LocalChannelContextBase {
    constructor(id, registry, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn, snapshotTree) {
        super(id, registry, runtime, () => this.services);
        this.snapshotTree = snapshotTree;
        const blobMap = new Map();
        const clonedSnapshotTree = (0, cloneDeep_1.default)(this.snapshotTree);
        // 0.47 back-compat Need to sanitize if snapshotTree.blobs still contains blob contents too.
        // This is for older snapshot which is generated by loader <=0.47 version which still contains
        // the contents within blobs. After a couple of revisions we can remove it.
        if (this.isSnapshotInOldFormatAndCollectBlobs(clonedSnapshotTree, blobMap)) {
            this.sanitizeSnapshot(clonedSnapshotTree);
        }
        this.services = new common_utils_1.Lazy(() => {
            return (0, channelContext_1.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger, clonedSnapshotTree, blobMap);
        });
        this.dirtyFn = () => { dirtyFn(id); };
    }
    async getChannel() {
        if (this.channel === undefined) {
            this.channel = await this.loadChannel()
                .catch((err) => {
                throw container_utils_1.DataProcessingError.wrapIfUnrecognized(err, "rehydratedLocalChannelContextFailedToLoadChannel", undefined);
            });
        }
        return this.channel;
    }
    async loadChannel() {
        (0, common_utils_1.assert)(!this.isLoaded, 0x18e /* "Channel must not already be loaded when loading" */);
        (0, common_utils_1.assert)(await this.services.value.objectStorage.contains(".attributes"), 0x190 /* ".attributes blob should be present" */);
        const attributes = await (0, driver_utils_1.readAndParse)(this.services.value.objectStorage, ".attributes");
        (0, common_utils_1.assert)(this.factory === undefined, 0x208 /* "Factory should be undefined before loading" */);
        this.factory = this.registry.get(attributes.type);
        if (this.factory === undefined) {
            throw new Error(`Channel Factory ${attributes.type} not registered`);
        }
        // Services will be assigned during this load.
        const channel = await this.factory.load(this.runtime, this.id, this.services.value, attributes);
        // Commit changes.
        this.channel = channel;
        // Send all pending messages to the channel
        for (const message of this.pending) {
            this.services.value.deltaConnection.process(message, false, undefined /* localOpMetadata */);
        }
        return this.channel;
    }
    isSnapshotInOldFormatAndCollectBlobs(snapshotTree, blobMap) {
        let sanitize = false;
        const blobsContents = snapshotTree.blobsContents;
        Object.entries(blobsContents).forEach(([key, value]) => {
            blobMap.set(key, value);
            if (snapshotTree.blobs[key] !== undefined) {
                sanitize = true;
            }
        });
        for (const value of Object.values(snapshotTree.trees)) {
            sanitize = sanitize || this.isSnapshotInOldFormatAndCollectBlobs(value, blobMap);
        }
        return sanitize;
    }
    sanitizeSnapshot(snapshotTree) {
        const blobMapInitial = new Map(Object.entries(snapshotTree.blobs));
        for (const [blobName, blobId] of blobMapInitial.entries()) {
            const blobValue = blobMapInitial.get(blobId);
            if (blobValue === undefined) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete snapshotTree.blobs[blobName];
            }
        }
        for (const value of Object.values(snapshotTree.trees)) {
            this.sanitizeSnapshot(value);
        }
    }
}
exports.RehydratedLocalChannelContext = RehydratedLocalChannelContext;
class LocalChannelContext extends LocalChannelContextBase {
    constructor(id, registry, type, runtime, dataStoreContext, storageService, logger, submitFn, dirtyFn, addedGCOutboundReferenceFn) {
        super(id, registry, runtime, () => this.services);
        (0, common_utils_1.assert)(type !== undefined, 0x209 /* "Factory Type should be defined" */);
        this.factory = registry.get(type);
        if (this.factory === undefined) {
            throw new Error(`Channel Factory ${type} not registered`);
        }
        this.channel = this.factory.create(runtime, id);
        this.services = new common_utils_1.Lazy(() => {
            return (0, channelContext_1.createServiceEndpoints)(this.id, dataStoreContext.connected, submitFn, this.dirtyFn, addedGCOutboundReferenceFn, storageService, logger);
        });
        this.dirtyFn = () => { dirtyFn(id); };
    }
}
exports.LocalChannelContext = LocalChannelContext;

},{"./channelContext":88,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"lodash/cloneDeep":502}],95:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteChannelContext = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const channelContext_1 = require("./channelContext");
class RemoteChannelContext {
    constructor(runtime, dataStoreContext, storageService, submitFn, dirtyFn, addedGCOutboundReferenceFn, id, baseSnapshot, registry, extraBlobs, createSummarizerNode, getBaseGCDetails, attachMessageType) {
        this.runtime = runtime;
        this.dataStoreContext = dataStoreContext;
        this.id = id;
        this.registry = registry;
        this.attachMessageType = attachMessageType;
        this.isLoaded = false;
        this.pending = [];
        (0, common_utils_1.assert)(!this.id.includes("/"), 0x310 /* Channel context ID cannot contain slashes */);
        this.subLogger = telemetry_utils_1.ChildLogger.create(this.runtime.logger, "RemoteChannelContext");
        this.services = (0, channelContext_1.createServiceEndpoints)(this.id, this.dataStoreContext.connected, submitFn, () => dirtyFn(this.id), addedGCOutboundReferenceFn, storageService, this.subLogger, baseSnapshot, extraBlobs);
        const thisSummarizeInternal = async (fullTree, trackState, telemetryContext) => this.summarizeInternal(fullTree, trackState, telemetryContext);
        this.summarizerNode = createSummarizerNode(thisSummarizeInternal, async (fullGC) => this.getGCDataInternal(fullGC), async () => getBaseGCDetails());
        this.thresholdOpsCounter = new telemetry_utils_1.ThresholdCounter(RemoteChannelContext.pendingOpsCountThreshold, this.subLogger);
    }
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    getChannel() {
        if (this.channelP === undefined) {
            this.channelP = this.loadChannel();
        }
        return this.channelP;
    }
    setConnectionState(connected, clientId) {
        // Connection events are ignored if the data store is not yet loaded
        if (!this.isLoaded) {
            return;
        }
        this.services.deltaConnection.setConnectionState(connected);
    }
    applyStashedOp(message) {
        (0, common_utils_1.assert)(this.isLoaded, 0x194 /* "Remote channel must be loaded when rebasing op" */);
        return this.services.deltaConnection.applyStashedOp(message);
    }
    processOp(message, local, localOpMetadata) {
        this.summarizerNode.invalidate(message.sequenceNumber);
        if (this.isLoaded) {
            this.services.deltaConnection.process(message, local, localOpMetadata);
        }
        else {
            (0, common_utils_1.assert)(!local, 0x195 /* "Remote channel must not be local when processing op" */);
            (0, common_utils_1.assert)(this.pending !== undefined, 0x23e /* "pending is undefined" */);
            this.pending.push(message);
            this.thresholdOpsCounter.sendIfMultiple("StorePendingOps", this.pending.length);
        }
    }
    reSubmit(content, localOpMetadata) {
        (0, common_utils_1.assert)(this.isLoaded, 0x196 /* "Remote channel must be loaded when resubmitting op" */);
        this.services.deltaConnection.reSubmit(content, localOpMetadata);
    }
    rollback(content, localOpMetadata) {
        (0, common_utils_1.assert)(this.isLoaded, 0x2f0 /* "Remote channel must be loaded when rolling back op" */);
        this.services.deltaConnection.rollback(content, localOpMetadata);
    }
    /**
     * Returns a summary at the current sequence number.
     * @param fullTree - true to bypass optimizations and force a full summary tree
     * @param trackState - This tells whether we should track state from this summary.
     * @param telemetryContext - summary data passed through the layers for telemetry purposes
     */
    async summarize(fullTree = false, trackState = true, telemetryContext) {
        return this.summarizerNode.summarize(fullTree, trackState, telemetryContext);
    }
    async summarizeInternal(fullTree, trackState, telemetryContext) {
        const channel = await this.getChannel();
        const summarizeResult = await (0, channelContext_1.summarizeChannelAsync)(channel, fullTree, trackState, telemetryContext);
        return Object.assign(Object.assign({}, summarizeResult), { id: this.id });
    }
    async loadChannel() {
        (0, common_utils_1.assert)(!this.isLoaded, 0x197 /* "Remote channel must not already be loaded when loading" */);
        let attributes;
        if (await this.services.objectStorage.contains(channelContext_1.attributesBlobKey)) {
            attributes = await (0, driver_utils_1.readAndParse)(this.services.objectStorage, channelContext_1.attributesBlobKey);
        }
        let factory;
        // this is a backward compatibility case where
        // the attach message doesn't include
        // the attributes. Since old attach messages
        // will not have attributes we need to keep
        // this as long as we support old attach messages
        if (attributes === undefined) {
            if (this.attachMessageType === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new container_utils_1.DataCorruptionError("channelTypeNotAvailable", {
                    channelId: {
                        value: this.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                });
            }
            factory = this.registry.get(this.attachMessageType);
            if (factory === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new container_utils_1.DataCorruptionError("channelFactoryNotRegisteredForAttachMessageType", {
                    channelId: {
                        value: this.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: this.attachMessageType,
                });
            }
            attributes = factory.attributes;
        }
        else {
            factory = this.registry.get(attributes.type);
            if (factory === undefined) {
                // TODO: dataStoreId may require a different tag from PackageData #7488
                throw new container_utils_1.DataCorruptionError("channelFactoryNotRegisteredForGivenType", {
                    channelId: {
                        value: this.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStoreId: {
                        value: this.dataStoreContext.id,
                        tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                    },
                    dataStorePackagePath: this.dataStoreContext.packagePath.join("/"),
                    channelFactoryType: attributes.type,
                });
            }
        }
        // Compare snapshot version to collaborative object version
        if (attributes.snapshotFormatVersion !== undefined
            && attributes.snapshotFormatVersion !== factory.attributes.snapshotFormatVersion) {
            this.subLogger.sendTelemetryEvent({
                eventName: "ChannelAttributesVersionMismatch",
                channelType: { value: attributes.type, tag: telemetry_utils_1.TelemetryDataTag.PackageData },
                channelSnapshotVersion: {
                    value: `${attributes.snapshotFormatVersion}@${attributes.packageVersion}`,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
                channelCodeVersion: {
                    value: `${factory.attributes.snapshotFormatVersion}@${factory.attributes.packageVersion}`,
                    tag: telemetry_utils_1.TelemetryDataTag.PackageData,
                },
            });
        }
        const channel = await factory.load(this.runtime, this.id, this.services, attributes);
        // Send all pending messages to the channel
        (0, common_utils_1.assert)(this.pending !== undefined, 0x23f /* "pending undefined" */);
        for (const message of this.pending) {
            this.services.deltaConnection.process(message, false, undefined /* localOpMetadata */);
        }
        this.thresholdOpsCounter.send("ProcessPendingOps", this.pending.length);
        // Commit changes.
        this.channel = channel;
        this.pending = undefined;
        this.isLoaded = true;
        // Because have some await between we created the service and here, the connection state might have changed
        // and we don't propagate the connection state when we are not loaded.  So we have to set it again here.
        this.services.deltaConnection.setConnectionState(this.dataStoreContext.connected);
        return this.channel;
    }
    /**
     * Returns the data used for garbage collection. This includes a list of GC nodes that represent this context.
     * Each node has a set of outbound routes to other GC nodes in the document.
     * If there is no new data in this context since the last summary, previous GC data is used.
     * If there is new data, the GC data is generated again (by calling getGCDataInternal).
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        return this.summarizerNode.getGCData(fullGC);
    }
    /**
     * Generates the data used for garbage collection. This is called when there is new data since last summary. It
     * loads the context and calls into the channel to get its GC data.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCDataInternal(fullGC = false) {
        const channel = await this.getChannel();
        return channel.getGCData(fullGC);
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        /**
         * Currently, DDSes are always considered referenced and are not garbage collected. Update the summarizer node's
         * used routes to contain a route to this channel context.
         * Once we have GC at DDS level, this will be updated to use the passed usedRoutes. See -
         * https://github.com/microsoft/FluidFramework/issues/4611
         */
        this.summarizerNode.updateUsedRoutes([""]);
    }
}
exports.RemoteChannelContext = RemoteChannelContext;
RemoteChannelContext.pendingOpsCountThreshold = 1000;

},{"./channelContext":88,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279}],96:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentDeltaConnection = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
// For now, this package is versioned and released in unison with the specific drivers
const packageVersion_1 = require("./packageVersion");
/**
 * Represents a connection to a stream of delta updates
 */
class DocumentDeltaConnection extends telemetry_utils_1.EventEmitterWithErrorHandling {
    /**
     * @param socket - websocket to be used
     * @param documentId - ID of the document
     * @param logger - for reporting telemetry events
     * @param enableLongPollingDowngrades - allow connection to be downgraded to long-polling on websocket failure
     */
    constructor(socket, documentId, logger, enableLongPollingDowngrades = false) {
        super((name, error) => {
            logger.sendErrorEvent({
                eventName: "DeltaConnection:EventException",
                name,
            }, error);
        });
        this.socket = socket;
        this.documentId = documentId;
        this.enableLongPollingDowngrades = enableLongPollingDowngrades;
        // Listen for ops sent before we receive a response to connect_document
        this.queuedMessages = [];
        this.queuedSignals = [];
        /**
         * A flag to indicate whether we have our handler attached.  If it's attached, we're queueing incoming ops
         * to later be retrieved via initialMessages.
         */
        this.earlyOpHandlerAttached = false;
        // Listeners only needed while the connection is in progress
        this.connectionListeners = new Map();
        // Listeners used throughout the lifetime of the DocumentDeltaConnection
        this.trackedListeners = new Map();
        /**
         * Flag to indicate whether the DocumentDeltaConnection is expected to still be capable of sending messages.
         * After disconnection, we flip this to prevent any stale messages from being emitted.
         */
        this._disposed = false;
        this.earlyOpHandler = (documentId, msgs) => {
            this.queuedMessages.push(...msgs);
        };
        this.earlySignalHandler = (msg) => {
            this.queuedSignals.push(msg);
        };
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(telemetry_utils_1.ChildLogger.create(logger, "DeltaConnection"));
        this.on("newListener", (event, listener) => {
            (0, common_utils_1.assert)(!this.disposed, 0x20a /* "register for event on disposed object" */);
            // Some events are already forwarded - see this.addTrackedListener() calls in initialize().
            if (DocumentDeltaConnection.eventsAlwaysForwarded.includes(event)) {
                (0, common_utils_1.assert)(this.trackedListeners.has(event), 0x245 /* "tracked listener" */);
                return;
            }
            if (!DocumentDeltaConnection.eventsToForward.includes(event)) {
                throw new Error(`DocumentDeltaConnection: Registering for unknown event: ${event}`);
            }
            // Whenever listener is added, we should subscribe on same event on socket, so these two things
            // should be in sync. This currently assumes that nobody unregisters and registers back listeners,
            // and that there are no "internal" listeners installed (like "error" case we skip above)
            // Better flow might be to always unconditionally register all handlers on successful connection,
            // though some logic (naming assert in initialMessages getter) might need to be adjusted (it becomes noop)
            (0, common_utils_1.assert)((this.listeners(event).length !== 0) === this.trackedListeners.has(event), 0x20b /* "mismatch" */);
            if (!this.trackedListeners.has(event)) {
                this.addTrackedListener(event, (...args) => {
                    this.emit(event, ...args);
                });
            }
        });
    }
    get hasDetails() {
        return !!this._details;
    }
    get disposed() {
        (0, common_utils_1.assert)(this._disposed || this.socket.connected, 0x244 /* "Socket is closed, but connection is not!" */);
        return this._disposed;
    }
    /**
     * @deprecated - Implementors should manage their own logger or monitoring context
     */
    get logger() {
        return this.mc.logger;
    }
    get details() {
        if (!this._details) {
            throw new Error("Internal error: calling method before _details is initialized!");
        }
        return this._details;
    }
    /**
     * Get the ID of the client who is sending the message
     *
     * @returns the client ID
     */
    get clientId() {
        return this.details.clientId;
    }
    /**
     * Get the mode of the client
     *
     * @returns the client mode
     */
    get mode() {
        return this.details.mode;
    }
    /**
     * Get the claims of the client who is sending the message
     *
     * @returns client claims
     */
    get claims() {
        return this.details.claims;
    }
    /**
     * Get whether or not this is an existing document
     *
     * @returns true if the document exists
     */
    get existing() {
        return this.details.existing;
    }
    /**
     * Get the maximum size of a message before chunking is required
     *
     * @returns the maximum size of a message before chunking is required
     */
    get maxMessageSize() {
        return this.details.serviceConfiguration.maxMessageSize;
    }
    /**
     * Semver of protocol being used with the service
     */
    get version() {
        return this.details.version;
    }
    /**
     * Configuration details provided by the service
     */
    get serviceConfiguration() {
        return this.details.serviceConfiguration;
    }
    checkNotClosed() {
        (0, common_utils_1.assert)(!this.disposed, 0x20c /* "connection disposed" */);
    }
    /**
     * Get messages sent during the connection
     *
     * @returns messages sent during the connection
     */
    get initialMessages() {
        this.checkNotClosed();
        // If we call this when the earlyOpHandler is not attached, then the queuedMessages may not include the
        // latest ops.  This could possibly indicate that initialMessages was called twice.
        (0, common_utils_1.assert)(this.earlyOpHandlerAttached, 0x08e /* "Potentially missed initial messages" */);
        // We will lose ops and perf will tank as we need to go to storage to become current!
        (0, common_utils_1.assert)(this.listeners("op").length !== 0, 0x08f /* "No op handler is setup!" */);
        this.removeEarlyOpHandler();
        if (this.queuedMessages.length > 0) {
            // Some messages were queued.
            // add them to the list of initialMessages to be processed
            this.details.initialMessages.push(...this.queuedMessages);
            this.details.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
            this.queuedMessages.length = 0;
        }
        return this.details.initialMessages;
    }
    /**
     * Get signals sent during the connection
     *
     * @returns signals sent during the connection
     */
    get initialSignals() {
        this.checkNotClosed();
        (0, common_utils_1.assert)(this.listeners("signal").length !== 0, 0x090 /* "No signal handler is setup!" */);
        this.removeEarlySignalHandler();
        if (this.queuedSignals.length > 0) {
            // Some signals were queued.
            // add them to the list of initialSignals to be processed
            this.details.initialSignals.push(...this.queuedSignals);
            this.queuedSignals.length = 0;
        }
        return this.details.initialSignals;
    }
    /**
     * Get initial client list
     *
     * @returns initial client list sent during the connection
     */
    get initialClients() {
        this.checkNotClosed();
        return this.details.initialClients;
    }
    emitMessages(type, messages) {
        // Although the implementation here disconnects the socket and does not reuse it, other subclasses
        // (e.g. OdspDocumentDeltaConnection) may reuse the socket.  In these cases, we need to avoid emitting
        // on the still-live socket.
        if (!this.disposed) {
            this.socket.emit(type, this.clientId, messages);
        }
    }
    submitCore(type, messages) {
        this.emitMessages(type, [messages]);
    }
    /**
     * Submits a new delta operation to the server
     *
     * @param message - delta operation to submit
     */
    submit(messages) {
        this.checkNotClosed();
        this.submitCore("submitOp", messages);
    }
    /**
     * Submits a new signal to the server
     *
     * @param message - signal to submit
     */
    submitSignal(message) {
        this.checkNotClosed();
        this.submitCore("submitSignal", [message]);
    }
    /**
     * Disconnect from the websocket, and permanently disable this DocumentDeltaConnection.
     */
    dispose() {
        this.disposeCore(false, // socketProtocolError
        (0, driver_utils_1.createGenericNetworkError)(
        // pre-0.58 error message: clientClosingConnection
        "Client closing delta connection", { canRetry: true }, { driverVersion: packageVersion_1.pkgVersion }));
    }
    disposeCore(socketProtocolError, err) {
        // Can't check this.disposed here, as we get here on socket closure,
        // so _disposed & socket.connected might be not in sync while processing
        // "dispose" event.
        if (this._disposed) {
            return;
        }
        // We set the disposed flag as a part of the contract for overriding the disconnect method. This is used by
        // DocumentDeltaConnection to determine if emitting messages (ops) on the socket is allowed, which is
        // important since OdspDocumentDeltaConnection reuses the socket rather than truly disconnecting it. Note that
        // OdspDocumentDeltaConnection may still send disconnect_document which is allowed; this is only intended
        // to prevent normal messages from being emitted.
        this._disposed = true;
        this.removeTrackedListeners();
        this.disconnect(socketProtocolError, err);
    }
    /**
     * Disconnect from the websocket.
     * @param socketProtocolError - true if error happened on socket / socket.io protocol level
     *  (not on Fluid protocol level)
     * @param reason - reason for disconnect
     */
    disconnect(socketProtocolError, reason) {
        this.socket.disconnect();
    }
    async initialize(connectMessage, timeout) {
        this.socket.on("op", this.earlyOpHandler);
        this.socket.on("signal", this.earlySignalHandler);
        this.earlyOpHandlerAttached = true;
        // Socket.io's reconnect_attempt event is unreliable, so we track connect_error count instead.
        let internalSocketConnectionFailureCount = 0;
        const isInternalSocketReconnectionEnabled = () => this.socket.io.reconnection();
        const getMaxInternalSocketReconnectionAttempts = () => isInternalSocketReconnectionEnabled()
            ? this.socket.io.reconnectionAttempts()
            : 0;
        const getMaxAllowedInternalSocketConnectionFailures = () => getMaxInternalSocketReconnectionAttempts() + 1;
        this._details = await new Promise((resolve, reject) => {
            const fail = (socketProtocolError, err) => {
                this.disposeCore(socketProtocolError, err);
                reject(err);
            };
            // Listen for connection issues
            this.addConnectionListener("connect_error", (error) => {
                var _a;
                internalSocketConnectionFailureCount++;
                let isWebSocketTransportError = false;
                try {
                    const description = error === null || error === void 0 ? void 0 : error.description;
                    if (description && typeof description === "object") {
                        if (error.type === "TransportError") {
                            isWebSocketTransportError = true;
                        }
                        // That's a WebSocket. Clear it as we can't log it.
                        description.target = undefined;
                    }
                }
                catch (_e) { }
                // Handle socket transport downgrading when not offline.
                if (isWebSocketTransportError &&
                    this.enableLongPollingDowngrades &&
                    ((_a = this.socket.io.opts.transports) === null || _a === void 0 ? void 0 : _a[0]) !== "polling") {
                    // Downgrade transports to polling upgrade mechanism.
                    this.socket.io.opts.transports = ["polling", "websocket"];
                    // Don't alter reconnection behavior if already enabled.
                    if (!isInternalSocketReconnectionEnabled()) {
                        // Allow single reconnection attempt using polling upgrade mechanism.
                        this.socket.io.reconnection(true);
                        this.socket.io.reconnectionAttempts(1);
                    }
                }
                // Allow built-in socket.io reconnection handling.
                if (isInternalSocketReconnectionEnabled() &&
                    internalSocketConnectionFailureCount < getMaxAllowedInternalSocketConnectionFailures()) {
                    // Reconnection is enabled and maximum reconnect attempts have not been reached.
                    return;
                }
                fail(true, this.createErrorObject("connect_error", error));
            });
            // Listen for timeouts
            this.addConnectionListener("connect_timeout", () => {
                fail(true, this.createErrorObject("connect_timeout"));
            });
            this.addConnectionListener("connect_document_success", (response) => {
                // If we sent a nonce and the server supports nonces, check that the nonces match
                if (connectMessage.nonce !== undefined &&
                    response.nonce !== undefined &&
                    response.nonce !== connectMessage.nonce) {
                    return;
                }
                const requestedMode = connectMessage.mode;
                const actualMode = response.mode;
                const writingPermitted = response.claims.scopes.includes(protocol_definitions_1.ScopeType.DocWrite);
                if (writingPermitted) {
                    // The only time we expect a mismatch in requested/actual is if we lack write permissions
                    // In this case we will get "read", even if we requested "write"
                    if (actualMode !== requestedMode) {
                        fail(false, this.createErrorObject("connect_document_success", "Connected in a different mode than was requested", false));
                        return;
                    }
                }
                else {
                    if (actualMode === "write") {
                        fail(false, this.createErrorObject("connect_document_success", "Connected in write mode without write permissions", false));
                        return;
                    }
                }
                this.checkpointSequenceNumber = response.checkpointSequenceNumber;
                this.removeConnectionListeners();
                resolve(response);
            });
            // Socket can be disconnected while waiting for Fluid protocol messages
            // (connect_document_error / connect_document_success), as well as before DeltaManager
            // had a chance to register its handlers.
            this.addTrackedListener("disconnect", (reason) => {
                const err = this.createErrorObject("disconnect", reason);
                this.emit("disconnect", err);
                fail(true, err);
            });
            this.addTrackedListener("error", ((error) => {
                // First, raise an error event, to give clients a chance to observe error contents
                // This includes "Invalid namespace" error, which we consider critical (reconnecting will not help)
                const err = this.createErrorObject("error", error, error !== "Invalid namespace");
                this.emit("error", err);
                // Disconnect socket - required if happened before initial handshake
                fail(true, err);
            }));
            this.addConnectionListener("connect_document_error", ((error) => {
                // If we sent a nonce and the server supports nonces, check that the nonces match
                if (connectMessage.nonce !== undefined &&
                    error.nonce !== undefined &&
                    error.nonce !== connectMessage.nonce) {
                    return;
                }
                // This is not an socket.io error - it's Fluid protocol error.
                // In this case fail connection and indicate that we were unable to create connection
                fail(false, this.createErrorObject("connect_document_error", error));
            }));
            this.socket.emit("connect_document", connectMessage);
            // Give extra 2 seconds for handshake on top of socket connection timeout
            this.socketConnectionTimeout = setTimeout(() => {
                fail(false, this.createErrorObject("orderingServiceHandshakeTimeout"));
            }, timeout + 2000);
        });
        (0, common_utils_1.assert)(!this.disposed, 0x246 /* "checking consistency of socket & _disposed flags" */);
    }
    removeEarlyOpHandler() {
        this.socket.removeListener("op", this.earlyOpHandler);
        this.earlyOpHandlerAttached = false;
    }
    removeEarlySignalHandler() {
        this.socket.removeListener("signal", this.earlySignalHandler);
    }
    addConnectionListener(event, listener) {
        (0, common_utils_1.assert)(!DocumentDeltaConnection.eventsAlwaysForwarded.includes(event), 0x247 /* "Use addTrackedListener instead" */);
        (0, common_utils_1.assert)(!DocumentDeltaConnection.eventsToForward.includes(event), 0x248 /* "should not subscribe to forwarded events" */);
        this.socket.on(event, listener);
        (0, common_utils_1.assert)(!this.connectionListeners.has(event), 0x20d /* "double connection listener" */);
        this.connectionListeners.set(event, listener);
    }
    addTrackedListener(event, listener) {
        this.socket.on(event, listener);
        (0, common_utils_1.assert)(!this.trackedListeners.has(event), 0x20e /* "double tracked listener" */);
        this.trackedListeners.set(event, listener);
    }
    removeTrackedListeners() {
        for (const [event, listener] of this.trackedListeners.entries()) {
            this.socket.off(event, listener);
        }
        // removeTrackedListeners removes all listeners, including connection listeners
        this.removeConnectionListeners();
        this.removeEarlyOpHandler();
        this.removeEarlySignalHandler();
        this.trackedListeners.clear();
    }
    removeConnectionListeners() {
        if (this.socketConnectionTimeout !== undefined) {
            clearTimeout(this.socketConnectionTimeout);
        }
        for (const [event, listener] of this.connectionListeners.entries()) {
            this.socket.off(event, listener);
        }
        this.connectionListeners.clear();
    }
    /**
     * Error raising for socket.io issues
     */
    createErrorObject(handler, error, canRetry = true) {
        // Note: we suspect the incoming error object is either:
        // - a string: log it in the message (if not a string, it may contain PII but will print as [object Object])
        // - an Error object thrown by socket.io engine. Be careful with not recording PII!
        let message;
        if ((error === null || error === void 0 ? void 0 : error.type) === "TransportError") {
            // JSON.stringify drops Error.message
            const messagePrefix = ((error === null || error === void 0 ? void 0 : error.message) !== undefined)
                ? `${error.message}: `
                : "";
            // Websocket errors reported by engine.io-client.
            // They are Error objects with description containing WS error and description = "TransportError"
            // Please see https://github.com/socketio/engine.io-client/blob/7245b80/lib/transport.ts#L44,
            message = `${messagePrefix}${JSON.stringify(error, (0, telemetry_utils_1.getCircularReplacer)())}`;
        }
        else {
            message = (0, common_utils_1.extractLogSafeErrorProperties)(error).message;
        }
        const errorObj = (0, driver_utils_1.createGenericNetworkError)(`socket.io (${handler}): ${message}`, { canRetry }, { driverVersion: packageVersion_1.pkgVersion });
        return errorObj;
    }
}
exports.DocumentDeltaConnection = DocumentDeltaConnection;
DocumentDeltaConnection.eventsToForward = ["nack", "op", "signal", "pong"];
// WARNING: These are critical events that we can't miss, so registration for them has to be in place at all times!
// Including before handshake is over, and after that (but before DeltaManager had a chance to put its own handlers)
DocumentDeltaConnection.eventsAlwaysForwarded = ["disconnect", "error"];

},{"./packageVersion":98,"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],97:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./documentDeltaConnection"), exports);

},{"./documentDeltaConnection":96}],98:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/driver-base";
exports.pkgVersion = "1.3.6";

},{}],99:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverErrorType = void 0;
/**
 * Driver Error types
 * Lists types that are likely to be used by all drivers
 */
var DriverErrorType;
(function (DriverErrorType) {
    /**
     * A fatal error with no specific interpretation covered by other DriverErrorType values
     */
    DriverErrorType["genericError"] = "genericError";
    /**
     * Some non-categorized (below) networking error
     * Include errors like  fatal server error (usually 500).
     */
    DriverErrorType["genericNetworkError"] = "genericNetworkError";
    /**
     * Access denied - user does not have enough privileges to open a file, or continue to operate on a file
     */
    DriverErrorType["authorizationError"] = "authorizationError";
    /**
     * File not found, or file deleted during session
     */
    DriverErrorType["fileNotFoundOrAccessDeniedError"] = "fileNotFoundOrAccessDeniedError";
    /**
     * Throttling error from server. Server is busy and is asking not to reconnect for some time
     */
    DriverErrorType["throttlingError"] = "throttlingError";
    /**
     * We can not reach server due to computer being offline.
     */
    DriverErrorType["offlineError"] = "offlineError";
    /*
     * Unsupported client protocol
     */
    DriverErrorType["unsupportedClientProtocolVersion"] = "unsupportedClientProtocolVersion";
    /**
     * User does not have write permissions to a file, but is changing content of a file.
     * That might be indication of some data store error - data stores should not generate ops in readonly mode.
     */
    DriverErrorType["writeError"] = "writeError";
    /**
     * A generic fetch failure that indicates we were not able to get a response from the server.
     * This may be due to the client being offline (though, if we are able to detect offline state it will be
     * logged as an offlineError instead).  Other possibilities could be DNS errors, malformed fetch request,
     * CSP violation, etc.
     */
    DriverErrorType["fetchFailure"] = "fetchFailure";
    /**
     * Unexpected response from server. Either JSON is malformed, or some required properties are missing
     */
    DriverErrorType["incorrectServerResponse"] = "incorrectServerResponse";
    /**
     * This error occurs when the file is modified externally (not through Fluid protocol) in storage.
     * It will occur in cases where client has some state or cache that is based on old content (identity) of a file,
     * and storage / driver / loader detects such mismatch.
     * When it's hit, client needs to forget all the knowlege about this file and start over.
     */
    DriverErrorType["fileOverwrittenInStorage"] = "fileOverwrittenInStorage";
    /**
     * The document is read-only and delta stream connection is forbidden.
     */
    DriverErrorType["deltaStreamConnectionForbidden"] = "deltaStreamConnectionForbidden";
    /**
     * The location of file/container can change on server. So if the file location moves and we try to access the old
     * location, then this error is thrown to let the client know about the new location info.
     */
    DriverErrorType["locationRedirection"] = "locationRedirection";
})(DriverErrorType = exports.DriverErrorType || (exports.DriverErrorType = {}));

},{}],100:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./driverError"), exports);
__exportStar(require("./storage"), exports);
__exportStar(require("./urlResolver"), exports);

},{"./driverError":99,"./storage":101,"./urlResolver":102}],101:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoaderCachingPolicy = void 0;
var LoaderCachingPolicy;
(function (LoaderCachingPolicy) {
    /**
     * The loader should not implement any prefetching or caching policy.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["NoCaching"] = 0] = "NoCaching";
    /**
     * The loader should implement prefetching policy, i.e. it should prefetch resources from the latest snapshot.
     */
    LoaderCachingPolicy[LoaderCachingPolicy["Prefetch"] = 1] = "Prefetch";
})(LoaderCachingPolicy = exports.LoaderCachingPolicy || (exports.LoaderCachingPolicy = {}));

},{}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverHeader = void 0;
/**
 * Additional key in the loader request header
 */
var DriverHeader;
(function (DriverHeader) {
    // Key to indicate whether the request for summarizer
    DriverHeader["summarizingClient"] = "fluid-client-summarizer";
    // createNew information, specific to each driver
    DriverHeader["createNew"] = "createNew";
})(DriverHeader = exports.DriverHeader || (exports.DriverHeader = {}));

},{}],103:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobAggregationStorage = exports.SnapshotExtractor = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/*
 * Work around for bufferToString having a bug - it can't consume IsoBuffer!
 * To be removed once bufferToString is fixed!
*/
function bufferToString2(blob, encoding) {
    if (blob instanceof Uint8Array) { // IsoBuffer does not have ctor, so it's not in proto chain :(
        return (0, common_utils_1.Uint8ArrayToString)(blob, encoding);
    }
    return (0, common_utils_1.bufferToString)(blob, encoding);
}
/**
 * Class responsible for aggregating smaller blobs into one and unpacking it later on.
 */
class BlobAggregator {
    constructor() {
        this.content = [];
    }
    addBlob(key, content) {
        this.content.push([key, content]);
    }
    getAggregatedBlobContent() {
        if (this.content.length === 0) {
            return undefined;
        }
        return JSON.stringify(this.content);
    }
    static load(input) {
        const data = bufferToString2(input, "utf-8");
        return JSON.parse(data);
    }
}
/*
 * Base class that deals with unpacking snapshots (in place) containing aggregated blobs
 * It relies on abstract methods for reads and storing unpacked blobs.
 */
class SnapshotExtractor {
    constructor() {
        this.aggregatedBlobName = "__big";
        this.virtualIdPrefix = "__";
        // counter for generation of virtual storage IDs
        this.virtualIdCounter = 0;
    }
    getNextVirtualId() {
        return `${this.virtualIdPrefix}${++this.virtualIdCounter}`;
    }
    async unpackSnapshotCore(snapshot, level = 0) {
        for (const key of Object.keys(snapshot.trees)) {
            const obj = snapshot.trees[key];
            await this.unpackSnapshotCore(obj, level + 1);
        }
        // For future proof, we will support multiple aggregated blobs with any name
        // that starts with this.aggregatedBlobName
        for (const key of Object.keys(snapshot.blobs)) {
            if (!key.startsWith(this.aggregatedBlobName)) {
                continue;
            }
            const blobId = snapshot.blobs[key];
            if (blobId !== undefined) {
                const blob = await this.getBlob(blobId, snapshot);
                for (const [path, value] of BlobAggregator.load(blob)) {
                    const id = this.getNextVirtualId();
                    this.setBlob(id, snapshot, value);
                    const pathSplit = path.split("/");
                    let subTree = snapshot;
                    for (const subPath of pathSplit.slice(0, pathSplit.length - 1)) {
                        if (subTree.trees[subPath] === undefined) {
                            subTree.trees[subPath] = { blobs: {}, trees: {} };
                        }
                        subTree = subTree.trees[subPath];
                    }
                    const blobName = pathSplit[pathSplit.length - 1];
                    (0, common_utils_1.assert)(subTree.blobs[blobName] === undefined, 0x0f6 /* "real blob ID exists" */);
                    subTree.blobs[blobName] = id;
                }
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete snapshot.blobs[this.aggregatedBlobName];
            }
        }
    }
}
exports.SnapshotExtractor = SnapshotExtractor;
/*
 * Snapshot extractor class that works in place, i.e. patches snapshot that has
 * blob content in ISnapshotTree.blobs itself, not in storage.
 * As result, it implements reading and writing of blobs to/from snapshot itself.
 * It follows existing pattern that mixes concerns - ISnapshotTree.blobs is used for two
 * purposes:
 * 1. map path name to blob ID
 * 2. map blob ID to blob content
 * #2 is what storage (IDocumentStorageService) is for, but in places where we do not have it
 * (like loading serialized earlier draft content), blob content is put directly into snapshot.
 * Ideally this should be fixed by using BlobCacheStorageService or something similar and
 * fixing existing flows to allow switching of storage.
 */
class SnapshotExtractorInPlace extends SnapshotExtractor {
    async getBlob(id, tree) {
        const blob = tree.blobs[id];
        (0, common_utils_1.assert)(blob !== undefined, 0x0f7 /* "aggregate blob missing" */);
        return (0, common_utils_1.stringToBuffer)(blob, "base64");
    }
    setBlob(id, tree, content) {
        (0, common_utils_1.assert)(tree.blobs[id] === undefined, 0x0f8 /* "blob from aggregate blob exists on its own" */);
        tree.blobs[id] = (0, common_utils_1.fromUtf8ToBase64)(content);
    }
}
/*
 * Snapshot packer and extractor.
 * When summary is written it will find and aggregate small blobs into bigger blobs
 * When snapshot is read, it will unpack aggregated blobs and provide them transparently to caller.
 */
class BlobAggregationStorage extends SnapshotExtractor {
    constructor(storage, logger, allowPacking, packingLevel, blobCutOffSize) {
        super();
        this.storage = storage;
        this.logger = logger;
        this.allowPacking = allowPacking;
        this.packingLevel = packingLevel;
        this.blobCutOffSize = blobCutOffSize;
        this.loadedFromSummary = false;
        this.virtualBlobs = new Map();
    }
    static wrap(storage, logger, allowPacking, packingLevel = 2) {
        var _a, _b, _c;
        if (storage instanceof BlobAggregationStorage) {
            return storage;
        }
        const mc = (0, telemetry_utils_1.loggerToMonitoringContext)(logger);
        const realAllowPackaging = (_b = (_a = mc.config.getBoolean("FluidAggregateBlobs")) !== null && _a !== void 0 ? _a : allowPacking) !== null && _b !== void 0 ? _b : false;
        // Always create BlobAggregationStorage even if storage is not asking for packing.
        // This is mostly to avoid cases where future changes in policy would result in inability to
        // load old files that were created with aggregation on.
        const minBlobSize = (_c = storage.policies) === null || _c === void 0 ? void 0 : _c.minBlobSize;
        return new BlobAggregationStorage(storage, logger, realAllowPackaging, packingLevel, minBlobSize);
    }
    static async unpackSnapshot(snapshot) {
        const converter = new SnapshotExtractorInPlace();
        await converter.unpackSnapshotCore(snapshot);
    }
    get policies() {
        const policies = this.storage.policies;
        if (policies) {
            return Object.assign(Object.assign({}, policies), { minBlobSize: undefined });
        }
    }
    async unpackSnapshot(snapshot) {
        // SummarizerNodeWithGC.refreshLatestSummary can call it when this.loadedFromSummary === false
        // (I assumed after file was created)
        // assert(!this.loadedFromSummary, "unpack without summary");
        this.loadedFromSummary = true;
        await this.unpackSnapshotCore(snapshot);
    }
    setBlob(id, tree, content) {
        this.virtualBlobs.set(id, (0, common_utils_1.stringToBuffer)(content, "utf-8"));
    }
    async getBlob(id, tree) {
        return this.readBlob(id).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "BlobDedupNoAggregateBlob" }, error);
            throw error;
        });
    }
    get repositoryUrl() { return this.storage.repositoryUrl; }
    async getVersions(versionId, count) {
        return this.storage.getVersions(versionId, count);
    }
    async downloadSummary(handle) {
        throw new Error("NYI");
    }
    // for now we are not optimizing these blobs, with assumption that this API is used only
    // for big blobs (images)
    async createBlob(file) {
        return this.storage.createBlob(file);
    }
    async getSnapshotTree(version) {
        const tree = await this.storage.getSnapshotTree(version);
        if (tree) {
            await this.unpackSnapshot(tree);
        }
        return tree;
    }
    async readBlob(id) {
        if (this.isRealStorageId(id)) {
            return this.storage.readBlob(id);
        }
        // We support only reading blobs from the summary we loaded from.
        // This may need to be extended to any general summary in the future as runtime usage pattern
        // of storage changes (for example, data stores start to load from recent summary, not from original
        // summary whole container loaded from)
        // are there other ways we can get here? createFile is one flow, but we should not be reading blobs
        // in such flow
        (0, common_utils_1.assert)(this.loadedFromSummary, 0x0f9 /* "never read summary" */);
        const blob = this.virtualBlobs.get(id);
        (0, common_utils_1.assert)(blob !== undefined, 0x0fa /* "virtual blob not found" */);
        return blob;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryNew = this.allowPacking ? await this.compressSmallBlobs(summary) : summary;
        return this.storage.uploadSummaryWithContext(summaryNew, context);
    }
    // For simplification, we assume that
    // - blob aggregation is done at data store level only for now
    // - data store either reuses previous summary, or generates full summary, i.e. there is no partial (some DDS)
    // summary produced by data stores.
    // These simplifications allow us not to touch handles, as they are self-contained (either do not use aggregated
    // blob Or contain aggregated blob that stays relevant for that sub-tree)
    // Note:
    // From perf perspective, it makes sense to place aggregated blobs one level up in the tree not to create extra
    // tree nodes (i.e. have shallow tree with less edges). But that creates problems with reusability of trees at
    // incremental summary time - we would need to understand handles and parse them. In current design we can skip
    // that step because if data store is reused, the hole sub-tree is reused included aggregated blob embedded into it
    // and that means we can do nothing and be correct!
    async compressSmallBlobs(summary, path = "", level = 0, aggregatorArg) {
        if (this.blobCutOffSize === undefined || this.blobCutOffSize < 0) {
            return summary;
        }
        let shouldCompress = false;
        let aggregator = aggregatorArg;
        // checking if this is a dataStore tree, since we only pack at data store level
        if (Object.keys(summary.tree).includes(".component")) {
            (0, common_utils_1.assert)(aggregator === undefined, 0x0fb /* "logic err with aggregator" */);
            (0, common_utils_1.assert)(level === this.packingLevel, 0x23b /* "we are not packing at the right level" */);
            aggregator = new BlobAggregator();
            shouldCompress = true;
        }
        else {
            (0, common_utils_1.assert)(level !== this.packingLevel, 0x23c /* "we are not packing at the right level" */);
        }
        const newSummary = Object.assign({}, summary);
        newSummary.tree = Object.assign({}, newSummary.tree);
        for (const key of Object.keys(summary.tree)) {
            const obj = summary.tree[key];
            // Get path relative to root of data store (where we do aggregation)
            const newPath = shouldCompress ? key : `${path}/${key}`;
            switch (obj.type) {
                case protocol_definitions_1.SummaryType.Tree:
                    // If client created empty tree, keep it as is
                    // Also do not package search blobs - they are part of storage contract
                    if (obj.tree !== {} && key !== "__search") {
                        const tree = await this.compressSmallBlobs(obj, newPath, level + 1, aggregator);
                        newSummary.tree[key] = tree;
                        if (tree.tree === {}) {
                            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                            delete newSummary.tree[key];
                        }
                    }
                    break;
                case protocol_definitions_1.SummaryType.Blob:
                    if (aggregator && typeof obj.content == "string" && obj.content.length < this.blobCutOffSize) {
                        aggregator.addBlob(newPath, obj.content);
                        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                        delete newSummary.tree[key];
                    }
                    break;
                case protocol_definitions_1.SummaryType.Handle: {
                    // Would be nice to:
                    // Trees: expand the tree
                    // Blobs: parse handle and ensure it points to real blob, not virtual blob.
                    // We can avoid it for now given data store is the granularity of incremental summaries.
                    let handlePath = obj.handle;
                    if (handlePath.startsWith("/")) {
                        handlePath = handlePath.substr(1);
                    }
                    // Ensure only whole data stores can be reused, no reusing at deeper level!
                    (0, common_utils_1.assert)(level === 0, 0x0fc /* "tree reuse at lower level" */);
                    (0, common_utils_1.assert)(!handlePath.includes("/"), 0x0fd /* "data stores are writing incremental summaries!" */);
                    break;
                }
                case protocol_definitions_1.SummaryType.Attachment:
                    (0, common_utils_1.assert)(this.isRealStorageId(obj.id), 0x0fe /* "attachment is aggregate blob" */);
                    break;
                default:
                    (0, common_utils_1.unreachableCase)(obj, `Unknown type: ${obj.type}`);
            }
        }
        (0, common_utils_1.assert)(newSummary.tree[this.aggregatedBlobName] === undefined, 0x0ff /* "duplicate aggregate blob" */);
        if (shouldCompress) {
            // Note: It would be great to add code here to unpack aggregate blob back to normal blobs
            // If only one blob made it into aggregate. Currently that does not happen as we always have
            // at least one .component blob and at least one DDS that has .attributes blob, so it's not an issue.
            // But it's possible that in future that would be great addition!
            // Good news - it's backward compatible change.
            (0, common_utils_1.assert)(aggregator !== undefined, 0x100 /* "logic error" */);
            const content = aggregator.getAggregatedBlobContent();
            if (content !== undefined) {
                newSummary.tree[this.aggregatedBlobName] = {
                    type: protocol_definitions_1.SummaryType.Blob,
                    content,
                };
            }
        }
        return newSummary;
    }
    isRealStorageId(id) {
        return !id.startsWith(this.virtualIdPrefix);
    }
}
exports.BlobAggregationStorage = BlobAggregationStorage;
// Tells data store if it can use incremental summary (i.e. reuse DDSes from previous summary
// when only one DDS changed).
// The answer has to be know long before we enable actual packing. The reason for the is the following:
// A the moment when we enable packing, we should assume that all clients out there wil already have bits
// that can unpack properly (i.e. enough time passed since we deployed bits that can unpack)
// But we can still have clients where some of them already pack, and some do not. If one summary was
// using packing, then it relies on non-incremental summaries going forward, even if next client who
// produced summary is not packing!
// This can have slight improvement by enabling it per file (based on "did summary we loaded from contain
// aggregated blobs"), but that's harder to make reliable, so going for simplicity.
BlobAggregationStorage.fullDataStoreSummaries = true;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],104:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobCacheStorageService = void 0;
const documentStorageServiceProxy_1 = require("./documentStorageServiceProxy");
/**
 * IDocumentStorageService adapter with pre-cached blobs.
 */
class BlobCacheStorageService extends documentStorageServiceProxy_1.DocumentStorageServiceProxy {
    constructor(internalStorageService, blobs) {
        super(internalStorageService);
        this.blobs = blobs;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    async readBlob(id) {
        const blob = this.blobs.get(id);
        if (blob !== undefined) {
            return blob;
        }
        return this.internalStorageService.readBlob(id);
    }
}
exports.BlobCacheStorageService = BlobCacheStorageService;

},{"./documentStorageServiceProxy":106}],105:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSnapshotTree = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const protocol_base_1 = require("@fluidframework/protocol-base");
const uuid_1 = require("uuid");
function flattenCore(path, treeEntries, blobMap) {
    const entries = [];
    for (const treeEntry of treeEntries) {
        const subPath = `${path}${treeEntry.path}`;
        if (treeEntry.type === protocol_definitions_1.TreeEntry.Blob) {
            const blob = treeEntry.value;
            const buffer = (0, common_utils_1.stringToBuffer)(blob.contents, blob.encoding);
            const id = (0, uuid_1.v4)();
            blobMap.set(id, buffer);
            const entry = {
                mode: protocol_definitions_1.FileMode[treeEntry.mode],
                path: subPath,
                sha: id,
                size: 0,
                type: "blob",
                url: "",
            };
            entries.push(entry);
        }
        else if (treeEntry.type === protocol_definitions_1.TreeEntry.Tree) {
            (0, common_utils_1.assert)(treeEntry.type === protocol_definitions_1.TreeEntry.Tree, 0x101 /* "Unexpected tree entry type on flatten!" */);
            const t = treeEntry.value;
            const entry = {
                mode: protocol_definitions_1.FileMode[treeEntry.mode],
                path: subPath,
                sha: "",
                size: -1,
                type: "tree",
                url: "",
            };
            entries.push(entry);
            const subTreeEntries = flattenCore(`${subPath}/`, t.entries, blobMap);
            entries.push(...subTreeEntries);
        }
    }
    return entries;
}
/**
 * Create a flatten view of an array of ITreeEntry
 *
 * @param tree - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content
 * @returns A flatten with of the ITreeEntry
 */
function flatten(tree, blobMap) {
    const entries = flattenCore("", tree, blobMap);
    return {
        sha: "",
        tree: entries,
        url: "",
    };
}
/**
 * Build a tree hierarchy base on an array of ITreeEntry
 *
 * @param entries - an array of ITreeEntry to flatten
 * @param blobMap - a map of blob's sha1 to content that gets filled with content from entries
 * NOTE: blobMap's validity is contingent on the returned promise's resolution
 * @returns the hierarchical tree
 */
function buildSnapshotTree(entries, blobMap) {
    const flattened = flatten(entries, blobMap);
    return (0, protocol_base_1.buildHierarchy)(flattened);
}
exports.buildSnapshotTree = buildSnapshotTree;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174,"uuid":544}],106:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentStorageServiceProxy = void 0;
class DocumentStorageServiceProxy {
    constructor(internalStorageService) {
        this.internalStorageService = internalStorageService;
    }
    set policies(policies) {
        this._policies = policies;
    }
    get policies() {
        var _a;
        return (_a = this._policies) !== null && _a !== void 0 ? _a : this.internalStorageService.policies;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.internalStorageService.getSnapshotTree(version, scenarioName);
    }
    async getVersions(versionId, count, scenarioName) {
        return this.internalStorageService.getVersions(versionId, count, scenarioName);
    }
    async uploadSummaryWithContext(summary, context) {
        return this.internalStorageService.uploadSummaryWithContext(summary, context);
    }
    async downloadSummary(handle) {
        return this.internalStorageService.downloadSummary(handle);
    }
    async createBlob(file) {
        return this.internalStorageService.createBlob(file);
    }
    async readBlob(blobId) {
        return this.internalStorageService.readBlob(blobId);
    }
}
exports.DocumentStorageServiceProxy = DocumentStorageServiceProxy;

},{}],107:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptyDocumentDeltaStorageService = void 0;
const parallelRequests_1 = require("./parallelRequests");
/**
 * Implementation of IDocumentDeltaStorageService that will always return an empty message queue when fetching messages
 */
class EmptyDocumentDeltaStorageService {
    fetchMessages(from, _to, _abortSignal, _cachedOnly, _fetchReason) {
        const queue = new parallelRequests_1.Queue();
        queue.pushDone();
        return queue;
    }
}
exports.EmptyDocumentDeltaStorageService = EmptyDocumentDeltaStorageService;

},{"./parallelRequests":118}],108:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsageError = void 0;
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
/** Error indicating an API is being used improperly resulting in an invalid operation. */
class UsageError extends telemetry_utils_1.LoggingError {
    constructor(message) {
        super(message, { usageError: true });
        this.errorType = "usageError";
    }
}
exports.UsageError = UsageError;

},{"@fluidframework/telemetry-utils":279}],109:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureFluidResolvedUrl = exports.isFluidResolvedUrl = void 0;
const isFluidResolvedUrl = (resolved) => (resolved === null || resolved === void 0 ? void 0 : resolved.type) === "fluid";
exports.isFluidResolvedUrl = isFluidResolvedUrl;
function ensureFluidResolvedUrl(resolved) {
    if (!(0, exports.isFluidResolvedUrl)(resolved)) {
        throw new Error(`resolved is not a Fluid url. Type: ${resolved === null || resolved === void 0 ? void 0 : resolved.type}`);
    }
}
exports.ensureFluidResolvedUrl = ensureFluidResolvedUrl;

},{}],110:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./blobCacheStorageService"), exports);
__exportStar(require("./blobAggregationStorage"), exports);
__exportStar(require("./buildSnapshotTree"), exports);
__exportStar(require("./documentStorageServiceProxy"), exports);
__exportStar(require("./insecureUrlResolver"), exports);
__exportStar(require("./multiDocumentServiceFactory"), exports);
__exportStar(require("./multiUrlResolver"), exports);
__exportStar(require("./network"), exports);
__exportStar(require("./readAndParse"), exports);
__exportStar(require("./fluidResolvedUrl"), exports);
__exportStar(require("./summaryForCreateNew"), exports);
__exportStar(require("./parallelRequests"), exports);
__exportStar(require("./prefetchDocumentStorageService"), exports);
__exportStar(require("./networkUtils"), exports);
__exportStar(require("./rateLimiter"), exports);
__exportStar(require("./runWithRetry"), exports);
__exportStar(require("./treeConversions"), exports);
__exportStar(require("./treeUtils"), exports);
__exportStar(require("./messageRecognition"), exports);
__exportStar(require("./error"), exports);
__exportStar(require("./emptyDocumentDeltaStorageService"), exports);

},{"./blobAggregationStorage":103,"./blobCacheStorageService":104,"./buildSnapshotTree":105,"./documentStorageServiceProxy":106,"./emptyDocumentDeltaStorageService":107,"./error":108,"./fluidResolvedUrl":109,"./insecureUrlResolver":111,"./messageRecognition":112,"./multiDocumentServiceFactory":113,"./multiUrlResolver":114,"./network":115,"./networkUtils":116,"./parallelRequests":118,"./prefetchDocumentStorageService":119,"./rateLimiter":120,"./readAndParse":121,"./runWithRetry":122,"./summaryForCreateNew":123,"./treeConversions":124,"./treeUtils":125}],111:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsecureUrlResolver = void 0;
const url_1 = require("url");
const common_utils_1 = require("@fluidframework/common-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const axios_1 = __importDefault(require("axios"));
/**
 * As the name implies this is not secure and should not be used in production. It simply makes the example easier
 * to get up and running.
 *
 * In our example we run a simple web server via webpack-dev-server. This defines a URL format of the form
 * http://localhost:8080/<documentId>/<path>.
 *
 * We then need to map that to a Fluid based URL. These are of the form
 * fluid://orderingUrl/<tenantId>/<documentId>/<path>.
 *
 * The tenantId/documentId pair defines the 'full' document ID the service makes use of. The path is then an optional
 * part of the URL that the document interprets and maps to a data store. It's exactly similar to how a web service
 * works or a router inside of a single page app framework.
 */
class InsecureUrlResolver {
    constructor(hostUrl, ordererUrl, storageUrl, tenantId, bearer, isForNodeTest = false) {
        this.hostUrl = hostUrl;
        this.ordererUrl = ordererUrl;
        this.storageUrl = storageUrl;
        this.tenantId = tenantId;
        this.bearer = bearer;
        this.isForNodeTest = isForNodeTest;
        this.cache = new Map();
    }
    async resolve(request) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[driver_definitions_1.DriverHeader.createNew]) {
            const [, queryString] = request.url.split("?");
            const searchParams = new URLSearchParams(queryString);
            const fileName = searchParams.get("fileName");
            return this.resolveHelper(fileName);
        }
        const parsedUrl = new URL(request.url);
        // If hosts match then we use the local tenant information. Otherwise we make a REST call out to the hosting
        // service using our bearer token.
        if (this.isForNodeTest) {
            const [, documentId, tmpRelativePath] = parsedUrl.pathname.substr(1).split("/");
            const relativePath = tmpRelativePath === undefined ? "" : tmpRelativePath;
            return this.resolveHelper(documentId, relativePath, parsedUrl.search);
        }
        else if (parsedUrl.host === window.location.host) {
            const fullPath = parsedUrl.pathname.substr(1);
            const documentId = fullPath.split("/")[0];
            const documentRelativePath = fullPath.slice(documentId.length);
            return this.resolveHelper(documentId, documentRelativePath);
        }
        else {
            const maybeResolvedUrl = this.cache.get(request.url);
            if (maybeResolvedUrl) {
                return maybeResolvedUrl;
            }
            const headers = {
                Authorization: `Bearer ${this.bearer}`,
            };
            const resolvedP = axios_1.default.post(`${this.hostUrl}/api/v1/load`, {
                url: request.url,
            }, {
                headers,
            });
            this.cache.set(request.url, resolvedP.then((resolved) => resolved.data));
            return this.cache.get(request.url);
        }
    }
    resolveHelper(documentId, documentRelativePath = "", queryParams = "") {
        const encodedTenantId = encodeURIComponent(this.tenantId);
        const host = new URL(this.ordererUrl).host;
        // when the document ID is not provided we need to resolve a special create new document URL.
        // the actual container ID will be generated by the driver.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if (!documentId) {
            const createNewResponse = {
                endpoints: {
                    deltaStorageUrl: `${this.ordererUrl}/deltas/${encodedTenantId}/new`,
                    ordererUrl: this.ordererUrl,
                    storageUrl: `${this.storageUrl}/repos/${encodedTenantId}`,
                },
                // document ID is ignored by the driver for new container requests
                id: "",
                tokens: {},
                type: "fluid",
                url: `fluid://${host}/${encodedTenantId}/new`,
            };
            return createNewResponse;
        }
        const encodedDocId = encodeURIComponent(documentId);
        const relativePath = !documentRelativePath || documentRelativePath.startsWith("/")
            ? documentRelativePath : `/${documentRelativePath}`;
        const documentUrl = `fluid://${host}/${encodedTenantId}/${encodedDocId}${relativePath}${queryParams}`;
        const deltaStorageUrl = `${this.ordererUrl}/deltas/${encodedTenantId}/${encodedDocId}`;
        const storageUrl = `${this.storageUrl}/repos/${encodedTenantId}`;
        const response = {
            endpoints: {
                deltaStorageUrl,
                ordererUrl: this.ordererUrl,
                storageUrl,
            },
            id: documentId,
            tokens: {},
            type: "fluid",
            url: documentUrl,
        };
        return response;
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        var _a, _b;
        const fluidResolvedUrl = resolvedUrl;
        const parsedUrl = (0, url_1.parse)(fluidResolvedUrl.url);
        const [, , documentId] = (_b = (_a = parsedUrl.pathname) === null || _a === void 0 ? void 0 : _a.split("/")) !== null && _b !== void 0 ? _b : [];
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        (0, common_utils_1.assert)(!!documentId, 0x273 /* "Invalid document id from parsed URL" */);
        let url = relativeUrl;
        if (url.startsWith("/")) {
            url = url.substr(1);
        }
        return `${this.hostUrl}/${encodeURIComponent(this.tenantId)}/${encodeURIComponent(documentId)}/${url}`;
    }
    createCreateNewRequest(fileName) {
        const createNewRequest = {
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            url: fileName ? `${this.hostUrl}?fileName=${fileName}` : this.hostUrl,
            headers: {
                [driver_definitions_1.DriverHeader.createNew]: true,
            },
        };
        return createNewRequest;
    }
}
exports.InsecureUrlResolver = InsecureUrlResolver;

},{"@fluidframework/common-utils":29,"@fluidframework/driver-definitions":100,"axios":313,"url":569}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUnpackedRuntimeMessage = exports.isRuntimeMessage = exports.isClientMessage = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below
 * "op"
 * "summarize"
 * "propose"
 * "reject"
 * "noop"
 */
function isClientMessage(message) {
    if (isRuntimeMessage(message)) {
        return true;
    }
    switch (message.type) {
        case protocol_definitions_1.MessageType.Propose:
        case protocol_definitions_1.MessageType.Reject:
        case protocol_definitions_1.MessageType.NoOp:
            return true;
        default:
            return false;
    }
}
exports.isClientMessage = isClientMessage;
/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below
 * "op"
 * "summarize"
 */
function isRuntimeMessage(message) {
    return message.type === protocol_definitions_1.MessageType.Operation || message.type === protocol_definitions_1.MessageType.Summarize;
}
exports.isRuntimeMessage = isRuntimeMessage;
var RuntimeMessage;
(function (RuntimeMessage) {
    RuntimeMessage["FluidDataStoreOp"] = "component";
    RuntimeMessage["Attach"] = "attach";
    RuntimeMessage["ChunkedOp"] = "chunkedOp";
    RuntimeMessage["BlobAttach"] = "blobAttach";
    RuntimeMessage["Rejoin"] = "rejoin";
    RuntimeMessage["Alias"] = "alias";
    RuntimeMessage["Operation"] = "op";
})(RuntimeMessage || (RuntimeMessage = {}));
/**
 *
 * @param message-message
 * @returns whether or not the message type is one listed below (legacy)
 * "component"
 * "attach"
 * "chunkedOp"
 * "blobAttach"
 * "rejoin"
 * "alias"
 * "op"
 */
function isUnpackedRuntimeMessage(message) {
    if (Object.values(RuntimeMessage).includes(message.type)) {
        return true;
    }
    return false;
}
exports.isUnpackedRuntimeMessage = isUnpackedRuntimeMessage;

},{"@fluidframework/protocol-definitions":174}],113:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiDocumentServiceFactory = void 0;
const url_1 = require("url");
const fluidResolvedUrl_1 = require("./fluidResolvedUrl");
class MultiDocumentServiceFactory {
    constructor(documentServiceFactories) {
        this.protocolName = "none:";
        this.protocolToDocumentFactoryMap = new Map();
        documentServiceFactories.forEach((factory) => {
            this.protocolToDocumentFactoryMap.set(factory.protocolName, factory);
        });
    }
    static create(documentServiceFactory) {
        if (Array.isArray(documentServiceFactory)) {
            const factories = [];
            documentServiceFactory.forEach((factory) => {
                const maybeMulti = factory;
                if (maybeMulti.protocolToDocumentFactoryMap !== undefined) {
                    factories.push(...maybeMulti.protocolToDocumentFactoryMap.values());
                }
                else {
                    factories.push(factory);
                }
            });
            if (factories.length === 1) {
                return factories[0];
            }
            return new MultiDocumentServiceFactory(factories);
        }
        return documentServiceFactory;
    }
    async createDocumentService(resolvedUrl, logger, clientIsSummarizer) {
        (0, fluidResolvedUrl_1.ensureFluidResolvedUrl)(resolvedUrl);
        const urlObj = (0, url_1.parse)(resolvedUrl.url);
        if (urlObj.protocol === undefined || urlObj.protocol === null) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createDocumentService(resolvedUrl, logger, clientIsSummarizer);
    }
    async createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer) {
        (0, fluidResolvedUrl_1.ensureFluidResolvedUrl)(createNewResolvedUrl);
        const urlObj = (0, url_1.parse)(createNewResolvedUrl.url);
        if (urlObj.protocol === undefined || urlObj.protocol === null) {
            throw new Error("No protocol provided");
        }
        const factory = this.protocolToDocumentFactoryMap.get(urlObj.protocol);
        if (factory === undefined) {
            throw new Error("Unknown Fluid protocol");
        }
        return factory.createContainer(createNewSummary, createNewResolvedUrl, logger, clientIsSummarizer);
    }
}
exports.MultiDocumentServiceFactory = MultiDocumentServiceFactory;

},{"./fluidResolvedUrl":109,"url":569}],114:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiUrlResolver = exports.configurableUrlResolver = void 0;
/**
 * Resolver that takes a list of url resolvers and then try each of them to resolve the url.
 * @param resolversList - List of url resolvers to be used to resolve the request.
 * @param request - Request to be resolved.
 */
async function configurableUrlResolver(resolversList, request) {
    let resolved;
    for (const resolver of resolversList) {
        resolved = await resolver.resolve(Object.assign({}, request));
        if (resolved !== undefined) {
            return resolved;
        }
    }
    return undefined;
}
exports.configurableUrlResolver = configurableUrlResolver;
class MultiUrlResolver {
    constructor(urlResolvers) {
        this.urlResolvers = urlResolvers;
    }
    static create(urlResolver) {
        if (Array.isArray(urlResolver)) {
            if (urlResolver.length === 1) {
                return urlResolver[0];
            }
            return new MultiUrlResolver(urlResolver);
        }
        return urlResolver;
    }
    async resolve(request) {
        return configurableUrlResolver(this.urlResolvers, request);
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        throw new Error("Not implmented");
    }
}
exports.MultiUrlResolver = MultiUrlResolver;

},{}],115:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRetryDelayFromError = exports.getRetryDelaySecondsFromError = exports.canRetryOnError = exports.createGenericNetworkError = exports.createWriteError = exports.ThrottlingError = exports.RetryableError = exports.NonRetryableError = exports.NetworkErrorBasic = exports.AuthorizationError = exports.DeltaStreamConnectionForbiddenError = exports.GenericNetworkError = exports.isOnline = exports.OnlineStatus = void 0;
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
var OnlineStatus;
(function (OnlineStatus) {
    OnlineStatus[OnlineStatus["Offline"] = 0] = "Offline";
    OnlineStatus[OnlineStatus["Online"] = 1] = "Online";
    OnlineStatus[OnlineStatus["Unknown"] = 2] = "Unknown";
})(OnlineStatus = exports.OnlineStatus || (exports.OnlineStatus = {}));
// It tells if we have local connection only - we might not have connection to web.
// No solution for node.js (other than resolve dns names / ping specific sites)
// Can also use window.addEventListener("online" / "offline")
function isOnline() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.onLine === "boolean") {
        return navigator.onLine ? OnlineStatus.Online : OnlineStatus.Offline;
    }
    return OnlineStatus.Unknown;
}
exports.isOnline = isOnline;
/**
 * Generic network error class.
 */
class GenericNetworkError extends telemetry_utils_1.LoggingError {
    constructor(message, canRetry, props) {
        super(message, props);
        this.canRetry = canRetry;
        this.errorType = driver_definitions_1.DriverErrorType.genericNetworkError;
    }
}
exports.GenericNetworkError = GenericNetworkError;
// Todo GH #6214: Remove after next drive def bump. This is necessary as there is no
// compatible way to augment an enum, as it can't be optional. So for now
// we need to duplicate the value here. We likely need to rethink our
// DriverErrorType strategy so that it supports extension with optional
// value.
const deltaStreamConnectionForbiddenStr = "deltaStreamConnectionForbidden";
class DeltaStreamConnectionForbiddenError extends telemetry_utils_1.LoggingError {
    constructor(message, props) {
        super(message, Object.assign(Object.assign({}, props), { statusCode: 400 }));
        this.errorType = DeltaStreamConnectionForbiddenError.errorType;
        this.canRetry = false;
    }
}
exports.DeltaStreamConnectionForbiddenError = DeltaStreamConnectionForbiddenError;
DeltaStreamConnectionForbiddenError.errorType = (_a = driver_definitions_1.DriverErrorType[deltaStreamConnectionForbiddenStr]) !== null && _a !== void 0 ? _a : deltaStreamConnectionForbiddenStr;
class AuthorizationError extends telemetry_utils_1.LoggingError {
    constructor(message, claims, tenantId, props) {
        // don't log claims or tenantId
        super(message, props, new Set(["claims", "tenantId"]));
        this.claims = claims;
        this.tenantId = tenantId;
        this.errorType = driver_definitions_1.DriverErrorType.authorizationError;
        this.canRetry = false;
    }
}
exports.AuthorizationError = AuthorizationError;
class NetworkErrorBasic extends telemetry_utils_1.LoggingError {
    constructor(message, errorType, canRetry, props) {
        super(message, props);
        this.errorType = errorType;
        this.canRetry = canRetry;
    }
}
exports.NetworkErrorBasic = NetworkErrorBasic;
class NonRetryableError extends NetworkErrorBasic {
    constructor(message, errorType, props) {
        super(message, errorType, false, props);
        this.errorType = errorType;
    }
}
exports.NonRetryableError = NonRetryableError;
class RetryableError extends NetworkErrorBasic {
    constructor(message, errorType, props) {
        super(message, errorType, true, props);
        this.errorType = errorType;
    }
}
exports.RetryableError = RetryableError;
/**
 * Throttling error class - used to communicate all throttling errors
 */
class ThrottlingError extends telemetry_utils_1.LoggingError {
    constructor(message, retryAfterSeconds, props) {
        super(message, props);
        this.retryAfterSeconds = retryAfterSeconds;
        this.errorType = driver_definitions_1.DriverErrorType.throttlingError;
        this.canRetry = true;
    }
}
exports.ThrottlingError = ThrottlingError;
const createWriteError = (message, props) => new NonRetryableError(message, driver_definitions_1.DriverErrorType.writeError, props);
exports.createWriteError = createWriteError;
function createGenericNetworkError(message, retryInfo, props) {
    if (retryInfo.retryAfterMs !== undefined && retryInfo.canRetry) {
        return new ThrottlingError(message, retryInfo.retryAfterMs / 1000, props);
    }
    return new GenericNetworkError(message, retryInfo.canRetry, props);
}
exports.createGenericNetworkError = createGenericNetworkError;
/**
 * Check if a connection error can be retried.  Unless explicitly allowed, retry is disallowed.
 * I.e. asserts or unexpected exceptions in our code result in container failure.
 * @param error - The error to inspect for ability to retry
 */
const canRetryOnError = (error) => (error === null || error === void 0 ? void 0 : error.canRetry) === true;
exports.canRetryOnError = canRetryOnError;
/** Check retryAfterSeconds property on error */
const getRetryDelaySecondsFromError = (error) => error === null || error === void 0 ? void 0 : error.retryAfterSeconds;
exports.getRetryDelaySecondsFromError = getRetryDelaySecondsFromError;
/** Check retryAfterSeconds property on error and convert to ms */
const getRetryDelayFromError = (error) => (error === null || error === void 0 ? void 0 : error.retryAfterSeconds) !== undefined ?
    error.retryAfterSeconds * 1000 : undefined;
exports.getRetryDelayFromError = getRetryDelayFromError;

},{"@fluidframework/driver-definitions":100,"@fluidframework/telemetry-utils":279}],116:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForConnectedState = exports.logNetworkFailure = void 0;
const network_1 = require("./network");
function logNetworkFailure(logger, event, error) {
    var _a, _b;
    const newEvent = Object.assign({}, event);
    const errorOnlineProp = error.online;
    newEvent.online = typeof errorOnlineProp === "string"
        ? errorOnlineProp
        : network_1.OnlineStatus[(0, network_1.isOnline)()];
    if (typeof navigator === "object" && navigator !== null) {
        const nav = navigator;
        const connection = (_b = (_a = nav.connection) !== null && _a !== void 0 ? _a : nav.mozConnection) !== null && _b !== void 0 ? _b : nav.webkitConnection;
        if (connection !== null && typeof connection === "object") {
            newEvent.connectionType = connection.type;
        }
    }
    // non-retryable errors are fatal and should be logged as errors
    newEvent.category = (0, network_1.canRetryOnError)(error) ? "generic" : "error";
    logger.sendTelemetryEvent(newEvent, error);
}
exports.logNetworkFailure = logNetworkFailure;
/**
 * Wait for browser to get to connected state.
 * If connected, waits minimum of minDelay anyway (between network retries)
 * If disconnected, polls every 30 seconds anyway, to make sure we are not getting stuck because of wrong signal
 * Note that browsers will have false positives (like having Hyper-V adapter on machine,
 * or machine connected to router that is not connected to internet)
 * But there should be no false negatives.
 * The only exception - Opera returns false when user enters "Work Offline" mode, regardless of actual connectivity.
 */
// eslint-disable-next-line @typescript-eslint/promise-function-async
function waitForConnectedState(minDelay) {
    // Use this frequency to poll even when we are offline and able to setup online/offline listener
    // This is mostly safety net
    const offlinePollFrequency = 30000;
    return new Promise((resolve) => {
        let listener = resolve;
        let delay = minDelay;
        if ((0, network_1.isOnline)() === network_1.OnlineStatus.Offline) {
            if ((window === null || window === void 0 ? void 0 : window.addEventListener) !== undefined) {
                listener = () => {
                    resolve();
                    window.removeEventListener("online", listener);
                };
                window.addEventListener("online", listener, false);
                delay = Math.max(minDelay, offlinePollFrequency);
            }
        }
        setTimeout(listener, delay);
    });
}
exports.waitForConnectedState = waitForConnectedState;

},{"./network":115}],117:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/driver-utils";
exports.pkgVersion = "1.3.6";

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamObserver = exports.streamFromMessages = exports.emptyMessageStream = exports.requestOps = exports.Queue = exports.ParallelRequests = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const network_1 = require("./network");
const networkUtils_1 = require("./networkUtils");
// For now, this package is versioned and released in unison with the specific drivers
const packageVersion_1 = require("./packageVersion");
const MaxFetchDelayInMs = 10000;
const MissingFetchDelayInMs = 100;
/**
 * Helper class to organize parallel fetching of data
 * It can be used to concurrently do many requests, while consuming
 * data in the right order. Take a look at UT for examples.
 * @param concurrency - level of concurrency
 * @param from - starting point of fetching data (inclusive)
 * @param to  - ending point of fetching data. exclusive, or undefined if unknown
 * @param payloadSize - batch size
 * @param logger - logger to use
 * @param requestCallback - callback to request batches
 * @returns - Queue that can be used to retrieve data
 */
class ParallelRequests {
    constructor(from, to, payloadSize, logger, requestCallback, responseCallback) {
        this.to = to;
        this.payloadSize = payloadSize;
        this.logger = logger;
        this.requestCallback = requestCallback;
        this.responseCallback = responseCallback;
        this.results = new Map();
        this.workingState = "working";
        this.requestsInFlight = 0;
        this.endEvent = new common_utils_1.Deferred();
        this.requests = 0;
        this.latestRequested = from;
        this.nextToDeliver = from;
        this.knewTo = (to !== undefined);
    }
    get working() { return this.workingState === "working"; }
    get canceled() { return this.workingState === "canceled"; }
    cancel() {
        if (this.working) {
            this.workingState = "canceled";
            this.endEvent.resolve();
        }
    }
    async run(concurrency) {
        (0, common_utils_1.assert)(concurrency > 0, 0x102 /* "invalid level of concurrency" */);
        (0, common_utils_1.assert)(this.working, 0x103 /* "trying to parallel run while not working" */);
        let c = concurrency;
        while (c > 0) {
            c--;
            this.addRequest();
        }
        this.dispatch(); // will recalculate and trigger this.endEvent if needed
        return this.endEvent.promise;
    }
    done() {
        // We should satisfy request fully.
        (0, common_utils_1.assert)(this.to !== undefined, 0x104 /* "undefined end point for parallel fetch" */);
        (0, common_utils_1.assert)(this.nextToDeliver >= this.to, 0x105 /* "unexpected end point for parallel fetch" */);
        if (this.working) {
            this.workingState = "done";
            this.endEvent.resolve();
        }
    }
    fail(error) {
        if (this.working) {
            this.workingState = "done";
            this.endEvent.reject(error);
        }
    }
    dispatch() {
        while (this.working) {
            const value = this.results.get(this.nextToDeliver);
            if (value === undefined) {
                break;
            }
            this.results.delete(this.nextToDeliver);
            (0, common_utils_1.assert)(value.length <= this.payloadSize, 0x1d9 /* "addRequestCore() should break into smaller chunks" */);
            this.nextToDeliver += value.length;
            this.responseCallback(value);
        }
        // Account for cancellation - state might be not in consistent state on cancelling operation
        if (this.working) {
            if (this.requestsInFlight === 0) {
                // we should have dispatched everything, no matter whether we knew about the end or not.
                // see comment in addRequestCore() around throwing away chunk if it's above this.to
                (0, common_utils_1.assert)(this.results.size === 0, 0x107 /* "ending dispatch with remaining results to be sent" */);
                this.done();
            }
            else if (this.to !== undefined && this.nextToDeliver >= this.to) {
                // Learned about the end and dispatched all the ops up to it.
                // Ignore all the in-flight requests above boundary - unblock caller sooner.
                (0, common_utils_1.assert)(!this.knewTo, 0x108 /* "ending results dispatch but knew in advance about more requests" */);
                this.done();
            }
        }
    }
    getNextChunk() {
        if (!this.working) {
            return undefined;
        }
        const from = this.latestRequested;
        if (this.to !== undefined) {
            if (this.to <= from) {
                return undefined;
            }
        }
        // this.latestRequested
        // inclusive on the right side! Exclusive on the left.
        this.latestRequested += this.payloadSize;
        if (this.to !== undefined) {
            this.latestRequested = Math.min(this.to, this.latestRequested);
        }
        (0, common_utils_1.assert)(from < this.latestRequested, 0x109 /* "unexpected next chunk position" */);
        return { from, to: this.latestRequested };
    }
    addRequest() {
        const chunk = this.getNextChunk();
        if (chunk === undefined) {
            return;
        }
        this.addRequestCore(chunk.from, chunk.to).catch(this.fail.bind(this));
    }
    async addRequestCore(fromArg, toArg) {
        (0, common_utils_1.assert)(this.working, 0x10a /* "cannot add parallel request while not working" */);
        let from = fromArg;
        let to = toArg;
        // to & from are exclusive
        this.requestsInFlight++;
        while (this.working) {
            const requestedLength = to - from;
            (0, common_utils_1.assert)(requestedLength > 0, 0x10b /* "invalid parallel request range" */);
            // We should not be wasting time asking for something useless.
            if (this.to !== undefined) {
                (0, common_utils_1.assert)(from < this.to, 0x10c /* "invalid parallel request start point" */);
                (0, common_utils_1.assert)(to <= this.to, 0x10d /* "invalid parallel request end point" */);
            }
            this.requests++;
            const promise = this.requestCallback(this.requests, from, to, this.to !== undefined, {});
            // dispatch any prior received data
            this.dispatch();
            const { payload, cancel, partial } = await promise;
            if (cancel) {
                this.cancel();
            }
            if (this.to !== undefined && from >= this.to) {
                // while we were waiting for response, we learned on what is the boundary
                // We can get here (with actual result!) if situation changed while this request was in
                // flight, i.e. the end was extended over what we learn in some other request
                // While it's useful not to throw this result, this is very corner cases and makes logic
                // (including consistency checks) much harder to write correctly.
                // So for now, we are throwing this result out the window.
                (0, common_utils_1.assert)(!this.knewTo, 0x10e /* "should not throw result if we knew about boundary in advance" */);
                // Learn how often it happens and if it's too wasteful to throw these chunks.
                // If it pops into our view a lot, we would need to reconsider how we approach it.
                // Note that this is not visible to user other than potentially not hitting 100% of
                // what we can in perf domain.
                if (payload.length !== 0) {
                    this.logger.sendErrorEvent({
                        eventName: "ParallelRequests_GotExtra",
                        from,
                        to,
                        end: this.to,
                        length: payload.length,
                    });
                }
                break;
            }
            if (this.working) {
                const fromOrig = from;
                const length = payload.length;
                let fullChunk = (requestedLength <= length); // we can possible get more than we asked.
                if (length !== 0) {
                    // We can get more than we asked for!
                    // This can screw up logic in dispatch!
                    // So push only batch size, and keep the rest for later - if conditions are favorable, we
                    // will be able to use it. If not (parallel request overlapping these ops), it's easier to
                    // discard them and wait for another (overlapping) request to come in later.
                    if (requestedLength < length) {
                        // This is error in a sense that it's not expected and likely points bug in other layer.
                        // This layer copes with this situation just fine.
                        this.logger.sendTelemetryEvent({
                            eventName: "ParallelRequests_Over",
                            from,
                            to,
                            length,
                        });
                    }
                    const data = payload.splice(0, requestedLength);
                    this.results.set(from, data);
                    from += data.length;
                }
                else {
                    // 1. empty (partial) chunks should not be returned by various caching / adapter layers -
                    //    they should fall back to next layer. This might be important invariant to hold to ensure
                    //    that we are less likely have bugs where such layer would keep returning empty partial
                    //    result on each call.
                    // 2. Current invariant is that callback does retries until it gets something,
                    //    with the goal of failing if zero data is retrieved in given amount of time.
                    //    This is very specific property of storage / ops, so this logic is not here, but given only
                    //    one user of this class, we assert that to catch issues earlier.
                    // These invariant can be relaxed if needed.
                    (0, common_utils_1.assert)(!partial, 0x10f /* "empty/partial chunks should not be returned by caching" */);
                    (0, common_utils_1.assert)(!this.knewTo, 0x110 /* "callback should retry until valid fetch before it learns new boundary" */);
                }
                if (!partial && !fullChunk) {
                    if (!this.knewTo) {
                        if (this.to === undefined || this.to > from) {
                            // The END
                            this.to = from;
                        }
                        break;
                    }
                    // We know that there are more items to be retrieved
                    // Can we get partial chunk? Ideally storage indicates that's not a full chunk
                    // Note that it's possible that not all ops hit storage yet.
                    // We will come back to request more, and if we can't get any more ops soon, it's
                    // catastrophic failure (see comment above on responsibility of callback to return something)
                    // This layer will just keep trying until it gets full set.
                    this.logger.sendPerformanceEvent({
                        eventName: "ParallelRequests_Partial",
                        from: fromOrig,
                        to,
                        length,
                    });
                }
                if (to === this.latestRequested) {
                    // we can go after full chunk at the end if we received partial chunk, or more than asked
                    // Also if we got more than we asked to, we can actually use those ops!
                    if (payload.length !== 0) {
                        this.results.set(from, payload);
                        from += payload.length;
                    }
                    this.latestRequested = from;
                    fullChunk = true;
                }
                if (fullChunk) {
                    const chunk = this.getNextChunk();
                    if (chunk === undefined) {
                        break;
                    }
                    from = chunk.from;
                    to = chunk.to;
                }
            }
        }
        this.requestsInFlight--;
        this.dispatch();
    }
}
exports.ParallelRequests = ParallelRequests;
/**
 * Helper queue class to allow async push / pull
 * It's essentially a pipe allowing multiple writers, and single reader
 */
class Queue {
    constructor() {
        this.queue = [];
        this.done = false;
    }
    pushValue(value) {
        this.pushCore(Promise.resolve({ done: false, value }));
    }
    pushError(error) {
        this.pushCore(Promise.reject(error));
        this.done = true;
    }
    pushDone() {
        this.pushCore(Promise.resolve({ done: true }));
        this.done = true;
    }
    pushCore(value) {
        (0, common_utils_1.assert)(!this.done, 0x112 /* "cannot push onto queue if done" */);
        if (this.deferred) {
            (0, common_utils_1.assert)(this.queue.length === 0, 0x113 /* "deferred queue should be empty" */);
            this.deferred.resolve(value);
            this.deferred = undefined;
        }
        else {
            this.queue.push(value);
        }
    }
    async read() {
        (0, common_utils_1.assert)(this.deferred === undefined, 0x114 /* "cannot pop if deferred" */);
        const value = this.queue.shift();
        if (value !== undefined) {
            return value;
        }
        (0, common_utils_1.assert)(!this.done, 0x115 /* "queue should not be done during pop" */);
        this.deferred = new common_utils_1.Deferred();
        return this.deferred.promise;
    }
}
exports.Queue = Queue;
/**
 * Retrieve single batch of ops
 * @param request - request index
 * @param from - inclusive boundary
 * @param to - exclusive boundary
 * @param telemetryEvent - telemetry event used to track consecutive batch of requests
 * @param strongTo - tells if ops in range from...to have to be there and have to be retrieved.
 * If false, returning less ops would mean we reached end of file.
 * @param logger - logger object to use to log progress & errors
 * @param signal - cancelation signal
 * @param scenarioName - reason for fetching ops
 * @returns - an object with resulting ops and cancellation / partial result flags
 */
async function getSingleOpBatch(get, props, strongTo, logger, signal, scenarioName) {
    let lastSuccessTime;
    let retry = 0;
    const deltas = [];
    const nothing = { partial: false, cancel: true, payload: [] };
    while ((signal === null || signal === void 0 ? void 0 : signal.aborted) !== true) {
        retry++;
        let delay = Math.min(MaxFetchDelayInMs, MissingFetchDelayInMs * Math.pow(2, retry));
        const startTime = common_utils_1.performance.now();
        try {
            // Issue async request for deltas - limit the number fetched to MaxBatchDeltas
            const deltasP = get(Object.assign(Object.assign({}, props), { retry }));
            const { messages, partialResult } = await deltasP;
            deltas.push(...messages);
            const deltasRetrievedLast = messages.length;
            if (deltasRetrievedLast !== 0 || !strongTo) {
                return { payload: deltas, cancel: false, partial: partialResult };
            }
            // Storage does not have ops we need.
            // Attempt to fetch more deltas. If we didn't receive any in the previous call we up our retry
            // count since something prevented us from seeing those deltas
            if (lastSuccessTime === undefined) {
                lastSuccessTime = common_utils_1.performance.now();
            }
            else if (common_utils_1.performance.now() - lastSuccessTime > 30000) {
                // If we are connected and receiving proper responses from server, but can't get any ops back,
                // then give up after some time. This likely indicates the issue with ordering service not flushing
                // ops to storage quick enough, and possibly waiting for summaries, while summarizer can't get
                // current as it can't get ops.
                throw (0, network_1.createGenericNetworkError)(
                // pre-0.58 error message: failedToRetrieveOpsFromStorage:TooManyRetries
                "Failed to retrieve ops from storage (Too Many Retries)", { canRetry: false }, Object.assign({ retry,
                    driverVersion: packageVersion_1.pkgVersion }, props));
            }
        }
        catch (error) {
            const canRetry = (0, network_1.canRetryOnError)(error);
            lastSuccessTime = undefined;
            const retryAfter = (0, network_1.getRetryDelayFromError)(error);
            // This will log to error table only if the error is non-retryable
            (0, networkUtils_1.logNetworkFailure)(logger, Object.assign(Object.assign({ eventName: "GetDeltas_Error" }, props), { retry, duration: common_utils_1.performance.now() - startTime, retryAfter, reason: scenarioName }), error);
            if (!canRetry) {
                // It's game over scenario.
                throw error;
            }
            if (retryAfter !== undefined && retryAfter >= 0) {
                delay = retryAfter;
            }
        }
        await (0, networkUtils_1.waitForConnectedState)(delay);
    }
    return nothing;
}
/**
 * Request ops from storage
 * @param get - Getter callback to get individual batches
 * @param concurrency - Number of concurrent requests to make
 * @param fromTotal - starting sequence number to fetch (inclusive)
 * @param toTotal - max (exclusive) sequence number to fetch
 * @param payloadSize - Payload size
 * @param logger - Logger to log progress and errors
 * @param signal - Cancelation signal
 * @param scenarioName - Reason for fetching ops
 * @returns - Messages fetched
 */
function requestOps(get, concurrency, fromTotal, toTotal, payloadSize, logger, signal, scenarioName) {
    let requests = 0;
    let lastFetch;
    let length = 0;
    const queue = new Queue();
    const propsTotal = {
        fromTotal,
        toTotal,
    };
    const telemetryEvent = telemetry_utils_1.PerformanceEvent.start(logger, Object.assign(Object.assign({ eventName: "GetDeltas" }, propsTotal), { reason: scenarioName }));
    const manager = new ParallelRequests(fromTotal, toTotal, payloadSize, logger, async (request, from, to, strongTo, propsPerRequest) => {
        requests++;
        return getSingleOpBatch(async (propsAll) => get(from, to, propsAll), Object.assign(Object.assign({ request, from, to }, propsTotal), propsPerRequest), strongTo, logger, signal, scenarioName);
    }, (deltas) => {
        // Assert continuing and right start.
        if (lastFetch === undefined) {
            (0, common_utils_1.assert)(deltas[0].sequenceNumber === fromTotal, 0x26d /* "wrong start" */);
        }
        else {
            (0, common_utils_1.assert)(deltas[0].sequenceNumber === lastFetch + 1, 0x26e /* "wrong start" */);
        }
        lastFetch = deltas[deltas.length - 1].sequenceNumber;
        (0, common_utils_1.assert)(lastFetch - deltas[0].sequenceNumber + 1 === deltas.length, 0x26f /* "continuous and no duplicates" */);
        length += deltas.length;
        queue.pushValue(deltas);
    });
    // Implement faster cancellation. getSingleOpBatch() checks signal, but only in between
    // waits (up to 10 seconds) and fetches (can take infinite amount of time).
    // While every such case should be improved and take into account signal (and thus cancel immediately),
    // it is beneficial to have catch-all
    const listener = (event) => { manager.cancel(); };
    if (signal !== undefined) {
        signal.addEventListener("abort", listener);
    }
    manager.run(concurrency)
        .finally(() => {
        if (signal !== undefined) {
            signal.removeEventListener("abort", listener);
        }
    }).then(() => {
        const props = {
            lastFetch,
            length,
            requests,
        };
        if (manager.canceled) {
            telemetryEvent.cancel(Object.assign(Object.assign({}, props), { error: "ops request cancelled by client" }));
        }
        else {
            (0, common_utils_1.assert)(toTotal === undefined || lastFetch !== undefined && lastFetch >= toTotal - 1, 0x270 /* "All requested ops fetched" */);
            telemetryEvent.end(props);
        }
        queue.pushDone();
    })
        .catch((error) => {
        telemetryEvent.cancel({
            lastFetch,
            length,
            requests,
        }, error);
        queue.pushError(error);
    });
    return queue;
}
exports.requestOps = requestOps;
exports.emptyMessageStream = {
    read: async () => { return { done: true }; },
};
function streamFromMessages(messagesArg) {
    let messages = messagesArg;
    return {
        read: async () => {
            if (messages === undefined) {
                return { done: true };
            }
            const value = await messages;
            messages = undefined;
            return value.length === 0 ? { done: true } : { done: false, value };
        },
    };
}
exports.streamFromMessages = streamFromMessages;
function streamObserver(stream, handler) {
    return {
        read: async () => {
            const value = await stream.read();
            handler(value);
            return value;
        },
    };
}
exports.streamObserver = streamObserver;

},{"./network":115,"./networkUtils":116,"./packageVersion":117,"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefetchDocumentStorageService = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const documentStorageServiceProxy_1 = require("./documentStorageServiceProxy");
const network_1 = require("./network");
class PrefetchDocumentStorageService extends documentStorageServiceProxy_1.DocumentStorageServiceProxy {
    constructor() {
        super(...arguments);
        // BlobId -> blob prefetchCache cache
        this.prefetchCache = new Map();
        this.prefetchEnabled = true;
    }
    get policies() {
        const policies = this.internalStorageService.policies;
        if (policies) {
            return Object.assign(Object.assign({}, policies), { caching: driver_definitions_1.LoaderCachingPolicy.NoCaching });
        }
    }
    async getSnapshotTree(version) {
        const p = this.internalStorageService.getSnapshotTree(version);
        if (this.prefetchEnabled) {
            // We don't care if the prefetch succeeds
            void p.then((tree) => {
                if (tree === null || tree === undefined) {
                    return;
                }
                this.prefetchTree(tree);
            });
        }
        return p;
    }
    async readBlob(blobId) {
        return this.cachedRead(blobId);
    }
    stopPrefetch() {
        this.prefetchEnabled = false;
        this.prefetchCache.clear();
    }
    async cachedRead(blobId) {
        if (this.prefetchEnabled) {
            const prefetchedBlobP = this.prefetchCache.get(blobId);
            if (prefetchedBlobP !== undefined) {
                return prefetchedBlobP;
            }
            const prefetchedBlobPFromStorage = this.internalStorageService.readBlob(blobId);
            this.prefetchCache.set(blobId, prefetchedBlobPFromStorage.catch((error) => {
                if ((0, network_1.canRetryOnError)(error)) {
                    this.prefetchCache.delete(blobId);
                }
                throw error;
            }));
            return prefetchedBlobPFromStorage;
        }
        return this.internalStorageService.readBlob(blobId);
    }
    prefetchTree(tree) {
        const secondary = [];
        this.prefetchTreeCore(tree, secondary);
        for (const blob of secondary) {
            // We don't care if the prefetch succeeds
            void this.cachedRead(blob);
        }
    }
    prefetchTreeCore(tree, secondary) {
        for (const blobKey of Object.keys(tree.blobs)) {
            const blob = tree.blobs[blobKey];
            if (blobKey.startsWith(".") || blobKey === "header" || blobKey.startsWith("quorum")) {
                if (blob !== null) {
                    // We don't care if the prefetch succeeds
                    void this.cachedRead(blob);
                }
            }
            else if (!blobKey.startsWith("deltas")) {
                if (blob !== null) {
                    secondary.push(blob);
                }
            }
        }
        for (const subTree of Object.keys(tree.trees)) {
            this.prefetchTreeCore(tree.trees[subTree], secondary);
        }
    }
}
exports.PrefetchDocumentStorageService = PrefetchDocumentStorageService;

},{"./documentStorageServiceProxy":106,"./network":115,"@fluidframework/driver-definitions":100}],120:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimiter = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
class RateLimiter {
    constructor(maxRequests) {
        this.maxRequests = maxRequests;
        this.tasks = [];
        // Run when one of the tasks finished running.
        // Release next task if we have one, or allow more tasks to run in future.
        this.release = () => {
            const task = this.tasks.shift();
            if (task !== undefined) {
                return task();
            }
            this.maxRequests++;
        };
        (0, common_utils_1.assert)(maxRequests > 0, 0x0ae /* "Tried to create rate limiter with 0 max requests!" */);
    }
    get waitQueueLength() {
        return this.tasks.length;
    }
    async acquire() {
        if (this.maxRequests > 0) {
            this.maxRequests--;
            return;
        }
        return new Promise((resolve) => {
            this.tasks.push(resolve);
        });
    }
    async schedule(work) {
        await this.acquire();
        return work().finally(this.release);
    }
}
exports.RateLimiter = RateLimiter;

},{"@fluidframework/common-utils":29}],121:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.readAndParse = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Read a blob from IDocumentStorageService and JSON.parse it into object of type T
 *
 * @param storage - the IDocumentStorageService to read from
 * @param id - the id of the blob to read and parse
 * @returns the object that we decoded and JSON.parse
 */
async function readAndParse(storage, id) {
    const blob = await storage.readBlob(id);
    const decoded = (0, common_utils_1.bufferToString)(blob, "utf8");
    return JSON.parse(decoded);
}
exports.readAndParse = readAndParse;

},{"@fluidframework/common-utils":29}],122:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithRetry = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const network_1 = require("./network");
const packageVersion_1 = require("./packageVersion");
const _1 = require(".");
async function runWithRetry(api, fetchCallName, logger, progress) {
    var _a, _b;
    let result;
    let success = false;
    let retryAfterMs = 1000; // has to be positive!
    let numRetries = 0;
    const startTime = common_utils_1.performance.now();
    let lastError;
    do {
        try {
            result = await api(progress.cancel);
            success = true;
        }
        catch (err) {
            // If it is not retriable, then just throw the error.
            if (!(0, network_1.canRetryOnError)(err)) {
                logger.sendTelemetryEvent({
                    eventName: `${fetchCallName}_cancel`,
                    retry: numRetries,
                    duration: common_utils_1.performance.now() - startTime,
                    fetchCallName,
                }, err);
                throw err;
            }
            if (((_a = progress.cancel) === null || _a === void 0 ? void 0 : _a.aborted) === true) {
                logger.sendTelemetryEvent({
                    eventName: `${fetchCallName}_runWithRetryAborted`,
                    retry: numRetries,
                    duration: common_utils_1.performance.now() - startTime,
                    fetchCallName,
                }, err);
                throw new _1.NonRetryableError("runWithRetry was Aborted", driver_definitions_1.DriverErrorType.genericError, { driverVersion: packageVersion_1.pkgVersion, fetchCallName });
            }
            numRetries++;
            lastError = err;
            // If the error is throttling error, then wait for the specified time before retrying.
            // If the waitTime is not specified, then we start with retrying immediately to max of 8s.
            retryAfterMs = (_b = (0, network_1.getRetryDelayFromError)(err)) !== null && _b !== void 0 ? _b : Math.min(retryAfterMs * 2, 8000);
            if (progress.onRetry) {
                progress.onRetry(retryAfterMs, err);
            }
            await (0, common_utils_1.delay)(retryAfterMs);
        }
    } while (!success);
    if (numRetries > 0) {
        logger.sendTelemetryEvent({
            eventName: `${fetchCallName}_lastError`,
            retry: numRetries,
            duration: common_utils_1.performance.now() - startTime,
            fetchCallName,
        }, lastError);
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return result;
}
exports.runWithRetry = runWithRetry;

},{".":110,"./network":115,"./packageVersion":117,"@fluidframework/common-utils":29,"@fluidframework/driver-definitions":100}],123:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuorumValuesFromProtocolSummary = exports.getDocAttributesFromProtocolSummary = exports.combineAppAndProtocolSummary = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Combine the app summary and protocol summary in 1 tree.
 * @param appSummary - Summary of the app.
 * @param protocolSummary - Summary of the protocol.
 */
function combineAppAndProtocolSummary(appSummary, protocolSummary) {
    const createNewSummary = {
        type: protocol_definitions_1.SummaryType.Tree,
        tree: {
            ".protocol": protocolSummary,
            ".app": appSummary,
        },
    };
    return createNewSummary;
}
exports.combineAppAndProtocolSummary = combineAppAndProtocolSummary;
/**
 * Extract the attributes from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getDocAttributesFromProtocolSummary(protocolSummary) {
    var _a;
    const attributesBlob = protocolSummary.tree.attributes;
    const documentAttributes = JSON.parse(attributesBlob.content);
    documentAttributes.term = (_a = documentAttributes.term) !== null && _a !== void 0 ? _a : 1;
    return documentAttributes;
}
exports.getDocAttributesFromProtocolSummary = getDocAttributesFromProtocolSummary;
/**
 * Extract quorum values from the protocol summary.
 * @param protocolSummary - protocol summary from which the values are to be extracted.
 */
function getQuorumValuesFromProtocolSummary(protocolSummary) {
    const quorumValuesBlob = protocolSummary.tree.quorumValues;
    const quorumValues = JSON.parse(quorumValuesBlob.content);
    return quorumValues;
}
exports.getQuorumValuesFromProtocolSummary = getQuorumValuesFromProtocolSummary;

},{"@fluidframework/protocol-definitions":174}],124:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSummaryTreeToSnapshotITree = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Converts ISummaryTree to ITree format.
 * @param summaryTree - summary tree in ISummaryTree format
 */
function convertSummaryTreeToSnapshotITree(summaryTree) {
    const entries = [];
    const protocolSummary = summaryTree.tree[".protocol"];
    const appSummary = summaryTree.tree[".app"];
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    const adaptSumaryTree = protocolSummary && appSummary;
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    const allSummaryEntries = adaptSumaryTree
        ? [
            ...Object.entries(protocolSummary.tree),
            ...Object.entries(appSummary.tree),
        ]
        : Object.entries(summaryTree.tree);
    for (const [key, value] of allSummaryEntries) {
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        const k = adaptSumaryTree && ["attributes"].includes(key) ? `.${key}` : key;
        switch (value.type) {
            case protocol_definitions_1.SummaryType.Blob: {
                let parsedContent;
                let encoding = "utf-8";
                if (typeof value.content === "string") {
                    parsedContent = value.content;
                }
                else {
                    parsedContent = (0, common_utils_1.Uint8ArrayToString)(value.content, "base64");
                    encoding = "base64";
                }
                entries.push(new protocol_base_1.BlobTreeEntry(k, parsedContent, encoding));
                break;
            }
            case protocol_definitions_1.SummaryType.Tree: {
                entries.push(new protocol_base_1.TreeTreeEntry(k, convertSummaryTreeToSnapshotITree(value)));
                break;
            }
            case protocol_definitions_1.SummaryType.Attachment: {
                entries.push(new protocol_base_1.AttachmentTreeEntry(k, value.id));
                break;
            }
            case protocol_definitions_1.SummaryType.Handle: {
                throw new Error("Should not have Handle type in summary tree");
            }
            default:
                (0, common_utils_1.unreachableCase)(value, "Unexpected summary tree type");
        }
    }
    return {
        entries,
        unreferenced: summaryTree.unreferenced,
    };
}
exports.convertSummaryTreeToSnapshotITree = convertSummaryTreeToSnapshotITree;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174}],125:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSnapshotAndBlobsToSummaryTree = exports.SummaryTreeAssembler = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Summary tree assembler (without stats collection).
 */
class SummaryTreeAssembler {
    constructor(props) {
        this.props = props;
        this.attachmentCounter = 0;
        this.summaryTree = {};
    }
    /**
    * Get final summary
    */
    get summary() {
        var _a;
        return {
            type: protocol_definitions_1.SummaryType.Tree,
            tree: Object.assign({}, this.summaryTree),
            unreferenced: (_a = this.props) === null || _a === void 0 ? void 0 : _a.unreferenced,
        };
    }
    /**
    * Add blob to summary
    */
    addBlob(key, content) {
        this.summaryTree[key] = {
            type: protocol_definitions_1.SummaryType.Blob,
            content,
        };
    }
    /**
    * Add handle to summary
    */
    addHandle(key, handleType, handle) {
        this.summaryTree[key] = {
            type: protocol_definitions_1.SummaryType.Handle,
            handleType,
            handle,
        };
    }
    /**
    * Add tree to summary
    */
    addTree(key, summary) {
        this.summaryTree[key] = summary;
    }
    /**
    * Add attachment to summary
    */
    addAttachment(id) {
        this.summaryTree[this.attachmentCounter++] = { id, type: protocol_definitions_1.SummaryType.Attachment };
    }
}
exports.SummaryTreeAssembler = SummaryTreeAssembler;
/**
 * Helper function that converts ISnapshotTree and blobs to ISummaryTree
 * @param snapshot - Source snapshot tree
 * @param blobs - Blobs cache
 * @returns Converted snapshot in ISummaryTree format
 */
function convertSnapshotAndBlobsToSummaryTree(snapshot, blobs) {
    const assembler = new SummaryTreeAssembler({
        unreferenced: snapshot.unreferenced,
    });
    for (const [path, id] of Object.entries(snapshot.blobs)) {
        const blob = blobs.get(id);
        (0, common_utils_1.assert)(blob !== undefined, 0x2dd /* "Cannot find blob for a given id" */);
        assembler.addBlob(path, common_utils_1.IsoBuffer.from(blob).toString("utf-8"));
    }
    for (const [key, tree] of Object.entries(snapshot.trees)) {
        const subtree = convertSnapshotAndBlobsToSummaryTree(tree, blobs);
        assembler.addTree(key, subtree);
    }
    return assembler.summary;
}
exports.convertSnapshotAndBlobsToSummaryTree = convertSnapshotAndBlobsToSummaryTree;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluidContainer = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Base {@link IFluidContainer} implementation.
 *
 * @remarks Note: this implementation is not complete. Consumers who rely on {@link IFluidContainer.attach}
 * will need to utilize or provide a service-specific implementation of this type that implements that method.
 */
class FluidContainer extends common_utils_1.TypedEventEmitter {
    constructor(container, rootDataObject) {
        super();
        this.container = container;
        this.rootDataObject = rootDataObject;
        this.connectedHandler = () => this.emit("connected");
        this.disconnectedHandler = () => this.emit("disconnected");
        this.disposedHandler = (error) => this.emit("disposed", error);
        this.savedHandler = () => this.emit("saved");
        this.dirtyHandler = () => this.emit("dirty");
        container.on("connected", this.connectedHandler);
        container.on("closed", this.disposedHandler);
        container.on("disconnected", this.disconnectedHandler);
        container.on("saved", this.savedHandler);
        container.on("dirty", this.dirtyHandler);
    }
    /**
     * {@inheritDoc IFluidContainer.isDirty}
     */
    get isDirty() {
        return this.container.isDirty;
    }
    /**
     * {@inheritDoc IFluidContainer.attachState}
     */
    get attachState() {
        return this.container.attachState;
    }
    /**
     * {@inheritDoc IFluidContainer.disposed}
     */
    get disposed() {
        return this.container.closed;
    }
    /**
     * {@inheritDoc IFluidContainer.connectionState}
     */
    get connectionState() {
        return this.container.connectionState;
    }
    /**
     * {@inheritDoc IFluidContainer.initialObjects}
     */
    get initialObjects() {
        return this.rootDataObject.initialObjects;
    }
    /**
     * Incomplete base implementation of {@link IFluidContainer.attach}.
     * @remarks Note: this implementation will unconditionally throw.
     * Consumers who rely on this will need to utilize or provide a service specific implementation of this base type
     * that provides an implementation of this method.
     *
     * The reason is because externally we are presenting a separation between the service and the `FluidContainer`,
     * but internally this separation is not there.
     */
    async attach() {
        throw new Error("Cannot attach container. Container is not in detached state");
    }
    /**
     * {@inheritDoc IFluidContainer.connect}
     */
    async connect() {
        var _a, _b;
        (_b = (_a = this.container).connect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * {@inheritDoc IFluidContainer.connect}
     */
    async disconnect() {
        var _a, _b;
        (_b = (_a = this.container).disconnect) === null || _b === void 0 ? void 0 : _b.call(_a);
    }
    /**
     * {@inheritDoc IFluidContainer.create}
     */
    async create(objectClass) {
        return this.rootDataObject.create(objectClass);
    }
    /**
     * {@inheritDoc IFluidContainer.dispose}
     */
    dispose() {
        this.container.close();
        this.container.off("connected", this.connectedHandler);
        this.container.off("closed", this.disposedHandler);
        this.container.off("disconnected", this.disconnectedHandler);
        this.container.off("saved", this.savedHandler);
        this.container.off("dirty", this.dirtyHandler);
    }
}
exports.FluidContainer = FluidContainer;

},{"@fluidframework/common-utils":29}],127:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Provides a simple and powerful way to consume collaborative Fluid data.
 *
 * @packageDocumentation
 */
__exportStar(require("./fluidContainer"), exports);
__exportStar(require("./rootDataObject"), exports);
__exportStar(require("./serviceAudience"), exports);
__exportStar(require("./types"), exports);

},{"./fluidContainer":126,"./rootDataObject":128,"./serviceAudience":129,"./types":130}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DOProviderContainerRuntimeFactory = exports.RootDataObject = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const aqueduct_1 = require("@fluidframework/aqueduct");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const utils_1 = require("./utils");
/**
 * The entry-point/root collaborative object of the Fluid Container.
 * This class abstracts the dynamic code required to build a Fluid Container into a static representation
 * for end customers.
 */
class RootDataObject extends aqueduct_1.DataObject {
    constructor() {
        super(...arguments);
        this.initialObjectsDirKey = "initial-objects-key";
        this._initialObjects = {};
    }
    get initialObjectsDir() {
        const dir = this.root.getSubDirectory(this.initialObjectsDirKey);
        if (dir === undefined) {
            throw new Error("InitialObjects sub-directory was not initialized");
        }
        return dir;
    }
    /**
     * The first time this object is initialized, creates each object identified in
     * {@link RootDataObjectProps.initialObjects} and stores them as unique values in the root directory.
     *
     * See {@link @fluidframework/aqueduct#PureDataObject.initializingFirstTime}
     */
    async initializingFirstTime(props) {
        this.root.createSubDirectory(this.initialObjectsDirKey);
        // Create initial objects provided by the developer
        const initialObjectsP = [];
        Object.entries(props.initialObjects).forEach(([id, objectClass]) => {
            const createObject = async () => {
                const obj = await this.create(objectClass);
                this.initialObjectsDir.set(id, obj.handle);
            };
            initialObjectsP.push(createObject());
        });
        await Promise.all(initialObjectsP);
    }
    /**
     * Every time an instance is initialized, loads all of the initial objects in the root directory so they can be
     * accessed immediately.
     *
     * See {@link @fluidframework/aqueduct#PureDataObject.hasInitialized}
     */
    async hasInitialized() {
        // We will always load the initial objects so they are available to the developer
        const loadInitialObjectsP = [];
        for (const [key, value] of Array.from(this.initialObjectsDir.entries())) {
            const loadDir = async () => {
                const obj = await value.get();
                Object.assign(this._initialObjects, { [key]: obj });
            };
            loadInitialObjectsP.push(loadDir());
        }
        await Promise.all(loadInitialObjectsP);
    }
    /**
     * Provides a record of the initial objects defined on creation.
     * See {@link RootDataObject.initializingFirstTime}
     */
    get initialObjects() {
        if (Object.keys(this._initialObjects).length === 0) {
            throw new Error("Initial Objects were not correctly initialized");
        }
        return this._initialObjects;
    }
    /**
     * Dynamically creates a new detached collaborative object (DDS/DataObject).
     * @param objectClass - Type of the collaborative object to be created.
     */
    async create(objectClass) {
        if ((0, utils_1.isDataObjectClass)(objectClass)) {
            return this.createDataObject(objectClass);
        }
        else if ((0, utils_1.isSharedObjectClass)(objectClass)) {
            return this.createSharedObject(objectClass);
        }
        throw new Error("Could not create new Fluid object because an unknown object was passed");
    }
    async createDataObject(dataObjectClass) {
        const factory = dataObjectClass.factory;
        const packagePath = [...this.context.packagePath, factory.type];
        const router = await this.context.containerRuntime.createDataStore(packagePath);
        return (0, runtime_utils_1.requestFluidObject)(router, "/");
    }
    createSharedObject(sharedObjectClass) {
        const factory = sharedObjectClass.getFactory();
        const obj = this.runtime.createChannel(undefined, factory.type);
        return obj;
    }
}
exports.RootDataObject = RootDataObject;
const rootDataStoreId = "rootDOId";
/**
 * Container code that provides a single {@link RootDataObject}.  This data object is
 * dynamically customized (registry and initial objects) based on the schema provided to the container runtime factory.
 */
class DOProviderContainerRuntimeFactory extends aqueduct_1.BaseContainerRuntimeFactory {
    constructor(schema) {
        const [registryEntries, sharedObjects] = (0, utils_1.parseDataObjectsFromSharedObjects)(schema);
        const rootDataObjectFactory = new aqueduct_1.DataObjectFactory("rootDO", RootDataObject, sharedObjects, {}, registryEntries);
        super([rootDataObjectFactory.registryEntry], undefined, [(0, aqueduct_1.defaultRouteRequestHandler)(rootDataStoreId)], 
        // temporary workaround to disable message batching until the message batch size issue is resolved
        // resolution progress is tracked by the Feature 465 work item in AzDO
        { flushMode: runtime_definitions_1.FlushMode.Immediate });
        this.rootDataObjectFactory = rootDataObjectFactory;
        this.initialObjects = schema.initialObjects;
    }
    /**
     * {@inheritDoc @fluidframework/aqueduct#BaseContainerRuntimeFactory.containerInitializingFirstTime}
     */
    async containerInitializingFirstTime(runtime) {
        // The first time we create the container we create the RootDataObject
        await this.rootDataObjectFactory.createRootInstance(rootDataStoreId, runtime, { initialObjects: this.initialObjects });
    }
}
exports.DOProviderContainerRuntimeFactory = DOProviderContainerRuntimeFactory;

},{"./utils":131,"@fluidframework/aqueduct":12,"@fluidframework/runtime-definitions":208,"@fluidframework/runtime-utils":213}],129:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceAudience = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Base class for providing audience information for sessions interacting with FluidContainer
 * This can be extended by different service-specific client packages to additional parameters to
 * the user and client details returned in IMember
 * @typeParam M - A service-specific member type.
 */
class ServiceAudience extends common_utils_1.TypedEventEmitter {
    constructor(
    /**
     * Fluid Container to read the audience from.
     */
    container) {
        super();
        this.container = container;
        /**
         * Retain the most recent member list.  This is so we have more information about a member
         * leaving the audience in the removeMember event.  It allows us to match the behavior of the
         * addMember event where it only fires on a change to the members this class exposes (and would
         * actually produce a change in what getMembers returns).  It also allows us to provide the
         * client details in the event which makes it easier to find that client connection in a map
         * keyed on the userId and not clientId.
         * This map will always be up-to-date in a removeMember event because it is set once at
         * construction and in every addMember event.
         * It is mapped clientId to M to be better work with what the IAudience event provides
         */
        this.lastMembers = new Map();
        this.audience = container.audience;
        // getMembers will assign lastMembers so the removeMember event has what it needs
        // in case it would fire before getMembers otherwise gets called the first time
        this.getMembers();
        this.audience.on("addMember", (clientId, details) => {
            if (this.shouldIncludeAsMember(details)) {
                const member = this.getMember(clientId);
                this.emit("memberAdded", clientId, member);
                this.emit("membersChanged");
            }
        });
        this.audience.on("removeMember", (clientId) => {
            if (this.lastMembers.has(clientId)) {
                this.emit("memberRemoved", clientId, this.lastMembers.get(clientId));
                this.emit("membersChanged");
            }
        });
        this.container.on("connected", () => this.emit("membersChanged"));
    }
    /**
     * {@inheritDoc IServiceAudience.getMembers}
     */
    getMembers() {
        const users = new Map();
        const clientMemberMap = new Map();
        // Iterate through the members and get the user specifics.
        this.audience.getMembers().forEach((member, clientId) => {
            if (this.shouldIncludeAsMember(member)) {
                const userId = member.user.id;
                // Ensure we're tracking the user
                let user = users.get(userId);
                if (user === undefined) {
                    user = this.createServiceMember(member);
                    users.set(userId, user);
                }
                // Add this connection to their collection
                user.connections.push({ id: clientId, mode: member.mode });
                clientMemberMap.set(clientId, user);
            }
        });
        this.lastMembers = clientMemberMap;
        return users;
    }
    /**
     * {@inheritDoc IServiceAudience.getMyself}
     */
    getMyself() {
        const clientId = this.container.clientId;
        if (clientId === undefined) {
            return undefined;
        }
        return this.getMember(clientId);
    }
    getMember(clientId) {
        // Fetch the user ID assoicated with this client ID from the runtime
        const internalAudienceMember = this.audience.getMember(clientId);
        if (internalAudienceMember === undefined) {
            return undefined;
        }
        // Return the member object with any other clients associated for this user
        const allMembers = this.getMembers();
        const member = allMembers.get(internalAudienceMember === null || internalAudienceMember === void 0 ? void 0 : internalAudienceMember.user.id);
        if (member === undefined) {
            throw Error(`Attempted to fetch client ${clientId} that is not part of the current member list`);
        }
        return member;
    }
    /**
     * Provides ability for the inheriting class to include/omit specific members.
     * An example use case is omitting the summarizer client.
     * @param member - Member to be included/omitted.
     */
    shouldIncludeAsMember(member) {
        // Include only human members
        return member.details.capabilities.interactive;
    }
}
exports.ServiceAudience = ServiceAudience;

},{"@fluidframework/common-utils":29}],130:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],131:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDataObjectsFromSharedObjects = exports.isSharedObjectClass = exports.isDataObjectClass = void 0;
/**
 * Runtime check to determine if a class is a DataObject type
 */
const isDataObjectClass = (obj) => {
    return (obj === null || obj === void 0 ? void 0 : obj.factory) !== undefined;
};
exports.isDataObjectClass = isDataObjectClass;
/**
 * Runtime check to determine if a class is a SharedObject type
 */
const isSharedObjectClass = (obj) => {
    return (obj === null || obj === void 0 ? void 0 : obj.getFactory) !== undefined;
};
exports.isSharedObjectClass = isSharedObjectClass;
/**
 * The ContainerSchema consists of initialObjects and dynamicObjectTypes. These types can be
 * of both SharedObject or DataObject. This function seperates the two and returns a registery
 * of DataObject types and an array of SharedObjects.
 */
const parseDataObjectsFromSharedObjects = (schema) => {
    var _a;
    const registryEntries = new Set();
    const sharedObjects = new Set();
    const tryAddObject = (obj) => {
        if ((0, exports.isSharedObjectClass)(obj)) {
            sharedObjects.add(obj.getFactory());
        }
        else if ((0, exports.isDataObjectClass)(obj)) {
            registryEntries.add([
                obj.factory.type,
                Promise.resolve(obj.factory),
            ]);
        }
        else {
            throw new Error(`Entry is neither a DataObject or a SharedObject`);
        }
    };
    // Add the object types that will be initialized
    const dedupedObjects = new Set([
        ...Object.values(schema.initialObjects),
        ...((_a = schema.dynamicObjectTypes) !== null && _a !== void 0 ? _a : []),
    ]);
    dedupedObjects.forEach(tryAddObject);
    if (registryEntries.size === 0 && sharedObjects.size === 0) {
        throw new Error("Container cannot be initialized without any DataTypes");
    }
    return [Array.from(registryEntries), Array.from(sharedObjects)];
};
exports.parseDataObjectsFromSharedObjects = parseDataObjectsFromSharedObjects;

},{}],132:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runGarbageCollection = void 0;
/**
 * Runs garbage collection on the given reference graph.
 * @param referenceGraph - The reference graph to run GC on. It's a list of nodes where each node has an id and set of
 * routes to other nodes in the graph.
 * @param rootIds - The ids of root nodes that are considered referenced.
 * @returns the ids of referenced nodes and the ids of deleted nodes in the referenced graph.
 */
function runGarbageCollection(referenceGraph, rootIds) {
    // This set keeps track of nodes that we have visited. It is used to detect cycles in the graph.
    const visited = new Set();
    // This tracks the ids of referenced nodes. The nodes corresponding to rootIds are always considered
    // referenced so we start with those.
    const referencedIds = [...rootIds];
    for (const id of referencedIds) {
        // If we have already seen this node, ignore and continue. Else, add it to visited list.
        if (visited.has(id)) {
            continue;
        }
        visited.add(id);
        // Get the node for the referenced id and add its outbound routes to referencedIds since they are
        // also referenced.
        const routes = referenceGraph[id];
        if (routes !== undefined) {
            referencedIds.push(...routes);
        }
    }
    const referencedNodeIds = [];
    const deletedNodeIds = [];
    for (const id of Object.keys(referenceGraph)) {
        // The nodes from the reference graph whose ids are in the visited list are referenced.
        // The rest of the nodes are deleted.
        if (visited.has(id)) {
            referencedNodeIds.push(id);
        }
        else {
            deletedNodeIds.push(id);
        }
    }
    return { referencedNodeIds, deletedNodeIds };
}
exports.runGarbageCollection = runGarbageCollection;

},{}],133:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
__exportStar(require("./garbageCollector"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./interfaces"), exports);

},{"./garbageCollector":132,"./interfaces":134,"./utils":135}],134:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],135:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GCDataBuilder = exports.concatGarbageCollectionData = exports.concatGarbageCollectionStates = exports.removeRouteFromAllNodes = exports.unpackChildNodesUsedRoutes = exports.unpackChildNodesGCDetails = exports.cloneGCData = exports.trimTrailingSlashes = exports.trimLeadingSlashes = exports.trimLeadingAndTrailingSlashes = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Trims the leading and trailing slashes from the given string.
 * @param str - A string that may contain leading and / or trailing slashes.
 * @returns A new string without leading and trailing slashes.
 */
function trimLeadingAndTrailingSlashes(str) {
    return str.replace(/^\/+|\/+$/g, "");
}
exports.trimLeadingAndTrailingSlashes = trimLeadingAndTrailingSlashes;
/**
 * Trims the leading slashes from the given string.
 * @param str - A string that may contain leading slashes.
 * @returns A new string without leading slashes.
 */
function trimLeadingSlashes(str) {
    return str.replace(/^\/+/g, "");
}
exports.trimLeadingSlashes = trimLeadingSlashes;
/**
 * Trims the trailing slashes from the given string.
 * @param str - A string that may contain trailing slashes.
 * @returns A new string without trailing slashes.
 */
function trimTrailingSlashes(str) {
    return str.replace(/\/+$/g, "");
}
exports.trimTrailingSlashes = trimTrailingSlashes;
/**
 * Helper function that clones the GC data.
 * @param gcData - The GC data to clone.
 * @returns a clone of the given GC data.
 */
function cloneGCData(gcData) {
    const clonedGCNodes = {};
    for (const [id, outboundRoutes] of Object.entries(gcData.gcNodes)) {
        clonedGCNodes[id] = Array.from(outboundRoutes);
    }
    return {
        gcNodes: clonedGCNodes,
    };
}
exports.cloneGCData = cloneGCData;
/**
 * Helper function that unpacks the GC details of the children from a given node's GC details.
 * @param gcDetails - The GC details of a node.
 * @returns A map of GC details of each children of the the given node.
 */
function unpackChildNodesGCDetails(gcDetails) {
    const childGCDetailsMap = new Map();
    // If GC data is not available, bail out.
    if (gcDetails.gcData === undefined) {
        return childGCDetailsMap;
    }
    // Remove the node's self GC nodes, if any, and generate the children GC nodes.
    const gcNodes = gcDetails.gcData.gcNodes;
    delete gcNodes["/"];
    for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
        (0, common_utils_1.assert)(id.startsWith("/"), 0x2ae /* "node id should always be an absolute route" */);
        const childId = id.split("/")[1];
        let childGCNodeId = id.slice(childId.length + 1);
        // GC node id always begins with "/". Handle the special case where a child's id in the parent's GC nodes is
        // of format `/root`. In this case, the childId is root and childGCNodeId is "". Make childGCNodeId = "/".
        if (childGCNodeId === "") {
            childGCNodeId = "/";
        }
        let childGCDetails = childGCDetailsMap.get(childId);
        if (childGCDetails === undefined) {
            childGCDetails = { gcData: { gcNodes: {} }, usedRoutes: [] };
        }
        // gcData should not undefined as its always at least initialized as  empty above.
        (0, common_utils_1.assert)(childGCDetails.gcData !== undefined, 0x2af /* "Child GC data should have been initialized" */);
        childGCDetails.gcData.gcNodes[childGCNodeId] = [...new Set(outboundRoutes)];
        childGCDetailsMap.set(childId, childGCDetails);
    }
    if (gcDetails.usedRoutes === undefined) {
        return childGCDetailsMap;
    }
    // Remove the node's self used route, if any, and generate the children used routes.
    const usedRoutes = gcDetails.usedRoutes.filter((route) => route !== "" && route !== "/");
    for (const route of usedRoutes) {
        (0, common_utils_1.assert)(route.startsWith("/"), 0x2b0 /* "Used route should always be an absolute route" */);
        const childId = route.split("/")[1];
        const childUsedRoute = route.slice(childId.length + 1);
        const childGCDetails = childGCDetailsMap.get(childId);
        (0, common_utils_1.assert)((childGCDetails === null || childGCDetails === void 0 ? void 0 : childGCDetails.usedRoutes) !== undefined, 0x2b1 /* "This should have be initiallized when generate GC nodes above" */);
        childGCDetails.usedRoutes.push(childUsedRoute);
        childGCDetailsMap.set(childId, childGCDetails);
    }
    return childGCDetailsMap;
}
exports.unpackChildNodesGCDetails = unpackChildNodesGCDetails;
/**
 * Helper function that unpacks the used routes of children from a given node's used routes.
 * @param usedRoutes - The used routes of a node.
 * @returns A map of used routes of each children of the the given node.
 */
function unpackChildNodesUsedRoutes(usedRoutes) {
    // Remove the node's self used route, if any, and generate the children used routes.
    const filteredUsedRoutes = usedRoutes.filter((route) => route !== "" && route !== "/");
    const childUsedRoutesMap = new Map();
    for (const route of filteredUsedRoutes) {
        (0, common_utils_1.assert)(route.startsWith("/"), 0x198 /* "Used route should always be an absolute route" */);
        const childId = route.split("/")[1];
        const childUsedRoute = route.slice(childId.length + 1);
        const childUsedRoutes = childUsedRoutesMap.get(childId);
        if (childUsedRoutes !== undefined) {
            childUsedRoutes.push(childUsedRoute);
        }
        else {
            childUsedRoutesMap.set(childId, [childUsedRoute]);
        }
    }
    return childUsedRoutesMap;
}
exports.unpackChildNodesUsedRoutes = unpackChildNodesUsedRoutes;
/**
 * Removes the given route from the outbound routes of all the given GC nodes, and any duplicates
 * @param gcNodes - The nodes from which the route is to be removed.
 * @param outboundRoute - The route to be removed.
 */
function removeRouteFromAllNodes(gcNodes, outboundRoute) {
    const channels = Object.entries(gcNodes);
    for (const [nodeId, outboundRoutes] of channels) {
        // Remove route from channel to parent for each channel
        const outboundRoutesSet = new Set(outboundRoutes);
        outboundRoutesSet.delete(outboundRoute);
        gcNodes[nodeId] = [...outboundRoutesSet];
    }
}
exports.removeRouteFromAllNodes = removeRouteFromAllNodes;
/**
 * Concatenates the given GC states and returns the concatenated GC state.
 */
function concatGarbageCollectionStates(gcState1, gcState2) {
    var _a;
    const combinedGCNodes = {};
    for (const [nodeId, nodeData] of Object.entries(gcState1.gcNodes)) {
        combinedGCNodes[nodeId] = {
            outboundRoutes: Array.from(nodeData.outboundRoutes),
            unreferencedTimestampMs: nodeData.unreferencedTimestampMs,
        };
    }
    for (const [nodeId, nodeData] of Object.entries(gcState2.gcNodes)) {
        let combinedNodedata = combinedGCNodes[nodeId];
        if (combinedNodedata === undefined) {
            combinedNodedata = {
                outboundRoutes: Array.from(nodeData.outboundRoutes),
                unreferencedTimestampMs: nodeData.unreferencedTimestampMs,
            };
        }
        else {
            // Validate that same node doesn't have different unreferenced timestamp.
            if (nodeData.unreferencedTimestampMs !== undefined
                && combinedNodedata.unreferencedTimestampMs !== undefined) {
                (0, common_utils_1.assert)(nodeData.unreferencedTimestampMs === combinedNodedata.unreferencedTimestampMs, 0x2b2 /* "Two entries for the same GC node with different unreferenced timestamp" */);
            }
            combinedNodedata = {
                outboundRoutes: [...new Set([...nodeData.outboundRoutes, ...combinedNodedata.outboundRoutes])],
                unreferencedTimestampMs: (_a = nodeData.unreferencedTimestampMs) !== null && _a !== void 0 ? _a : combinedNodedata.unreferencedTimestampMs,
            };
        }
        combinedGCNodes[nodeId] = combinedNodedata;
    }
    return { gcNodes: combinedGCNodes };
}
exports.concatGarbageCollectionStates = concatGarbageCollectionStates;
/**
 * Concatenates the given GC datas and returns the concatenated GC data.
 */
function concatGarbageCollectionData(gcData1, gcData2) {
    const combinedGCData = cloneGCData(gcData1);
    for (const [id, routes] of Object.entries(gcData2.gcNodes)) {
        if (combinedGCData.gcNodes[id] === undefined) {
            combinedGCData.gcNodes[id] = Array.from(routes);
        }
        else {
            const combinedRoutes = [...routes, ...combinedGCData.gcNodes[id]];
            combinedGCData.gcNodes[id] = [...new Set(combinedRoutes)];
        }
    }
    return combinedGCData;
}
exports.concatGarbageCollectionData = concatGarbageCollectionData;
class GCDataBuilder {
    constructor() {
        this.gcNodesSet = {};
    }
    get gcNodes() {
        const gcNodes = {};
        for (const [nodeId, outboundRoutes] of Object.entries(this.gcNodesSet)) {
            gcNodes[nodeId] = [...outboundRoutes];
        }
        return gcNodes;
    }
    addNode(id, outboundRoutes) {
        this.gcNodesSet[id] = new Set(outboundRoutes);
    }
    /**
     * Adds the given GC nodes. It does the following:
     * - Normalizes the ids of the given nodes.
     * - Prefixes the given `prefixId` to the given nodes' ids.
     * - Adds the outbound routes of the nodes against the normalized and prefixed id.
     */
    prefixAndAddNodes(prefixId, gcNodes) {
        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
            // Remove any leading slashes from the id.
            let normalizedId = trimLeadingSlashes(id);
            // Prefix the given id to the normalized id.
            normalizedId = `/${prefixId}/${normalizedId}`;
            // Remove any trailing slashes from the normalized id. Note that the trailing slashes are removed after
            // adding the prefix for handling the special case where id is "/".
            normalizedId = trimTrailingSlashes(normalizedId);
            // Add the outbound routes against the normalized and prefixed id without duplicates.
            this.gcNodesSet[normalizedId] = new Set(outboundRoutes);
        }
    }
    addNodes(gcNodes) {
        for (const [id, outboundRoutes] of Object.entries(gcNodes)) {
            this.gcNodesSet[id] = new Set(outboundRoutes);
        }
    }
    /**
     * Adds the given outbound route to the outbound routes of all GC nodes.
     */
    addRouteToAllNodes(outboundRoute) {
        for (const outboundRoutes of Object.values(this.gcNodesSet)) {
            outboundRoutes.add(outboundRoute);
        }
    }
    getGCData() {
        return {
            gcNodes: this.gcNodes,
        };
    }
}
exports.GCDataBuilder = GCDataBuilder;

},{"@fluidframework/common-utils":29}],136:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedDirectory = exports.DirectoryFactory = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const path = __importStar(require("path-browserify"));
const localValues_1 = require("./localValues");
const packageVersion_1 = require("./packageVersion");
// We use path-browserify since this code can run safely on the server or the browser.
// We standardize on using posix slashes everywhere.
const posix = path.posix;
const snapshotFileName = "header";
/**
 * The factory that defines the directory.
 * @sealed
 */
class DirectoryFactory {
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
     */
    get type() {
        return DirectoryFactory.Type;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
     */
    get attributes() {
        return DirectoryFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const directory = new SharedDirectory(id, runtime, attributes);
        await directory.load(services);
        return directory;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
     */
    create(runtime, id) {
        const directory = new SharedDirectory(id, runtime, DirectoryFactory.Attributes);
        directory.initializeLocal();
        return directory;
    }
}
exports.DirectoryFactory = DirectoryFactory;
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
 */
DirectoryFactory.Type = "https://graph.microsoft.com/types/directory";
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
 */
DirectoryFactory.Attributes = {
    type: DirectoryFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};
/**
 * SharedDirectory provides a hierarchical organization of map-like data structures as SubDirectories.
 * The values stored within can be accessed like a map, and the hierarchy can be navigated using path syntax.
 * SubDirectories can be retrieved for use as working directories.
 *
 * @example
 * ```typescript
 * mySharedDirectory.createSubDirectory("a").createSubDirectory("b").createSubDirectory("c").set("foo", val1);
 * const mySubDir = mySharedDirectory.getWorkingDirectory("/a/b/c");
 * mySubDir.get("foo"); // returns val1
 * ```
 *
 * @sealed
 */
class SharedDirectory extends shared_object_base_1.SharedObject {
    /**
     * Constructs a new shared directory. If the object is non-local an id and service interfaces will
     * be provided.
     * @param id - String identifier for the SharedDirectory
     * @param runtime - Data store runtime
     * @param type - Type identifier
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_directory_");
        /**
         * String representation for the class.
         */
        this[_a] = "SharedDirectory";
        /**
         * Root of the SharedDirectory, most operations on the SharedDirectory itself act on the root.
         */
        this.root = new SubDirectory(this, this.runtime, this.serializer, posix.sep);
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        this.localValueMaker = new localValues_1.LocalValueMaker(this.serializer);
        this.setMessageHandlers();
        // Mirror the containedValueChanged op on the SharedDirectory
        this.root.on("containedValueChanged", (changed, local) => {
            this.emit("containedValueChanged", changed, local, this);
        });
        this.root.on("subDirectoryCreated", (relativePath, local) => {
            this.emit("subDirectoryCreated", relativePath, local, this);
        });
        this.root.on("subDirectoryDeleted", (relativePath, local) => {
            this.emit("subDirectoryDeleted", relativePath, local, this);
        });
    }
    /**
     * Create a new shared directory
     *
     * @param runtime - Data store runtime the new shared directory belongs to
     * @param id - Optional name of the shared directory
     * @returns Newly create shared directory (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, DirectoryFactory.Type);
    }
    /**
     * Get a factory for SharedDirectory to register with the data store.
     *
     * @returns A factory that creates and load SharedDirectory
     */
    static getFactory() {
        return new DirectoryFactory();
    }
    /**
     * {@inheritDoc IDirectory.absolutePath}
     */
    get absolutePath() {
        return this.root.absolutePath;
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        return this.root.get(key);
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        this.root.set(key, value);
        return this;
    }
    dispose(error) {
        this.root.dispose(error);
    }
    get disposed() {
        return this.root.disposed;
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        return this.root.delete(key);
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        this.root.clear();
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.root.has(key);
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        return this.root.size;
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this.root.forEach(callback);
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.root[Symbol.iterator]();
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        return this.root.entries();
    }
    /**
     * {@inheritDoc IDirectory.countSubDirectory}
     */
    countSubDirectory() {
        return this.root.countSubDirectory();
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        return this.root.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        return this.root.values();
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        return this.root.createSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        return this.root.getSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        return this.root.hasSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        return this.root.deleteSubDirectory(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        return this.root.subdirectories();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        const absolutePath = this.makeAbsolute(relativePath);
        if (absolutePath === posix.sep) {
            return this.root;
        }
        let currentSubDir = this.root;
        const subdirs = absolutePath.substr(1).split(posix.sep);
        for (const subdir of subdirs) {
            currentSubDir = currentSubDir.getSubDirectory(subdir);
            if (!currentSubDir) {
                return undefined;
            }
        }
        return currentSubDir;
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}
     * @internal
     */
    summarizeCore(serializer, telemetryContext) {
        return this.serializeDirectory(this.root, serializer);
    }
    /**
     * Submits an operation
     * @param op - Op to submit
     * @param localOpMetadata - The local metadata associated with the op. We send a unique id that is used to track
     * this op while it has not been ack'd. This will be sent when we receive this op back from the server.
     * @internal
     */
    submitDirectoryMessage(op, localOpMetadata) {
        this.submitLocalMessage(op, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
     * @internal
     */
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
     * @internal
     */
    reSubmitCore(content, localOpMetadata) {
        const message = content;
        const handler = this.messageHandlers.get(message.type);
        (0, common_utils_1.assert)(handler !== undefined, 0x00d /* Missing message handler for message type */);
        handler.submit(message, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     * @internal
     */
    async loadCore(storage) {
        const data = await (0, driver_utils_1.readAndParse)(storage, snapshotFileName);
        const newFormat = data;
        if (Array.isArray(newFormat.blobs)) {
            // New storage format
            this.populate(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const dataExtra = await (0, driver_utils_1.readAndParse)(storage, value);
                this.populate(dataExtra);
            }));
        }
        else {
            // Old storage format
            this.populate(data);
        }
    }
    /**
     * Populate the directory with the given directory data.
     * @param data - A JSON string containing serialized directory data
     * @internal
     */
    populate(data) {
        const stack = [];
        stack.push([this.root, data]);
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [currentSubDir, currentSubDirObject] = stack.pop();
            if (currentSubDirObject.subdirectories) {
                for (const [subdirName, subdirObject] of Object.entries(currentSubDirObject.subdirectories)) {
                    let newSubDir = currentSubDir.getSubDirectory(subdirName);
                    if (!newSubDir) {
                        newSubDir = new SubDirectory(this, this.runtime, this.serializer, posix.join(currentSubDir.absolutePath, subdirName));
                        currentSubDir.populateSubDirectory(subdirName, newSubDir);
                    }
                    stack.push([newSubDir, subdirObject]);
                }
            }
            if (currentSubDirObject.storage) {
                for (const [key, serializable] of Object.entries(currentSubDirObject.storage)) {
                    const localValue = this.makeLocal(key, currentSubDir.absolutePath, serializable);
                    currentSubDir.populateStorage(key, localValue);
                }
            }
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
     * @internal
     */
    processCore(message, local, localOpMetadata) {
        if (message.type === protocol_definitions_1.MessageType.Operation) {
            const op = message.contents;
            const handler = this.messageHandlers.get(op.type);
            (0, common_utils_1.assert)(handler !== undefined, 0x00e /* Missing message handler for message type */);
            handler.process(op, local, localOpMetadata);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}
     * @internal
    */
    rollback(content, localOpMetadata) {
        const op = content;
        const subdir = this.getWorkingDirectory(op.path);
        if (subdir) {
            subdir.rollback(op, localOpMetadata);
        }
    }
    /**
     * Converts the given relative path to absolute against the root.
     * @param relativePath - The path to convert
     */
    makeAbsolute(relativePath) {
        return posix.resolve(posix.sep, relativePath);
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a snapshot load or an incoming set op)
     * will have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the ID but not have the actual map or its data yet.  makeLocal's job
     * is to convert that information into a real object for local usage.
     * @param key - Key of element being converted
     * @param absolutePath - Path of element being converted
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, absolutePath, serializable) {
        (0, common_utils_1.assert)(serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain] || serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Shared], 0x1e4 /* "Unexpected serializable type" */);
        return this.localValueMaker.fromSerializable(serializable);
    }
    /**
     * Set the message handlers for the directory.
     */
    setMessageHandlers() {
        this.messageHandlers.set("clear", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processClearMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitClearMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("delete", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.processDeleteMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitKeyMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("set", {
            process: (op, local, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    const context = local ? undefined : this.makeLocal(op.key, op.path, op.value);
                    subdir.processSetMessage(op, context, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const subdir = this.getWorkingDirectory(op.path);
                if (subdir) {
                    subdir.resubmitKeyMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("createSubDirectory", {
            process: (op, local, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processCreateSubDirectoryMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);
                }
            },
        });
        this.messageHandlers.set("deleteSubDirectory", {
            process: (op, local, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    parentSubdir.processDeleteSubDirectoryMessage(op, local, localOpMetadata);
                }
            },
            submit: (op, localOpMetadata) => {
                const parentSubdir = this.getWorkingDirectory(op.path);
                if (parentSubdir) {
                    // We don't reuse the metadata but send a new one on each submit.
                    parentSubdir.resubmitSubDirectoryMessage(op, localOpMetadata);
                }
            },
        });
    }
    /**
     * @internal
     */
    applyStashedOp() {
        throw new Error("not implemented");
    }
    serializeDirectory(root, serializer, telemetryContext) {
        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        let counter = 0;
        const blobs = [];
        const stack = [];
        const content = {};
        stack.push([root, content]);
        while (stack.length > 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const [currentSubDir, currentSubDirObject] = stack.pop();
            for (const [key, value] of currentSubDir.getSerializedStorage(serializer)) {
                if (!currentSubDirObject.storage) {
                    currentSubDirObject.storage = {};
                }
                const result = {
                    type: value.type,
                    // eslint-disable-next-line @typescript-eslint/ban-types
                    value: value.value && JSON.parse(value.value),
                };
                if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                    const extraContent = {};
                    let largeContent = extraContent;
                    if (currentSubDir.absolutePath !== posix.sep) {
                        for (const dir of currentSubDir.absolutePath.substr(1).split(posix.sep)) {
                            const subDataObject = {};
                            largeContent.subdirectories = { [dir]: subDataObject };
                            largeContent = subDataObject;
                        }
                    }
                    largeContent.storage = { [key]: result };
                    const blobName = `blob${counter}`;
                    counter++;
                    blobs.push(blobName);
                    builder.addBlob(blobName, JSON.stringify(extraContent));
                }
                else {
                    currentSubDirObject.storage[key] = result;
                }
            }
            for (const [subdirName, subdir] of currentSubDir.subdirectories()) {
                if (!currentSubDirObject.subdirectories) {
                    currentSubDirObject.subdirectories = {};
                }
                const subDataObject = {};
                currentSubDirObject.subdirectories[subdirName] = subDataObject;
                stack.push([subdir, subDataObject]);
            }
        }
        const newFormat = {
            blobs,
            content,
        };
        builder.addBlob(snapshotFileName, JSON.stringify(newFormat));
        return builder.getSummaryTree();
    }
}
exports.SharedDirectory = SharedDirectory;
function isKeyEditLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" && metadata.type === "edit";
}
function isClearLocalOpMetadata(metadata) {
    return metadata !== undefined && metadata.type === "clear" && typeof metadata.pendingMessageId === "number" &&
        typeof metadata.previousStorage === "object";
}
function isSubDirLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        ((metadata.type === "createSubDir" && typeof metadata.previouslyExisted === "boolean") ||
            metadata.type === "deleteSubDir");
}
function isDirectoryLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "edit" || metadata.type === "deleteSubDir" ||
            (metadata.type === "clear" && typeof metadata.previousStorage === "object") ||
            (metadata.type === "createSubDir" && typeof metadata.previouslyExisted === "boolean"));
}
/**
 * Node of the directory tree.
 * @sealed
 */
class SubDirectory extends common_utils_1.TypedEventEmitter {
    /**
     * Constructor.
     * @param directory - Reference back to the SharedDirectory to perform operations
     * @param runtime - The data store runtime this directory is associated with
     * @param serializer - The serializer to serialize / parse handles
     * @param absolutePath - The absolute path of this IDirectory
     */
    constructor(directory, runtime, serializer, absolutePath) {
        super();
        this.directory = directory;
        this.runtime = runtime;
        this.serializer = serializer;
        this.absolutePath = absolutePath;
        /**
         * Tells if the sub directory is deleted or not.
         */
        this._deleted = false;
        /**
         * String representation for the class.
         */
        this[_b] = "SubDirectory";
        /**
         * The in-memory data the directory is storing.
         */
        this._storage = new Map();
        /**
         * The subdirectories the directory is holding.
         */
        this._subdirectories = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * Subdirectories that have been modified locally but not yet ack'd from the server.
         */
        this.pendingSubDirectories = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * The pending ids of any clears that have been performed locally but not yet ack'd from the server
         */
        this.pendingClearMessageIds = [];
    }
    dispose(error) {
        this._deleted = true;
        this.emit("disposed", this);
    }
    /**
     * Unmark the deleted property when rolling back delete.
     */
    undispose() {
        this._deleted = false;
    }
    get disposed() {
        return this._deleted;
    }
    throwIfDisposed() {
        if (this._deleted) {
            throw new container_utils_1.UsageError("Cannot access Disposed subDirectory");
        }
    }
    /**
     * Checks whether the given key exists in this IDirectory.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        this.throwIfDisposed();
        return this._storage.has(key);
    }
    /**
     * {@inheritDoc IDirectory.get}
     */
    get(key) {
        var _c;
        this.throwIfDisposed();
        return (_c = this._storage.get(key)) === null || _c === void 0 ? void 0 : _c.value;
    }
    /**
     * {@inheritDoc IDirectory.set}
     */
    set(key, value) {
        this.throwIfDisposed();
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.directory.localValueMaker.fromInMemory(value);
        const serializableValue = (0, localValues_1.makeSerializable)(localValue, this.serializer, this.directory.handle);
        // Set the value locally.
        const previousValue = this.setCore(key, localValue, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return this;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "set",
            value: serializableValue,
        };
        this.submitKeyMessage(op, previousValue);
        return this;
    }
    /**
     * {@inheritDoc IDirectory.countSubDirectory}
     */
    countSubDirectory() {
        return this._subdirectories.size;
    }
    /**
     * {@inheritDoc IDirectory.createSubDirectory}
     */
    createSubDirectory(subdirName) {
        this.throwIfDisposed();
        // Undefined/null subdirectory names can't be serialized to JSON in the manner we currently snapshot.
        if (subdirName === undefined || subdirName === null) {
            throw new Error("SubDirectory name may not be undefined or null");
        }
        if (subdirName.includes(posix.sep)) {
            throw new Error(`SubDirectory name may not contain ${posix.sep}`);
        }
        // Create the sub directory locally first.
        const isNew = this.createSubDirectoryCore(subdirName, true);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const subDir = this._subdirectories.get(subdirName);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return subDir;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "createSubDirectory",
        };
        this.submitCreateSubDirectoryMessage(op, !isNew);
        return subDir;
    }
    /**
     * {@inheritDoc IDirectory.getSubDirectory}
     */
    getSubDirectory(subdirName) {
        this.throwIfDisposed();
        return this._subdirectories.get(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.hasSubDirectory}
     */
    hasSubDirectory(subdirName) {
        this.throwIfDisposed();
        return this._subdirectories.has(subdirName);
    }
    /**
     * {@inheritDoc IDirectory.deleteSubDirectory}
     */
    deleteSubDirectory(subdirName) {
        this.throwIfDisposed();
        // Delete the sub directory locally first.
        const subDir = this.deleteSubDirectoryCore(subdirName, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return subDir !== undefined;
        }
        const op = {
            path: this.absolutePath,
            subdirName,
            type: "deleteSubDirectory",
        };
        this.submitDeleteSubDirectoryMessage(op, subDir);
        return subDir !== undefined;
    }
    /**
     * {@inheritDoc IDirectory.subdirectories}
     */
    subdirectories() {
        this.throwIfDisposed();
        return this._subdirectories.entries();
    }
    /**
     * {@inheritDoc IDirectory.getWorkingDirectory}
     */
    getWorkingDirectory(relativePath) {
        this.throwIfDisposed();
        return this.directory.getWorkingDirectory(this.makeAbsolute(relativePath));
    }
    /**
     * Deletes the given key from within this IDirectory.
     * @param key - The key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        this.throwIfDisposed();
        // Delete the key locally first.
        const previousValue = this.deleteCore(key, true);
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            return previousValue !== undefined;
        }
        const op = {
            key,
            path: this.absolutePath,
            type: "delete",
        };
        this.submitKeyMessage(op, previousValue);
        return previousValue !== undefined;
    }
    /**
     * Deletes all keys from within this IDirectory.
     */
    clear() {
        this.throwIfDisposed();
        // If we are not attached, don't submit the op.
        if (!this.directory.isAttached()) {
            this.clearCore(true);
            return;
        }
        const copy = new Map(this._storage);
        this.clearCore(true);
        const op = {
            path: this.absolutePath,
            type: "clear",
        };
        this.submitClearMessage(op, copy);
    }
    /**
     * Issue a callback on each entry under this IDirectory.
     * @param callback - Callback to issue
     */
    forEach(callback) {
        this.throwIfDisposed();
        this._storage.forEach((localValue, key, map) => {
            callback(localValue.value, key, map);
        });
    }
    /**
     * The number of entries under this IDirectory.
     */
    get size() {
        this.throwIfDisposed();
        return this._storage.size;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    entries() {
        this.throwIfDisposed();
        const localEntriesIterator = this._storage.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the keys under this IDirectory.
     * @returns The iterator
     */
    keys() {
        this.throwIfDisposed();
        return this._storage.keys();
    }
    /**
     * Get an iterator over the values under this IDirectory.
     * @returns The iterator
     */
    values() {
        this.throwIfDisposed();
        const localValuesIterator = this._storage.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries under this IDirectory.
     * @returns The iterator
     */
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        this.throwIfDisposed();
        return this.entries();
    }
    /**
     * Process a clear operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processClearMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (local) {
            (0, common_utils_1.assert)(isClearLocalOpMetadata(localOpMetadata), 0x00f /* pendingMessageId is missing from the local client's operation */);
            const pendingClearMessageId = this.pendingClearMessageIds.shift();
            (0, common_utils_1.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32a /* pendingMessageId does not match */);
            return;
        }
        this.clearExceptPendingKeys();
    }
    /**
     * Process a delete operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {
            return;
        }
        this.deleteCore(op.key, local);
    }
    /**
     * Process a set operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processSetMessage(op, context, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessStorageOperation(op, local, localOpMetadata)) {
            return;
        }
        // needProcessStorageOperation should have returned false if local is true
        // so we can assume context is not undefined
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.setCore(op.key, context, local);
    }
    /**
     * Process a create subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processCreateSubDirectoryMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {
            return;
        }
        this.createSubDirectoryCore(op.subdirName, local);
    }
    /**
     * Process a delete subdirectory operation.
     * @param op - The op to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @internal
     */
    processDeleteSubDirectoryMessage(op, local, localOpMetadata) {
        this.throwIfDisposed();
        if (!this.needProcessSubDirectoryOperation(op, local, localOpMetadata)) {
            return;
        }
        this.deleteSubDirectoryCore(op.subdirName, local);
    }
    /**
     * Submit a clear operation.
     * @param op - The operation
     */
    submitClearMessage(op, previousValue) {
        this.throwIfDisposed();
        const pendingMsgId = ++this.pendingMessageId;
        this.pendingClearMessageIds.push(pendingMsgId);
        const metadata = {
            type: "clear",
            pendingMessageId: pendingMsgId,
            previousStorage: previousValue,
        };
        this.directory.submitDirectoryMessage(op, metadata);
    }
    /**
     * Resubmit a clear operation.
     * @param op - The operation
     * @internal
     */
    resubmitClearMessage(op, localOpMetadata) {
        (0, common_utils_1.assert)(isClearLocalOpMetadata(localOpMetadata), 0x32b /* Invalid localOpMetadata for clear */);
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingClearMessageId = this.pendingClearMessageIds.shift();
        (0, common_utils_1.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x32c /* pendingMessageId does not match */);
        this.submitClearMessage(op, localOpMetadata.previousStorage);
    }
    /**
     * Get a new pending message id for the op and cache it to track the pending op
     */
    getKeyMessageId(op) {
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingKeys.get(op.key);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(pendingMessageId);
        }
        else {
            this.pendingKeys.set(op.key, [pendingMessageId]);
        }
        return pendingMessageId;
    }
    /**
     * Submit a key operation.
     * @param op - The operation
     * @param previousValue - The value of the key before this op
     */
    submitKeyMessage(op, previousValue) {
        this.throwIfDisposed();
        const pendingMessageId = this.getKeyMessageId(op);
        const localMetadata = { type: "edit", pendingMessageId, previousValue };
        this.directory.submitDirectoryMessage(op, localMetadata);
    }
    /**
     * Submit a key message to remote clients based on a previous submit.
     * @param op - The map key message
     * @param localOpMetadata - Metadata from the previous submit
     * @internal
     */
    resubmitKeyMessage(op, localOpMetadata) {
        (0, common_utils_1.assert)(isKeyEditLocalOpMetadata(localOpMetadata), 0x32d /* Invalid localOpMetadata in submit */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingKeys.get(op.key);
        (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x32e /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingKeys.delete(op.key);
        }
        this.submitKeyMessage(op, localOpMetadata.previousValue);
    }
    /**
     * Get a new pending message id for the op and cache it to track the pending op
     */
    getSubDirMessageId(op) {
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const newMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(newMessageId);
        }
        else {
            this.pendingSubDirectories.set(op.subdirName, [newMessageId]);
        }
        return newMessageId;
    }
    /**
     * Submit a create subdirectory operation.
     * @param op - The operation
     * @param prevExisted - Whether the subdirectory existed before the op
     */
    submitCreateSubDirectoryMessage(op, prevExisted) {
        this.throwIfDisposed();
        const newMessageId = this.getSubDirMessageId(op);
        const localOpMetadata = {
            type: "createSubDir",
            pendingMessageId: newMessageId,
            previouslyExisted: prevExisted,
        };
        this.directory.submitDirectoryMessage(op, localOpMetadata);
    }
    /**
     * Submit a delete subdirectory operation.
     * @param op - The operation
     * @param subDir - Any subdirectory deleted by the op
     */
    submitDeleteSubDirectoryMessage(op, subDir) {
        this.throwIfDisposed();
        const newMessageId = this.getSubDirMessageId(op);
        const localOpMetadata = {
            type: "deleteSubDir",
            pendingMessageId: newMessageId,
            subDirectory: subDir,
        };
        this.directory.submitDirectoryMessage(op, localOpMetadata);
    }
    /**
     * Submit a subdirectory operation again
     * @param op - The operation
     * @param localOpMetadata - metadata submitted with the op originally
     * @internal
     */
    resubmitSubDirectoryMessage(op, localOpMetadata) {
        (0, common_utils_1.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x32f /* Invalid localOpMetadata for sub directory op */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
        (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x330 /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingSubDirectories.delete(op.subdirName);
        }
        if (localOpMetadata.type === "createSubDir") {
            this.submitCreateSubDirectoryMessage(op, localOpMetadata.previouslyExisted);
        }
        else {
            this.submitDeleteSubDirectoryMessage(op, localOpMetadata.subDirectory);
        }
    }
    /**
     * Get the storage of this subdirectory in a serializable format, to be used in snapshotting.
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns The JSONable string representing the storage of this subdirectory
     * @internal
     */
    *getSerializedStorage(serializer) {
        this.throwIfDisposed();
        for (const [key, localValue] of this._storage) {
            const value = localValue.makeSerialized(serializer, this.directory.handle);
            const res = [key, value];
            yield res;
        }
    }
    /**
     * Populate a key value in this subdirectory's storage, to be used when loading from snapshot.
     * @param key - The key to populate
     * @param localValue - The local value to populate into it
     * @internal
     */
    populateStorage(key, localValue) {
        this.throwIfDisposed();
        this._storage.set(key, localValue);
    }
    /**
     * Populate a subdirectory into this subdirectory, to be used when loading from snapshot.
     * @param subdirName - The name of the subdirectory to add
     * @param newSubDir - The new subdirectory to add
     * @internal
     */
    populateSubDirectory(subdirName, newSubDir) {
        this.throwIfDisposed();
        this._subdirectories.set(subdirName, newSubDir);
    }
    /**
     * Retrieve the local value at the given key.  This is used to get value type information stashed on the local
     * value so op handlers can be retrieved
     * @param key - The key to retrieve from
     * @returns The local value
     * @internal
     */
    getLocalValue(key) {
        this.throwIfDisposed();
        return this._storage.get(key);
    }
    /**
     * Remove the pendingMessageId from the map tracking it on rollback
     * @param map - map tracking the pending messages
     * @param key - key of the edit in the op
     */
    rollbackPendingMessageId(map, key, pendingMessageId) {
        const pendingMessageIds = map.get(key);
        const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();
        if (!pendingMessageIds || lastPendingMessageId !== pendingMessageId) {
            throw new Error("Rollback op does not match last pending");
        }
        if (pendingMessageIds.length === 0) {
            map.delete(key);
        }
    }
    /**
     * Rollback a local op
     * @param op - The operation to rollback
     * @param localOpMetadata - The local metadata associated with the op.
     */
    rollback(op, localOpMetadata) {
        if (!isDirectoryLocalOpMetadata(localOpMetadata)) {
            throw new Error("Invalid localOpMetadata");
        }
        if (op.type === "clear" && localOpMetadata.type === "clear") {
            localOpMetadata.previousStorage.forEach((localValue, key) => {
                this.setCore(key, localValue, true);
            });
            const lastPendingClearId = this.pendingClearMessageIds.pop();
            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does match last clear");
            }
        }
        else if ((op.type === "delete" || op.type === "set") && localOpMetadata.type === "edit") {
            if (localOpMetadata.previousValue === undefined) {
                this.deleteCore(op.key, true);
            }
            else {
                this.setCore(op.key, localOpMetadata.previousValue, true);
            }
            this.rollbackPendingMessageId(this.pendingKeys, op.key, localOpMetadata.pendingMessageId);
        }
        else if (op.type === "createSubDirectory" && localOpMetadata.type === "createSubDir") {
            if (!localOpMetadata.previouslyExisted) {
                this.deleteSubDirectoryCore(op.subdirName, true);
            }
            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);
        }
        else if (op.type === "deleteSubDirectory" && localOpMetadata.type === "deleteSubDir") {
            if (localOpMetadata.subDirectory !== undefined) {
                this.undeleteSubDirectoryTree(localOpMetadata.subDirectory);
                // don't need to register events because deleting never unregistered
                this._subdirectories.set(op.subdirName, localOpMetadata.subDirectory);
                this.emit("subDirectoryCreated", op.subdirName, true, this);
            }
            this.rollbackPendingMessageId(this.pendingSubDirectories, op.subdirName, localOpMetadata.pendingMessageId);
        }
        else {
            throw new Error("Unsupported op for rollback");
        }
    }
    /**
     * Converts the given relative path into an absolute path.
     * @param path - Relative path to convert
     * @returns The equivalent absolute path
     */
    makeAbsolute(relativePath) {
        return posix.resolve(this.absolutePath, relativePath);
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the operation originated from the local client
     * @param localOpMetadata - For local client ops, this is the metadata that was submitted with the op.
     * For ops from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessStorageOperation(op, local, localOpMetadata) {
        if (this.pendingClearMessageIds.length > 0) {
            if (local) {
                (0, common_utils_1.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata) &&
                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x010 /* "Received out of order storage op when there is an unackd clear message" */);
            }
            // If I have a NACK clear, we can ignore all ops.
            return false;
        }
        const pendingKeyMessageId = this.pendingKeys.get(op.key);
        if (pendingKeyMessageId !== undefined) {
            // Found an NACK op, clear it from the directory if the latest sequence number in the directory
            // match the message's and don't process the op.
            if (local) {
                (0, common_utils_1.assert)(localOpMetadata !== undefined && isKeyEditLocalOpMetadata(localOpMetadata), 0x011 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingKeys.get(op.key);
                (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x331 /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param message - The message
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessSubDirectoryOperation(op, local, localOpMetadata) {
        const pendingSubDirectoryMessageId = this.pendingSubDirectories.get(op.subdirName);
        if (pendingSubDirectoryMessageId !== undefined) {
            if (local) {
                (0, common_utils_1.assert)(isSubDirLocalOpMetadata(localOpMetadata), 0x012 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingSubDirectories.get(op.subdirName);
                (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x332 /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingSubDirectories.delete(op.subdirName);
                }
            }
            return false;
        }
        return !local;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key, map) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this._storage.get(key));
        });
        this.clearCore(false);
        temp.forEach((value, key, map) => {
            this.setCore(key, value, true);
        });
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     */
    clearCore(local) {
        this._storage.clear();
        this.directory.emit("clear", local, this.directory);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key if it existed, undefined if it did not exist
     */
    deleteCore(key, local) {
        const previousLocalValue = this._storage.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        const successfullyRemoved = this._storage.delete(key);
        if (successfullyRemoved) {
            const event = { key, path: this.absolutePath, previousValue };
            this.directory.emit("valueChanged", event, local, this.directory);
            const containedEvent = { key, previousValue };
            this.emit("containedValueChanged", containedEvent, local, this);
        }
        return previousLocalValue;
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key, if any
     */
    setCore(key, value, local) {
        const previousLocalValue = this._storage.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        this._storage.set(key, value);
        const event = { key, path: this.absolutePath, previousValue };
        this.directory.emit("valueChanged", event, local, this.directory);
        const containedEvent = { key, previousValue };
        this.emit("containedValueChanged", containedEvent, local, this);
        return previousLocalValue;
    }
    /**
     * Create subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being created
     * @param local - Whether the message originated from the local client
     * @returns - True if is newly created, false if it already existed.
     */
    createSubDirectoryCore(subdirName, local) {
        if (!this._subdirectories.has(subdirName)) {
            const absolutePath = posix.join(this.absolutePath, subdirName);
            const subDir = new SubDirectory(this.directory, this.runtime, this.serializer, absolutePath);
            this.registerEventsOnSubDirectory(subDir, subdirName);
            this._subdirectories.set(subdirName, subDir);
            this.emit("subDirectoryCreated", subdirName, local, this);
            return true;
        }
        return false;
    }
    registerEventsOnSubDirectory(subDirectory, subDirName) {
        subDirectory.on("subDirectoryCreated", (relativePath, local) => {
            this.emit("subDirectoryCreated", posix.join(subDirName, relativePath), local, this);
        });
        subDirectory.on("subDirectoryDeleted", (relativePath, local) => {
            this.emit("subDirectoryDeleted", posix.join(subDirName, relativePath), local, this);
        });
    }
    /**
     * Delete subdirectory implementation used for both locally sourced creation as well as incoming remote creation.
     * @param subdirName - The name of the subdirectory being deleted
     * @param local - Whether the message originated from the local client
     */
    deleteSubDirectoryCore(subdirName, local) {
        const previousValue = this._subdirectories.get(subdirName);
        // This should make the subdirectory structure unreachable so it can be GC'd and won't appear in snapshots
        // Might want to consider cleaning out the structure more exhaustively though? But not when rollback.
        if (previousValue !== undefined) {
            this._subdirectories.delete(subdirName);
            this.disposeSubDirectoryTree(previousValue);
            this.emit("subDirectoryDeleted", subdirName, local, this);
        }
        return previousValue;
    }
    disposeSubDirectoryTree(directory) {
        if (!directory) {
            return;
        }
        // Dispose the subdirectory tree. This will dispose the subdirectories from bottom to top.
        const subDirectories = directory.subdirectories();
        for (const [_, subDirectory] of subDirectories) {
            this.disposeSubDirectoryTree(subDirectory);
        }
        if (typeof directory.dispose === "function") {
            directory.dispose();
        }
    }
    undeleteSubDirectoryTree(directory) {
        // Restore deleted subdirectory tree. This will unmark "deleted" from the subdirectories from bottom to top.
        for (const [_, subDirectory] of this._subdirectories.entries()) {
            this.undeleteSubDirectoryTree(subDirectory);
        }
        directory.undispose();
    }
}

},{"./localValues":139,"./packageVersion":142,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-utils":213,"@fluidframework/shared-object-base":261,"path-browserify":526}],137:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalValueMaker = void 0;
/**
 * The `map` package provides interfaces and implementing classes for map-like distributed data structures.
 *
 * @remarks The following distributed data structures are defined in this package:
 *
 * - {@link SharedMap}
 *
 * - {@link SharedDirectory}
 *
 * @packageDocumentation
 */
__exportStar(require("./interfaces"), exports);
__exportStar(require("./map"), exports);
__exportStar(require("./directory"), exports);
var localValues_1 = require("./localValues");
Object.defineProperty(exports, "LocalValueMaker", { enumerable: true, get: function () { return localValues_1.LocalValueMaker; } });

},{"./directory":136,"./interfaces":138,"./localValues":139,"./map":140}],138:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134}],139:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalValueMaker = exports.PlainLocalValue = exports.makeSerializable = void 0;
const shared_object_base_1 = require("@fluidframework/shared-object-base");
function makeSerializable(localValue, serializer, bind) {
    const value = localValue.makeSerialized(serializer, bind);
    return {
        type: value.type,
        value: value.value && JSON.parse(value.value),
    };
}
exports.makeSerializable = makeSerializable;
/**
 * Manages a contained plain value.  May also contain shared object handles.
 */
class PlainLocalValue {
    /**
     * Create a new PlainLocalValue.
     * @param value - The value to store, which may contain shared object handles
     */
    constructor(value) {
        this.value = value;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain];
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        // Stringify to convert to the serialized handle values - and then parse in order to create
        // a POJO for the op
        const value = (0, shared_object_base_1.serializeHandles)(this.value, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
}
exports.PlainLocalValue = PlainLocalValue;
/**
 * A LocalValueMaker enables a container type DDS to produce and store local values with minimal awareness of how
 * those objects are stored, serialized, and deserialized.
 */
class LocalValueMaker {
    /**
     * Create a new LocalValueMaker.
     * @param serializer - The serializer to serialize / parse handles.
     */
    constructor(serializer) {
        this.serializer = serializer;
    }
    /**
     * Create a new local value from an incoming serialized value.
     * @param serializable - The serializable value to make local
     */
    fromSerializable(serializable) {
        // Migrate from old shared value to handles
        if (serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Shared]) {
            serializable.type = shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain];
            const handle = {
                type: "__fluid_handle__",
                url: serializable.value,
            };
            serializable.value = handle;
        }
        const translatedValue = (0, shared_object_base_1.parseHandles)(serializable.value, this.serializer);
        return new PlainLocalValue(translatedValue);
    }
    /**
     * Create a new local value containing a given plain object.
     * @param value - The value to store
     * @returns An ILocalValue containing the value
     */
    fromInMemory(value) {
        return new PlainLocalValue(value);
    }
}
exports.LocalValueMaker = LocalValueMaker;

},{"@fluidframework/shared-object-base":261}],140:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedMap = exports.MapFactory = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const mapKernel_1 = require("./mapKernel");
const packageVersion_1 = require("./packageVersion");
const snapshotFileName = "header";
/**
 * The factory that defines the map.
 * @sealed
 */
class MapFactory {
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
     */
    get type() {
        return MapFactory.Type;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
     */
    get attributes() {
        return MapFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const map = new SharedMap(id, runtime, attributes);
        await map.load(services);
        return map;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.create}
     */
    create(runtime, id) {
        const map = new SharedMap(id, runtime, MapFactory.Attributes);
        map.initializeLocal();
        return map;
    }
}
exports.MapFactory = MapFactory;
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory."type"}
 */
MapFactory.Type = "https://graph.microsoft.com/types/map";
/**
 * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.attributes}
 */
MapFactory.Attributes = {
    type: MapFactory.Type,
    snapshotFormatVersion: "0.2",
    packageVersion: packageVersion_1.pkgVersion,
};
/**
 * The SharedMap distributed data structure can be used to store key-value pairs. It provides the same API for setting
 * and retrieving values that JavaScript developers are accustomed to with the
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map | Map} built-in object.
 * However, the keys of a SharedMap must be strings.
 */
class SharedMap extends shared_object_base_1.SharedObject {
    /**
     * Do not call the constructor. Instead, you should use the {@link SharedMap.create | create method}.
     *
     * @param id - String identifier.
     * @param runtime - Data store runtime.
     * @param attributes - The attributes for the map.
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_map_");
        /**
         * String representation for the class.
         */
        this[_a] = "SharedMap";
        this.kernel = new mapKernel_1.MapKernel(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), () => this.isAttached(), this);
    }
    /**
     * Create a new shared map.
     * @param runtime - The data store runtime that the new shared map belongs to.
     * @param id - Optional name of the shared map.
     * @returns Newly created shared map.
     *
     * @example
     * To create a `SharedMap`, call the static create method:
     *
     * ```typescript
     * const myMap = SharedMap.create(this.runtime, id);
     * ```
     */
    static create(runtime, id) {
        return runtime.createChannel(id, MapFactory.Type);
    }
    /**
     * Get a factory for SharedMap to register with the data store.
     * @returns A factory that creates SharedMaps and loads them from storage.
     */
    static getFactory() {
        return new MapFactory();
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.kernel.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        return this.kernel.entries();
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        return this.kernel.values();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.kernel.entries();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.kernel.size;
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.kernel.forEach(callbackFn);
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        return this.kernel.get(key);
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.kernel.has(key);
    }
    /**
     * {@inheritDoc ISharedMap.set}
     */
    set(key, value) {
        this.kernel.set(key, value);
        return this;
    }
    /**
     * Delete a key from the map.
     * @param key - Key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        return this.kernel.delete(key);
    }
    /**
     * Clear all data from the map.
     */
    clear() {
        this.kernel.clear();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.summarizeCore}
     * @internal
     */
    summarizeCore(serializer, telemetryContext) {
        let currentSize = 0;
        let counter = 0;
        let headerBlob = {};
        const blobs = [];
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        const data = this.kernel.getSerializedStorage(serializer);
        // If single property exceeds this size, it goes into its own blob
        const MinValueSizeSeparateSnapshotBlob = 8 * 1024;
        // Maximum blob size for multiple map properties
        // Should be bigger than MinValueSizeSeparateSnapshotBlob
        const MaxSnapshotBlobSize = 16 * 1024;
        // Partitioning algorithm:
        // 1) Split large (over MinValueSizeSeparateSnapshotBlob = 8K) properties into their own blobs.
        //    Naming (across snapshots) of such blob does not have to be stable across snapshots,
        //    As de-duping process (in driver) should not care about paths, only content.
        // 2) Split remaining properties into blobs of MaxSnapshotBlobSize (16K) size.
        //    This process does not produce stable partitioning. This means
        //    modification (including addition / deletion) of property can shift properties across blobs
        //    and result in non-incremental snapshot.
        //    This can be improved in the future, without being format breaking change, as loading sequence
        //    loads all blobs at once and partitioning schema has no impact on that process.
        for (const key of Object.keys(data)) {
            const value = data[key];
            if (value.value && value.value.length >= MinValueSizeSeparateSnapshotBlob) {
                const blobName = `blob${counter}`;
                counter++;
                blobs.push(blobName);
                const content = {
                    [key]: {
                        type: value.type,
                        value: JSON.parse(value.value),
                    },
                };
                builder.addBlob(blobName, JSON.stringify(content));
            }
            else {
                currentSize += value.type.length + 21; // Approximation cost of property header
                if (value.value) {
                    currentSize += value.value.length;
                }
                if (currentSize > MaxSnapshotBlobSize) {
                    const blobName = `blob${counter}`;
                    counter++;
                    blobs.push(blobName);
                    builder.addBlob(blobName, JSON.stringify(headerBlob));
                    headerBlob = {};
                    currentSize = 0;
                }
                headerBlob[key] = {
                    type: value.type,
                    value: value.value === undefined ? undefined : JSON.parse(value.value),
                };
            }
        }
        const header = {
            blobs,
            content: headerBlob,
        };
        builder.addBlob(snapshotFileName, JSON.stringify(header));
        return builder.getSummaryTree();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     * @internal
     */
    async loadCore(storage) {
        const json = await (0, driver_utils_1.readAndParse)(storage, snapshotFileName);
        const newFormat = json;
        if (Array.isArray(newFormat.blobs)) {
            this.kernel.populateFromSerializable(newFormat.content);
            await Promise.all(newFormat.blobs.map(async (value) => {
                const content = await (0, driver_utils_1.readAndParse)(storage, value);
                this.kernel.populateFromSerializable(content);
            }));
        }
        else {
            this.kernel.populateFromSerializable(json);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.onDisconnect}
     * @internal
     */
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.reSubmitCore}
     * @internal
     */
    reSubmitCore(content, localOpMetadata) {
        this.kernel.trySubmitMessage(content, localOpMetadata);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}
     * @internal
     */
    applyStashedOp(content) {
        this.kernel.tryProcessMessage(content, false, undefined);
        return this.kernel.tryGetStashedOpLocalMetadata(content);
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.processCore}
     * @internal
     */
    processCore(message, local, localOpMetadata) {
        if (message.type === protocol_definitions_1.MessageType.Operation) {
            this.kernel.tryProcessMessage(message.contents, local, localOpMetadata);
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.rollback}
     * @internal
    */
    rollback(content, localOpMetadata) {
        this.kernel.rollback(content, localOpMetadata);
    }
}
exports.SharedMap = SharedMap;

},{"./mapKernel":141,"./packageVersion":142,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-utils":213,"@fluidframework/shared-object-base":261}],141:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapKernel = void 0;
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const common_utils_1 = require("@fluidframework/common-utils");
const localValues_1 = require("./localValues");
function isMapKeyLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "add" || metadata.type === "edit");
}
function isClearLocalOpMetadata(metadata) {
    return metadata !== undefined && metadata.type === "clear" && typeof metadata.pendingMessageId === "number";
}
function isMapLocalOpMetadata(metadata) {
    return metadata !== undefined && typeof metadata.pendingMessageId === "number" &&
        (metadata.type === "add" || metadata.type === "edit" || metadata.type === "clear");
}
/**
 * A SharedMap is a map-like distributed data structure.
 */
class MapKernel {
    /**
     * Create a new shared map kernel.
     * @param serializer - The serializer to serialize / parse handles
     * @param handle - The handle of the shared object using the kernel
     * @param submitMessage - A callback to submit a message through the shared object
     * @param isAttached - To query whether the shared object should generate ops
     * @param valueTypes - The value types to register
     * @param eventEmitter - The object that will emit map events
     */
    constructor(serializer, handle, submitMessage, isAttached, eventEmitter) {
        this.serializer = serializer;
        this.handle = handle;
        this.submitMessage = submitMessage;
        this.isAttached = isAttached;
        this.eventEmitter = eventEmitter;
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        /**
         * The in-memory data the map is storing.
         */
        this.data = new Map();
        /**
         * Keys that have been modified locally but not yet ack'd from the server.
         */
        this.pendingKeys = new Map();
        /**
         * This is used to assign a unique id to every outgoing operation and helps in tracking unack'd ops.
         */
        this.pendingMessageId = -1;
        /**
         * The pending ids of any clears that have been performed locally but not yet ack'd from the server
         */
        this.pendingClearMessageIds = [];
        this.localValueMaker = new localValues_1.LocalValueMaker(serializer);
        this.messageHandlers = this.getMessageHandlers();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.data.size;
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.data.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this.data.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: [nextVal.value[0], nextVal.value[1].value], done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this.data.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                if (nextVal.done) {
                    return { value: undefined, done: true };
                }
                else {
                    // Unpack the stored value
                    return { value: nextVal.value.value, done: false };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.data.forEach((localValue, key, m) => {
            callbackFn(localValue.value, key, m);
        });
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        const localValue = this.data.get(key);
        return localValue === undefined ? undefined : localValue.value;
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.data.has(key);
    }
    /**
     * {@inheritDoc ISharedMap.set}
     */
    set(key, value) {
        // Undefined/null keys can't be serialized to JSON in the manner we currently snapshot.
        if (key === undefined || key === null) {
            throw new Error("Undefined and null keys are not supported");
        }
        // Create a local value and serialize it.
        const localValue = this.localValueMaker.fromInMemory(value);
        const serializableValue = (0, localValues_1.makeSerializable)(localValue, this.serializer, this.handle);
        // Set the value locally.
        const previousValue = this.setCore(key, localValue, true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            key,
            type: "set",
            value: serializableValue,
        };
        this.submitMapKeyMessage(op, previousValue);
    }
    /**
     * Delete a key from the map.
     * @param key - Key to delete
     * @returns True if the key existed and was deleted, false if it did not exist
     */
    delete(key) {
        // Delete the key locally first.
        const previousValue = this.deleteCore(key, true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return previousValue !== undefined;
        }
        const op = {
            key,
            type: "delete",
        };
        this.submitMapKeyMessage(op, previousValue);
        return previousValue !== undefined;
    }
    /**
     * Clear all data from the map.
     */
    clear() {
        const copy = this.isAttached() ? new Map(this.data) : undefined;
        // Clear the data locally first.
        this.clearCore(true);
        // If we are not attached, don't submit the op.
        if (!this.isAttached()) {
            return;
        }
        const op = {
            type: "clear",
        };
        this.submitMapClearMessage(op, copy);
    }
    /**
     * Serializes the data stored in the shared map to a JSON string
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns A JSON string containing serialized map data
     */
    getSerializedStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);
        });
        return serializableMapData;
    }
    getSerializableStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = (0, localValues_1.makeSerializable)(localValue, serializer, this.handle);
        });
        return serializableMapData;
    }
    serialize(serializer) {
        return JSON.stringify(this.getSerializableStorage(serializer));
    }
    /**
     * Populate the kernel with the given map data.
     * @param data - A JSON string containing serialized map data
     */
    populateFromSerializable(json) {
        for (const [key, serializable] of Object.entries(json)) {
            const localValue = {
                key,
                value: this.makeLocal(key, serializable),
            };
            this.data.set(localValue.key, localValue.value);
        }
    }
    populate(json) {
        this.populateFromSerializable(JSON.parse(json));
    }
    /**
     * Submit the given op if a handler is registered.
     * @param op - The operation to attempt to submit
     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     * @returns True if the operation was submitted, false otherwise.
     */
    trySubmitMessage(op, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            return false;
        }
        handler.submit(op, localOpMetadata);
        return true;
    }
    tryGetStashedOpLocalMetadata(op) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            throw new Error("no apply stashed op handler");
        }
        return handler.getStashedOpLocalMetadata(op);
    }
    /**
     * Process the given op if a handler is registered.
     * @param op - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation was processed, false otherwise.
     */
    tryProcessMessage(op, local, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler === undefined) {
            return false;
        }
        handler.process(op, local, localOpMetadata);
        return true;
    }
    /**
     * Rollback a local op
     * @param op - The operation to rollback
     * @param localOpMetadata - The local metadata associated with the op.
     */
    rollback(op, localOpMetadata) {
        if (!isMapLocalOpMetadata(localOpMetadata)) {
            throw new Error("Invalid localOpMetadata");
        }
        if (op.type === "clear" && localOpMetadata.type === "clear") {
            if (localOpMetadata.previousMap === undefined) {
                throw new Error("Cannot rollback without previous map");
            }
            localOpMetadata.previousMap.forEach((localValue, key) => {
                this.setCore(key, localValue, true);
            });
            const lastPendingClearId = this.pendingClearMessageIds.pop();
            if (lastPendingClearId === undefined || lastPendingClearId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does match last clear");
            }
        }
        else if (op.type === "delete" || op.type === "set") {
            if (localOpMetadata.type === "add") {
                this.deleteCore(op.key, true);
            }
            else if (localOpMetadata.type === "edit" && localOpMetadata.previousValue !== undefined) {
                this.setCore(op.key, localOpMetadata.previousValue, true);
            }
            else {
                throw new Error("Cannot rollback without previous value");
            }
            const pendingMessageIds = this.pendingKeys.get(op.key);
            const lastPendingMessageId = pendingMessageIds === null || pendingMessageIds === void 0 ? void 0 : pendingMessageIds.pop();
            if (!pendingMessageIds || lastPendingMessageId !== localOpMetadata.pendingMessageId) {
                throw new Error("Rollback op does not match last pending");
            }
            if (pendingMessageIds.length === 0) {
                this.pendingKeys.delete(op.key);
            }
        }
        else {
            throw new Error("Unsupported op for rollback");
        }
    }
    /**
     * Set implementation used for both locally sourced sets as well as incoming remote sets.
     * @param key - The key being set
     * @param value - The value being set
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key, if any
     */
    setCore(key, value, local) {
        const previousLocalValue = this.data.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        this.data.set(key, value);
        this.eventEmitter.emit("valueChanged", { key, previousValue }, local, this.eventEmitter);
        return previousLocalValue;
    }
    /**
     * Clear implementation used for both locally sourced clears as well as incoming remote clears.
     * @param local - Whether the message originated from the local client
     */
    clearCore(local) {
        this.data.clear();
        this.eventEmitter.emit("clear", local, this.eventEmitter);
    }
    /**
     * Delete implementation used for both locally sourced deletes as well as incoming remote deletes.
     * @param key - The key being deleted
     * @param local - Whether the message originated from the local client
     * @returns Previous local value of the key if it existed, undefined if it did not exist
     */
    deleteCore(key, local) {
        const previousLocalValue = this.data.get(key);
        const previousValue = previousLocalValue === null || previousLocalValue === void 0 ? void 0 : previousLocalValue.value;
        const successfullyRemoved = this.data.delete(key);
        if (successfullyRemoved) {
            this.eventEmitter.emit("valueChanged", { key, previousValue }, local, this.eventEmitter);
        }
        return previousLocalValue;
    }
    /**
     * Clear all keys in memory in response to a remote clear, but retain keys we have modified but not yet been ack'd.
     */
    clearExceptPendingKeys() {
        // Assuming the pendingKeys is small and the map is large
        // we will get the value for the pendingKeys and clear the map
        const temp = new Map();
        this.pendingKeys.forEach((value, key) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            temp.set(key, this.data.get(key));
        });
        this.clearCore(false);
        temp.forEach((value, key) => {
            this.setCore(key, value, true);
        });
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will
     * have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's
     * job is to convert that information into a real object for local usage.
     * @param key - The key that the caller intends to store the local value into (used for ops later).  But
     * doesn't actually store the local value into that key.  So better not lie!
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, serializable) {
        if (serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain] || serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Shared]) {
            return this.localValueMaker.fromSerializable(serializable);
        }
        else {
            throw new Error("Unknown local value type");
        }
    }
    /**
     * If our local operations that have not yet been ack'd will eventually overwrite an incoming operation, we should
     * not process the incoming operation.
     * @param op - Operation to check
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation should be processed, false otherwise
     */
    needProcessKeyOperation(op, local, localOpMetadata) {
        if (this.pendingClearMessageIds.length > 0) {
            if (local) {
                (0, common_utils_1.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata) &&
                    localOpMetadata.pendingMessageId < this.pendingClearMessageIds[0], 0x013 /* "Received out of order op when there is an unackd clear message" */);
            }
            // If we have an unack'd clear, we can ignore all ops.
            return false;
        }
        const pendingKeyMessageId = this.pendingKeys.get(op.key);
        if (pendingKeyMessageId !== undefined) {
            // Found an unack'd op. Clear it from the map if the pendingMessageId in the map matches this message's
            // and don't process the op.
            if (local) {
                (0, common_utils_1.assert)(localOpMetadata !== undefined && isMapKeyLocalOpMetadata(localOpMetadata), 0x014 /* pendingMessageId is missing from the local client's operation */);
                const pendingMessageIds = this.pendingKeys.get(op.key);
                (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2fa /* Unexpected pending message received */);
                pendingMessageIds.shift();
                if (pendingMessageIds.length === 0) {
                    this.pendingKeys.delete(op.key);
                }
            }
            return false;
        }
        // If we don't have a NACK op on the key, we need to process the remote ops.
        return !local;
    }
    /**
     * Get the message handlers for the map.
     * @returns A map of string op names to IMapMessageHandlers for those ops
     */
    getMessageHandlers() {
        const messageHandlers = new Map();
        messageHandlers.set("clear", {
            process: (op, local, localOpMetadata) => {
                if (local) {
                    (0, common_utils_1.assert)(isClearLocalOpMetadata(localOpMetadata), 0x015 /* "pendingMessageId is missing from the local client's clear operation" */);
                    const pendingClearMessageId = this.pendingClearMessageIds.shift();
                    (0, common_utils_1.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fb /* pendingMessageId does not match */);
                    return;
                }
                if (this.pendingKeys.size !== 0) {
                    this.clearExceptPendingKeys();
                    return;
                }
                this.clearCore(local);
            },
            submit: (op, localOpMetadata) => {
                (0, common_utils_1.assert)(isClearLocalOpMetadata(localOpMetadata), 0x2fc /* Invalid localOpMetadata for clear */);
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                const pendingClearMessageId = this.pendingClearMessageIds.shift();
                (0, common_utils_1.assert)(pendingClearMessageId === localOpMetadata.pendingMessageId, 0x2fd /* pendingMessageId does not match */);
                this.submitMapClearMessage(op, localOpMetadata.previousMap);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "clear", pendingMessageId: this.getMapClearMessageId() };
            },
        });
        messageHandlers.set("delete", {
            process: (op, local, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                this.deleteCore(op.key, local);
            },
            submit: (op, localOpMetadata) => {
                this.resubmitMapKeyMessage(op, localOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "edit", pendingMessageId: this.getMapKeyMessageId(op) };
            },
        });
        messageHandlers.set("set", {
            process: (op, local, localOpMetadata) => {
                if (!this.needProcessKeyOperation(op, local, localOpMetadata)) {
                    return;
                }
                // needProcessKeyOperation should have returned false if local is true
                const context = this.makeLocal(op.key, op.value);
                this.setCore(op.key, context, local);
            },
            submit: (op, localOpMetadata) => {
                this.resubmitMapKeyMessage(op, localOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                // We don't reuse the metadata pendingMessageId but send a new one on each submit.
                return { type: "edit", pendingMessageId: this.getMapKeyMessageId(op) };
            },
        });
        return messageHandlers;
    }
    getMapClearMessageId() {
        const pendingMessageId = ++this.pendingMessageId;
        this.pendingClearMessageIds.push(pendingMessageId);
        return pendingMessageId;
    }
    /**
     * Submit a clear message to remote clients.
     * @param op - The clear message
     */
    submitMapClearMessage(op, previousMap) {
        const metadata = { type: "clear", pendingMessageId: this.getMapClearMessageId(), previousMap };
        this.submitMessage(op, metadata);
    }
    getMapKeyMessageId(op) {
        const pendingMessageId = ++this.pendingMessageId;
        const pendingMessageIds = this.pendingKeys.get(op.key);
        if (pendingMessageIds !== undefined) {
            pendingMessageIds.push(pendingMessageId);
        }
        else {
            this.pendingKeys.set(op.key, [pendingMessageId]);
        }
        return pendingMessageId;
    }
    /**
     * Submit a map key message to remote clients.
     * @param op - The map key message
     * @param previousValue - The value of the key before this op
     */
    submitMapKeyMessage(op, previousValue) {
        const pendingMessageId = this.getMapKeyMessageId(op);
        const localMetadata = previousValue ?
            { type: "edit", pendingMessageId, previousValue } :
            { type: "add", pendingMessageId };
        this.submitMessage(op, localMetadata);
    }
    /**
     * Submit a map key message to remote clients based on a previous submit.
     * @param op - The map key message
     * @param localOpMetadata - Metadata from the previous submit
     */
    resubmitMapKeyMessage(op, localOpMetadata) {
        (0, common_utils_1.assert)(isMapKeyLocalOpMetadata(localOpMetadata), 0x2fe /* Invalid localOpMetadata in submit */);
        // clear the old pending message id
        const pendingMessageIds = this.pendingKeys.get(op.key);
        (0, common_utils_1.assert)(pendingMessageIds !== undefined && pendingMessageIds[0] === localOpMetadata.pendingMessageId, 0x2ff /* Unexpected pending message received */);
        pendingMessageIds.shift();
        if (pendingMessageIds.length === 0) {
            this.pendingKeys.delete(op.key);
        }
        // We don't reuse the metadata pendingMessageId but send a new one on each submit.
        const pendingMessageId = this.getMapKeyMessageId(op);
        const localMetadata = localOpMetadata.type === "edit" ?
            { type: "edit", pendingMessageId, previousValue: localOpMetadata.previousValue } :
            { type: "add", pendingMessageId };
        this.submitMessage(op, localMetadata);
    }
}
exports.MapKernel = MapKernel;

},{"./localValues":139,"@fluidframework/common-utils":29,"@fluidframework/shared-object-base":261}],142:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/map";
exports.pkgVersion = "1.3.6";

},{}],143:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],144:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const collections_1 = require("./collections");
const constants_1 = require("./constants");
const localReference_1 = require("./localReference");
const mergeTree_1 = require("./mergeTree");
const opBuilder_1 = require("./opBuilder");
const ops_1 = require("./ops");
const snapshotlegacy_1 = require("./snapshotlegacy");
const snapshotLoader_1 = require("./snapshotLoader");
const textSegment_1 = require("./textSegment");
const snapshotV1_1 = require("./snapshotV1");
function elapsedMicroseconds(trace) {
    return trace.trace().duration * 1000;
}
class Client {
    constructor(
    // Passing this callback would be unnecessary if Client were merged with SharedSegmentSequence
    specToSegment, logger, options) {
        this.specToSegment = specToSegment;
        this.logger = logger;
        this.measureOps = false;
        this.accumTime = 0;
        this.localTime = 0;
        this.localOps = 0;
        this.accumWindowTime = 0;
        this.accumWindow = 0;
        this.accumOps = 0;
        this.maxWindowTime = 0;
        this.clientNameToIds = new collections_1.RedBlackTree(mergeTree_1.compareStrings);
        this.shortClientIdMap = [];
        this.pendingConsensus = new Map();
        this.mergeTree = new mergeTree_1.MergeTree(options);
    }
    get mergeTreeDeltaCallback() { return this.mergeTree.mergeTreeDeltaCallback; }
    set mergeTreeDeltaCallback(callback) {
        this.mergeTree.mergeTreeDeltaCallback = callback;
    }
    get mergeTreeMaintenanceCallback() {
        return this.mergeTree.mergeTreeMaintenanceCallback;
    }
    set mergeTreeMaintenanceCallback(callback) {
        this.mergeTree.mergeTreeMaintenanceCallback = callback;
    }
    /**
     * The merge tree maintains a queue of segment groups for each local operation.
     * These segment groups track segments modified by an operation.
     * This method peeks the tail of that queue, and returns the segments groups there.
     * It is used to get the segment group(s) for the previous operations.
     * @param count - The number segment groups to get peek from the tail of the queue. Default 1.
     */
    peekPendingSegmentGroups(count = 1) {
        var _a, _b;
        if (count === 1) {
            return (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.last();
        }
        let taken = 0;
        return (_b = this.mergeTree.pendingSegments) === null || _b === void 0 ? void 0 : _b.some(() => {
            if (taken < count) {
                taken++;
                return true;
            }
            return false;
        }, true);
    }
    /**
     * Annotate a marker and call the callback on consensus.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarkerNotifyConsensus(marker, props, consensusCallback) {
        const combiningOp = {
            name: "consensus",
        };
        const annotateOp = this.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            const consensusInfo = {
                callback: consensusCallback,
                marker,
            };
            this.pendingConsensus.set(marker.getId(), consensusInfo);
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the markers with the provided properties
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = (0, opBuilder_1.createAnnotateMarkerOp)(marker, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        else {
            return undefined;
        }
    }
    /**
     * Annotates the range with the provided properties
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Specifies how to combine values for the property, such as "incr" for increment.
     * @returns The annotate op if valid, otherwise undefined
     */
    annotateRangeLocal(start, end, props, combiningOp) {
        const annotateOp = (0, opBuilder_1.createAnnotateRangeOp)(start, end, props, combiningOp);
        if (this.applyAnnotateRangeOp({ op: annotateOp })) {
            return annotateOp;
        }
        return undefined;
    }
    /**
     * Removes the range
     *
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    removeRangeLocal(start, end) {
        const removeOp = (0, opBuilder_1.createRemoveRangeOp)(start, end);
        if (this.applyRemoveRangeOp({ op: removeOp })) {
            return removeOp;
        }
        return undefined;
    }
    /**
     * @param pos - The position to insert the segment at
     * @param segment - The segment to insert
     */
    insertSegmentLocal(pos, segment) {
        if (segment.cachedLength <= 0) {
            return undefined;
        }
        const insertOp = (0, opBuilder_1.createInsertSegmentOp)(pos, segment);
        if (this.applyInsertOp({ op: insertOp })) {
            return insertOp;
        }
        return undefined;
    }
    /**
     * @param refPos - The reference position to insert the segment at
     * @param segment - The segment to insert
     */
    insertAtReferencePositionLocal(refPos, segment) {
        const pos = this.mergeTree.referencePositionToLocalPosition(refPos, this.getCurrentSeq(), this.getClientId());
        if (pos === localReference_1.LocalReference.DetachedPosition) {
            return undefined;
        }
        const op = (0, opBuilder_1.createInsertSegmentOp)(pos, segment);
        const opArgs = { op };
        let traceStart;
        if (this.measureOps) {
            traceStart = common_utils_1.Trace.start();
        }
        this.mergeTree.insertAtReferencePosition(refPos, segment, opArgs);
        this.completeAndLogOp(opArgs, this.getClientSequenceArgs(opArgs), { start: op.pos1 }, traceStart);
        return op;
    }
    walkSegments(handler, start, end, accum, splitRange = false) {
        this.mergeTree.mapRange({
            leaf: handler,
        }, this.getCurrentSeq(), this.getClientId(), accum, start, end, splitRange);
    }
    /**
     * Serializes the data required for garbage collection. The IFluidHandles stored in all segments that haven't
     * been removed represent routes to other objects. We serialize the data in these segments using the passed in
     * serializer which keeps track of all serialized handles.
     */
    serializeGCData(handle, handleCollectingSerializer) {
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            // Only serialize segments that have not been removed.
            if (seg.removedSeq === undefined) {
                handleCollectingSerializer.stringify(seg.clone().toJSONObject(), handle);
            }
            return true;
        });
    }
    getCollabWindow() {
        return this.mergeTree.getCollabWindow();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this merge tree
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        if ((segment === null || segment === void 0 ? void 0 : segment.parent) === undefined) {
            return -1;
        }
        return this.mergeTree.getPosition(segment, this.getCurrentSeq(), this.getClientId());
    }
    /**
     * @deprecated - use createReferencePosition instead
     */
    addLocalReference(lref) {
        return this.mergeTree.addLocalReference(lref);
    }
    /**
     * @deprecated - use removeReferencePosition instead
     */
    removeLocalReference(lref) {
        return this.removeLocalReferencePosition(lref);
    }
    createLocalReferencePosition(segment, offset, refType, properties) {
        return this.mergeTree.createLocalReferencePosition(segment, offset, refType, properties, this);
    }
    removeLocalReferencePosition(lref) {
        return this.mergeTree.removeLocalReferencePosition(lref);
    }
    localReferencePositionToPosition(lref) {
        return this.mergeTree.referencePositionToLocalPosition(lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.mergeTree.posFromRelativePos(relativePos);
    }
    getMarkerFromId(id) {
        return this.mergeTree.getMarkerFromId(id);
    }
    /**
     * Performs the remove based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the remove was applied. False if it could not be.
     */
    applyRemoveRangeOp(opArgs) {
        (0, common_utils_1.assert)(opArgs.op.type === ops_1.MergeTreeDeltaType.REMOVE, 0x02d /* "Unexpected op type on range remove!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = common_utils_1.Trace.start();
        }
        this.mergeTree.markRangeRemoved(range.start, range.end, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, false, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the annotate based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the annotate was applied. False if it could not be.
     */
    applyAnnotateRangeOp(opArgs) {
        (0, common_utils_1.assert)(opArgs.op.type === ops_1.MergeTreeDeltaType.ANNOTATE, 0x02e /* "Unexpected op type on range annotate!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = common_utils_1.Trace.start();
        }
        this.mergeTree.annotateRange(range.start, range.end, op.props, op.combiningOp, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     * Performs the insert based on the provided op
     * @param opArgs - The ops args for the op
     * @returns True if the insert was applied. False if it could not be.
     */
    applyInsertOp(opArgs) {
        (0, common_utils_1.assert)(opArgs.op.type === ops_1.MergeTreeDeltaType.INSERT, 0x02f /* "Unexpected op type on range insert!" */);
        const op = opArgs.op;
        const clientArgs = this.getClientSequenceArgs(opArgs);
        const range = this.getValidOpRange(op, clientArgs);
        if (!range) {
            return false;
        }
        let segments;
        if (op.seg) {
            segments = [this.specToSegment(op.seg)];
        }
        if (!segments || segments.length === 0) {
            return false;
        }
        let traceStart;
        if (this.measureOps) {
            traceStart = common_utils_1.Trace.start();
        }
        this.mergeTree.insertSegments(range.start, segments, clientArgs.referenceSequenceNumber, clientArgs.clientId, clientArgs.sequenceNumber, opArgs);
        this.completeAndLogOp(opArgs, clientArgs, range, traceStart);
        return true;
    }
    /**
     *
     * @param opArgs - The op args of the op to complete
     * @param clientArgs - The client args for the op
     * @param range - The range the op applied to
     * @param clockStart - Optional. The clock start if timing data should be updated.
     */
    completeAndLogOp(opArgs, clientArgs, range, traceStart) {
        if (!opArgs.sequencedMessage) {
            if (traceStart) {
                this.localTime += elapsedMicroseconds(traceStart);
                this.localOps++;
            }
        }
        else {
            (0, common_utils_1.assert)(this.mergeTree.getCollabWindow().currentSeq < clientArgs.sequenceNumber, 0x030 /* "Incoming remote op sequence# <= local collabWindow's currentSequence#" */);
            (0, common_utils_1.assert)(this.mergeTree.getCollabWindow().minSeq <= opArgs.sequencedMessage.minimumSequenceNumber, 0x031 /* "Incoming remote op minSequence# < local collabWindow's minSequence#" */);
            if (traceStart) {
                this.accumTime += elapsedMicroseconds(traceStart);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
        }
    }
    /**
     * Returns a valid range for the op, or undefined
     * @param op - The op to generate the range for
     * @param clientArgs - The client args for the op
     */
    getValidOpRange(op, clientArgs) {
        let start = op.pos1;
        if (start === undefined && op.relativePos1) {
            start = this.mergeTree.posFromRelativePos(op.relativePos1, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        let end = op.pos2;
        if (end === undefined && op.relativePos2) {
            end = this.mergeTree.posFromRelativePos(op.relativePos2, clientArgs.referenceSequenceNumber, clientArgs.clientId);
        }
        // Validate if local op
        if (clientArgs.clientId === this.getClientId()) {
            const length = this.getLength();
            const invalidPositions = [];
            // Validate start position
            //
            if (start === undefined
                || start < 0
                || start > length
                || start === length && op.type !== ops_1.MergeTreeDeltaType.INSERT) {
                invalidPositions.push("start");
            }
            // Validate end if not insert, or insert has end
            //
            if (op.type !== ops_1.MergeTreeDeltaType.INSERT || end !== undefined) {
                if (end === undefined || end <= start) {
                    invalidPositions.push("end");
                }
            }
            if (invalidPositions.length > 0) {
                throw new telemetry_utils_1.LoggingError("RangeOutOfBounds", {
                    usageError: true,
                    end,
                    invalidPositions: invalidPositions.toString(),
                    length,
                    opPos1: op.pos1,
                    opPos1Relative: op.relativePos1 !== undefined,
                    opPos2: op.pos2,
                    opPos2Relative: op.relativePos2 !== undefined,
                    opType: op.type,
                    start,
                });
            }
        }
        // start and end are guaranteed to be non-null here, otherwise we throw above.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
        return { start, end };
    }
    /**
     * Gets the client args from the op if remote, otherwise uses the local clients info
     * @param sequencedMessage - The sequencedMessage to get the client sequence args for
     */
    getClientSequenceArgsForMessage(sequencedMessage) {
        // If there this no sequenced message, then the op is local
        // and unacked, so use this clients sequenced args
        //
        if (!sequencedMessage) {
            const segWindow = this.getCollabWindow();
            return {
                clientId: segWindow.clientId,
                referenceSequenceNumber: segWindow.currentSeq,
                sequenceNumber: this.getLocalSequenceNumber(),
            };
        }
        else {
            return {
                clientId: this.getOrAddShortClientId(sequencedMessage.clientId),
                referenceSequenceNumber: sequencedMessage.referenceSequenceNumber,
                sequenceNumber: sequencedMessage.sequenceNumber,
            };
        }
    }
    /**
     * Gets the client args from the op if remote, otherwise uses the local clients info
     * @param opArgs - The op arg to get the client sequence args for
     */
    getClientSequenceArgs(opArgs) {
        return this.getClientSequenceArgsForMessage(opArgs.sequencedMessage);
    }
    ackPendingSegment(opArgs) {
        const ackOp = (deltaOpArgs) => {
            let trace;
            if (this.measureOps) {
                trace = common_utils_1.Trace.start();
            }
            this.mergeTree.ackPendingSegment(deltaOpArgs);
            if (deltaOpArgs.op.type === ops_1.MergeTreeDeltaType.ANNOTATE) {
                if (deltaOpArgs.op.combiningOp && (deltaOpArgs.op.combiningOp.name === "consensus")) {
                    this.updateConsensusProperty(deltaOpArgs.op, deltaOpArgs.sequencedMessage);
                }
            }
            if (trace) {
                this.accumTime += elapsedMicroseconds(trace);
                this.accumOps++;
                this.accumWindow += (this.getCurrentSeq() - this.getCollabWindow().minSeq);
            }
        };
        if (opArgs.op.type === ops_1.MergeTreeDeltaType.GROUP) {
            for (const memberOp of opArgs.op.ops) {
                ackOp({
                    groupOp: opArgs.op,
                    op: memberOp,
                    sequencedMessage: opArgs.sequencedMessage,
                });
            }
        }
        else {
            ackOp(opArgs);
        }
    }
    // as functions are modified move them above the eslint-disabled waterline and lint them
    cloneFromSegments() {
        const clone = new Client(this.specToSegment, this.logger, this.mergeTree.options);
        const segments = [];
        const newRoot = this.mergeTree.blockClone(this.mergeTree.root, segments);
        clone.mergeTree.root = newRoot;
        return clone;
    }
    getOrAddShortClientId(longClientId) {
        if (!this.clientNameToIds.get(longClientId)) {
            this.addLongClientId(longClientId);
        }
        return this.getShortClientId(longClientId);
    }
    getShortClientId(longClientId) {
        return this.clientNameToIds.get(longClientId).data;
    }
    getLongClientId(shortClientId) {
        if (shortClientId >= 0) {
            return this.shortClientIdMap[shortClientId];
        }
        else {
            return "original";
        }
    }
    addLongClientId(longClientId) {
        this.clientNameToIds.put(longClientId, this.shortClientIdMap.length);
        this.shortClientIdMap.push(longClientId);
    }
    /**
     * During reconnect, we must find the positions to pending segments
     * relative to other pending segments. This methods computes that
     * position relative to a localSeq. Pending segments above the localSeq
     * will be ignored.
     *
     * @param segment - The segment to find the position for
     * @param localSeq - The localSeq to find the position of the segment at
     */
    findReconnectionPosition(segment, localSeq) {
        (0, common_utils_1.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x032 /* "localSeq greater than collab window" */);
        let segmentPosition = 0;
        /*
            Walk the segments up to the current segment, and calculate it's
            position taking into account local segments that were modified,
            after the current segment.

            TODO: Consider embedding this information into the tree for
            more efficient look up of pending segment positions.
        */
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            // If we've found the desired segment, terminate the walk and return 'segmentPosition'.
            if (seg === segment) {
                return false;
            }
            // Otherwise, advance segmentPosition if the segment has been inserted and not removed
            // with respect to the given 'localSeq'.
            //
            // Note that all ACKed / remote ops are applied and we only need concern ourself with
            // determining if locally pending ops fall before/after the given 'localSeq'.
            if ((seg.localSeq === undefined || seg.localSeq <= localSeq) // Is inserted
                && (seg.removedSeq === undefined || seg.localRemovedSeq > localSeq) // Not removed
            ) {
                segmentPosition += seg.cachedLength;
            }
            return true;
        });
        return segmentPosition;
    }
    /**
     * Rebases a (local) position from the perspective `{ seq: seqNumberFrom, localSeq }` to the perspective
     * of the current sequence number. This is desirable when rebasing operations for reconnection.
     *
     * If the position refers to a segment/offset that was removed by some operation between `seqNumberFrom` and
     * the current sequence number, the returned position will align with the position of a reference given
     * `SlideOnRemove` semantics.
     */
    rebasePosition(pos, seqNumberFrom, localSeq) {
        (0, common_utils_1.assert)(localSeq <= this.mergeTree.collabWindow.localSeq, 0x300 /* localSeq greater than collab window */);
        let segment;
        let posAccumulated = 0;
        let offset = pos;
        const isInsertedInView = (seg) => (seg.seq !== undefined && seg.seq !== constants_1.UnassignedSequenceNumber && seg.seq <= seqNumberFrom)
            || (seg.localSeq !== undefined && seg.localSeq <= localSeq);
        const isRemovedFromView = ({ removedSeq, localRemovedSeq }) => (removedSeq !== undefined && removedSeq !== constants_1.UnassignedSequenceNumber && removedSeq <= seqNumberFrom)
            || (localRemovedSeq !== undefined && localRemovedSeq <= localSeq);
        this.mergeTree.walkAllSegments(this.mergeTree.root, (seg) => {
            (0, common_utils_1.assert)(seg.seq !== undefined || seg.localSeq !== undefined, 0x301 /* Either seq or localSeq should be defined */);
            segment = seg;
            if (isInsertedInView(seg) && !isRemovedFromView(seg)) {
                posAccumulated += seg.cachedLength;
                if (offset >= seg.cachedLength) {
                    offset -= seg.cachedLength;
                }
            }
            // Keep going while we've yet to reach the segment at the desired position
            return posAccumulated <= pos;
        });
        (0, common_utils_1.assert)(segment !== undefined, 0x302 /* No segment found */);
        const seqNumberTo = this.getCollabWindow().currentSeq;
        if ((segment.removedSeq !== undefined &&
            segment.removedSeq !== constants_1.UnassignedSequenceNumber &&
            segment.removedSeq <= seqNumberTo)
            || (segment.localRemovedSeq !== undefined && segment.localRemovedSeq <= localSeq)) {
            // Segment that the position was in has been removed: null out offset.
            offset = 0;
        }
        (0, common_utils_1.assert)(0 <= offset && offset < segment.cachedLength, 0x303 /* Invalid offset */);
        return this.findReconnectionPosition(segment, localSeq) + offset;
    }
    resetPendingDeltaToOps(resetOp, segmentGroup) {
        var _a, _b;
        (0, common_utils_1.assert)(!!segmentGroup, 0x033 /* "Segment group undefined" */);
        const NACKedSegmentGroup = (_a = this.mergeTree.pendingSegments) === null || _a === void 0 ? void 0 : _a.dequeue();
        (0, common_utils_1.assert)(segmentGroup === NACKedSegmentGroup, 0x034 /* "Segment group not at head of merge tree pending queue" */);
        const opList = [];
        // We need to sort the segments by ordinal, as the segments are not sorted in the segment group.
        // The reason they need them sorted, as they have the same local sequence number and which means
        // farther segments will  take into account nearer segments when calculating their position.
        // By sorting we ensure the nearer segment will be applied and sequenced before the father segments
        // so their recalculated positions will be correct.
        for (const segment of segmentGroup.segments.sort((a, b) => a.ordinal < b.ordinal ? -1 : 1)) {
            const segmentSegGroup = segment.segmentGroups.dequeue();
            (0, common_utils_1.assert)(segmentGroup === segmentSegGroup, 0x035 /* "Segment group not at head of segment pending queue" */);
            const segmentPosition = this.findReconnectionPosition(segment, segmentGroup.localSeq);
            let newOp;
            switch (resetOp.type) {
                case ops_1.MergeTreeDeltaType.ANNOTATE:
                    (0, common_utils_1.assert)(((_b = segment.propertyManager) === null || _b === void 0 ? void 0 : _b.hasPendingProperties()) === true, 0x036 /* "Segment has no pending properties" */);
                    // if the segment has been removed, there's no need to send the annotate op
                    // unless the remove was local, in which case the annotate must have come
                    // before the remove
                    if (segment.removedSeq === undefined || segment.localRemovedSeq !== undefined) {
                        newOp = (0, opBuilder_1.createAnnotateRangeOp)(segmentPosition, segmentPosition + segment.cachedLength, resetOp.props, resetOp.combiningOp);
                    }
                    break;
                case ops_1.MergeTreeDeltaType.INSERT:
                    (0, common_utils_1.assert)(segment.seq === constants_1.UnassignedSequenceNumber, 0x037 /* "Segment already has assigned sequence number" */);
                    let segInsertOp = segment;
                    if (typeof resetOp.seg === "object" && resetOp.seg.props !== undefined) {
                        segInsertOp = segment.clone();
                        segInsertOp.properties = resetOp.seg.props;
                    }
                    newOp = (0, opBuilder_1.createInsertSegmentOp)(segmentPosition, segInsertOp);
                    break;
                case ops_1.MergeTreeDeltaType.REMOVE:
                    if (segment.localRemovedSeq !== undefined) {
                        newOp = (0, opBuilder_1.createRemoveRangeOp)(segmentPosition, segmentPosition + segment.cachedLength);
                    }
                    break;
                default:
                    throw new Error(`Invalid op type`);
            }
            if (newOp) {
                const newSegmentGroup = { segments: [], localSeq: segmentGroup.localSeq };
                segment.segmentGroups.enqueue(newSegmentGroup);
                this.mergeTree.pendingSegments.enqueue(newSegmentGroup);
                opList.push(newOp);
            }
        }
        return opList;
    }
    applyRemoteOp(opArgs) {
        const op = opArgs.op;
        const msg = opArgs.sequencedMessage;
        this.getOrAddShortClientId(msg.clientId);
        switch (op.type) {
            case ops_1.MergeTreeDeltaType.INSERT:
                this.applyInsertOp(opArgs);
                break;
            case ops_1.MergeTreeDeltaType.REMOVE:
                this.applyRemoveRangeOp(opArgs);
                break;
            case ops_1.MergeTreeDeltaType.ANNOTATE:
                this.applyAnnotateRangeOp(opArgs);
                break;
            case ops_1.MergeTreeDeltaType.GROUP: {
                for (const memberOp of op.ops) {
                    this.applyRemoteOp({
                        op: memberOp,
                        groupOp: op,
                        sequencedMessage: msg,
                    });
                }
                break;
            }
            default:
                break;
        }
    }
    applyStashedOp(op) {
        let metadata;
        switch (op.type) {
            case ops_1.MergeTreeDeltaType.INSERT:
                this.applyInsertOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case ops_1.MergeTreeDeltaType.REMOVE:
                this.applyRemoveRangeOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case ops_1.MergeTreeDeltaType.ANNOTATE:
                this.applyAnnotateRangeOp({ op });
                metadata = this.peekPendingSegmentGroups();
                break;
            case ops_1.MergeTreeDeltaType.GROUP:
                return op.ops.map((o) => this.applyStashedOp(o));
            default:
                (0, common_utils_1.unreachableCase)(op, "unrecognized op type");
        }
        (0, common_utils_1.assert)(!!metadata, 0x2db /* "Applying op must generate a pending segment" */);
        return metadata;
    }
    applyMsg(msg, local = false) {
        var _a;
        // Ensure client ID is registered
        this.getOrAddShortClientId(msg.clientId);
        // Apply if an operation message
        if (msg.type === protocol_definitions_1.MessageType.Operation) {
            const opArgs = {
                op: msg.contents,
                sequencedMessage: msg,
            };
            if (((_a = opArgs.sequencedMessage) === null || _a === void 0 ? void 0 : _a.clientId) === this.longClientId || local) {
                this.ackPendingSegment(opArgs);
            }
            else {
                this.applyRemoteOp(opArgs);
            }
        }
        this.updateSeqNumbers(msg.minimumSequenceNumber, msg.sequenceNumber);
    }
    updateSeqNumbers(min, seq) {
        const collabWindow = this.mergeTree.getCollabWindow();
        // Equal is fine here due to SharedSegmentSequence<>.snapshotContent() potentially updating with same #
        (0, common_utils_1.assert)(collabWindow.currentSeq <= seq, 0x038 /* "Incoming op sequence# < local collabWindow's currentSequence#" */);
        collabWindow.currentSeq = seq;
        (0, common_utils_1.assert)(min <= seq, 0x039 /* "Incoming op sequence# < minSequence#" */);
        this.updateMinSeq(min);
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        const shortRemoteClientId = this.getOrAddShortClientId(remoteClientId);
        return this.mergeTree.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, shortRemoteClientId);
    }
    /**
     *  Given an pending operation and segment group, regenerate the op, so it
     *  can be resubmitted
     * @param resetOp - The op to reset
     * @param segmentGroup - The segment group associated with the op
     */
    regeneratePendingOp(resetOp, segmentGroup) {
        const opList = [];
        if (resetOp.type === ops_1.MergeTreeDeltaType.GROUP) {
            if (Array.isArray(segmentGroup)) {
                (0, common_utils_1.assert)(resetOp.ops.length === segmentGroup.length, 0x03a /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                for (let i = 0; i < resetOp.ops.length; i++) {
                    opList.push(...this.resetPendingDeltaToOps(resetOp.ops[i], segmentGroup[i]));
                }
            }
            else {
                // A group op containing a single op will pass a direct reference to 'segmentGroup'
                // rather than an array of segment groups.  (See 'peekPendingSegmentGroups()')
                (0, common_utils_1.assert)(resetOp.ops.length === 1, 0x03b /* "Number of ops in 'resetOp' must match the number of segment groups provided." */);
                opList.push(...this.resetPendingDeltaToOps(resetOp.ops[0], segmentGroup));
            }
        }
        else {
            (0, common_utils_1.assert)(resetOp.type !== ops_1.MergeTreeDeltaType.GROUP, 0x03c /* "Reset op has 'group' delta type!" */);
            (0, common_utils_1.assert)(!Array.isArray(segmentGroup), 0x03d /* "segmentGroup is array rather than singleton!" */);
            opList.push(...this.resetPendingDeltaToOps(resetOp, segmentGroup));
        }
        return opList.length === 1 ? opList[0] : (0, opBuilder_1.createGroupOp)(...opList);
    }
    createTextHelper() {
        return new textSegment_1.MergeTreeTextHelper(this.mergeTree);
    }
    summarize(runtime, handle, serializer, catchUpMsgs) {
        var _a;
        const deltaManager = runtime.deltaManager;
        const minSeq = deltaManager.minimumSequenceNumber;
        // Catch up to latest MSN, if we have not had a chance to do it.
        // Required for case where FluidDataStoreRuntime.attachChannel()
        // generates summary right after loading data store.
        this.updateSeqNumbers(minSeq, deltaManager.lastSequenceNumber);
        // One of the summaries (from SPO) I observed to have chunk.chunkSequenceNumber > minSeq!
        // Not sure why - need to catch it sooner
        (0, common_utils_1.assert)(this.getCollabWindow().minSeq === minSeq, 0x03e /* "minSeq mismatch between collab window and delta manager!" */);
        // Must continue to support legacy
        //       (See https://github.com/microsoft/FluidFramework/issues/84)
        if (((_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) === true) {
            (0, common_utils_1.assert)(catchUpMsgs === undefined || catchUpMsgs.length === 0, 0x03f /* "New format should not emit catchup ops" */);
            const snap = new snapshotV1_1.SnapshotV1(this.mergeTree, this.logger, (id) => this.getLongClientId(id));
            snap.extractSync();
            return snap.emit(serializer, handle);
        }
        else {
            const snap = new snapshotlegacy_1.SnapshotLegacy(this.mergeTree, this.logger);
            snap.extractSync();
            return snap.emit(catchUpMsgs, serializer, handle);
        }
    }
    async load(runtime, storage, serializer) {
        const loader = new snapshotLoader_1.SnapshotLoader(runtime, this, this.mergeTree, this.logger, serializer);
        return loader.initialize(storage);
    }
    getStackContext(startPos, rangeLabels) {
        return this.mergeTree.getStackContext(startPos, this.getCollabWindow().clientId, rangeLabels);
    }
    getLocalSequenceNumber() {
        const segWindow = this.getCollabWindow();
        if (segWindow.collaborating) {
            return constants_1.UnassignedSequenceNumber;
        }
        else {
            return constants_1.UniversalSequenceNumber;
        }
    }
    localTransaction(groupOp) {
        for (const op of groupOp.ops) {
            const opArgs = {
                op,
                groupOp,
            };
            switch (op.type) {
                case ops_1.MergeTreeDeltaType.INSERT:
                    this.applyInsertOp(opArgs);
                    break;
                case ops_1.MergeTreeDeltaType.ANNOTATE:
                    this.applyAnnotateRangeOp(opArgs);
                    break;
                case ops_1.MergeTreeDeltaType.REMOVE:
                    this.applyRemoveRangeOp(opArgs);
                    break;
                default:
                    break;
            }
        }
    }
    updateConsensusProperty(op, msg) {
        const markerId = op.relativePos1.id;
        const consensusInfo = this.pendingConsensus.get(markerId);
        if (consensusInfo) {
            consensusInfo.marker.addProperties(op.props, op.combiningOp, msg.sequenceNumber);
        }
        this.mergeTree.addMinSeqListener(msg.sequenceNumber, () => consensusInfo.callback(consensusInfo.marker));
    }
    updateMinSeq(minSeq) {
        let trace;
        if (this.measureOps) {
            trace = common_utils_1.Trace.start();
        }
        this.mergeTree.setMinSeq(minSeq);
        if (trace) {
            const elapsed = elapsedMicroseconds(trace);
            this.accumWindowTime += elapsed;
            if (elapsed > this.maxWindowTime) {
                this.maxWindowTime = elapsed;
            }
        }
    }
    getContainingSegment(pos, op) {
        const args = this.getClientSequenceArgsForMessage(op);
        return this.mergeTree.getContainingSegment(pos, args.referenceSequenceNumber, args.clientId);
    }
    /**
     * Returns the position to slide a reference to if a slide is required.
     * @param segoff - The segment and offset to slide from
     * @returns - segment and offset to slide the reference to
     */
    getSlideToSegment(segoff) {
        return this.mergeTree._getSlideToSegment(segoff);
    }
    getPropertiesAtPosition(pos) {
        let propertiesAtPosition;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            propertiesAtPosition = seg.properties;
        }
        return propertiesAtPosition;
    }
    getRangeExtentsOfPosition(pos) {
        let posStart;
        let posAfterEnd;
        const segoff = this.getContainingSegment(pos);
        const seg = segoff.segment;
        if (seg) {
            posStart = this.getPosition(seg);
            posAfterEnd = posStart + seg.cachedLength;
        }
        return { posStart, posAfterEnd };
    }
    getCurrentSeq() {
        return this.getCollabWindow().currentSeq;
    }
    getClientId() {
        return this.getCollabWindow().clientId;
    }
    getLength() { return this.mergeTree.length; }
    startOrUpdateCollaboration(longClientId, minSeq = 0, currentSeq = 0) {
        // we should always have a client id if we are collaborating
        // if the client id is undefined we are likely bound to a detached
        // container, so we should keep going in local mode. once
        // the container attaches this will be called again on connect with the
        // client id
        if (longClientId !== undefined) {
            if (this.longClientId === undefined) {
                this.longClientId = longClientId;
                this.addLongClientId(this.longClientId);
                this.mergeTree.startCollaboration(this.getShortClientId(this.longClientId), minSeq, currentSeq);
            }
            else {
                const oldClientId = this.longClientId;
                const oldData = this.clientNameToIds.get(oldClientId).data;
                this.longClientId = longClientId;
                this.clientNameToIds.put(longClientId, oldData);
                this.shortClientIdMap[oldData] = longClientId;
            }
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        const clientId = this.getClientId();
        return this.mergeTree.findTile(startPos, clientId, tileLabel, preceding);
    }
}
exports.Client = Client;

},{"./collections":145,"./constants":146,"./localReference":148,"./mergeTree":149,"./opBuilder":152,"./ops":153,"./snapshotLoader":160,"./snapshotV1":161,"./snapshotlegacy":162,"./textSegment":164,"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279}],145:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TST = exports.IntervalTree = exports.integerRangeToString = exports.RedBlackTree = exports.RBColor = exports.Heap = exports.List = exports.ListMakeHead = exports.ListRemoveEntry = exports.Stack = void 0;
class Stack {
    constructor() {
        this.items = [];
    }
    push(val) {
        this.items.push(val);
    }
    empty() {
        return this.items.length === 0;
    }
    top() {
        return this.items[this.items.length - 1];
    }
    pop() {
        return this.items.pop();
    }
}
exports.Stack = Stack;
function ListRemoveEntry(entry) {
    if (entry === undefined) {
        return undefined;
    }
    else if (entry.isHead) {
        return undefined;
    }
    else {
        entry.next.prev = entry.prev;
        entry.prev.next = entry.next;
    }
    return (entry);
}
exports.ListRemoveEntry = ListRemoveEntry;
function ListMakeEntry(data) {
    return new List(false, data);
}
function ListMakeHead() {
    return new List(true, undefined);
}
exports.ListMakeHead = ListMakeHead;
class List {
    constructor(isHead, data) {
        this.isHead = isHead;
        this.data = data;
        this.prev = this;
        this.next = this;
    }
    clear() {
        if (this.isHead) {
            this.prev = this;
            this.next = this;
        }
    }
    add(data) {
        const entry = ListMakeEntry(data);
        this.prev.next = entry;
        entry.next = this;
        entry.prev = this.prev;
        this.prev = entry;
        return (entry);
    }
    dequeue() {
        if (!this.empty()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const removedEntry = ListRemoveEntry(this.next);
            return removedEntry.data;
        }
    }
    enqueue(data) {
        return this.add(data);
    }
    walk(fn) {
        for (let entry = this.next; !(entry.isHead); entry = entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            fn(entry.data, entry);
        }
    }
    some(fn, rev) {
        const rtn = [];
        const start = rev ? this.prev : this.next;
        for (let entry = start; !(entry.isHead); entry = rev ? entry.prev : entry.next) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const data = entry.data;
            if (fn(data, entry)) {
                if (rev) {
                    // preserve list order when in reverse
                    rtn.unshift(data);
                }
                else {
                    rtn.push(data);
                }
            }
        }
        return rtn;
    }
    count() {
        let entry;
        let i;
        entry = this.next;
        for (i = 0; !(entry.isHead); i++) {
            entry = entry.next;
        }
        return (i);
    }
    first() {
        if (!this.empty()) {
            return (this.next.data);
        }
    }
    last() {
        if (!this.empty()) {
            return (this.prev.data);
        }
    }
    empty() {
        return (this.next === this);
    }
    /**
     * @deprecated - use unshift
     */
    push(data) {
        this.unshift(data);
    }
    unshift(data) {
        const entry = ListMakeEntry(data);
        entry.data = data;
        entry.isHead = false;
        entry.next = this.next;
        entry.prev = this;
        this.next = entry;
        entry.next.prev = entry;
    }
    [Symbol.iterator]() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let node = this;
        const iterator = {
            next() {
                while (node && node.next.isHead === false) {
                    node = node.next;
                    if (node.data !== undefined) {
                        return { value: node.data, done: false };
                    }
                }
                return { value: undefined, done: true };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
}
exports.List = List;
class Heap {
    constructor(a, comp) {
        this.comp = comp;
        this.L = [comp.min];
        for (let i = 0, len = a.length; i < len; i++) {
            this.add(a[i]);
        }
    }
    count() {
        return this.L.length - 1;
    }
    peek() {
        return this.L[1];
    }
    get() {
        const x = this.L[1];
        this.L[1] = this.L[this.count()];
        this.L.pop();
        this.fixDown(1);
        return x;
    }
    add(x) {
        this.L.push(x);
        this.fixup(this.count());
    }
    /* eslint-disable no-bitwise */
    fixup(k) {
        let _k = k;
        while (_k > 1 && (this.comp.compare(this.L[_k >> 1], this.L[_k]) > 0)) {
            const tmp = this.L[_k >> 1];
            this.L[_k >> 1] = this.L[_k];
            this.L[_k] = tmp;
            _k = _k >> 1;
        }
    }
    fixDown(k) {
        let _k = k;
        while ((_k << 1) <= (this.count())) {
            let j = _k << 1;
            if ((j < this.count()) && (this.comp.compare(this.L[j], this.L[j + 1]) > 0)) {
                j++;
            }
            if (this.comp.compare(this.L[_k], this.L[j]) <= 0) {
                break;
            }
            const tmp = this.L[_k];
            this.L[_k] = this.L[j];
            this.L[j] = tmp;
            _k = j;
        }
    }
}
exports.Heap = Heap;
exports.RBColor = {
    RED: 0,
    BLACK: 1,
};
class RedBlackTree {
    constructor(compareKeys, aug) {
        this.compareKeys = compareKeys;
        this.aug = aug;
    }
    makeNode(key, data, color, size) {
        return { key, data, color, size };
    }
    isRed(node) {
        return !!node && (node.color === exports.RBColor.RED);
    }
    nodeSize(node) {
        return node ? node.size : 0;
    }
    size() {
        return this.nodeSize(this.root);
    }
    isEmpty() {
        return !this.root;
    }
    get(key) {
        if (key !== undefined) {
            return this.nodeGet(this.root, key);
        }
    }
    nodeGet(node, key) {
        let _node = node;
        while (_node) {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node = _node.left;
            }
            else if (cmp > 0) {
                _node = _node.right;
            }
            else {
                return _node;
            }
        }
    }
    contains(key) {
        return this.get(key);
    }
    gather(key, matcher) {
        const results = [];
        if (key !== undefined) {
            this.nodeGather(this.root, results, key, matcher);
        }
        return results;
    }
    nodeGather(node, results, key, matcher) {
        if (node) {
            if (matcher.continueSubtree(node.left, key)) {
                this.nodeGather(node.left, results, key, matcher);
            }
            if (matcher.matchNode(node, key)) {
                results.push(node);
            }
            if (matcher.continueSubtree(node.right, key)) {
                this.nodeGather(node.right, results, key, matcher);
            }
        }
    }
    walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn) {
        this.nodeWalkExactMatchesForward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);
    }
    nodeWalkExactMatchesForward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {
        if (!node) {
            return;
        }
        const result = compareFn(node);
        if (continueLeftFn(result)) {
            this.nodeWalkExactMatchesForward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
        if (result === 0) {
            actionFn(node);
        }
        if (continueRightFn(result)) {
            this.nodeWalkExactMatchesForward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
    }
    walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn) {
        this.nodeWalkExactMatchesBackward(this.root, compareFn, actionFn, continueLeftFn, continueRightFn);
    }
    nodeWalkExactMatchesBackward(node, compareFn, actionFn, continueLeftFn, continueRightFn) {
        if (!node) {
            return;
        }
        const result = compareFn(node);
        if (continueRightFn(result)) {
            this.nodeWalkExactMatchesBackward(node.right, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
        if (result === 0) {
            actionFn(node);
        }
        if (continueLeftFn(result)) {
            this.nodeWalkExactMatchesBackward(node.left, compareFn, actionFn, continueLeftFn, continueRightFn);
        }
    }
    put(key, data, conflict) {
        if (key !== undefined) {
            if (data === undefined) {
                this.remove(key);
            }
            else {
                this.root = this.nodePut(this.root, key, data, conflict);
                this.root.color = exports.RBColor.BLACK;
            }
        }
    }
    nodePut(node, key, data, conflict) {
        let _node = node;
        if (!_node) {
            return this.makeNode(key, data, exports.RBColor.RED, 1);
        }
        else {
            const cmp = this.compareKeys(key, _node.key);
            if (cmp < 0) {
                _node.left = this.nodePut(_node.left, key, data, conflict);
            }
            else if (cmp > 0) {
                _node.right = this.nodePut(_node.right, key, data, conflict);
            }
            else {
                if (conflict) {
                    const kd = conflict(key, _node.key, data, _node.data);
                    if (kd.key) {
                        _node.key = kd.key;
                    }
                    if (kd.data) {
                        _node.data = kd.data;
                    }
                    else {
                        _node.data = data;
                    }
                }
                else {
                    _node.data = data;
                }
            }
            if (this.isRed(_node.right) && (!this.isRed(_node.left))) {
                _node = this.rotateLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (this.isRed(_node.left) && this.isRed(_node.left.left)) {
                _node = this.rotateRight(_node);
            }
            if (this.isRed(_node.left) && this.isRed(_node.right)) {
                this.flipColors(_node);
            }
            _node.size = this.nodeSize(_node.left) + this.nodeSize(_node.right) + 1;
            if (this.aug) {
                this.updateLocal(_node);
            }
            return _node;
        }
    }
    updateLocal(node) {
        if (this.aug) {
            if (this.isRed(node.left)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.left);
            }
            if (this.isRed(node.right)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.aug.update(node.right);
            }
            this.aug.update(node);
        }
    }
    nodeRemoveMin(node) {
        let _node = node;
        if (_node.left) {
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemoveMin(_node.left);
            return this.balance(_node);
        }
    }
    remove(key) {
        if (key !== undefined) {
            if (!this.contains(key)) {
                return;
            }
            this.removeExisting(key);
        }
        // TODO: error on undefined key
    }
    removeExisting(key) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if ((!this.isRed(this.root.left)) && (!this.isRed(this.root.right))) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.root.color = exports.RBColor.RED;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.root = this.nodeRemove(this.root, key);
    }
    nodeRemove(node, key) {
        let _node = node;
        if (this.compareKeys(key, _node.key) < 0) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.left)) && (!this.isRed(_node.left.left))) {
                _node = this.moveRedLeft(_node);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.left = this.nodeRemove(_node.left, key);
        }
        else {
            if (this.isRed(_node.left)) {
                _node = this.rotateRight(_node);
            }
            if ((this.compareKeys(key, _node.key) === 0) && (!_node.right)) {
                return undefined;
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((!this.isRed(_node.right)) && (!this.isRed(_node.right.left))) {
                _node = this.moveRedRight(_node);
            }
            if (this.compareKeys(key, _node.key) === 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const subtreeMin = this.nodeMin(_node.right);
                _node.key = subtreeMin.key;
                _node.data = subtreeMin.data;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemoveMin(_node.right);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _node.right = this.nodeRemove(_node.right, key);
            }
        }
        return this.balance(_node);
    }
    floor(key) {
        if (!this.isEmpty()) {
            return this.nodeFloor(this.root, key);
        }
    }
    nodeFloor(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp === 0) {
                return node;
            }
            else if (cmp < 0) {
                return this.nodeFloor(node.left, key);
            }
            else {
                const rightFloor = this.nodeFloor(node.right, key);
                if (rightFloor) {
                    return rightFloor;
                }
                else {
                    return node;
                }
            }
        }
    }
    ceil(key) {
        if (!this.isEmpty()) {
            return this.nodeCeil(this.root, key);
        }
    }
    nodeCeil(node, key) {
        if (node) {
            const cmp = this.compareKeys(key, node.key);
            if (cmp === 0) {
                return node;
            }
            else if (cmp > 0) {
                return this.nodeCeil(node.right, key);
            }
            else {
                const leftCeil = this.nodeCeil(node.left, key);
                if (leftCeil) {
                    return leftCeil;
                }
                else {
                    return node;
                }
            }
        }
    }
    min() {
        if (this.root) {
            return this.nodeMin(this.root);
        }
    }
    nodeMin(node) {
        if (!node.left) {
            return node;
        }
        else {
            return this.nodeMin(node.left);
        }
    }
    max() {
        if (this.root) {
            return this.nodeMax(this.root);
        }
    }
    nodeMax(node) {
        if (!node.right) {
            return node;
        }
        else {
            return this.nodeMax(node.right);
        }
    }
    rotateRight(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const leftChild = node.left;
        node.left = leftChild.right;
        leftChild.right = node;
        leftChild.color = leftChild.right.color;
        leftChild.right.color = exports.RBColor.RED;
        leftChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(leftChild);
        }
        return leftChild;
    }
    rotateLeft(node) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const rightChild = node.right;
        node.right = rightChild.left;
        rightChild.left = node;
        rightChild.color = rightChild.left.color;
        rightChild.left.color = exports.RBColor.RED;
        rightChild.size = node.size;
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.updateLocal(node);
            this.updateLocal(rightChild);
        }
        return rightChild;
    }
    oppositeColor(c) {
        return (c === exports.RBColor.BLACK) ? exports.RBColor.RED : exports.RBColor.BLACK;
    }
    flipColors(node) {
        node.color = this.oppositeColor(node.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.left.color = this.oppositeColor(node.left.color);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        node.right.color = this.oppositeColor(node.right.color);
    }
    moveRedLeft(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.right.left)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            _node.right = this.rotateRight(_node.right);
            _node = this.rotateLeft(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    moveRedRight(node) {
        let _node = node;
        this.flipColors(_node);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(_node.left.left)) {
            _node = this.rotateRight(_node);
            this.flipColors(_node);
        }
        return _node;
    }
    balance(input) {
        let node = input;
        if (this.isRed(node.right)) {
            node = this.rotateLeft(node);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        if (this.isRed(node.left) && this.isRed(node.left.left)) {
            node = this.rotateRight(node);
        }
        if (this.isRed(node.left) && (this.isRed(node.right))) {
            this.flipColors(node);
        }
        node.size = this.nodeSize(node.left) + this.nodeSize(node.right) + 1;
        if (this.aug) {
            this.aug.update(node);
        }
        return node;
    }
    mapRange(action, accum, start, end) {
        this.nodeMap(this.root, action, start, end);
    }
    map(action, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, action, accum);
    }
    keys() {
        const keyList = [];
        const actions = {
            showStructure: true,
            infix: (node) => {
                keyList.push(node.key);
                return true;
            },
        };
        this.walk(actions);
        return keyList;
    }
    /**
     * Depth-first traversal with custom action; if action returns
     * false, traversal is halted.
     * @param action - action to apply to each node
     */
    walk(actions) {
        this.nodeWalk(this.root, actions);
    }
    walkBackward(actions) {
        this.nodeWalkBackward(this.root, actions);
    }
    nodeWalk(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.pre(node);
                }
            }
            if (node.left) {
                go = this.nodeWalk(node.left, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalk(node.right, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeWalkBackward(node, actions) {
        let go = true;
        if (node) {
            if (actions.pre) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.pre(node);
                }
            }
            if (node.right) {
                go = this.nodeWalkBackward(node.right, actions);
            }
            if (go && actions.infix) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.infix(node);
                }
            }
            if (go) {
                go = this.nodeWalkBackward(node.left, actions);
            }
            if (go && actions.post) {
                if (actions.showStructure || (node.color === exports.RBColor.BLACK)) {
                    go = actions.post(node);
                }
            }
        }
        return go;
    }
    nodeMap(node, action, accum, start, end) {
        let _start = start;
        let _end = end;
        if (!node) {
            return true;
        }
        if (_start === undefined) {
            _start = this.nodeMin(node).key;
        }
        if (_end === undefined) {
            _end = this.nodeMax(node).key;
        }
        const cmpStart = this.compareKeys(_start, node.key);
        const cmpEnd = this.compareKeys(_end, node.key);
        let go = true;
        if (cmpStart < 0) {
            go = this.nodeMap(node.left, action, accum, _start, _end);
        }
        if (go && (cmpStart <= 0) && (cmpEnd >= 0)) {
            // REVIEW: test for black node here
            go = action(node, accum);
        }
        if (go && (cmpEnd > 0)) {
            go = this.nodeMap(node.right, action, accum, _start, _end);
        }
        return go;
    }
}
exports.RedBlackTree = RedBlackTree;
const integerRangeToString = (range) => `[${range.start},${range.end})`;
exports.integerRangeToString = integerRangeToString;
const intervalComparer = (a, b) => a.compare(b);
class IntervalTree {
    constructor() {
        this.intervals = new RedBlackTree(intervalComparer, this);
    }
    remove(x) {
        this.intervals.remove(x);
    }
    removeExisting(x) {
        this.intervals.removeExisting(x);
    }
    put(x, conflict) {
        let rbConflict;
        if (conflict) {
            rbConflict = (key, currentKey) => {
                const ival = conflict(key, currentKey);
                return {
                    key: ival,
                };
            };
        }
        this.intervals.put(x, { minmax: x.clone() }, rbConflict);
    }
    map(fn) {
        const actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    mapUntil(fn) {
        const actions = {
            infix: (node) => {
                return fn(node.key);
            },
            showStructure: true,
        };
        this.intervals.walk(actions);
    }
    mapBackward(fn) {
        const actions = {
            infix: (node) => {
                fn(node.key);
                return true;
            },
            showStructure: true,
        };
        this.intervals.walkBackward(actions);
    }
    // TODO: toString()
    match(x) {
        return this.intervals.gather(x, this);
    }
    matchNode(node, key) {
        return !!node && node.key.overlaps(key);
    }
    continueSubtree(node, key) {
        return !!node && node.data.minmax.overlaps(key);
    }
    update(node) {
        if (node.left && node.right) {
            node.data.minmax = node.key.union(node.left.data.minmax.union(node.right.data.minmax));
        }
        else {
            if (node.left) {
                node.data.minmax = node.key.union(node.left.data.minmax);
            }
            else if (node.right) {
                node.data.minmax = node.key.union(node.right.data.minmax);
            }
            else {
                node.data.minmax = node.key.clone();
            }
        }
    }
}
exports.IntervalTree = IntervalTree;
class TST {
    constructor() {
        this.n = 0;
    }
    size() {
        return this.n;
    }
    contains(key) {
        return this.get(key);
    }
    get(key) {
        const x = this.nodeGet(this.root, key, 0);
        if (x === undefined) {
            return undefined;
        }
        return x.val;
    }
    nodeGet(x, key, d) {
        if (x === undefined) {
            return undefined;
        }
        const c = key.charAt(d);
        if (c < x.c) {
            return this.nodeGet(x.left, key, d);
        }
        else if (c > x.c) {
            return this.nodeGet(x.right, key, d);
        }
        else if (d < (key.length - 1)) {
            return this.nodeGet(x.mid, key, d + 1);
        }
        else {
            return x;
        }
    }
    put(key, val) {
        if (!this.contains(key)) {
            this.n++;
        }
        this.root = this.nodePut(this.root, key, val, 0);
    }
    nodePut(x, key, val, d) {
        let _x = x;
        const c = key.charAt(d);
        if (_x === undefined) {
            _x = { c };
        }
        if (c < _x.c) {
            _x.left = this.nodePut(_x.left, key, val, d);
        }
        else if (c > _x.c) {
            _x.right = this.nodePut(_x.right, key, val, d);
        }
        else if (d < (key.length - 1)) {
            _x.mid = this.nodePut(_x.mid, key, val, d + 1);
        }
        else {
            _x.val = val;
        }
        return _x;
    }
    neighbors(text, distance = 2) {
        let q = [];
        this.nodeProximity(this.root, { text: "" }, 0, text, distance, q);
        q = q.filter((value) => (value.text.length > 0));
        return q;
    }
    keysWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push(text);
        }
        this.collect(x.mid, { text }, q);
        return q;
    }
    collect(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collect(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push(prefix.text + x.c);
        }
        this.collect(x.mid, { text: prefix.text + x.c }, q);
        this.collect(x.right, prefix, q);
    }
    mapNode(x, prefix, fn) {
        if (x === undefined) {
            return;
        }
        const key = prefix.text + x.c;
        this.mapNode(x.left, prefix, fn);
        if (x.val) {
            fn(key, x.val);
        }
        this.mapNode(x.mid, { text: key }, fn);
        this.mapNode(x.right, prefix, fn);
    }
    map(fn) {
        this.mapNode(this.root, { text: "" }, fn);
    }
    pairsWithPrefix(text) {
        const q = [];
        const x = this.nodeGet(this.root, text, 0);
        if (x === undefined) {
            return q;
        }
        if (x.val !== undefined) {
            q.push({ key: text, val: x.val });
        }
        this.collectPairs(x.mid, { text }, q);
        return q;
    }
    collectPairs(x, prefix, q) {
        if (x === undefined) {
            return;
        }
        this.collectPairs(x.left, prefix, q);
        if (x.val !== undefined) {
            q.push({ key: prefix.text + x.c, val: x.val });
        }
        this.collectPairs(x.mid, { text: prefix.text + x.c }, q);
        this.collectPairs(x.right, prefix, q);
    }
    nodeProximity(x, prefix, d, pattern, distance, q) {
        if ((x === undefined) || (distance < 0)) {
            return;
        }
        const c = pattern.charAt(d);
        if ((distance > 0) || (c < x.c)) {
            this.nodeProximity(x.left, prefix, d, pattern, distance, q);
        }
        if (x.val !== undefined) {
            const remD = distance - (pattern.length - d);
            if (remD >= 0) {
                let invD = distance;
                if (c !== x.c) {
                    invD--;
                }
                q.push({ text: prefix.text + x.c, val: x.val, invDistance: invD });
            }
        }
        const recurD = (d < (pattern.length - 1)) ? d + 1 : d;
        if (c === x.c) {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance, q);
        }
        else {
            this.nodeProximity(x.mid, { text: prefix.text + x.c }, recurD, pattern, distance - 1, q);
        }
        if ((distance > 0) || (c > x.c)) {
            this.nodeProximity(x.right, prefix, d, pattern, distance, q);
        }
    }
}
exports.TST = TST;

},{}],146:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonCollabClient = exports.LocalClientId = exports.TreeMaintenanceSequenceNumber = exports.UnassignedSequenceNumber = exports.UniversalSequenceNumber = void 0;
/**
 * Sequence numbers for shared segments start at 1 or greater.  Every segment marked
 * with sequence number zero will be counted as part of the requested string.
 */
exports.UniversalSequenceNumber = 0;
exports.UnassignedSequenceNumber = -1;
exports.TreeMaintenanceSequenceNumber = -2;
exports.LocalClientId = -1;
exports.NonCollabClient = -2;

},{}],147:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalReferenceCollection = exports.LocalReference = void 0;
__exportStar(require("./base"), exports);
__exportStar(require("./client"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./constants"), exports);
var localReference_1 = require("./localReference");
Object.defineProperty(exports, "LocalReference", { enumerable: true, get: function () { return localReference_1.LocalReference; } });
Object.defineProperty(exports, "LocalReferenceCollection", { enumerable: true, get: function () { return localReference_1.LocalReferenceCollection; } });
__exportStar(require("./mergeTree"), exports);
__exportStar(require("./mergeTreeDeltaCallback"), exports);
__exportStar(require("./mergeTreeTracking"), exports);
__exportStar(require("./opBuilder"), exports);
__exportStar(require("./ops"), exports);
__exportStar(require("./properties"), exports);
__exportStar(require("./segmentGroupCollection"), exports);
__exportStar(require("./segmentPropertiesManager"), exports);
__exportStar(require("./snapshotlegacy"), exports);
__exportStar(require("./sortedSegmentSet"), exports);
__exportStar(require("./textSegment"), exports);
__exportStar(require("./referencePositions"), exports);

},{"./base":143,"./client":144,"./collections":145,"./constants":146,"./localReference":148,"./mergeTree":149,"./mergeTreeDeltaCallback":150,"./mergeTreeTracking":151,"./opBuilder":152,"./ops":153,"./properties":155,"./referencePositions":156,"./segmentGroupCollection":157,"./segmentPropertiesManager":158,"./snapshotlegacy":162,"./sortedSegmentSet":163,"./textSegment":164}],148:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalReferenceCollection = exports.LocalReference = exports._validateReferenceType = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const collections_1 = require("./collections");
const ops_1 = require("./ops");
const properties_1 = require("./properties");
const referencePositions_1 = require("./referencePositions");
/**
 * @internal
 */
function _validateReferenceType(refType) {
    let exclusiveCount = 0;
    if ((0, referencePositions_1.refTypeIncludesFlag)(refType, ops_1.ReferenceType.Transient)) {
        ++exclusiveCount;
    }
    if ((0, referencePositions_1.refTypeIncludesFlag)(refType, ops_1.ReferenceType.SlideOnRemove)) {
        ++exclusiveCount;
    }
    if ((0, referencePositions_1.refTypeIncludesFlag)(refType, ops_1.ReferenceType.StayOnRemove)) {
        ++exclusiveCount;
    }
    if (exclusiveCount > 1) {
        throw new container_utils_1.UsageError("Reference types can only be one of Transient, SlideOnRemove, and StayOnRemove");
    }
}
exports._validateReferenceType = _validateReferenceType;
/**
 * @deprecated - Use LocalReferencePosition
 */
class LocalReference {
    /**
     * @deprecated - use createReferencePosition
     */
    constructor(client, initSegment, 
    /**
     * @deprecated - use getOffset
     */
    offset = 0, refType = ops_1.ReferenceType.Simple, properties) {
        this.client = client;
        this.offset = offset;
        this.refType = refType;
        _validateReferenceType(refType);
        this.segment = initSegment;
        this.properties = properties;
    }
    /**
     * @deprecated - use minReferencePosition
     */
    min(b) {
        return (0, referencePositions_1.minReferencePosition)(this, b);
    }
    /**
     * @deprecated - use maxReferencePosition
     */
    max(b) {
        return (0, referencePositions_1.maxReferencePosition)(this, b);
    }
    /**
     * @deprecated - use compareReferencePositions
     */
    compare(b) {
        return (0, referencePositions_1.compareReferencePositions)(this, b);
    }
    /**
     * @deprecated - use getLocalReferencePosition
     */
    toPosition() {
        return this.getClient().localReferencePositionToPosition(this);
    }
    /**
     * @deprecated - use refHasTileLabels
     */
    hasTileLabels() {
        return (0, referencePositions_1.refHasTileLabels)(this);
    }
    /**
     * @deprecated - use refHasRangeLabels
     */
    hasRangeLabels() {
        return (0, referencePositions_1.refHasRangeLabels)(this);
    }
    /**
     * @deprecated - use refHasTileLabel
     */
    hasTileLabel(label) {
        return (0, referencePositions_1.refHasTileLabel)(this, label);
    }
    /**
     * @deprecated - use refHasRangeLabel
     */
    hasRangeLabel(label) {
        return (0, referencePositions_1.refHasRangeLabel)(this, label);
    }
    /**
     * @deprecated - use refGetTileLabels
     */
    getTileLabels() {
        return (0, referencePositions_1.refGetTileLabels)(this);
    }
    /**
     * @deprecated - use refGetRangeLabels
     */
    getRangeLabels() {
        return (0, referencePositions_1.refGetRangeLabels)(this);
    }
    isLeaf() {
        return false;
    }
    addProperties(newProps, op) {
        this.properties = (0, properties_1.addProperties)(this.properties, newProps, op);
    }
    /**
     * @deprecated - no longer supported
     */
    getClient() {
        return this.client;
    }
    getSegment() {
        return this.segment;
    }
    getOffset() {
        return this.offset;
    }
    getProperties() {
        return this.properties;
    }
}
exports.LocalReference = LocalReference;
/**
 * @deprecated - use DetachedReferencePosition
 */
LocalReference.DetachedPosition = -1;
function assertLocalReferences(lref) {
    (0, common_utils_1.assert)(lref instanceof LocalReference, 0x2e0 /* "lref not a Local Reference" */);
}
/**
 * Represents a collection of {@link ReferencePosition}s associated with one segment in a merge-tree.
 */
class LocalReferenceCollection {
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    constructor(
    /** Segment this `LocalReferenceCollection` is associated to. */
    segment, initialRefsByfOffset = new Array(segment.cachedLength)) {
        this.segment = segment;
        /**
         *
         * @internal - this method should only be called by mergeTree
         */
        this.hierRefCount = 0;
        this.refCount = 0;
        // Since javascript arrays are sparse the above won't populate any of the
        // indices, but it will ensure the length property of the array matches
        // the length of the segment.
        this.refsByOffset = initialRefsByfOffset;
    }
    static append(seg1, seg2) {
        if (seg2.localRefs && !seg2.localRefs.empty) {
            if (!seg1.localRefs) {
                seg1.localRefs = new LocalReferenceCollection(seg1);
            }
            (0, common_utils_1.assert)(seg1.localRefs.refsByOffset.length === seg1.cachedLength, 0x2be /* "LocalReferences array contains a gap" */);
            seg1.localRefs.append(seg2.localRefs);
        }
        else if (seg1.localRefs) {
            // Since creating the LocalReferenceCollection, we may have appended
            // segments that had no local references. Account for them now by padding the array.
            seg1.localRefs.refsByOffset.length += seg2.cachedLength;
        }
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    [Symbol.iterator]() {
        const subiterators = [];
        for (const refs of this.refsByOffset) {
            if (refs) {
                if (refs.before) {
                    subiterators.push(refs.before[Symbol.iterator]());
                }
                if (refs.at) {
                    subiterators.push(refs.at[Symbol.iterator]());
                }
                if (refs.after) {
                    subiterators.push(refs.after[Symbol.iterator]());
                }
            }
        }
        const iterator = {
            next() {
                while (subiterators.length > 0) {
                    const next = subiterators[0].next();
                    if (next.done === true) {
                        subiterators.shift();
                    }
                    else {
                        return next;
                    }
                }
                return { value: undefined, done: true };
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    clear() {
        this.refCount = 0;
        this.hierRefCount = 0;
        const detachSegments = (refs) => {
            if (refs) {
                for (const r of refs) {
                    if (r.segment === this.segment) {
                        r.segment = undefined;
                    }
                }
            }
        };
        for (let i = 0; i < this.refsByOffset.length; i++) {
            const refsAtOffset = this.refsByOffset[i];
            if (refsAtOffset) {
                detachSegments(refsAtOffset.before);
                detachSegments(refsAtOffset.at);
                detachSegments(refsAtOffset.before);
                this.refsByOffset[i] = undefined;
            }
        }
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    get empty() {
        return this.refCount === 0;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    createLocalRef(offset, refType, properties, client) {
        const ref = new LocalReference(client, this.segment, offset, refType, properties);
        if (!(0, referencePositions_1.refTypeIncludesFlag)(ref, ops_1.ReferenceType.Transient)) {
            this.addLocalRef(ref);
        }
        return ref;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    addLocalRef(lref) {
        var _a, _b;
        (0, common_utils_1.assert)(!(0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.Transient), 0x2df /* "transient references cannot be bound to segments" */);
        assertLocalReferences(lref);
        const refsAtOffset = this.refsByOffset[lref.offset] =
            (_a = this.refsByOffset[lref.offset]) !== null && _a !== void 0 ? _a : { at: (0, collections_1.ListMakeHead)() };
        const atRefs = refsAtOffset.at =
            (_b = refsAtOffset.at) !== null && _b !== void 0 ? _b : (0, collections_1.ListMakeHead)();
        atRefs.enqueue(lref);
        if ((0, referencePositions_1.refHasRangeLabels)(lref) || (0, referencePositions_1.refHasTileLabels)(lref)) {
            this.hierRefCount++;
        }
        this.refCount++;
    }
    /**
     *
     * @internal - this method should only be called by mergeTree
     */
    removeLocalRef(lref) {
        assertLocalReferences(lref);
        const tryRemoveRef = (refs) => {
            if (refs) {
                let node = refs;
                do {
                    node = node.next;
                    if (node.data === lref) {
                        (0, collections_1.ListRemoveEntry)(node);
                        if ((0, referencePositions_1.refHasRangeLabels)(lref) || (0, referencePositions_1.refHasTileLabels)(lref)) {
                            this.hierRefCount--;
                        }
                        this.refCount--;
                        return lref;
                    }
                } while (!node.isHead);
            }
        };
        const refAtOffset = this.refsByOffset[lref.offset];
        if (refAtOffset !== undefined) {
            let ref = tryRemoveRef(refAtOffset.before);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.at);
            if (ref) {
                return ref;
            }
            ref = tryRemoveRef(refAtOffset.after);
            if (ref) {
                return ref;
            }
        }
    }
    /**
     * @internal - this method should only be called by mergeTree
     *
     * Called by 'append()' implementations to append local refs from the given 'other' segment to the
     * end of 'this' segment.
     *
     * Note: This method should be invoked after the caller has ensured that segments can be merged,
     *       but before 'this' segment's cachedLength has changed, or the adjustment to the local refs
     *       will be incorrect.
     */
    append(other) {
        if (!other || other.empty) {
            return;
        }
        this.hierRefCount += other.hierRefCount;
        this.refCount += other.refCount;
        other.hierRefCount = 0;
        for (const lref of other) {
            lref.segment = this.segment;
            lref.offset += this.refsByOffset.length;
        }
        this.refsByOffset.push(...other.refsByOffset);
    }
    /**
     * @internal - this method should only be called by mergeTree
     *
     * Splits this `LocalReferenceCollection` into the intervals [0, offset) and [offset, originalLength).
     * Local references in the former half of this split will remain associated with the segment used on construction.
     * Local references in the latter half of this split will be transferred to `splitSeg`,
     * and its `localRefs` field will be set.
     * @param offset - Offset into the original segment at which the collection should be split
     * @param splitSeg - Split segment which originally corresponded to the indices [offset, originalLength)
     * before splitting.
     */
    split(offset, splitSeg) {
        if (!this.empty) {
            const localRefs = new LocalReferenceCollection(splitSeg, this.refsByOffset.splice(offset, this.refsByOffset.length - offset));
            splitSeg.localRefs = localRefs;
            for (const lref of localRefs) {
                lref.segment = splitSeg;
                lref.offset -= offset;
                if ((0, referencePositions_1.refHasRangeLabels)(lref) || (0, referencePositions_1.refHasTileLabels)(lref)) {
                    this.hierRefCount--;
                    localRefs.hierRefCount++;
                }
                this.refCount--;
                localRefs.refCount++;
            }
        }
        else {
            // shrink the offset array when empty and splitting
            this.refsByOffset.length = offset;
        }
    }
    addBeforeTombstones(...refs) {
        var _a, _b, _c, _d, _e;
        const beforeRefs = (_b = (_a = this.refsByOffset[0]) === null || _a === void 0 ? void 0 : _a.before) !== null && _b !== void 0 ? _b : (0, collections_1.ListMakeHead)();
        for (const iterable of refs) {
            for (const lref of iterable) {
                assertLocalReferences(lref);
                if ((0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.SlideOnRemove)) {
                    beforeRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = 0;
                    if ((0, referencePositions_1.refHasRangeLabels)(lref) || (0, referencePositions_1.refHasTileLabels)(lref)) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (!beforeRefs.empty() && ((_c = this.refsByOffset[0]) === null || _c === void 0 ? void 0 : _c.before) === undefined) {
            const refsAtOffset = this.refsByOffset[0] =
                (_d = this.refsByOffset[0]) !== null && _d !== void 0 ? _d : { before: beforeRefs };
            refsAtOffset.before = (_e = refsAtOffset.before) !== null && _e !== void 0 ? _e : beforeRefs;
        }
    }
    addAfterTombstones(...refs) {
        var _a, _b, _c, _d, _e;
        const lastOffset = this.refsByOffset.length - 1;
        const afterRefs = (_b = (_a = this.refsByOffset[lastOffset]) === null || _a === void 0 ? void 0 : _a.after) !== null && _b !== void 0 ? _b : (0, collections_1.ListMakeHead)();
        for (const iterable of refs) {
            for (const lref of iterable) {
                assertLocalReferences(lref);
                if ((0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.SlideOnRemove)) {
                    afterRefs.push(lref);
                    lref.segment = this.segment;
                    lref.offset = this.segment.cachedLength - 1;
                    if ((0, referencePositions_1.refHasRangeLabels)(lref) || (0, referencePositions_1.refHasTileLabels)(lref)) {
                        this.hierRefCount++;
                    }
                    this.refCount++;
                }
                else {
                    lref.segment = undefined;
                }
            }
        }
        if (!afterRefs.empty() && ((_c = this.refsByOffset[lastOffset]) === null || _c === void 0 ? void 0 : _c.after) === undefined) {
            const refsAtOffset = this.refsByOffset[lastOffset] =
                (_d = this.refsByOffset[lastOffset]) !== null && _d !== void 0 ? _d : { after: afterRefs };
            refsAtOffset.after = (_e = refsAtOffset.after) !== null && _e !== void 0 ? _e : afterRefs;
        }
    }
}
exports.LocalReferenceCollection = LocalReferenceCollection;

},{"./collections":145,"./ops":153,"./properties":155,"./referencePositions":156,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87}],149:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeTree = exports.clientSeqComparer = exports.internedSpaces = exports.compareStrings = exports.compareNumbers = exports.CollaborationWindow = exports.IncrementalMapState = exports.IncrementalExecOp = exports.Marker = exports.reservedMarkerSimpleTypeKey = exports.reservedMarkerIdKey = exports.BaseSegment = exports.MergeBlock = exports.MaxNodesInBlock = exports.ordinalToArray = exports.MergeNode = exports.toRemovalInfo = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/consistent-type-assertions */
/* eslint-disable @typescript-eslint/prefer-optional-chain, no-bitwise */
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const collections_1 = require("./collections");
const constants_1 = require("./constants");
const localReference_1 = require("./localReference");
const mergeTreeDeltaCallback_1 = require("./mergeTreeDeltaCallback");
const mergeTreeTracking_1 = require("./mergeTreeTracking");
const ops_1 = require("./ops");
const partialLengths_1 = require("./partialLengths");
const properties_1 = require("./properties");
const referencePositions_1 = require("./referencePositions");
const segmentGroupCollection_1 = require("./segmentGroupCollection");
const segmentPropertiesManager_1 = require("./segmentPropertiesManager");
function toRemovalInfo(maybe) {
    if ((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) !== undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) !== undefined) {
        return maybe;
    }
    (0, common_utils_1.assert)((maybe === null || maybe === void 0 ? void 0 : maybe.removedClientIds) === undefined && (maybe === null || maybe === void 0 ? void 0 : maybe.removedSeq) === undefined, 0x2bf /* "both removedClientIds and removedSeq should be set or not set" */);
}
exports.toRemovalInfo = toRemovalInfo;
function isRemoved(segment) {
    return toRemovalInfo(segment) !== undefined;
}
function isRemovedAndAcked(segment) {
    const removalInfo = toRemovalInfo(segment);
    return removalInfo !== undefined && removalInfo.removedSeq !== constants_1.UnassignedSequenceNumber;
}
class MergeNode {
    constructor() {
        this.index = 0;
        this.ordinal = "";
        this.cachedLength = 0;
    }
    isLeaf() {
        return false;
    }
}
exports.MergeNode = MergeNode;
function addTile(tile, tiles) {
    const tileLabels = (0, referencePositions_1.refGetTileLabels)(tile);
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            tiles[tileLabel] = tile;
        }
    }
}
function addTileIfNotPresent(tile, tiles) {
    const tileLabels = (0, referencePositions_1.refGetTileLabels)(tile);
    if (tileLabels) {
        for (const tileLabel of tileLabels) {
            if (tiles[tileLabel] === undefined) {
                tiles[tileLabel] = tile;
            }
        }
    }
}
function applyStackDelta(currentStackMap, deltaStackMap) {
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const label in deltaStackMap) {
        const deltaStack = deltaStackMap[label];
        if (!deltaStack.empty()) {
            let currentStack = currentStackMap[label];
            if (currentStack === undefined) {
                currentStack = new collections_1.Stack();
                currentStackMap[label] = currentStack;
            }
            for (const delta of deltaStack.items) {
                applyRangeReference(currentStack, delta);
            }
        }
    }
}
function applyRangeReference(stack, delta) {
    if ((0, referencePositions_1.refTypeIncludesFlag)(delta, ops_1.ReferenceType.NestBegin)) {
        stack.push(delta);
        return true;
    }
    else {
        // Assume delta is end reference
        const top = stack.top();
        // TODO: match end with begin
        if (top && ((0, referencePositions_1.refTypeIncludesFlag)(top, ops_1.ReferenceType.NestBegin))) {
            stack.pop();
        }
        else {
            stack.push(delta);
        }
        return false;
    }
}
function addNodeReferences(mergeTree, node, rightmostTiles, leftmostTiles, rangeStacks) {
    var _a;
    function updateRangeInfo(label, refPos) {
        let stack = rangeStacks[label];
        if (stack === undefined) {
            stack = new collections_1.Stack();
            rangeStacks[label] = stack;
        }
        applyRangeReference(stack, refPos);
    }
    if (node.isLeaf()) {
        const segment = node;
        if (((_a = mergeTree.localNetLength(segment)) !== null && _a !== void 0 ? _a : 0) > 0) {
            if (Marker.is(segment)) {
                const markerId = segment.getId();
                // Also in insertMarker but need for reload segs case
                // can add option for this only from reload segs
                if (markerId) {
                    mergeTree.mapIdToSegment(markerId, segment);
                }
                if ((0, referencePositions_1.refTypeIncludesFlag)(segment, ops_1.ReferenceType.Tile)) {
                    addTile(segment, rightmostTiles);
                    addTileIfNotPresent(segment, leftmostTiles);
                }
                if (segment.refType & (ops_1.ReferenceType.NestBegin | ops_1.ReferenceType.NestEnd)) {
                    const rangeLabels = (0, referencePositions_1.refGetRangeLabels)(segment);
                    if (rangeLabels) {
                        for (const label of rangeLabels) {
                            updateRangeInfo(label, segment);
                        }
                    }
                }
            }
            else {
                const baseSegment = node;
                if (baseSegment.localRefs && (baseSegment.localRefs.hierRefCount !== undefined) &&
                    (baseSegment.localRefs.hierRefCount > 0)) {
                    for (const lref of baseSegment.localRefs) {
                        if ((0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.Tile)) {
                            addTile(lref, rightmostTiles);
                            addTileIfNotPresent(lref, leftmostTiles);
                        }
                        if (lref.refType & (ops_1.ReferenceType.NestBegin | ops_1.ReferenceType.NestEnd)) {
                            for (const label of (0, referencePositions_1.refGetRangeLabels)(lref)) {
                                updateRangeInfo(label, lref);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(rangeStacks, block.rangeStacks);
        (0, properties_1.extend)(rightmostTiles, block.rightmostTiles);
        (0, properties_1.extendIfUndefined)(leftmostTiles, block.leftmostTiles);
    }
}
function ordinalToArray(ord) {
    const a = [];
    if (ord) {
        for (let i = 0, len = ord.length; i < len; i++) {
            a.push(ord.charCodeAt(i));
        }
    }
    return a;
}
exports.ordinalToArray = ordinalToArray;
// Note that the actual branching factor of the MergeTree is `MaxNodesInBlock - 1`.  This is because
// the MergeTree always inserts first, then checks for overflow and splits if the child count equals
// `MaxNodesInBlock`.  (i.e., `MaxNodesInBlock` contains 1 extra slot for temporary storage to
// facilitate splits.)
exports.MaxNodesInBlock = 8;
class MergeBlock extends MergeNode {
    constructor(childCount) {
        super();
        this.childCount = childCount;
        this.children = new Array(exports.MaxNodesInBlock);
    }
    hierBlock() {
        return undefined;
    }
    setOrdinal(child, index) {
        let childCount = this.childCount;
        if (childCount === 8) {
            childCount = 7;
        }
        (0, common_utils_1.assert)((childCount >= 1) && (childCount <= 7), 0x040 /* "Child count is not within [1,7] range!" */);
        let localOrdinal;
        const ordinalWidth = 1 << (exports.MaxNodesInBlock - (childCount + 1));
        if (index === 0) {
            localOrdinal = ordinalWidth - 1;
        }
        else {
            const prevOrd = this.children[index - 1].ordinal;
            const prevOrdCode = prevOrd.charCodeAt(prevOrd.length - 1);
            localOrdinal = prevOrdCode + ordinalWidth;
        }
        child.ordinal = this.ordinal + String.fromCharCode(localOrdinal);
        (0, common_utils_1.assert)(child.ordinal.length === (this.ordinal.length + 1), 0x041 /* "Unexpected child ordinal length!" */);
        if (index > 0) {
            (0, common_utils_1.assert)(child.ordinal > this.children[index - 1].ordinal, 0x042);
        }
    }
    assignChild(child, index, updateOrdinal = true) {
        child.parent = this;
        child.index = index;
        if (updateOrdinal) {
            this.setOrdinal(child, index);
        }
        this.children[index] = child;
    }
}
exports.MergeBlock = MergeBlock;
class HierMergeBlock extends MergeBlock {
    constructor(childCount) {
        super(childCount);
        this.rightmostTiles = (0, properties_1.createMap)();
        this.leftmostTiles = (0, properties_1.createMap)();
        this.rangeStacks = (0, properties_1.createMap)();
    }
    addNodeReferences(mergeTree, node) {
        addNodeReferences(mergeTree, node, this.rightmostTiles, this.leftmostTiles, this.rangeStacks);
    }
    hierBlock() {
        return this;
    }
    hierToString(indentCount) {
        let strbuf = "";
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in this.rangeStacks) {
            const stack = this.rangeStacks[key];
            strbuf += internedSpaces(indentCount);
            strbuf += `${key}: `;
            for (const item of stack.items) {
                strbuf += `${item.toString()} `;
            }
            strbuf += "\n";
        }
        return strbuf;
    }
}
function nodeTotalLength(mergeTree, node) {
    if (!node.isLeaf()) {
        return node.cachedLength;
    }
    return mergeTree.localNetLength(node);
}
class BaseSegment extends MergeNode {
    constructor() {
        super(...arguments);
        this.clientId = constants_1.LocalClientId;
        this.seq = constants_1.UniversalSequenceNumber;
        this.segmentGroups = new segmentGroupCollection_1.SegmentGroupCollection(this);
        this.trackingCollection = new mergeTreeTracking_1.TrackingGroupCollection(this);
    }
    addProperties(newProps, op, seq, collabWindow) {
        if (!this.propertyManager) {
            this.propertyManager = new segmentPropertiesManager_1.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0, properties_1.createMap)();
        }
        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collabWindow && collabWindow.collaborating);
    }
    hasProperty(key) {
        return !!this.properties && (this.properties[key] !== undefined);
    }
    isLeaf() {
        return true;
    }
    cloneInto(b) {
        var _a;
        b.clientId = this.clientId;
        // TODO: deep clone properties
        b.properties = (0, properties_1.clone)(this.properties);
        b.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();
        // TODO: copy removed client overlap and branch removal info
        b.removedSeq = this.removedSeq;
        b.seq = this.seq;
    }
    canAppend(segment) {
        return false;
    }
    addSerializedProps(jseg) {
        if (this.properties) {
            jseg.props = this.properties;
        }
    }
    ack(segmentGroup, opArgs, mergeTree) {
        const currentSegmentGroup = this.segmentGroups.dequeue();
        (0, common_utils_1.assert)(currentSegmentGroup === segmentGroup, 0x043 /* "On ack, unexpected segmentGroup!" */);
        switch (opArgs.op.type) {
            case ops_1.MergeTreeDeltaType.ANNOTATE:
                (0, common_utils_1.assert)(!!this.propertyManager, 0x044 /* "On annotate ack, missing segment property manager!" */);
                this.propertyManager.ackPendingProperties(opArgs.op);
                return true;
            case ops_1.MergeTreeDeltaType.INSERT:
                (0, common_utils_1.assert)(this.seq === constants_1.UnassignedSequenceNumber, 0x045 /* "On insert, seq number already assigned!" */);
                this.seq = opArgs.sequencedMessage.sequenceNumber;
                this.localSeq = undefined;
                return true;
            case ops_1.MergeTreeDeltaType.REMOVE:
                const removalInfo = toRemovalInfo(this);
                (0, common_utils_1.assert)(removalInfo !== undefined, 0x046 /* "On remove ack, missing removal info!" */);
                this.localRemovedSeq = undefined;
                if (removalInfo.removedSeq === constants_1.UnassignedSequenceNumber) {
                    removalInfo.removedSeq = opArgs.sequencedMessage.sequenceNumber;
                    return true;
                }
                return false;
            default:
                throw new Error(`${opArgs.op.type} is in unrecognized operation type`);
        }
    }
    splitAt(pos) {
        var _a;
        if (pos > 0) {
            const leafSegment = this.createSplitSegmentAt(pos);
            if (leafSegment) {
                this.copyPropertiesTo(leafSegment);
                leafSegment.parent = this.parent;
                // Give the leaf a temporary yet valid ordinal.
                // when this segment is put in the tree, it will get it's real ordinal,
                // but this ordinal meets all the necessary invariants for now.
                leafSegment.ordinal = this.ordinal + String.fromCharCode(0);
                leafSegment.removedClientIds = (_a = this.removedClientIds) === null || _a === void 0 ? void 0 : _a.slice();
                leafSegment.removedSeq = this.removedSeq;
                leafSegment.localRemovedSeq = this.localRemovedSeq;
                leafSegment.seq = this.seq;
                leafSegment.localSeq = this.localSeq;
                leafSegment.clientId = this.clientId;
                this.segmentGroups.copyTo(leafSegment);
                this.trackingCollection.copyTo(leafSegment);
                if (this.localRefs) {
                    this.localRefs.split(pos, leafSegment);
                }
            }
            return leafSegment;
        }
    }
    copyPropertiesTo(other) {
        if (this.propertyManager) {
            if (this.properties) {
                other.propertyManager = new segmentPropertiesManager_1.PropertiesManager();
                other.properties = this.propertyManager.copyTo(this.properties, other.properties, other.propertyManager);
            }
        }
    }
}
exports.BaseSegment = BaseSegment;
exports.reservedMarkerIdKey = "markerId";
exports.reservedMarkerSimpleTypeKey = "markerSimpleType";
class Marker extends BaseSegment {
    constructor(refType) {
        super();
        this.refType = refType;
        this.type = Marker.type;
        this.cachedLength = 1;
    }
    static is(segment) {
        return segment.type === Marker.type;
    }
    static make(refType, props) {
        const marker = new Marker(refType);
        if (props) {
            marker.addProperties(props);
        }
        return marker;
    }
    toJSONObject() {
        const obj = { marker: { refType: this.refType } };
        super.addSerializedProps(obj);
        return obj;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "marker" in spec) {
            return Marker.make(spec.marker.refType, spec.props);
        }
        return undefined;
    }
    clone() {
        const b = Marker.make(this.refType, this.properties);
        this.cloneInto(b);
        return b;
    }
    getSegment() {
        return this;
    }
    getOffset() {
        return 0;
    }
    hasSimpleType(simpleTypeName) {
        return !!this.properties &&
            this.properties[exports.reservedMarkerSimpleTypeKey] === simpleTypeName;
    }
    getProperties() {
        return this.properties;
    }
    getId() {
        if (this.properties && this.properties[exports.reservedMarkerIdKey]) {
            return this.properties[exports.reservedMarkerIdKey];
        }
    }
    /**
     * @deprecated - use refHasTileLabels
     */
    hasTileLabels() {
        return (0, referencePositions_1.refHasTileLabels)(this);
    }
    /**
     * @deprecated - use refHasRangeLabels
     */
    hasRangeLabels() {
        return (0, referencePositions_1.refHasRangeLabels)(this);
    }
    /**
     * @deprecated - use refHasTileLabel
     */
    hasTileLabel(label) {
        return (0, referencePositions_1.refHasTileLabel)(this, label);
    }
    /**
     * @deprecated - use refHasRangeLabel
     */
    hasRangeLabel(label) {
        return (0, referencePositions_1.refHasRangeLabel)(this, label);
    }
    /**
     * @deprecated - use refGetTileLabels
     */
    getTileLabels() {
        return (0, referencePositions_1.refGetTileLabels)(this);
    }
    /**
     * @deprecated - use refGetRangeLabels
     */
    getRangeLabels() {
        return (0, referencePositions_1.refGetRangeLabels)(this);
    }
    toString() {
        let bbuf = "";
        if ((0, referencePositions_1.refTypeIncludesFlag)(this, ops_1.ReferenceType.Tile)) {
            bbuf += "Tile";
        }
        if ((0, referencePositions_1.refTypeIncludesFlag)(this, ops_1.ReferenceType.NestBegin)) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeBegin";
        }
        if ((0, referencePositions_1.refTypeIncludesFlag)(this, ops_1.ReferenceType.NestEnd)) {
            if (bbuf.length > 0) {
                bbuf += "; ";
            }
            bbuf += "RangeEnd";
        }
        let lbuf = "";
        const id = this.getId();
        if (id) {
            bbuf += ` (${id}) `;
        }
        const tileLabels = (0, referencePositions_1.refGetTileLabels)(this);
        if (tileLabels) {
            lbuf += "tile -- ";
            for (let i = 0, len = tileLabels.length; i < len; i++) {
                const tileLabel = tileLabels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += tileLabel;
            }
        }
        const rangeLabels = (0, referencePositions_1.refGetRangeLabels)(this);
        if (rangeLabels) {
            let rangeKind = "begin";
            if ((0, referencePositions_1.refTypeIncludesFlag)(this, ops_1.ReferenceType.NestEnd)) {
                rangeKind = "end";
            }
            if (tileLabels) {
                lbuf += " ";
            }
            lbuf += `range ${rangeKind} -- `;
            const labels = rangeLabels;
            for (let i = 0, len = labels.length; i < len; i++) {
                const rangeLabel = labels[i];
                if (i > 0) {
                    lbuf += "; ";
                }
                lbuf += rangeLabel;
            }
        }
        let pbuf = "";
        if (this.properties) {
            pbuf += JSON.stringify(this.properties, (key, value) => {
                // Avoid circular reference when stringifying makers containing handles.
                // (Substitute a debug string instead.)
                const handle = !!value && value.IFluidHandle;
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return handle
                    ? `#Handle(${handle.routeContext.path}/${handle.path})`
                    : value;
            });
        }
        return `M ${bbuf}: ${lbuf} ${pbuf}`;
    }
    createSplitSegmentAt(pos) {
        return undefined;
    }
    canAppend(segment) {
        return false;
    }
    append() { throw new Error("Can not append to marker"); }
}
exports.Marker = Marker;
Marker.type = "Marker";
var IncrementalExecOp;
(function (IncrementalExecOp) {
    IncrementalExecOp[IncrementalExecOp["Go"] = 0] = "Go";
    IncrementalExecOp[IncrementalExecOp["Stop"] = 1] = "Stop";
    IncrementalExecOp[IncrementalExecOp["Yield"] = 2] = "Yield";
})(IncrementalExecOp = exports.IncrementalExecOp || (exports.IncrementalExecOp = {}));
class IncrementalMapState {
    constructor(block, actions, pos, refSeq, clientId, context, start, end, childIndex = 0) {
        this.block = block;
        this.actions = actions;
        this.pos = pos;
        this.refSeq = refSeq;
        this.clientId = clientId;
        this.context = context;
        this.start = start;
        this.end = end;
        this.childIndex = childIndex;
        this.op = IncrementalExecOp.Go;
    }
}
exports.IncrementalMapState = IncrementalMapState;
class CollaborationWindow {
    constructor() {
        this.clientId = constants_1.LocalClientId;
        this.collaborating = false;
        // Lowest-numbered segment in window; no client can reference a state before this one
        this.minSeq = 0;
        // Highest-numbered segment in window and current
        // reference segment for this client
        this.currentSeq = 0;
        this.localSeq = 0;
    }
    loadFrom(a) {
        this.clientId = a.clientId;
        this.collaborating = a.collaborating;
        this.minSeq = a.minSeq;
        this.currentSeq = a.currentSeq;
    }
}
exports.CollaborationWindow = CollaborationWindow;
const compareNumbers = (a, b) => a - b;
exports.compareNumbers = compareNumbers;
const compareStrings = (a, b) => a.localeCompare(b);
exports.compareStrings = compareStrings;
const indentStrings = ["", " ", "  "];
function internedSpaces(n) {
    if (indentStrings[n] === undefined) {
        indentStrings[n] = "";
        for (let i = 0; i < n; i++) {
            indentStrings[n] += " ";
        }
    }
    return indentStrings[n];
}
exports.internedSpaces = internedSpaces;
exports.clientSeqComparer = {
    min: { refSeq: -1, clientId: "" },
    compare: (a, b) => a.refSeq - b.refSeq,
};
const LRUSegmentComparer = {
    min: { maxSeq: -2 },
    compare: (a, b) => a.maxSeq - b.maxSeq,
};
function applyLeafRangeMarker(marker, searchInfo) {
    for (const rangeLabel of searchInfo.rangeLabels) {
        if ((0, referencePositions_1.refHasRangeLabel)(marker, rangeLabel)) {
            let currentStack = searchInfo.stacks[rangeLabel];
            if (currentStack === undefined) {
                currentStack = new collections_1.Stack();
                searchInfo.stacks[rangeLabel] = currentStack;
            }
            applyRangeReference(currentStack, marker);
        }
    }
}
function recordRangeLeaf(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if (segment.refType &
            (ops_1.ReferenceType.NestBegin | ops_1.ReferenceType.NestEnd)) {
            applyLeafRangeMarker(segment, searchInfo);
        }
    }
    return false;
}
function rangeShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    var _a;
    if (node.isLeaf()) {
        const seg = node;
        if ((((_a = searchInfo.mergeTree.localNetLength(seg)) !== null && _a !== void 0 ? _a : 0) > 0) && Marker.is(seg)) {
            if (seg.refType &
                (ops_1.ReferenceType.NestBegin | ops_1.ReferenceType.NestEnd)) {
                applyLeafRangeMarker(seg, searchInfo);
            }
        }
    }
    else {
        const block = node;
        applyStackDelta(searchInfo.stacks, block.rangeStacks);
    }
    return true;
}
function recordTileStart(segment, segpos, refSeq, clientId, start, end, searchInfo) {
    if (Marker.is(segment)) {
        if ((0, referencePositions_1.refHasTileLabel)(segment, searchInfo.tileLabel)) {
            searchInfo.tile = segment;
        }
    }
    return false;
}
function tileShift(node, segpos, refSeq, clientId, offset, end, searchInfo) {
    if (node.isLeaf()) {
        const seg = node;
        if ((searchInfo.mergeTree.localNetLength(seg) > 0) && Marker.is(seg)) {
            if ((0, referencePositions_1.refHasTileLabel)(seg, searchInfo.tileLabel)) {
                searchInfo.tile = seg;
            }
        }
    }
    else {
        const block = node;
        let marker;
        if (searchInfo.posPrecedesTile) {
            marker = block.rightmostTiles[searchInfo.tileLabel];
        }
        else {
            marker = block.leftmostTiles[searchInfo.tileLabel];
        }
        if (marker !== undefined) {
            searchInfo.tile = marker;
        }
    }
    return true;
}
const minListenerComparer = {
    min: { minRequired: Number.MIN_VALUE, onMinGE: () => { (0, common_utils_1.assert)(false, 0x048 /* "onMinGE()" */); } },
    compare: (a, b) => a.minRequired - b.minRequired,
};
// Represents a sequence of text segments
class MergeTree {
    // TODO: make and use interface describing options
    constructor(options) {
        this.options = options;
        this.blockUpdateActions = MergeTree.initBlockUpdateActions;
        this.collabWindow = new CollaborationWindow();
        // TODO: add remove on segment remove
        // for now assume only markers have ids and so point directly at the Segment
        // if we need to have pointers to non-markers, we can change to point at local refs
        this.idToSegment = new Map();
        this.splitLeafSegment = (segment, pos) => {
            if (!(pos > 0 && segment)) {
                return {};
            }
            const next = segment.splitAt(pos);
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    operation: mergeTreeDeltaCallback_1.MergeTreeMaintenanceType.SPLIT,
                    deltaSegments: [{ segment }, { segment: next }],
                }, undefined);
            }
            return { next };
        };
        this.root = this.makeBlock(0);
    }
    makeBlock(childCount) {
        const block = new HierMergeBlock(childCount);
        block.ordinal = "";
        return block;
    }
    clone() {
        const b = new MergeTree(this.options);
        // For now assume that b will not collaborate
        b.root = b.blockClone(this.root);
    }
    blockClone(block, segments) {
        const bBlock = this.makeBlock(block.childCount);
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                const segment = this.segmentClone(child);
                bBlock.assignChild(segment, i);
                if (segments) {
                    segments.push(segment);
                }
            }
            else {
                bBlock.assignChild(this.blockClone(child, segments), i);
            }
        }
        this.nodeUpdateLengthNewStructure(bBlock);
        this.nodeUpdateOrdinals(bBlock);
        return bBlock;
    }
    segmentClone(segment) {
        const b = segment.clone();
        return b;
    }
    localNetLength(segment) {
        const removalInfo = toRemovalInfo(segment);
        if (removalInfo !== undefined) {
            return 0;
        }
        else {
            return segment.cachedLength;
        }
    }
    // TODO: remove id when segment removed
    mapIdToSegment(id, segment) {
        this.idToSegment.set(id, segment);
    }
    addNode(block, node) {
        const index = block.childCount++;
        block.assignChild(node, index, false);
        return index;
    }
    /* eslint-disable max-len */
    reloadFromSegments(segments) {
        // This code assumes that a later call to `startCollaboration()` will initialize partial lengths.
        (0, common_utils_1.assert)(!this.collabWindow.collaborating, 0x049 /* "Trying to reload from segments while collaborating!" */);
        const maxChildren = exports.MaxNodesInBlock - 1;
        // Starting with the leaf segments, recursively builds the B-Tree layer by layer from the bottom up.
        const buildMergeBlock = (nodes) => {
            const blockCount = Math.ceil(nodes.length / maxChildren); // Compute # blocks require for this level of B-Tree
            const blocks = new Array(blockCount); // Pre-alloc array to collect nodes
            // For each block in this level of the B-Tree...
            for (let nodeIndex = 0, blockIndex = 0; // Start with the first block and first node
             blockIndex < blockCount; // If we have more blocks, we also have more nodes to insert
             blockIndex++ // Advance to next block in this layer.
            ) {
                const block = blocks[blockIndex] = this.makeBlock(0);
                // For each child of the current block, insert a node (while we have nodes left)
                // and update the block's info.
                for (let childIndex = 0; childIndex < maxChildren && nodeIndex < nodes.length; // While we still have children & nodes left
                 childIndex++, nodeIndex++ // Advance to next child & node
                ) {
                    // Insert the next node into the current block
                    this.addNode(block, nodes[nodeIndex]);
                }
                // Calculate this block's info.  Previously this was inlined into the above loop as a micro-optimization,
                // but it turns out to be negligible in practice since `reloadFromSegments()` is only invoked for the
                // snapshot header.  The bulk of the segments in long documents are inserted via `insertSegments()`.
                this.blockUpdate(block);
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return blocks.length === 1 // If there is only one block at this layer...
                ? blocks[0] // ...then we're done.  Return the root.
                : buildMergeBlock(blocks); // ...otherwise recursively build the next layer above blocks.
        };
        if (segments.length > 0) {
            this.root = buildMergeBlock(segments);
            this.nodeUpdateOrdinals(this.root);
        }
        else {
            this.root = this.makeBlock(0);
        }
    }
    /* eslint-enable max-len */
    // For now assume min starts at zero
    startCollaboration(localClientId, minSeq, currentSeq) {
        this.collabWindow.clientId = localClientId;
        this.collabWindow.minSeq = minSeq;
        this.collabWindow.collaborating = true;
        this.collabWindow.currentSeq = currentSeq;
        this.segmentsToScour = new collections_1.Heap([], LRUSegmentComparer);
        this.pendingSegments = (0, collections_1.ListMakeHead)();
        this.nodeUpdateLengthNewStructure(this.root, true);
    }
    addToLRUSet(segment, seq) {
        // If the parent node has not yet been marked for scour (i.e., needsScour is not false or undefined),
        // add the segment and mark the mark the node now.
        // TODO: 'seq' may be less than the current sequence number when inserting pre-ACKed
        //       segments from a snapshot.  We currently skip these for now.
        if (segment.parent.needsScour !== true && seq > this.collabWindow.currentSeq) {
            segment.parent.needsScour = true;
            this.segmentsToScour.add({ segment, maxSeq: seq });
        }
    }
    underflow(node) {
        return node.childCount < (exports.MaxNodesInBlock / 2);
    }
    scourNode(node, holdNodes) {
        let prevSegment;
        for (let k = 0; k < node.childCount; k++) {
            const childNode = node.children[k];
            if (childNode.isLeaf()) {
                const segment = childNode;
                if (segment.segmentGroups.empty) {
                    if (segment.removedSeq !== undefined) {
                        if (segment.removedSeq > this.collabWindow.minSeq) {
                            holdNodes.push(segment);
                        }
                        else if (!segment.trackingCollection.empty) {
                            holdNodes.push(segment);
                        }
                        else {
                            // Notify maintenance event observers that the segment is being unlinked from the MergeTree
                            if (this.mergeTreeMaintenanceCallback) {
                                this.mergeTreeMaintenanceCallback({
                                    operation: mergeTreeDeltaCallback_1.MergeTreeMaintenanceType.UNLINK,
                                    deltaSegments: [{ segment }],
                                }, undefined);
                            }
                            segment.parent = undefined;
                        }
                        prevSegment = undefined;
                    }
                    else {
                        if (segment.seq <= this.collabWindow.minSeq) {
                            const canAppend = prevSegment
                                && prevSegment.canAppend(segment)
                                && (0, properties_1.matchProperties)(prevSegment.properties, segment.properties)
                                && prevSegment.trackingCollection.matches(segment.trackingCollection)
                                && this.localNetLength(segment) > 0;
                            if (canAppend) {
                                prevSegment.append(segment);
                                if (this.mergeTreeMaintenanceCallback) {
                                    this.mergeTreeMaintenanceCallback({
                                        operation: mergeTreeDeltaCallback_1.MergeTreeMaintenanceType.APPEND,
                                        deltaSegments: [{ segment: prevSegment }, { segment }],
                                    }, undefined);
                                }
                                segment.parent = undefined;
                                segment.trackingCollection.trackingGroups.forEach((tg) => tg.unlink(segment));
                            }
                            else {
                                holdNodes.push(segment);
                                if (this.localNetLength(segment) > 0) {
                                    prevSegment = segment;
                                }
                                else {
                                    prevSegment = undefined;
                                }
                            }
                        }
                        else {
                            holdNodes.push(segment);
                            prevSegment = undefined;
                        }
                    }
                }
                else {
                    holdNodes.push(segment);
                    prevSegment = undefined;
                }
            }
            else {
                holdNodes.push(childNode);
                prevSegment = undefined;
            }
        }
    }
    // Interior node with all node children
    packParent(parent) {
        const children = parent.children;
        let childIndex;
        let childBlock;
        const holdNodes = [];
        for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
            // Debug assert not isLeaf()
            childBlock = children[childIndex];
            this.scourNode(childBlock, holdNodes);
            // Will replace this block with a packed block
            childBlock.parent = undefined;
        }
        const totalNodeCount = holdNodes.length;
        const halfCount = exports.MaxNodesInBlock / 2;
        let childCount = Math.min(exports.MaxNodesInBlock - 1, Math.floor(totalNodeCount / halfCount));
        if (childCount < 1) {
            childCount = 1;
        }
        const baseCount = Math.floor(totalNodeCount / childCount);
        let extraCount = totalNodeCount % childCount;
        const packedBlocks = new Array(exports.MaxNodesInBlock);
        let readCount = 0;
        for (let nodeIndex = 0; nodeIndex < childCount; nodeIndex++) {
            let nodeCount = baseCount;
            if (extraCount > 0) {
                nodeCount++;
                extraCount--;
            }
            const packedBlock = this.makeBlock(nodeCount);
            for (let packedNodeIndex = 0; packedNodeIndex < nodeCount; packedNodeIndex++) {
                const nodeToPack = holdNodes[readCount++];
                packedBlock.assignChild(nodeToPack, packedNodeIndex, false);
            }
            packedBlock.parent = parent;
            packedBlocks[nodeIndex] = packedBlock;
            this.nodeUpdateLengthNewStructure(packedBlock);
        }
        parent.children = packedBlocks;
        for (let j = 0; j < childCount; j++) {
            parent.assignChild(packedBlocks[j], j, false);
        }
        parent.childCount = childCount;
        if (this.underflow(parent) && (parent.parent)) {
            this.packParent(parent.parent);
        }
        else {
            this.nodeUpdateOrdinals(parent);
            this.blockUpdatePathLengths(parent, constants_1.UnassignedSequenceNumber, -1, true);
        }
    }
    zamboniSegments(zamboniSegmentsMaxCount = MergeTree.zamboniSegmentsMaxCount) {
        if (!this.collabWindow.collaborating) {
            return;
        }
        for (let i = 0; i < zamboniSegmentsMaxCount; i++) {
            let segmentToScour = this.segmentsToScour.peek();
            if (!segmentToScour || segmentToScour.maxSeq > this.collabWindow.minSeq) {
                break;
            }
            segmentToScour = this.segmentsToScour.get();
            // Only skip scouring if needs scour is explicitly false, not true or undefined
            if (segmentToScour.segment.parent && segmentToScour.segment.parent.needsScour !== false) {
                const block = segmentToScour.segment.parent;
                const childrenCopy = [];
                this.scourNode(block, childrenCopy);
                // This will avoid the cost of re-scouring nodes
                // that have recently been scoured
                block.needsScour = false;
                const newChildCount = childrenCopy.length;
                if (newChildCount < block.childCount) {
                    block.childCount = newChildCount;
                    block.children = childrenCopy;
                    for (let j = 0; j < newChildCount; j++) {
                        block.assignChild(childrenCopy[j], j, false);
                    }
                    if (this.underflow(block) && block.parent) {
                        this.packParent(block.parent);
                    }
                    else {
                        this.nodeUpdateOrdinals(block);
                        this.blockUpdatePathLengths(block, constants_1.UnassignedSequenceNumber, -1, true);
                    }
                }
            }
        }
    }
    getCollabWindow() {
        return this.collabWindow;
    }
    getStats() {
        const nodeGetStats = (block) => {
            const stats = {
                maxHeight: 0,
                nodeCount: 0,
                leafCount: 0,
                removedLeafCount: 0,
                liveCount: 0,
                histo: [],
            };
            for (let k = 0; k < exports.MaxNodesInBlock; k++) {
                stats.histo[k] = 0;
            }
            for (let i = 0; i < block.childCount; i++) {
                const child = block.children[i];
                let height = 1;
                if (!child.isLeaf()) {
                    const childStats = nodeGetStats(child);
                    height = 1 + childStats.maxHeight;
                    stats.nodeCount += childStats.nodeCount;
                    stats.leafCount += childStats.leafCount;
                    stats.removedLeafCount += childStats.removedLeafCount;
                    stats.liveCount += childStats.liveCount;
                    for (let j = 0; j < exports.MaxNodesInBlock; j++) {
                        stats.histo[j] += childStats.histo[j];
                    }
                }
                else {
                    stats.leafCount++;
                    const segment = child;
                    if (segment.removedSeq !== undefined) {
                        stats.removedLeafCount++;
                    }
                }
                if (height > stats.maxHeight) {
                    stats.maxHeight = height;
                }
            }
            stats.histo[block.childCount]++;
            stats.nodeCount++;
            stats.liveCount += block.childCount;
            return stats;
        };
        const rootStats = nodeGetStats(this.root);
        return rootStats;
    }
    getLength(refSeq, clientId) {
        return this.blockLength(this.root, refSeq, clientId);
    }
    /**
     * Returns the current length of the MergeTree for the local client.
     */
    get length() { return this.root.cachedLength; }
    getPosition(node, refSeq, clientId) {
        var _a;
        let totalOffset = 0;
        let parent = node.parent;
        let prevParent;
        while (parent) {
            const children = parent.children;
            for (let childIndex = 0; childIndex < parent.childCount; childIndex++) {
                const child = children[childIndex];
                if ((prevParent && (child === prevParent)) || (child === node)) {
                    break;
                }
                totalOffset += (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            }
            prevParent = parent;
            parent = parent.parent;
        }
        return totalOffset;
    }
    getContainingSegment(pos, refSeq, clientId) {
        let segment;
        let offset;
        const leaf = (leafSeg, segpos, _refSeq, _clientId, start) => {
            segment = leafSeg;
            offset = start;
            return false;
        };
        this.searchBlock(this.root, pos, 0, refSeq, clientId, { leaf }, undefined);
        return { segment, offset };
    }
    /**
     * @internal must only be used by client
     * @param segoff - The segment and offset to slide from
     * @returns The segment and offset to slide to
     */
    _getSlideToSegment(segoff) {
        if (!segoff.segment || !isRemovedAndAcked(segoff.segment)) {
            return segoff;
        }
        let slideToSegment;
        const goFurtherToFindSlideToSegment = (seg) => {
            if (seg.seq !== constants_1.UnassignedSequenceNumber && !isRemovedAndAcked(seg)) {
                slideToSegment = seg;
                return false;
            }
            return true;
        };
        // Slide to the next farthest valid segment in the tree.
        this.rightExcursion(segoff.segment, goFurtherToFindSlideToSegment);
        if (slideToSegment) {
            return { segment: slideToSegment, offset: 0 };
        }
        // If no such segment is found, slide to the last valid segment.
        this.leftExcursion(segoff.segment, goFurtherToFindSlideToSegment);
        // Workaround TypeScript issue (https://github.com/microsoft/TypeScript/issues/9998)
        slideToSegment = slideToSegment;
        if (slideToSegment) {
            // If slid nearer then offset should be at the end of the segment
            return { segment: slideToSegment, offset: slideToSegment.cachedLength - 1 };
        }
        return { segment: undefined, offset: 0 };
    }
    /**
     * This method should only be called when the current client sequence number is
     * max(remove segment sequence number, add reference sequence number).
     * Otherwise eventual consistency is not guaranteed.
     * See `packages\dds\merge-tree\REFERENCEPOSITIONS.md`
     */
    slideReferences(segment, refsToSlide) {
        var _a, _b, _c, _d, _e;
        (0, common_utils_1.assert)(isRemovedAndAcked(segment), 0x2f1 /* slideReferences from a segment which has not been removed and acked */);
        (0, common_utils_1.assert)(!!segment.localRefs, 0x2f2 /* Ref not in the segment localRefs */);
        const newSegoff = this._getSlideToSegment({ segment, offset: 0 });
        const newSegment = newSegoff.segment;
        if (newSegment && !newSegment.localRefs) {
            newSegment.localRefs = new localReference_1.LocalReferenceCollection(newSegment);
        }
        for (const ref of refsToSlide) {
            (_b = (_a = ref.callbacks) === null || _a === void 0 ? void 0 : _a.beforeSlide) === null || _b === void 0 ? void 0 : _b.call(_a);
            const removedRef = segment.localRefs.removeLocalRef(ref);
            (0, common_utils_1.assert)(ref === removedRef, 0x2f3 /* Ref not in the segment localRefs */);
            if (!newSegment) {
                // No valid segments (all nodes removed or not yet created)
                ref.segment = undefined;
                ref.offset = 0;
            }
            else {
                ref.segment = newSegment;
                ref.offset = (_c = newSegoff.offset) !== null && _c !== void 0 ? _c : 0;
                (0, common_utils_1.assert)(!!newSegment.localRefs, 0x2f4 /* localRefs must be allocated */);
                newSegment.localRefs.addLocalRef(ref);
            }
            (_e = (_d = ref.callbacks) === null || _d === void 0 ? void 0 : _d.afterSlide) === null || _e === void 0 ? void 0 : _e.call(_d);
        }
        // TODO is it required to update the path lengths?
        if (newSegment) {
            this.blockUpdatePathLengths(newSegment.parent, constants_1.TreeMaintenanceSequenceNumber, constants_1.LocalClientId);
        }
    }
    updateSegmentRefsAfterMarkRemoved(segment, pending) {
        if (!segment.localRefs || segment.localRefs.empty) {
            return;
        }
        const refsToSlide = [];
        const refsToStay = [];
        for (const lref of segment.localRefs) {
            if ((0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.StayOnRemove)) {
                refsToStay.push(lref);
            }
            else if ((0, referencePositions_1.refTypeIncludesFlag)(lref, ops_1.ReferenceType.SlideOnRemove)) {
                if (pending) {
                    refsToStay.push(lref);
                }
                else {
                    refsToSlide.push(lref);
                }
            }
        }
        // Rethink implementation of keeping and sliding refs once other reference
        // changes are complete. This works but is fragile and possibly slow.
        if (!pending) {
            this.slideReferences(segment, refsToSlide);
        }
        segment.localRefs.clear();
        for (const lref of refsToStay) {
            lref.segment = segment;
            segment.localRefs.addLocalRef(lref);
        }
    }
    blockLength(node, refSeq, clientId) {
        if ((this.collabWindow.collaborating) && (clientId !== this.collabWindow.clientId)) {
            return node.partialLengths.getPartialLength(refSeq, clientId);
        }
        else {
            return node.cachedLength;
        }
    }
    nodeLength(node, refSeq, clientId) {
        if ((!this.collabWindow.collaborating) || (this.collabWindow.clientId === clientId)) {
            // Local client sees all segments, even when collaborating
            if (!node.isLeaf()) {
                return node.cachedLength;
            }
            else {
                return this.localNetLength(node);
            }
        }
        else {
            // Sequence number within window
            if (!node.isLeaf()) {
                return node.partialLengths.getPartialLength(refSeq, clientId);
            }
            else {
                const segment = node;
                const removalInfo = toRemovalInfo(segment);
                if (removalInfo !== undefined
                    && removalInfo.removedSeq !== constants_1.UnassignedSequenceNumber
                    && removalInfo.removedSeq <= refSeq) {
                    // this segment is a tombstone eligible for zamboni
                    // so should never be considered, as it may not exist
                    // on other clients
                    return undefined;
                }
                if (((segment.clientId === clientId) ||
                    ((segment.seq !== constants_1.UnassignedSequenceNumber) && (segment.seq <= refSeq)))) {
                    // Segment happened by reference sequence number or segment from requesting client
                    if (removalInfo !== undefined) {
                        if (removalInfo.removedClientIds.includes(clientId)) {
                            return 0;
                        }
                        else {
                            return segment.cachedLength;
                        }
                    }
                    else {
                        return segment.cachedLength;
                    }
                }
                else {
                    // the segment was inserted and removed before the
                    // this context, so it will never exist for this
                    // context
                    if (removalInfo !== undefined
                        && removalInfo.removedSeq !== constants_1.UnassignedSequenceNumber) {
                        return undefined;
                    }
                    // Segment invisible to client at reference sequence number/branch id/client id of op
                    return 0;
                }
            }
        }
    }
    addMinSeqListener(minRequired, onMinGE) {
        if (!this.minSeqListeners) {
            this.minSeqListeners = new collections_1.Heap([], minListenerComparer);
        }
        this.minSeqListeners.add({ minRequired, onMinGE });
    }
    notifyMinSeqListeners() {
        if (this.minSeqListeners) {
            while ((this.minSeqListeners.count() > 0) &&
                (this.minSeqListeners.peek().minRequired <= this.collabWindow.minSeq)) {
                const minListener = this.minSeqListeners.get();
                minListener.onMinGE(this.collabWindow.minSeq);
            }
        }
    }
    setMinSeq(minSeq) {
        (0, common_utils_1.assert)(minSeq <= this.collabWindow.currentSeq, 0x04e);
        // Only move forward
        (0, common_utils_1.assert)(this.collabWindow.minSeq <= minSeq, 0x04f /* "minSeq of collab window > target minSeq!" */);
        if (minSeq > this.collabWindow.minSeq) {
            this.collabWindow.minSeq = minSeq;
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
            this.notifyMinSeqListeners();
        }
    }
    referencePositionToLocalPosition(refPos, refSeq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        const seg = refPos.getSegment();
        if (seg && seg.parent) {
            const offset = !seg.removedSeq ? refPos.getOffset() : 0;
            return offset + this.getPosition(seg, refSeq, clientId);
        }
        return localReference_1.LocalReference.DetachedPosition;
    }
    getStackContext(startPos, clientId, rangeLabels) {
        const searchInfo = {
            mergeTree: this,
            stacks: (0, properties_1.createMap)(),
            rangeLabels,
        };
        this.search(startPos, constants_1.UniversalSequenceNumber, clientId, { leaf: recordRangeLeaf, shift: rangeShift }, searchInfo);
        return searchInfo.stacks;
    }
    // TODO: filter function
    findTile(startPos, clientId, tileLabel, posPrecedesTile = true) {
        const searchInfo = {
            mergeTree: this,
            posPrecedesTile,
            tileLabel,
        };
        if (posPrecedesTile) {
            this.search(startPos, constants_1.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        else {
            this.backwardSearch(startPos, constants_1.UniversalSequenceNumber, clientId, { leaf: recordTileStart, shift: tileShift }, searchInfo);
        }
        if (searchInfo.tile) {
            let pos;
            if (searchInfo.tile.isLeaf()) {
                const marker = searchInfo.tile;
                pos = this.getPosition(marker, constants_1.UniversalSequenceNumber, clientId);
            }
            else {
                const localRef = searchInfo.tile;
                pos = localRef.toPosition();
            }
            return { tile: searchInfo.tile, pos };
        }
    }
    search(pos, refSeq, clientId, actions, clientData) {
        return this.searchBlock(this.root, pos, 0, refSeq, clientId, actions, clientData);
    }
    searchBlock(block, pos, segpos, refSeq, clientId, actions, clientData) {
        var _a;
        let _pos = pos;
        let _segpos = segpos;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = 0; childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            if ((!contains && _pos < len)
                || (contains && contains(child, _pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.searchBlock(child, _pos, _segpos, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, _segpos, refSeq, clientId, _pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, _segpos, refSeq, clientId, _pos, undefined, clientData);
                }
                _pos -= len;
                _segpos += len;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segpos, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    backwardSearch(pos, refSeq, clientId, actions, clientData) {
        const len = this.getLength(refSeq, clientId);
        if (pos > len) {
            return undefined;
        }
        return this.backwardSearchBlock(this.root, pos, len, refSeq, clientId, actions, clientData);
    }
    backwardSearchBlock(block, pos, segEnd, refSeq, clientId, actions, clientData) {
        var _a;
        let _segEnd = segEnd;
        const children = block.children;
        if (actions && actions.pre) {
            actions.pre(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
        const contains = actions && actions.contains;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            const segpos = _segEnd - len;
            if (((!contains) && (pos >= segpos)) ||
                (contains && contains(child, pos, refSeq, clientId, undefined, undefined, clientData))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    return this.backwardSearchBlock(child, pos, _segEnd, refSeq, clientId, actions, clientData);
                }
                else {
                    if (actions && actions.leaf) {
                        actions.leaf(child, segpos, refSeq, clientId, pos, -1, clientData);
                    }
                    return child;
                }
            }
            else {
                if (actions && actions.shift) {
                    actions.shift(child, segpos, refSeq, clientId, pos, undefined, clientData);
                }
                _segEnd = segpos;
            }
        }
        if (actions && actions.post) {
            actions.post(block, _segEnd, refSeq, clientId, undefined, undefined, clientData);
        }
    }
    updateRoot(splitNode) {
        if (splitNode !== undefined) {
            const newRoot = this.makeBlock(2);
            newRoot.assignChild(this.root, 0, false);
            newRoot.assignChild(splitNode, 1, false);
            this.root = newRoot;
            this.nodeUpdateOrdinals(this.root);
            this.nodeUpdateLengthNewStructure(this.root);
        }
    }
    /**
     * Assign sequence number to existing segment; update partial lengths to reflect the change
     * @param seq - sequence number given by server to pending segment
     */
    ackPendingSegment(opArgs) {
        const seq = opArgs.sequencedMessage.sequenceNumber;
        const pendingSegmentGroup = this.pendingSegments.dequeue();
        const nodesToUpdate = [];
        let overwrite = false;
        if (pendingSegmentGroup !== undefined) {
            const deltaSegments = [];
            pendingSegmentGroup.segments.map((pendingSegment) => {
                const overlappingRemove = !pendingSegment.ack(pendingSegmentGroup, opArgs, this);
                overwrite = overlappingRemove || overwrite;
                if (!overlappingRemove && opArgs.op.type === ops_1.MergeTreeDeltaType.REMOVE) {
                    this.updateSegmentRefsAfterMarkRemoved(pendingSegment, false);
                }
                if (MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(pendingSegment, seq);
                }
                if (!nodesToUpdate.includes(pendingSegment.parent)) {
                    nodesToUpdate.push(pendingSegment.parent);
                }
                deltaSegments.push({
                    segment: pendingSegment,
                });
            });
            if (this.mergeTreeMaintenanceCallback) {
                this.mergeTreeMaintenanceCallback({
                    deltaSegments,
                    operation: mergeTreeDeltaCallback_1.MergeTreeMaintenanceType.ACKNOWLEDGED,
                }, opArgs);
            }
            const clientId = this.collabWindow.clientId;
            for (const node of nodesToUpdate) {
                this.blockUpdatePathLengths(node, seq, clientId, overwrite);
                // NodeUpdatePathLengths(node, seq, clientId, true);
            }
        }
        if (MergeTree.options.zamboniSegments) {
            this.zamboniSegments();
        }
    }
    addToPendingList(segment, segmentGroup, localSeq) {
        let _segmentGroup = segmentGroup;
        if (_segmentGroup === undefined) {
            // TODO: review the cast
            _segmentGroup = { segments: [], localSeq };
            this.pendingSegments.enqueue(_segmentGroup);
        }
        segment.segmentGroups.enqueue(_segmentGroup);
        return _segmentGroup;
    }
    // TODO: error checking
    getMarkerFromId(id) {
        return this.idToSegment.get(id);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     * @param refseq - The reference sequence number at which to compute the position.
     * @param clientId - The client id with which to compute the position.
     */
    posFromRelativePos(relativePos, refseq = this.collabWindow.currentSeq, clientId = this.collabWindow.clientId) {
        let pos = -1;
        let marker;
        if (relativePos.id) {
            marker = this.getMarkerFromId(relativePos.id);
        }
        if (marker) {
            pos = this.getPosition(marker, refseq, clientId);
            if (!relativePos.before) {
                pos += marker.cachedLength;
                if (relativePos.offset !== undefined) {
                    pos += relativePos.offset;
                }
            }
            else {
                if (relativePos.offset !== undefined) {
                    pos -= relativePos.offset;
                }
            }
        }
        return pos;
    }
    insertSegments(pos, segments, refSeq, clientId, seq, opArgs) {
        this.ensureIntervalBoundary(pos, refSeq, clientId);
        const localSeq = seq === constants_1.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        this.blockInsert(pos, refSeq, clientId, seq, localSeq, segments);
        // opArgs == undefined => loading snapshot or test code
        if (this.mergeTreeDeltaCallback && opArgs !== undefined) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: ops_1.MergeTreeDeltaType.INSERT,
                deltaSegments: segments.map((segment) => ({ segment })),
            });
        }
        if (this.collabWindow.collaborating && MergeTree.options.zamboniSegments &&
            (seq !== constants_1.UnassignedSequenceNumber)) {
            this.zamboniSegments();
        }
    }
    insertAtReferencePosition(referencePosition, insertSegment, opArgs) {
        if (insertSegment.cachedLength === 0) {
            return;
        }
        if (insertSegment.parent
            || insertSegment.removedSeq
            || insertSegment.seq !== constants_1.UniversalSequenceNumber) {
            throw new Error("Cannot insert segment that has already been inserted.");
        }
        const rebalanceTree = (segment) => {
            // Blocks should never be left full
            // if the inserts makes the block full
            // then we need to walk up the chain of parents
            // and split the blocks until we find a block with
            // room
            let block = segment.parent;
            let ordinalUpdateNode = block;
            while (block !== undefined) {
                if (block.childCount >= exports.MaxNodesInBlock) {
                    const splitNode = this.split(block);
                    if (block === this.root) {
                        this.updateRoot(splitNode);
                        // Update root already updates all it's children ordinals
                        ordinalUpdateNode = undefined;
                    }
                    else {
                        this.insertChildNode(block.parent, splitNode, block.index + 1);
                        ordinalUpdateNode = splitNode.parent;
                        this.blockUpdateLength(block.parent, constants_1.UnassignedSequenceNumber, clientId);
                    }
                }
                else {
                    this.blockUpdateLength(block, constants_1.UnassignedSequenceNumber, clientId);
                }
                block = block.parent;
            }
            // Only update ordinals once, for all children,
            // on the path
            if (ordinalUpdateNode) {
                this.nodeUpdateOrdinals(ordinalUpdateNode);
            }
        };
        const clientId = this.collabWindow.clientId;
        const refSegment = referencePosition.getSegment();
        const refOffset = referencePosition.getOffset();
        const refSegLen = this.nodeLength(refSegment, this.collabWindow.currentSeq, clientId);
        let startSeg = refSegment;
        // if the change isn't at a boundary, we need to split the segment
        if (refOffset !== 0 && refSegLen !== undefined && refSegLen !== 0) {
            const splitSeg = this.splitLeafSegment(refSegment, refOffset);
            (0, common_utils_1.assert)(!!splitSeg.next, 0x050 /* "Next segment changes are undefined!" */);
            this.insertChildNode(refSegment.parent, splitSeg.next, refSegment.index + 1);
            rebalanceTree(splitSeg.next);
            startSeg = splitSeg.next;
        }
        // walk back from the segment, to see if there is a previous tie break seg
        this.leftExcursion(startSeg, (backSeg) => {
            if (!backSeg.isLeaf()) {
                return true;
            }
            const backLen = this.nodeLength(backSeg, this.collabWindow.currentSeq, clientId);
            // ignore removed segments
            if (backLen === undefined) {
                return true;
            }
            // Find the nearest 0 length seg we can insert over, as all other inserts
            // go near to far
            if (backLen === 0) {
                if (this.breakTie(0, backSeg, constants_1.UnassignedSequenceNumber)) {
                    startSeg = backSeg;
                }
                return true;
            }
            return false;
        });
        if (this.collabWindow.collaborating) {
            insertSegment.localSeq = ++this.collabWindow.localSeq;
            insertSegment.seq = constants_1.UnassignedSequenceNumber;
        }
        else {
            insertSegment.seq = constants_1.UniversalSequenceNumber;
        }
        insertSegment.clientId = clientId;
        if (Marker.is(insertSegment)) {
            const markerId = insertSegment.getId();
            if (markerId) {
                this.mapIdToSegment(markerId, insertSegment);
            }
        }
        this.insertChildNode(startSeg.parent, insertSegment, startSeg.index);
        rebalanceTree(insertSegment);
        if (this.mergeTreeDeltaCallback) {
            this.mergeTreeDeltaCallback(opArgs, {
                deltaSegments: [{ segment: insertSegment }],
                operation: ops_1.MergeTreeDeltaType.INSERT,
            });
        }
        if (this.collabWindow.collaborating) {
            this.addToPendingList(insertSegment, undefined, insertSegment.localSeq);
        }
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence. The client ref seq must be above the minimum sequence number
     * or the return value will be undefined.
     * Generally this method is used in conjunction with signals which provide
     * point in time values for the below parameters, and is useful for things
     * like displaying user position. It should not be used with persisted values
     * as persisted values will quickly become invalid as the remoteClientRefSeq
     * moves below the minimum sequence number
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        if (remoteClientRefSeq < this.collabWindow.minSeq) {
            return undefined;
        }
        const segmentInfo = this.getContainingSegment(remoteClientPosition, remoteClientRefSeq, remoteClientId);
        const segwindow = this.getCollabWindow();
        if (segmentInfo && segmentInfo.segment) {
            const segmentPosition = this.getPosition(segmentInfo.segment, segwindow.currentSeq, segwindow.clientId);
            return segmentPosition + segmentInfo.offset;
        }
        else {
            if (remoteClientPosition === this.getLength(remoteClientRefSeq, remoteClientId)) {
                return this.getLength(segwindow.currentSeq, segwindow.clientId);
            }
        }
    }
    insertChildNode(block, child, childIndex) {
        (0, common_utils_1.assert)(block.childCount < exports.MaxNodesInBlock, 0x051 /* "Too many children on merge block!" */);
        for (let i = block.childCount; i > childIndex; i--) {
            block.children[i] = block.children[i - 1];
            block.children[i].index = i;
        }
        block.childCount++;
        block.assignChild(child, childIndex, false);
    }
    blockInsert(pos, refSeq, clientId, seq, localSeq, newSegments) {
        let segIsLocal = false;
        const checkSegmentIsLocal = (segment) => {
            if (segment.seq === constants_1.UnassignedSequenceNumber) {
                segIsLocal = true;
            }
            // Only need to look at first segment that follows finished node
            return false;
        };
        const continueFrom = (node) => {
            segIsLocal = false;
            this.rightExcursion(node, checkSegmentIsLocal);
            return segIsLocal;
        };
        let segmentGroup;
        const saveIfLocal = (locSegment) => {
            // Save segment so can assign sequence number when acked by server
            if (this.collabWindow.collaborating) {
                if ((locSegment.seq === constants_1.UnassignedSequenceNumber) && (clientId === this.collabWindow.clientId)) {
                    segmentGroup = this.addToPendingList(locSegment, segmentGroup, localSeq);
                    // eslint-disable-next-line @typescript-eslint/brace-style
                }
                // LocSegment.seq === 0 when coming from SharedSegmentSequence.loadBody()
                // In all other cases this has to be true (checked by addToLRUSet):
                // locSegment.seq > this.collabWindow.currentSeq
                else if ((locSegment.seq > this.collabWindow.minSeq) &&
                    MergeTree.options.zamboniSegments) {
                    this.addToLRUSet(locSegment, locSegment.seq);
                }
            }
        };
        const onLeaf = (segment, _pos, context) => {
            const segmentChanges = {};
            if (segment) {
                // Insert before segment
                segmentChanges.replaceCurrent = context.candidateSegment;
                segmentChanges.next = segment;
            }
            else {
                segmentChanges.next = context.candidateSegment;
            }
            return segmentChanges;
        };
        // TODO: build tree from segs and insert all at once
        let insertPos = pos;
        for (const newSegment of newSegments) {
            segIsLocal = false;
            if (newSegment.cachedLength > 0) {
                newSegment.seq = seq;
                newSegment.localSeq = localSeq;
                newSegment.clientId = clientId;
                if (Marker.is(newSegment)) {
                    const markerId = newSegment.getId();
                    if (markerId) {
                        this.mapIdToSegment(markerId, newSegment);
                    }
                }
                const splitNode = this.insertingWalk(this.root, insertPos, refSeq, clientId, seq, { leaf: onLeaf, candidateSegment: newSegment, continuePredicate: continueFrom });
                if (newSegment.parent === undefined) {
                    throw new Error(`MergeTree insert failed: ${JSON.stringify({
                        currentSeq: this.collabWindow.currentSeq,
                        minSeq: this.collabWindow.minSeq,
                        segSeq: newSegment.seq,
                    })}`);
                }
                this.updateRoot(splitNode);
                saveIfLocal(newSegment);
                insertPos += newSegment.cachedLength;
            }
        }
    }
    ensureIntervalBoundary(pos, refSeq, clientId) {
        const splitNode = this.insertingWalk(this.root, pos, refSeq, clientId, constants_1.TreeMaintenanceSequenceNumber, { leaf: this.splitLeafSegment });
        this.updateRoot(splitNode);
    }
    // Assume called only when pos == len
    breakTie(pos, node, seq) {
        var _a;
        if (node.isLeaf()) {
            if (pos === 0) {
                // normalize the seq numbers
                // if the new seg is local (UnassignedSequenceNumber) give it the highest possible
                // seq for comparison, as it will get a seq higher than any other seq once sequences
                // if the current seg is local (UnassignedSequenceNumber) give it the second highest
                // possible seq, as the highest is reserved for the previous.
                const newSeq = seq === constants_1.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER : seq;
                const segSeq = node.seq === constants_1.UnassignedSequenceNumber ? Number.MAX_SAFE_INTEGER - 1 : (_a = node.seq) !== null && _a !== void 0 ? _a : 0;
                return newSeq > segSeq;
            }
            return false;
        }
        else {
            return true;
        }
    }
    // Visit segments starting from node's left siblings, then up to node's parent
    leftExcursion(node, leafAction) {
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let _node;
            let matchedStart = false;
            for (childIndex = parent.childCount - 1; childIndex >= 0; childIndex--) {
                _node = children[childIndex];
                if (matchedStart) {
                    if (!_node.isLeaf()) {
                        const childBlock = _node;
                        go = this.nodeMapReverse(childBlock, leafAction, 0, constants_1.UniversalSequenceNumber, this.collabWindow.clientId);
                    }
                    else {
                        go = leafAction(_node, 0, constants_1.UniversalSequenceNumber, this.collabWindow.clientId, 0, 0, undefined);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === _node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    /**
     * Visit segments starting from node's right siblings, then up to node's parent.
     * All segments past `node` are visited, regardless of their visibility.
     */
    rightExcursion(node, leafAction) {
        let go = true;
        let startNode = node;
        let parent = startNode.parent;
        while (parent) {
            const children = parent.children;
            let childIndex;
            let _node;
            let matchedStart = false;
            for (childIndex = 0; childIndex < parent.childCount; childIndex++) {
                _node = children[childIndex];
                if (matchedStart) {
                    if (!_node.isLeaf()) {
                        const childBlock = _node;
                        go = this.walkAllSegments(childBlock, leafAction);
                    }
                    else {
                        go = leafAction(_node);
                    }
                    if (!go) {
                        return;
                    }
                }
                else {
                    matchedStart = (startNode === _node);
                }
            }
            startNode = parent;
            parent = parent.parent;
        }
    }
    insertingWalk(block, pos, refSeq, clientId, seq, context) {
        let _pos = pos;
        const children = block.children;
        let childIndex;
        let child;
        let newNode;
        let fromSplit;
        for (childIndex = 0; childIndex < block.childCount; childIndex++) {
            child = children[childIndex];
            const len = this.nodeLength(child, refSeq, clientId);
            if (len === undefined) {
                // if the seg len in undefined, the segment
                // will be removed, so should just be skipped for now
                continue;
            }
            if ((_pos < len) || ((_pos === len) && this.breakTie(_pos, child, seq))) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    const childBlock = child;
                    // Internal node
                    const splitNode = this.insertingWalk(childBlock, _pos, refSeq, clientId, seq, context);
                    if (splitNode === undefined) {
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        else {
                            this.blockUpdateLength(block, seq, clientId);
                        }
                        return undefined;
                    }
                    else if (splitNode === MergeTree.theUnfinishedNode) {
                        _pos -= len; // Act as if shifted segment
                        continue;
                    }
                    else {
                        newNode = splitNode;
                        fromSplit = splitNode;
                        childIndex++; // Insert after
                    }
                }
                else {
                    const segment = child;
                    const segmentChanges = context.leaf(segment, _pos, context);
                    if (segmentChanges.replaceCurrent) {
                        block.assignChild(segmentChanges.replaceCurrent, childIndex, false);
                        segmentChanges.replaceCurrent.ordinal = child.ordinal;
                    }
                    if (segmentChanges.next) {
                        newNode = segmentChanges.next;
                        childIndex++; // Insert after
                    }
                    else {
                        // No change
                        if (context.structureChange) {
                            this.nodeUpdateLengthNewStructure(block);
                        }
                        return undefined;
                    }
                }
                break;
            }
            else {
                _pos -= len;
            }
        }
        if (!newNode) {
            if (_pos === 0) {
                if ((seq !== constants_1.UnassignedSequenceNumber) && context.continuePredicate &&
                    context.continuePredicate(block)) {
                    return MergeTree.theUnfinishedNode;
                }
                else {
                    const segmentChanges = context.leaf(undefined, _pos, context);
                    newNode = segmentChanges.next;
                    // Assert segmentChanges.replaceCurrent === undefined
                }
            }
        }
        if (newNode) {
            for (let i = block.childCount; i > childIndex; i--) {
                block.children[i] = block.children[i - 1];
                block.children[i].index = i;
            }
            block.assignChild(newNode, childIndex, false);
            block.childCount++;
            block.setOrdinal(newNode, childIndex);
            if (block.childCount < exports.MaxNodesInBlock) {
                if (fromSplit) {
                    this.nodeUpdateOrdinals(fromSplit);
                }
                if (context.structureChange) {
                    this.nodeUpdateLengthNewStructure(block);
                }
                else {
                    this.blockUpdateLength(block, seq, clientId);
                }
                return undefined;
            }
            else {
                // Don't update ordinals because higher block will do it
                return this.split(block);
            }
        }
        else {
            return undefined;
        }
    }
    split(node) {
        const halfCount = exports.MaxNodesInBlock / 2;
        const newNode = this.makeBlock(halfCount);
        node.childCount = halfCount;
        // Update ordinals to reflect lowered child count
        this.nodeUpdateOrdinals(node);
        for (let i = 0; i < halfCount; i++) {
            newNode.assignChild(node.children[halfCount + i], i, false);
            node.children[halfCount + i] = undefined;
        }
        this.nodeUpdateLengthNewStructure(node);
        this.nodeUpdateLengthNewStructure(newNode);
        return newNode;
    }
    nodeUpdateOrdinals(block) {
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            block.setOrdinal(child, i);
            if (!child.isLeaf()) {
                this.nodeUpdateOrdinals(child);
            }
        }
    }
    /**
     * Annotate a range with properties
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     * @param refSeq - The reference sequence number to use to apply the annotate
     * @param clientId - The id of the client making the annotate
     * @param seq - The sequence number of the annotate operation
     * @param opArgs - The op args for the annotate op. this is passed to the merge tree callback if there is one
     */
    annotateRange(start, end, props, combiningOp, refSeq, clientId, seq, opArgs) {
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        const deltaSegments = [];
        const localSeq = seq === constants_1.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        let segmentGroup;
        const annotateSegment = (segment) => {
            const propertyDeltas = segment.addProperties(props, combiningOp, seq, this.collabWindow);
            deltaSegments.push({ segment, propertyDeltas });
            if (this.collabWindow.collaborating) {
                if (seq === constants_1.UnassignedSequenceNumber) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
            }
            return true;
        };
        this.mapRange({ leaf: annotateSegment }, refSeq, clientId, undefined, start, end);
        // OpArgs == undefined => test code
        if (this.mergeTreeDeltaCallback && deltaSegments.length > 0) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: ops_1.MergeTreeDeltaType.ANNOTATE,
                deltaSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== constants_1.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
    }
    markRangeRemoved(start, end, refSeq, clientId, seq, overwrite = false, opArgs) {
        let _overwrite = overwrite;
        this.ensureIntervalBoundary(start, refSeq, clientId);
        this.ensureIntervalBoundary(end, refSeq, clientId);
        let segmentGroup;
        const removedSegments = [];
        const segmentsWithRefs = [];
        const localSeq = seq === constants_1.UnassignedSequenceNumber ? ++this.collabWindow.localSeq : undefined;
        const markRemoved = (segment, pos, _start, _end) => {
            const existingRemovalInfo = toRemovalInfo(segment);
            if (existingRemovalInfo !== undefined) {
                _overwrite = true;
                if (existingRemovalInfo.removedSeq === constants_1.UnassignedSequenceNumber) {
                    // we removed this locally, but someone else removed it first
                    // so put them at the head of the list
                    // the list isn't ordered, but we
                    // keep first removal at the head.
                    existingRemovalInfo.removedClientIds.unshift(clientId);
                    existingRemovalInfo.removedSeq = seq;
                    segment.localRemovedSeq = undefined;
                }
                else {
                    // Do not replace earlier sequence number for remove
                    existingRemovalInfo.removedClientIds.push(clientId);
                }
            }
            else {
                segment.removedClientIds = [clientId];
                segment.removedSeq = seq;
                segment.localRemovedSeq = localSeq;
                removedSegments.push({ segment });
            }
            if (segment.localRefs && !segment.localRefs.empty) {
                segmentsWithRefs.push(segment);
            }
            // Save segment so can assign removed sequence number when acked by server
            if (this.collabWindow.collaborating) {
                if (segment.removedSeq === constants_1.UnassignedSequenceNumber && clientId === this.collabWindow.clientId) {
                    segmentGroup = this.addToPendingList(segment, segmentGroup, localSeq);
                }
                else {
                    if (MergeTree.options.zamboniSegments) {
                        this.addToLRUSet(segment, seq);
                    }
                }
            }
            return true;
        };
        const afterMarkRemoved = (node, pos, _start, _end) => {
            if (_overwrite) {
                this.nodeUpdateLengthNewStructure(node);
            }
            else {
                this.blockUpdateLength(node, seq, clientId);
            }
            return true;
        };
        this.mapRange({ leaf: markRemoved, post: afterMarkRemoved }, refSeq, clientId, undefined, start, end);
        const pending = this.collabWindow.collaborating && clientId === this.collabWindow.clientId;
        for (const segment of segmentsWithRefs) {
            this.updateSegmentRefsAfterMarkRemoved(segment, pending);
        }
        // opArgs == undefined => test code
        if (this.mergeTreeDeltaCallback && removedSegments.length > 0) {
            this.mergeTreeDeltaCallback(opArgs, {
                operation: ops_1.MergeTreeDeltaType.REMOVE,
                deltaSegments: removedSegments,
            });
        }
        if (this.collabWindow.collaborating && (seq !== constants_1.UnassignedSequenceNumber)) {
            if (MergeTree.options.zamboniSegments) {
                this.zamboniSegments();
            }
        }
    }
    nodeUpdateLengthNewStructure(node, recur = false) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating) {
            node.partialLengths = partialLengths_1.PartialSequenceLengths.combine(this, node, this.collabWindow, recur);
        }
    }
    removeLocalReferencePosition(lref) {
        var _a;
        const segment = lref.getSegment();
        if (segment) {
            const removedRefs = (_a = segment === null || segment === void 0 ? void 0 : segment.localRefs) === null || _a === void 0 ? void 0 : _a.removeLocalRef(lref);
            if (removedRefs !== undefined) {
                this.blockUpdatePathLengths(segment.parent, constants_1.TreeMaintenanceSequenceNumber, constants_1.LocalClientId);
            }
            return removedRefs;
        }
    }
    createLocalReferencePosition(segment, offset, refType, properties, client) {
        var _a;
        if (isRemoved(segment)) {
            if (!(0, referencePositions_1.refTypeIncludesFlag)(refType, ops_1.ReferenceType.SlideOnRemove | ops_1.ReferenceType.Transient)) {
                throw new container_utils_1.UsageError("Can only create SlideOnRemove or Transient local reference position on a removed segment");
            }
        }
        const localRefs = (_a = segment.localRefs) !== null && _a !== void 0 ? _a : new localReference_1.LocalReferenceCollection(segment);
        segment.localRefs = localRefs;
        const segRef = localRefs.createLocalRef(offset, refType, properties, client);
        this.blockUpdatePathLengths(segment.parent, constants_1.TreeMaintenanceSequenceNumber, constants_1.LocalClientId);
        return segRef;
    }
    /**
     * @deprecated - use removeLocalReferencePosition
     */
    removeLocalReference(segment, lref) {
        if (segment.localRefs) {
            const removedRef = segment.localRefs.removeLocalRef(lref);
            if (removedRef) {
                this.blockUpdatePathLengths(segment.parent, constants_1.TreeMaintenanceSequenceNumber, constants_1.LocalClientId);
            }
        }
    }
    /**
     * @deprecated - use createLocalReference
     */
    addLocalReference(lref) {
        const segment = lref.segment;
        let localRefs = segment.localRefs;
        if (!localRefs) {
            localRefs = new localReference_1.LocalReferenceCollection(segment);
            segment.localRefs = localRefs;
        }
        localRefs.addLocalRef(lref);
        this.blockUpdatePathLengths(segment.parent, constants_1.TreeMaintenanceSequenceNumber, constants_1.LocalClientId);
    }
    blockUpdate(block) {
        var _a;
        let len = 0;
        const hierBlock = block.hierBlock();
        if (hierBlock) {
            hierBlock.rightmostTiles = (0, properties_1.createMap)();
            hierBlock.leftmostTiles = (0, properties_1.createMap)();
            hierBlock.rangeStacks = {};
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            len += (_a = nodeTotalLength(this, child)) !== null && _a !== void 0 ? _a : 0;
            if (hierBlock) {
                hierBlock.addNodeReferences(this, child);
            }
            if (this.blockUpdateActions) {
                this.blockUpdateActions.child(block, i);
            }
        }
        block.cachedLength = len;
    }
    blockUpdatePathLengths(startBlock, seq, clientId, newStructure = false) {
        let block = startBlock;
        while (block !== undefined) {
            if (newStructure) {
                this.nodeUpdateLengthNewStructure(block);
            }
            else {
                this.blockUpdateLength(block, seq, clientId);
            }
            block = block.parent;
        }
    }
    blockUpdateLength(node, seq, clientId) {
        this.blockUpdate(node);
        if (this.collabWindow.collaborating
            && seq !== constants_1.UnassignedSequenceNumber
            && seq !== constants_1.TreeMaintenanceSequenceNumber) {
            if (node.partialLengths !== undefined
                && MergeTree.options.incrementalUpdate
                && clientId !== constants_1.NonCollabClient) {
                node.partialLengths.update(this, node, seq, clientId, this.collabWindow);
            }
            else {
                node.partialLengths = partialLengths_1.PartialSequenceLengths.combine(this, node, this.collabWindow);
            }
        }
    }
    map(actions, refSeq, clientId, accum) {
        // TODO: optimize to avoid comparisons
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum);
    }
    mapRange(actions, refSeq, clientId, accum, start, end, splitRange = false) {
        if (splitRange) {
            if (start) {
                this.ensureIntervalBoundary(start, refSeq, clientId);
            }
            if (end) {
                this.ensureIntervalBoundary(end, refSeq, clientId);
            }
        }
        this.nodeMap(this.root, actions, 0, refSeq, clientId, accum, start, end);
    }
    incrementalBlockMap(stateStack) {
        var _a;
        while (!stateStack.empty()) {
            // We already check the stack is not empty
            const state = stateStack.top();
            if (state.op !== IncrementalExecOp.Go) {
                return;
            }
            if (state.childIndex === 0) {
                if (state.start === undefined) {
                    state.start = 0;
                }
                if (state.end === undefined) {
                    state.end = this.blockLength(state.block, state.refSeq, state.clientId);
                }
                if (state.actions.pre) {
                    state.actions.pre(state);
                }
            }
            if ((state.op === IncrementalExecOp.Go) && (state.childIndex < state.block.childCount)) {
                const child = state.block.children[state.childIndex];
                const len = (_a = this.nodeLength(child, state.refSeq, state.clientId)) !== null && _a !== void 0 ? _a : 0;
                if ((len > 0) && (state.start < len) && (state.end > 0)) {
                    if (!child.isLeaf()) {
                        const childState = new IncrementalMapState(child, state.actions, state.pos, state.refSeq, state.clientId, state.context, state.start, state.end, 0);
                        stateStack.push(childState);
                    }
                    else {
                        state.actions.leaf(child, state);
                    }
                }
                state.pos += len;
                state.start -= len;
                state.end -= len;
                state.childIndex++;
            }
            else {
                if (state.childIndex === state.block.childCount) {
                    if ((state.op === IncrementalExecOp.Go) && state.actions.post) {
                        state.actions.post(state);
                    }
                    stateStack.pop();
                }
            }
        }
    }
    nodeMap(node, actions, pos, refSeq, clientId, accum, start, end) {
        var _a;
        let _start = start;
        let _end = end;
        let _pos = pos;
        if (_start === undefined) {
            _start = 0;
        }
        if (_end === undefined) {
            _end = this.blockLength(node, refSeq, clientId);
        }
        let go = true;
        if (actions.pre) {
            go = actions.pre(node, _pos, refSeq, clientId, _start, _end, accum);
            if (!go) {
                // Cancel this node but not entire traversal
                return true;
            }
        }
        const children = node.children;
        for (let childIndex = 0; childIndex < node.childCount; childIndex++) {
            const child = children[childIndex];
            const len = (_a = this.nodeLength(child, refSeq, clientId)) !== null && _a !== void 0 ? _a : 0;
            if (go && (_end > 0) && (len > 0) && (_start < len)) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMap(child, actions, _pos, refSeq, clientId, accum, _start, _end);
                    }
                }
                else {
                    if (actions.leaf) {
                        go = actions.leaf(child, _pos, refSeq, clientId, _start, _end, accum);
                    }
                }
            }
            if (!go) {
                break;
            }
            if (actions.shift) {
                actions.shift(child, _pos, refSeq, clientId, _start, _end, accum);
            }
            _pos += len;
            _start -= len;
            _end -= len;
        }
        if (go && actions.post) {
            go = actions.post(node, _pos, refSeq, clientId, _start, _end, accum);
        }
        return go;
    }
    // Invokes the leaf action for all segments.  Note that *all* segments are visited
    // regardless of if they would be visible to the current `clientId` and `refSeq`.
    walkAllSegments(block, action, accum) {
        let go = true;
        const children = block.children;
        for (let childIndex = 0; go && childIndex < block.childCount; childIndex++) {
            const child = children[childIndex];
            go = child.isLeaf()
                ? action(child, accum)
                : this.walkAllSegments(child, action, accum);
        }
        return go;
    }
    // Straight call every segment; goes until leaf action returns false
    nodeMapReverse(block, leafAction, pos, refSeq, clientId) {
        let go = true;
        const children = block.children;
        for (let childIndex = block.childCount - 1; childIndex >= 0; childIndex--) {
            const child = children[childIndex];
            if (go) {
                // Found entry containing pos
                if (!child.isLeaf()) {
                    if (go) {
                        go = this.nodeMapReverse(child, leafAction, pos, refSeq, clientId);
                    }
                }
                else {
                    go = leafAction(child, pos, refSeq, clientId, 0, 0, undefined);
                }
            }
            if (!go) {
                break;
            }
        }
        return go;
    }
}
exports.MergeTree = MergeTree;
MergeTree.zamboniSegmentsMaxCount = 2;
MergeTree.options = {
    incrementalUpdate: true,
    insertAfterRemovedSegs: true,
    zamboniSegments: true,
};
MergeTree.theUnfinishedNode = { childCount: -1 };

},{"./collections":145,"./constants":146,"./localReference":148,"./mergeTreeDeltaCallback":150,"./mergeTreeTracking":151,"./ops":153,"./partialLengths":154,"./properties":155,"./referencePositions":156,"./segmentGroupCollection":157,"./segmentPropertiesManager":158,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87}],150:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeTreeMaintenanceType = void 0;
/**
 * Enum-like constant defining the types of "maintenance" events on a merge tree.
 * Maintenance events correspond to structural segment changes or acks of pending segments.
 *
 * Note: these values are assigned negative integers to avoid clashing with `MergeTreeDeltaType`.
 */
exports.MergeTreeMaintenanceType = {
    /**
     * Notification that a segment "append" has occurred, i.e. two adjacent segments have been merged.
     * BEWARE: `deltaSegments` on the corresponding event will contain both the merged segment and the latter
     * segment, pre-merge.
     * For example, if the merge tree originally had two adjacent segments [A][B] and called A.append(B) to get
     * segment [AB], `deltaSegments` would contain [AB] and [B].
     */
    APPEND: -1,
    /**
     * Notification that a segment has been split in two.
     * `deltaSegments` on the corresponding event will contain the resulting two segments.
     */
    SPLIT: -2,
    /**
     * Notification that a segment has been unlinked (i.e. removed) from the MergeTree.
     * This occurs on leaf segments during Zamboni when the segment's tracking collection is empty
     * (e.g., not being tracked for undo/redo).
     * It also occurs on internal merge tree segments when re-packing children to maintain tree balancing invariants.
     */
    UNLINK: -3,
    /**
     * Notification that a local change has been acknowledged by the server.
     * This means that it has made the round trip to the server and has had a sequence number assigned.
     */
    ACKNOWLEDGED: -4,
};

},{}],151:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrackingGroupCollection = exports.TrackingGroup = void 0;
const sortedSegmentSet_1 = require("./sortedSegmentSet");
class TrackingGroup {
    constructor() {
        this.segmentSet = new sortedSegmentSet_1.SortedSegmentSet();
    }
    get segments() {
        return this.segmentSet.items;
    }
    get size() {
        return this.segmentSet.size;
    }
    has(segment) {
        return this.segmentSet.has(segment);
    }
    link(segment) {
        if (!this.segmentSet.has(segment)) {
            this.segmentSet.addOrUpdate(segment);
            segment.trackingCollection.link(this);
        }
    }
    unlink(segment) {
        if (this.segmentSet.remove(segment)) {
            segment.trackingCollection.unlink(this);
        }
    }
}
exports.TrackingGroup = TrackingGroup;
class TrackingGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.trackingGroups = new Set();
    }
    link(trackingGroup) {
        if (trackingGroup) {
            if (!this.trackingGroups.has(trackingGroup)) {
                this.trackingGroups.add(trackingGroup);
            }
            if (!trackingGroup.has(this.segment)) {
                trackingGroup.link(this.segment);
            }
        }
    }
    unlink(trackingGroup) {
        if (trackingGroup.has(this.segment)) {
            trackingGroup.unlink(this.segment);
        }
        this.trackingGroups.delete(trackingGroup);
    }
    copyTo(segment) {
        this.trackingGroups.forEach((sg) => segment.trackingCollection.link(sg));
    }
    get empty() {
        return this.trackingGroups.size === 0;
    }
    matches(trackingCollection) {
        if (!trackingCollection
            || this.trackingGroups.size !== trackingCollection.trackingGroups.size) {
            return false;
        }
        for (const tg of this.trackingGroups.values()) {
            if (!trackingCollection.trackingGroups.has(tg)) {
                return false;
            }
        }
        return true;
    }
}
exports.TrackingGroupCollection = TrackingGroupCollection;

},{"./sortedSegmentSet":163}],152:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGroupOp = exports.createInsertOp = exports.createInsertSegmentOp = exports.createRemoveRangeOp = exports.createAnnotateRangeOp = exports.createAnnotateMarkerOp = void 0;
const ops_1 = require("./ops");
/**
 * Creates the op for annotating the markers with the provided properties
 * @param marker - The marker to annotate
 * @param props - The properties to annotate the marker with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateMarkerOp(marker, props, combiningOp) {
    const id = marker.getId();
    if (!id) {
        return undefined;
    }
    return {
        combiningOp,
        props,
        relativePos1: { id, before: true },
        relativePos2: { id },
        type: ops_1.MergeTreeDeltaType.ANNOTATE,
    };
}
exports.createAnnotateMarkerOp = createAnnotateMarkerOp;
/**
 * Creates the op for annotating the range with the provided properties
 * @param start - The inclusive start position of the range to annotate
 * @param end - The exclusive end position of the range to annotate
 * @param props - The properties to annotate the range with
 * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
 * @returns The annotate op
 */
function createAnnotateRangeOp(start, end, props, combiningOp) {
    return {
        combiningOp,
        pos1: start,
        pos2: end,
        props,
        type: ops_1.MergeTreeDeltaType.ANNOTATE,
    };
}
exports.createAnnotateRangeOp = createAnnotateRangeOp;
/**
 * Creates the op to remove a range
 *
 * @param start - The inclusive start of the range to remove
 * @param end - The exclusive end of the range to remove
 */
function createRemoveRangeOp(start, end) {
    return {
        pos1: start,
        pos2: end,
        type: ops_1.MergeTreeDeltaType.REMOVE,
    };
}
exports.createRemoveRangeOp = createRemoveRangeOp;
/**
 *
 * @param pos - The position to insert the segment at
 * @param segment - The segment to insert
 */
function createInsertSegmentOp(pos, segment) {
    return createInsertOp(pos, segment.toJSONObject());
}
exports.createInsertSegmentOp = createInsertSegmentOp;
function createInsertOp(pos, segSpec) {
    return {
        pos1: pos,
        seg: segSpec,
        type: ops_1.MergeTreeDeltaType.INSERT,
    };
}
exports.createInsertOp = createInsertOp;
/**
 *
 * @param ops - The ops to group
 */
function createGroupOp(...ops) {
    return {
        ops,
        type: ops_1.MergeTreeDeltaType.GROUP,
    };
}
exports.createGroupOp = createGroupOp;

},{"./ops":153}],153:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeTreeDeltaType = exports.ReferenceType = void 0;
var ReferenceType;
(function (ReferenceType) {
    ReferenceType[ReferenceType["Simple"] = 0] = "Simple";
    ReferenceType[ReferenceType["Tile"] = 1] = "Tile";
    ReferenceType[ReferenceType["NestBegin"] = 2] = "NestBegin";
    ReferenceType[ReferenceType["NestEnd"] = 4] = "NestEnd";
    ReferenceType[ReferenceType["RangeBegin"] = 16] = "RangeBegin";
    ReferenceType[ReferenceType["RangeEnd"] = 32] = "RangeEnd";
    ReferenceType[ReferenceType["SlideOnRemove"] = 64] = "SlideOnRemove";
    ReferenceType[ReferenceType["StayOnRemove"] = 128] = "StayOnRemove";
    ReferenceType[ReferenceType["Transient"] = 256] = "Transient";
})(ReferenceType = exports.ReferenceType || (exports.ReferenceType = {}));
// Note: Assigned positive integers to avoid clashing with MergeTreeMaintenanceType
exports.MergeTreeDeltaType = {
    INSERT: 0,
    REMOVE: 1,
    ANNOTATE: 2,
    GROUP: 3,
};

},{}],154:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PartialSequenceLengths = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const collections_1 = require("./collections");
const constants_1 = require("./constants");
const mergeTree_1 = require("./mergeTree");
/**
 * Returns the partial length whose sequence number is
 * the greatest sequence number within a that is
 * less than or equal to key.
 * @param a - array of partial segment lengths
 * @param key - sequence number
 */
function latestLEQ(a, key) {
    let best = -1;
    let lo = 0;
    let hi = a.length - 1;
    while (lo <= hi) {
        const mid = lo + Math.floor((hi - lo) / 2);
        if (a[mid].seq <= key) {
            if ((best < 0) || (a[best].seq < a[mid].seq)) {
                best = mid;
            }
            lo = mid + 1;
        }
        else {
            hi = mid - 1;
        }
    }
    return best;
}
/**
 * Keep track of partial sums of segment lengths for all sequence numbers
 * in the current collaboration window (if any).  Only used during active
 * collaboration.
 */
class PartialSequenceLengths {
    constructor(minSeq) {
        this.minSeq = minSeq;
        this.minLength = 0;
        this.segmentCount = 0;
        this.partialLengths = [];
        this.clientSeqNumbers = [];
    }
    static combine(mergeTree, block, collabWindow, recur = false) {
        return PartialSequenceLengths.combineBranch(mergeTree, block, collabWindow, recur);
    }
    /**
     * Combine the partial lengths of block's children
     * @param block - an interior node; it is assumed that each interior node child of this block
     * has its partials up to date
     * @param collabWindow - segment window of the segment tree containing textSegmentBlock
     */
    static combineBranch(mergeTree, block, collabWindow, recur = false) {
        let combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
        PartialSequenceLengths.fromLeaves(combinedPartialLengths, block, collabWindow);
        let prevPartial;
        function cloneOverlapRemoveClients(oldTree) {
            if (!oldTree) {
                return undefined;
            }
            const newTree = new collections_1.RedBlackTree(mergeTree_1.compareNumbers);
            oldTree.map((bProp) => {
                newTree.put(bProp.data.clientId, Object.assign({}, bProp.data));
                return true;
            });
            return newTree;
        }
        function combineOverlapClients(a, b) {
            const overlapRemoveClientsA = a.overlapRemoveClients;
            if (overlapRemoveClientsA) {
                if (b.overlapRemoveClients) {
                    b.overlapRemoveClients.map((bProp) => {
                        const aProp = overlapRemoveClientsA.get(bProp.key);
                        if (aProp) {
                            aProp.data.seglen += bProp.data.seglen;
                        }
                        else {
                            overlapRemoveClientsA.put(bProp.data.clientId, Object.assign({}, bProp.data));
                        }
                        return true;
                    });
                }
            }
            else {
                a.overlapRemoveClients = cloneOverlapRemoveClients(b.overlapRemoveClients);
            }
        }
        function addNext(partialLength) {
            const seq = partialLength.seq;
            let pLen = 0;
            if (prevPartial) {
                if (prevPartial.seq === partialLength.seq) {
                    prevPartial.seglen += partialLength.seglen;
                    prevPartial.len += partialLength.seglen;
                    combineOverlapClients(prevPartial, partialLength);
                    return;
                }
                else {
                    pLen = prevPartial.len;
                    // Previous sequence number is finished
                    combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
                }
            }
            prevPartial = {
                clientId: partialLength.clientId,
                len: pLen + partialLength.seglen,
                overlapRemoveClients: cloneOverlapRemoveClients(partialLength.overlapRemoveClients),
                seglen: partialLength.seglen,
                seq,
            };
            combinedPartialLengths.partialLengths.push(prevPartial);
        }
        const childPartials = [];
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                if (recur) {
                    childBlock.partialLengths =
                        PartialSequenceLengths.combine(mergeTree, childBlock, collabWindow, true);
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                childPartials.push(childBlock.partialLengths);
            }
        }
        let childPartialsLen = childPartials.length;
        if (childPartialsLen !== 0) {
            // Some children are interior nodes
            if (combinedPartialLengths.partialLengths.length > 0) {
                // Some children were leaves; add combined partials from these segments
                childPartials.push(combinedPartialLengths);
                childPartialsLen++;
                combinedPartialLengths = new PartialSequenceLengths(collabWindow.minSeq);
            }
            const indices = new Array(childPartialsLen);
            const childPartialsCounts = new Array(childPartialsLen);
            for (let i = 0; i < childPartialsLen; i++) {
                indices[i] = 0;
                childPartialsCounts[i] = childPartials[i].partialLengths.length;
                combinedPartialLengths.minLength += childPartials[i].minLength;
                combinedPartialLengths.segmentCount += childPartials[i].segmentCount;
            }
            let outerIndexOfEarliest = 0;
            let earliestPartialLength;
            while (outerIndexOfEarliest >= 0) {
                outerIndexOfEarliest = -1;
                for (let k = 0; k < childPartialsLen; k++) {
                    // Find next earliest sequence number
                    if (indices[k] < childPartialsCounts[k]) {
                        const cpLen = childPartials[k].partialLengths[indices[k]];
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        if ((outerIndexOfEarliest < 0) || (cpLen.seq < earliestPartialLength.seq)) {
                            outerIndexOfEarliest = k;
                            earliestPartialLength = cpLen;
                        }
                    }
                }
                if (outerIndexOfEarliest >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    addNext(earliestPartialLength);
                    indices[outerIndexOfEarliest]++;
                }
            }
            // Add client entry for last partial, if any
            if (prevPartial) {
                combinedPartialLengths.addClientSeqNumberFromPartial(prevPartial);
            }
        }
        // TODO: incremental zamboni during build
        if (PartialSequenceLengths.options.zamboni) {
            combinedPartialLengths.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
        return combinedPartialLengths;
    }
    static fromLeaves(combinedPartialLengths, block, collabWindow) {
        combinedPartialLengths.minLength = 0;
        combinedPartialLengths.segmentCount = block.childCount;
        function seqLTE(seq, minSeq) {
            return seq !== undefined && seq !== constants_1.UnassignedSequenceNumber && seq <= minSeq;
        }
        for (let i = 0; i < block.childCount; i++) {
            const child = block.children[i];
            if (child.isLeaf()) {
                // Leaf segment
                const segment = child;
                if (seqLTE(segment.seq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength += segment.cachedLength;
                }
                else {
                    if (segment.seq !== constants_1.UnassignedSequenceNumber) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment);
                    }
                }
                const removalInfo = (0, mergeTree_1.toRemovalInfo)(segment);
                if (seqLTE(removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq, collabWindow.minSeq)) {
                    combinedPartialLengths.minLength -= segment.cachedLength;
                }
                else {
                    if (removalInfo !== undefined
                        && removalInfo.removedSeq !== constants_1.UnassignedSequenceNumber) {
                        PartialSequenceLengths.insertSegment(combinedPartialLengths, segment, removalInfo);
                    }
                }
            }
        }
        // Post-process correctly-ordered partials computing sums and creating
        // lists for each present client id
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        let prevLen = 0;
        for (let i = 0; i < seqPartialsLen; i++) {
            seqPartials[i].len = prevLen + seqPartials[i].seglen;
            prevLen = seqPartials[i].len;
            combinedPartialLengths.addClientSeqNumberFromPartial(seqPartials[i]);
        }
        if (PartialSequenceLengths.options.verify) {
            combinedPartialLengths.verify();
        }
    }
    static getOverlapClients(overlapClientIds, seglen) {
        const bst = new collections_1.RedBlackTree(mergeTree_1.compareNumbers);
        for (const clientId of overlapClientIds) {
            bst.put(clientId, { clientId, seglen });
        }
        return bst;
    }
    static accumulateRemoveClientOverlap(partialLength, overlapRemoveClientIds, seglen) {
        if (partialLength.overlapRemoveClients) {
            for (const clientId of overlapRemoveClientIds) {
                const overlapClientNode = partialLength.overlapRemoveClients.get(clientId);
                if (!overlapClientNode) {
                    partialLength.overlapRemoveClients.put(clientId, { clientId, seglen });
                }
                else {
                    overlapClientNode.data.seglen += seglen;
                }
            }
        }
        else {
            partialLength.overlapRemoveClients =
                PartialSequenceLengths.getOverlapClients(overlapRemoveClientIds, seglen);
        }
    }
    static insertSegment(combinedPartialLengths, segment, removalInfo) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let seq = segment.seq;
        let segmentLen = segment.cachedLength;
        let clientId = segment.clientId;
        let removeClientOverlap;
        if (removalInfo) {
            seq = removalInfo.removedSeq;
            segmentLen = -segmentLen;
            // this code still assume removed client id and
            // overlap clients are separate. so we need to pull
            // then apart first.
            clientId = removalInfo.removedClientIds[0];
            removeClientOverlap = removalInfo.removedClientIds.length > 1
                ? removalInfo.removedClientIds.slice(1)
                : undefined;
        }
        const seqPartials = combinedPartialLengths.partialLengths;
        const seqPartialsLen = seqPartials.length;
        // Find the first entry with sequence number greater or equal to seq
        let indexFirstGTE = 0;
        for (; indexFirstGTE < seqPartialsLen; indexFirstGTE++) {
            if (seqPartials[indexFirstGTE].seq >= seq) {
                break;
            }
        }
        if ((indexFirstGTE < seqPartialsLen) && (seqPartials[indexFirstGTE].seq === seq)) {
            seqPartials[indexFirstGTE].seglen += segmentLen;
            if (removeClientOverlap) {
                PartialSequenceLengths.accumulateRemoveClientOverlap(seqPartials[indexFirstGTE], removeClientOverlap, segmentLen);
            }
        }
        else {
            let pLen;
            if (removeClientOverlap) {
                const overlapClients = PartialSequenceLengths.getOverlapClients(removeClientOverlap, segmentLen);
                pLen = { seq, clientId, len: 0, seglen: segmentLen, overlapRemoveClients: overlapClients };
            }
            else {
                pLen = { seq, clientId, len: 0, seglen: segmentLen };
            }
            if (indexFirstGTE < seqPartialsLen) {
                // Shift entries with greater sequence numbers
                // TODO: investigate performance improvement using BST
                for (let k = seqPartialsLen; k > indexFirstGTE; k--) {
                    seqPartials[k] = seqPartials[k - 1];
                }
                seqPartials[indexFirstGTE] = pLen;
            }
            else {
                seqPartials.push(pLen);
            }
        }
    }
    static addSeq(partialLengths, seq, seqSeglen, clientId) {
        let seqPartialLen;
        let penultPartialLen;
        let leqIndex = latestLEQ(partialLengths, seq);
        if (leqIndex >= 0) {
            const pLen = partialLengths[leqIndex];
            if (pLen.seq === seq) {
                seqPartialLen = pLen;
                leqIndex = latestLEQ(partialLengths, seq - 1);
                if (leqIndex >= 0) {
                    penultPartialLen = partialLengths[leqIndex];
                }
            }
            else {
                penultPartialLen = pLen;
            }
        }
        if (seqPartialLen === undefined) {
            // len will be assigned below, making this assertion true.
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            seqPartialLen = {
                clientId,
                seglen: seqSeglen,
                seq,
            };
            partialLengths.push(seqPartialLen);
        }
        else {
            seqPartialLen.seglen = seqSeglen;
            // Assert client id matches
        }
        if (penultPartialLen !== undefined) {
            seqPartialLen.len = seqPartialLen.seglen + penultPartialLen.len;
        }
        else {
            seqPartialLen.len = seqPartialLen.seglen;
        }
    }
    // Assume: seq is latest sequence number; no structural change to sub-tree, but a segment
    // with sequence number seq has been added within the sub-tree
    // TODO: assert client id matches
    update(mergeTree, node, seq, clientId, collabWindow) {
        let seqSeglen = 0;
        let segCount = 0;
        // Compute length for seq across children
        for (let i = 0; i < node.childCount; i++) {
            const child = node.children[i];
            if (!child.isLeaf()) {
                const childBlock = child;
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const branchPartialLengths = childBlock.partialLengths;
                const partialLengths = branchPartialLengths.partialLengths;
                const seqIndex = latestLEQ(partialLengths, seq);
                if (seqIndex >= 0) {
                    const leqPartial = partialLengths[seqIndex];
                    if (leqPartial.seq === seq) {
                        seqSeglen += leqPartial.seglen;
                    }
                }
                segCount += branchPartialLengths.segmentCount;
            }
            else {
                const segment = child;
                const removalInfo = (0, mergeTree_1.toRemovalInfo)(segment);
                if (segment.seq === seq) {
                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) !== seq) {
                        seqSeglen += segment.cachedLength;
                    }
                }
                else {
                    if ((removalInfo === null || removalInfo === void 0 ? void 0 : removalInfo.removedSeq) === seq) {
                        seqSeglen -= segment.cachedLength;
                    }
                }
                segCount++;
            }
        }
        this.segmentCount = segCount;
        PartialSequenceLengths.addSeq(this.partialLengths, seq, seqSeglen, clientId);
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        PartialSequenceLengths.addSeq(this.clientSeqNumbers[clientId], seq, seqSeglen);
        if (PartialSequenceLengths.options.zamboni) {
            this.zamboni(collabWindow);
        }
        if (PartialSequenceLengths.options.verify) {
            this.verify();
        }
    }
    getPartialLength(refSeq, clientId) {
        let pLen = this.minLength;
        const seqIndex = latestLEQ(this.partialLengths, refSeq);
        const cliLatestIndex = this.cliLatest(clientId);
        const cliSeq = this.clientSeqNumbers[clientId];
        if (seqIndex >= 0) {
            // Add the partial length up to refSeq
            pLen += this.partialLengths[seqIndex].len;
            if (cliLatestIndex >= 0) {
                const cliLatest = cliSeq[cliLatestIndex];
                if (cliLatest.seq > refSeq) {
                    // The client has local edits after refSeq, add in the length adjustments
                    pLen += cliLatest.len;
                    const precedingCliIndex = this.cliLatestLEQ(clientId, refSeq);
                    if (precedingCliIndex >= 0) {
                        pLen -= cliSeq[precedingCliIndex].len;
                    }
                }
            }
        }
        else {
            // RefSeq is before any of the partial lengths
            // so just add in all local edits of that client (which should all be after the refSeq)
            if (cliLatestIndex >= 0) {
                const cliLatest = cliSeq[cliLatestIndex];
                pLen += cliLatest.len;
            }
        }
        return pLen;
    }
    toString(glc, indentCount = 0) {
        let buf = "";
        for (const partial of this.partialLengths) {
            buf += `(${partial.seq},${partial.len}) `;
        }
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            if (this.clientSeqNumbers[clientId].length > 0) {
                buf += `Client `;
                if (glc) {
                    buf += `${glc(+clientId)}`;
                }
                else {
                    buf += `${clientId}`;
                }
                buf += "[";
                for (const partial of this.clientSeqNumbers[clientId]) {
                    buf += `(${partial.seq},${partial.len})`;
                }
                buf += "]";
            }
        }
        buf = `min(seq ${this.minSeq}): ${this.minLength}; sc: ${this.segmentCount};${buf}`;
        return buf;
    }
    // Clear away partial sums for sequence numbers earlier than the current window
    zamboni(segmentWindow) {
        function copyDown(partialLengths) {
            const mindex = latestLEQ(partialLengths, segmentWindow.minSeq);
            let minLength = 0;
            if (mindex >= 0) {
                minLength = partialLengths[mindex].len;
                const seqCount = partialLengths.length;
                if (mindex <= (seqCount - 1)) {
                    // Still some entries remaining
                    const remainingCount = (seqCount - mindex) - 1;
                    // Copy down
                    for (let i = 0; i < remainingCount; i++) {
                        partialLengths[i] = partialLengths[i + mindex + 1];
                        partialLengths[i].len -= minLength;
                    }
                    partialLengths.length = remainingCount;
                }
            }
            return minLength;
        }
        this.minLength += copyDown(this.partialLengths);
        // eslint-disable-next-line @typescript-eslint/no-for-in-array, guard-for-in, no-restricted-syntax
        for (const clientId in this.clientSeqNumbers) {
            const cliPartials = this.clientSeqNumbers[clientId];
            if (cliPartials) {
                copyDown(cliPartials);
            }
        }
    }
    addClientSeqNumber(clientId, seq, seglen) {
        if (this.clientSeqNumbers[clientId] === undefined) {
            this.clientSeqNumbers[clientId] = [];
        }
        const cli = this.clientSeqNumbers[clientId];
        let pLen = seglen;
        if (cli.length > 0) {
            pLen += cli[cli.length - 1].len;
        }
        cli.push({ seq, len: pLen, seglen });
    }
    // Assumes sequence number already coalesced
    addClientSeqNumberFromPartial(partialLength) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.addClientSeqNumber(partialLength.clientId, partialLength.seq, partialLength.seglen);
        if (partialLength.overlapRemoveClients) {
            partialLength.overlapRemoveClients.map((oc) => {
                this.addClientSeqNumber(oc.data.clientId, partialLength.seq, oc.data.seglen);
                return true;
            });
        }
    }
    cliLatestLEQ(clientId, refSeq) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs) {
            return latestLEQ(cliSeqs, refSeq);
        }
        else {
            return -1;
        }
    }
    cliLatest(clientId) {
        const cliSeqs = this.clientSeqNumbers[clientId];
        if (cliSeqs && (cliSeqs.length > 0)) {
            return cliSeqs.length - 1;
        }
        else {
            return -1;
        }
    }
    // Debug only
    verifyPartialLengths(partialLengths, clientPartials) {
        if (partialLengths.length === 0) {
            return 0;
        }
        let lastSeqNum = 0;
        let accumSegLen = 0;
        let count = 0;
        for (const partialLength of partialLengths) {
            // Count total number of partial length
            count++;
            // Sequence number should be larger or equal to minseq
            (0, common_utils_1.assert)(this.minSeq <= partialLength.seq, 0x054 /* "Sequence number less than minSeq!" */);
            // Sequence number should be sorted
            (0, common_utils_1.assert)(lastSeqNum < partialLength.seq, 0x055 /* "Sequence number is not sorted!" */);
            lastSeqNum = partialLength.seq;
            // Len is a accumulation of all the seglen adjustments
            accumSegLen += partialLength.seglen;
            if (accumSegLen !== partialLength.len) {
                (0, common_utils_1.assert)(false, 0x056 /* "Unexpected total for accumulation of all seglen adjustments!" */);
            }
            if (clientPartials) {
                // Client partials used to track local edits so we can account for them some refSeq.
                // But the information we keep track of are since minSeq, so we keep track of more history
                // then needed, and some of them doesn't make sense to be used for length calculations
                // e.g. if you have this sequence, where the minSeq is #5 because of other clients
                //    seq 10: client 1: insert seg #1
                //    seq 11: client 2: delete seg #2 refseq: 10
                // minLength is 0, we would have keep a record of seglen: -1 for clientPartialLengths for client 2
                // So if you ask for partial length for client 2 @ seq 5, we will have return -1.
                // However, that combination is invalid, since we should never see any ops with refseq < 10 for
                // client 2 after seq 11.
            }
            else {
                // Len adjustment should not make length negative
                if (this.minLength + partialLength.len < 0) {
                    (0, common_utils_1.assert)(false, 0x057 /* "Negative length after length adjustment!" */);
                }
            }
            if (partialLength.overlapRemoveClients) {
                // Only the flat partialLengths can have overlapRemoveClients, the per client view shouldn't
                (0, common_utils_1.assert)(!clientPartials, 0x058 /* "Both overlapRemoveClients and clientPartials are set!" */);
                // Each overlap client count as one
                count += partialLength.overlapRemoveClients.size();
            }
        }
        return count;
    }
    verify() {
        if (this.clientSeqNumbers) {
            let cliCount = 0;
            for (const cliSeq of this.clientSeqNumbers) {
                if (cliSeq) {
                    cliCount += this.verifyPartialLengths(cliSeq, true);
                }
            }
            // If we have client view, we should have the flat view
            (0, common_utils_1.assert)(!!this.partialLengths, 0x059 /* "Client view exists but flat view does not!" */);
            const flatCount = this.verifyPartialLengths(this.partialLengths, false);
            // The number of partial lengths on the client view and flat view should be the same
            (0, common_utils_1.assert)(flatCount === cliCount, 0x05a /* "Mismatch between number of partial lengths on client and flat views!" */);
        }
        else {
            // If we don't have a client view, we shouldn't have the flat view either
            (0, common_utils_1.assert)(!this.partialLengths, 0x05b /* "Flat view exists but client view does not!" */);
        }
    }
}
exports.PartialSequenceLengths = PartialSequenceLengths;
PartialSequenceLengths.options = {
    verify: false,
    zamboni: true,
};

},{"./collections":145,"./constants":146,"./mergeTree":149,"@fluidframework/common-utils":29}],155:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMap = exports.extendIfUndefined = exports.addProperties = exports.clone = exports.extend = exports.matchProperties = exports.combine = void 0;
function combine(combiningInfo, currentValue, newValue, seq) {
    let _currentValue = currentValue;
    if (_currentValue === undefined) {
        _currentValue = combiningInfo.defaultValue;
    }
    // Fixed set of operations for now
    switch (combiningInfo.name) {
        case "incr":
            _currentValue += newValue;
            if (combiningInfo.minValue) {
                if (_currentValue < combiningInfo.minValue) {
                    _currentValue = combiningInfo.minValue;
                }
            }
            break;
        case "consensus":
            if (_currentValue === undefined) {
                const cv = {
                    value: newValue,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    seq: seq,
                };
                _currentValue = cv;
            }
            else {
                const cv = _currentValue;
                if (cv.seq === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    cv.seq = seq;
                }
            }
            break;
        default:
            break;
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return _currentValue;
}
exports.combine = combine;
function matchProperties(a, b) {
    if (a) {
        if (!b) {
            return false;
        }
        else {
            // For now, straightforward; later use hashing
            // eslint-disable-next-line no-restricted-syntax
            for (const key in a) {
                if (b[key] === undefined) {
                    return false;
                }
                else if (typeof b[key] === "object") {
                    if (!matchProperties(a[key], b[key])) {
                        return false;
                    }
                }
                else if (b[key] !== a[key]) {
                    return false;
                }
            }
            // eslint-disable-next-line no-restricted-syntax
            for (const key in b) {
                if (a[key] === undefined) {
                    return false;
                }
            }
        }
    }
    else {
        if (b) {
            return false;
        }
    }
    return true;
}
exports.matchProperties = matchProperties;
function extend(base, extension, combiningOp, seq) {
    if (extension !== undefined) {
        // eslint-disable-next-line guard-for-in, no-restricted-syntax
        for (const key in extension) {
            const v = extension[key];
            if (v === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete base[key];
            }
            else {
                if (combiningOp && (combiningOp.name !== "rewrite")) {
                    base[key] = combine(combiningOp, base[key], v, seq);
                }
                else {
                    base[key] = v;
                }
            }
        }
    }
    return base;
}
exports.extend = extend;
function clone(extension) {
    if (extension === undefined) {
        return undefined;
    }
    const cloneMap = createMap();
    // eslint-disable-next-line guard-for-in, no-restricted-syntax
    for (const key in extension) {
        const v = extension[key];
        if (v !== null) {
            cloneMap[key] = v;
        }
    }
    return cloneMap;
}
exports.clone = clone;
function addProperties(oldProps, newProps, op, seq) {
    let _oldProps = oldProps;
    if ((!_oldProps) || (op && (op.name === "rewrite"))) {
        _oldProps = createMap();
    }
    extend(_oldProps, newProps, op, seq);
    return _oldProps;
}
exports.addProperties = addProperties;
function extendIfUndefined(base, extension) {
    if (extension !== undefined) {
        // eslint-disable-next-line no-restricted-syntax
        for (const key in extension) {
            if (base[key] === undefined) {
                base[key] = extension[key];
            }
        }
    }
    return base;
}
exports.extendIfUndefined = extendIfUndefined;
// Create a MapLike with good performance.
function createMap() {
    return Object.create(null);
}
exports.createMap = createMap;

},{}],156:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareReferencePositions = exports.maxReferencePosition = exports.minReferencePosition = exports.DetachedReferencePosition = exports.refHasRangeLabels = exports.refHasTileLabels = exports.refHasRangeLabel = exports.refHasTileLabel = exports.refGetRangeLabels = exports.refGetTileLabels = exports.refTypeIncludesFlag = exports.reservedRangeLabelsKey = exports.reservedTileLabelsKey = void 0;
const ops_1 = require("./ops");
exports.reservedTileLabelsKey = "referenceTileLabels";
exports.reservedRangeLabelsKey = "referenceRangeLabels";
function refTypeIncludesFlag(refPosOrType, flags) {
    const refType = typeof refPosOrType === "number" ? refPosOrType : refPosOrType.refType;
    // eslint-disable-next-line no-bitwise
    return (refType & flags) !== 0;
}
exports.refTypeIncludesFlag = refTypeIncludesFlag;
const refGetTileLabels = (refPos) => refTypeIncludesFlag(refPos, ops_1.ReferenceType.Tile)
    && refPos.properties ? refPos.properties[exports.reservedTileLabelsKey] : undefined;
exports.refGetTileLabels = refGetTileLabels;
const refGetRangeLabels = (refPos) => 
// eslint-disable-next-line no-bitwise
(refTypeIncludesFlag(refPos, ops_1.ReferenceType.NestBegin | ops_1.ReferenceType.NestEnd))
    && refPos.properties ? refPos.properties[exports.reservedRangeLabelsKey] : undefined;
exports.refGetRangeLabels = refGetRangeLabels;
function refHasTileLabel(refPos, label) {
    const tileLabels = (0, exports.refGetTileLabels)(refPos);
    if (tileLabels) {
        for (const refLabel of tileLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
exports.refHasTileLabel = refHasTileLabel;
function refHasRangeLabel(refPos, label) {
    const rangeLabels = (0, exports.refGetRangeLabels)(refPos);
    if (rangeLabels) {
        for (const refLabel of rangeLabels) {
            if (label === refLabel) {
                return true;
            }
        }
    }
    return false;
}
exports.refHasRangeLabel = refHasRangeLabel;
function refHasTileLabels(refPos) {
    return (0, exports.refGetTileLabels)(refPos) !== undefined;
}
exports.refHasTileLabels = refHasTileLabels;
function refHasRangeLabels(refPos) {
    return (0, exports.refGetRangeLabels)(refPos) !== undefined;
}
exports.refHasRangeLabels = refHasRangeLabels;
exports.DetachedReferencePosition = -1;
function minReferencePosition(a, b) {
    if (compareReferencePositions(a, b) < 0) {
        return a;
    }
    else {
        return b;
    }
}
exports.minReferencePosition = minReferencePosition;
function maxReferencePosition(a, b) {
    if (compareReferencePositions(a, b) > 0) {
        return a;
    }
    else {
        return b;
    }
}
exports.maxReferencePosition = maxReferencePosition;
function compareReferencePositions(a, b) {
    const aSeg = a.getSegment();
    const bSeg = b.getSegment();
    if (aSeg === bSeg) {
        return a.getOffset() - b.getOffset();
    }
    else {
        if (aSeg === undefined
            || (bSeg !== undefined &&
                aSeg.ordinal < bSeg.ordinal)) {
            return -1;
        }
        else {
            return 1;
        }
    }
}
exports.compareReferencePositions = compareReferencePositions;

},{"./ops":153}],157:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SegmentGroupCollection = void 0;
const collections_1 = require("./collections");
class SegmentGroupCollection {
    constructor(segment) {
        this.segment = segment;
        this.segmentGroups = (0, collections_1.ListMakeHead)();
    }
    get size() {
        return this.segmentGroups.count();
    }
    get empty() {
        return this.segmentGroups.empty();
    }
    enqueue(segmentGroup) {
        this.segmentGroups.enqueue(segmentGroup);
        segmentGroup.segments.push(this.segment);
    }
    dequeue() {
        return this.segmentGroups.dequeue();
    }
    clear() {
        this.segmentGroups.clear();
    }
    copyTo(segment) {
        this.segmentGroups.walk((sg) => segment.segmentGroups.enqueue(sg));
    }
}
exports.SegmentGroupCollection = SegmentGroupCollection;

},{"./collections":145}],158:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertiesManager = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const common_utils_1 = require("@fluidframework/common-utils");
const constants_1 = require("./constants");
const properties_1 = require("./properties");
class PropertiesManager {
    constructor() {
        this.pendingRewriteCount = 0;
    }
    ackPendingProperties(annotateOp) {
        var _a, _b;
        if (annotateOp.combiningOp && annotateOp.combiningOp.name === "rewrite") {
            this.pendingRewriteCount--;
        }
        for (const key of Object.keys(annotateOp.props)) {
            if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) !== undefined) {
                (0, common_utils_1.assert)(this.pendingKeyUpdateCount[key] > 0, 0x05c /* "Trying to update more annotate props than do exist!" */);
                this.pendingKeyUpdateCount[key]--;
                if (((_b = this.pendingKeyUpdateCount) === null || _b === void 0 ? void 0 : _b[key]) === 0) {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete this.pendingKeyUpdateCount[key];
                }
            }
        }
    }
    addProperties(oldProps, newProps, op, seq, collaborating = false) {
        var _a;
        if (!this.pendingKeyUpdateCount) {
            this.pendingKeyUpdateCount = (0, properties_1.createMap)();
        }
        // There are outstanding local rewrites, so block all non-local changes
        if (this.pendingRewriteCount > 0 && seq !== constants_1.UnassignedSequenceNumber && collaborating) {
            return undefined;
        }
        const rewrite = (op && op.name === "rewrite");
        const combiningOp = !rewrite ? op ? op : undefined : undefined;
        const shouldModifyKey = (key) => {
            var _a;
            if (seq === constants_1.UnassignedSequenceNumber
                || ((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined
                || combiningOp) {
                return true;
            }
            return false;
        };
        const deltas = {};
        if (rewrite) {
            if (collaborating && seq === constants_1.UnassignedSequenceNumber) {
                this.pendingRewriteCount++;
            }
            // We are re-writing so delete all the properties
            // not in the new props
            for (const key of Object.keys(oldProps)) {
                if (!newProps[key] && shouldModifyKey(key)) {
                    deltas[key] = oldProps[key];
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete oldProps[key];
                }
            }
        }
        for (const key of Object.keys(newProps)) {
            if (collaborating) {
                if (seq === constants_1.UnassignedSequenceNumber) {
                    if (((_a = this.pendingKeyUpdateCount) === null || _a === void 0 ? void 0 : _a[key]) === undefined) {
                        this.pendingKeyUpdateCount[key] = 0;
                    }
                    this.pendingKeyUpdateCount[key]++;
                }
                else if (!shouldModifyKey(key)) {
                    continue;
                }
            }
            const previousValue = oldProps[key];
            // The delta should be null if undefined, as thats how we encode delete
            deltas[key] = (previousValue === undefined) ? null : previousValue;
            let newValue;
            if (combiningOp) {
                newValue = (0, properties_1.combine)(combiningOp, previousValue, newValue, seq);
            }
            else {
                newValue = newProps[key];
            }
            if (newValue === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete oldProps[key];
            }
            else {
                oldProps[key] = newValue;
            }
        }
        return deltas;
    }
    copyTo(oldProps, newProps, newManager) {
        if (oldProps) {
            if (!newProps) {
                // eslint-disable-next-line no-param-reassign
                newProps = (0, properties_1.createMap)();
            }
            if (!newManager) {
                throw new Error("Must provide new PropertyManager");
            }
            for (const key of Object.keys(oldProps)) {
                newProps[key] = oldProps[key];
            }
            newManager.pendingRewriteCount = this.pendingRewriteCount;
            newManager.pendingKeyUpdateCount = (0, properties_1.createMap)();
            for (const key of Object.keys(this.pendingKeyUpdateCount)) {
                newManager.pendingKeyUpdateCount[key] = this.pendingKeyUpdateCount[key];
            }
        }
        return newProps;
    }
    hasPendingProperties() {
        return this.pendingRewriteCount > 0 || Object.keys(this.pendingKeyUpdateCount).length > 0;
    }
}
exports.PropertiesManager = PropertiesManager;

},{"./constants":146,"./properties":155,"@fluidframework/common-utils":29}],159:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toLatestVersion = exports.serializeAsMaxSupportedVersion = exports.serializeAsMinSupportedVersion = exports.hasMergeInfo = void 0;
const snapshotlegacy_1 = require("./snapshotlegacy");
/**
 * Returns true if the given 'spec' is an IJSONSegmentWithMergeInfo.
 */
function hasMergeInfo(spec) {
    return !!spec && typeof spec === "object" && "json" in spec;
}
exports.hasMergeInfo = hasMergeInfo;
function serializeAsMinSupportedVersion(path, chunk, logger, options, serializer, bind) {
    let targetChuck;
    if (chunk.version !== undefined) {
        logger.send({
            eventName: "MergeTreeChunk:serializeAsMinSupportedVersion",
            category: "generic",
            fromChunkVersion: chunk.version,
            toChunkVersion: undefined,
        });
    }
    switch (chunk.version) {
        case undefined:
            targetChuck = chunk;
            targetChuck.headerMetadata = buildHeaderMetadataForLegacyChunk(path, targetChuck, options);
            break;
        case "1":
            const chunkV1 = chunk;
            const headerMetadata = path === snapshotlegacy_1.SnapshotLegacy.header ? chunkV1.headerMetadata : undefined;
            targetChuck = {
                version: undefined,
                chunkStartSegmentIndex: chunkV1.startIndex,
                chunkLengthChars: chunkV1.length,
                chunkSegmentCount: chunkV1.segmentCount,
                segmentTexts: chunkV1.segments,
                totalLengthChars: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalLength,
                totalSegmentCount: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.totalSegmentCount,
                chunkSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.sequenceNumber,
                chunkMinSequenceNumber: headerMetadata === null || headerMetadata === void 0 ? void 0 : headerMetadata.minSequenceNumber,
                headerMetadata,
            };
            break;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
    return serializer.stringify(targetChuck, bind);
}
exports.serializeAsMinSupportedVersion = serializeAsMinSupportedVersion;
function serializeAsMaxSupportedVersion(path, chunk, logger, options, serializer, bind) {
    const targetChuck = toLatestVersion(path, chunk, logger, options);
    return serializer.stringify(targetChuck, bind);
}
exports.serializeAsMaxSupportedVersion = serializeAsMaxSupportedVersion;
function toLatestVersion(path, chunk, logger, options) {
    switch (chunk.version) {
        case undefined: {
            const chunkLegacy = chunk;
            return {
                version: "1",
                length: chunkLegacy.chunkLengthChars,
                segmentCount: chunkLegacy.chunkSegmentCount,
                headerMetadata: buildHeaderMetadataForLegacyChunk(path, chunkLegacy, options),
                segments: chunkLegacy.segmentTexts,
                startIndex: chunkLegacy.chunkStartSegmentIndex,
            };
        }
        case "1":
            return chunk;
        default:
            throw new Error(`Unsupported chunk path: ${path} version: ${chunk.version}`);
    }
}
exports.toLatestVersion = toLatestVersion;
function buildHeaderMetadataForLegacyChunk(path, chunk, options) {
    if (path === snapshotlegacy_1.SnapshotLegacy.header) {
        if (chunk.headerMetadata !== undefined) {
            return chunk.headerMetadata;
        }
        const chunkIds = [{ id: snapshotlegacy_1.SnapshotLegacy.header }];
        if (chunk.chunkLengthChars < chunk.totalLengthChars) {
            chunkIds.push({ id: snapshotlegacy_1.SnapshotLegacy.body });
        }
        return {
            orderedChunkMetadata: chunkIds,
            minSequenceNumber: chunk.chunkMinSequenceNumber,
            sequenceNumber: chunk.chunkSequenceNumber,
            totalLength: chunk.totalLengthChars,
            totalSegmentCount: chunk.totalSegmentCount,
        };
    }
    return undefined;
}

},{"./snapshotlegacy":162}],160:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotLoader = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const constants_1 = require("./constants");
const snapshotChunks_1 = require("./snapshotChunks");
const snapshotV1_1 = require("./snapshotV1");
const snapshotlegacy_1 = require("./snapshotlegacy");
class SnapshotLoader {
    constructor(runtime, client, mergeTree, logger, serializer) {
        this.runtime = runtime;
        this.client = client;
        this.mergeTree = mergeTree;
        this.serializer = serializer;
        this.specToSegment = (spec) => {
            var _a;
            let seg;
            if ((0, snapshotChunks_1.hasMergeInfo)(spec)) {
                seg = this.client.specToSegment(spec.json);
                // `specToSegment()` initializes `seg` with the LocalClientId.  Overwrite this with
                // the `spec` client (if specified).  Otherwise overwrite with `NonCollabClient`.
                seg.clientId = spec.client !== undefined
                    ? this.client.getOrAddShortClientId(spec.client)
                    : constants_1.NonCollabClient;
                seg.seq = spec.seq !== undefined
                    ? spec.seq
                    : constants_1.UniversalSequenceNumber;
                if (spec.removedSeq !== undefined) {
                    seg.removedSeq = spec.removedSeq;
                }
                // this format had a bug where it didn't store all the overlap clients
                // this is for back compat, so we change the singular id to an array
                // this will only cause problems if there is an overlapping delete
                // spanning the snapshot, which should be rare
                if (spec.removedClient !== undefined) {
                    seg.removedClientIds = [this.client.getOrAddShortClientId(spec.removedClient)];
                }
                if (spec.removedClientIds !== undefined) {
                    seg.removedClientIds = (_a = spec.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((sid) => this.client.getOrAddShortClientId(sid));
                }
            }
            else {
                seg = this.client.specToSegment(spec);
                seg.seq = constants_1.UniversalSequenceNumber;
                // `specToSegment()` initializes `seg` with the LocalClientId.  We must overwrite this with
                // `NonCollabClient`.
                seg.clientId = constants_1.NonCollabClient;
            }
            return seg;
        };
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "SnapshotLoader");
    }
    async initialize(services) {
        const headerLoadedP = services.readBlob(snapshotlegacy_1.SnapshotLegacy.header).then((header) => {
            (0, common_utils_1.assert)(!!header, 0x05f /* "Missing blob header on legacy snapshot!" */);
            return this.loadHeader((0, common_utils_1.bufferToString)(header, "utf8"));
        });
        const catchupOpsP = this.loadBodyAndCatchupOps(headerLoadedP, services);
        catchupOpsP.catch((err) => this.logger.sendErrorEvent({ eventName: "CatchupOpsLoadFailure" }, err));
        await headerLoadedP;
        return { catchupOpsP };
    }
    async loadBodyAndCatchupOps(headerChunkP, services) {
        const blobsP = services.list("");
        const headerChunk = await headerChunkP;
        // TODO we shouldn't need to wait on the body being complete to finish initialization.
        // To fully support this we need to be able to process inbound ops for pending segments.
        await this.loadBody(headerChunk, services);
        const blobs = await blobsP;
        if (blobs.length === headerChunk.headerMetadata.orderedChunkMetadata.length + 1) {
            headerChunk.headerMetadata.orderedChunkMetadata.forEach((md) => blobs.splice(blobs.indexOf(md.id), 1));
            (0, common_utils_1.assert)(blobs.length === 1, 0x060 /* There should be only one blob with catch up ops */);
            // TODO: The 'Snapshot.catchupOps' tree entry is purely for backwards compatibility.
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            return this.loadCatchupOps(services.readBlob(blobs[0]));
        }
        else if (blobs.length !== headerChunk.headerMetadata.orderedChunkMetadata.length) {
            throw new Error("Unexpected blobs in snapshot");
        }
        return [];
    }
    loadHeader(header) {
        var _a;
        const chunk = snapshotV1_1.SnapshotV1.processChunk(snapshotlegacy_1.SnapshotLegacy.header, header, this.logger, this.mergeTree.options, this.serializer);
        const segs = chunk.segments.map(this.specToSegment);
        this.mergeTree.reloadFromSegments(segs);
        if (chunk.headerMetadata === undefined) {
            throw new Error("header metadata not available");
        }
        // If we load a detached container from snapshot, then we don't supply a default clientId
        // because we don't want to start collaboration.
        if (this.runtime.attachState !== container_definitions_1.AttachState.Detached) {
            // specify a default client id, "snapshot" here as we
            // should enter collaboration/op sending mode if we load
            // a snapshot in any case (summary or attach message)
            // once we get a client id this will be called with that
            // clientId in the connected event
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "snapshot", 
            // TODO: Make 'minSeq' non-optional once the new snapshot format becomes the default?
            //       (See https://github.com/microsoft/FluidFramework/issues/84)
            /* minSeq: */ chunk.headerMetadata.minSequenceNumber !== undefined
                ? chunk.headerMetadata.minSequenceNumber
                : chunk.headerMetadata.sequenceNumber, 
            /* currentSeq: */ chunk.headerMetadata.sequenceNumber);
        }
        return chunk;
    }
    async loadBody(chunk1, services) {
        (0, common_utils_1.assert)(chunk1.length <= chunk1.headerMetadata.totalLength, 0x061 /* "Mismatch in totalLength" */);
        (0, common_utils_1.assert)(chunk1.segmentCount <= chunk1.headerMetadata.totalSegmentCount, 0x062 /* "Mismatch in totalSegmentCount" */);
        if (chunk1.segmentCount === chunk1.headerMetadata.totalSegmentCount) {
            return;
        }
        const segs = [];
        let lengthSofar = chunk1.length;
        for (let chunkIndex = 1; chunkIndex < chunk1.headerMetadata.orderedChunkMetadata.length; chunkIndex++) {
            const chunk = await snapshotV1_1.SnapshotV1.loadChunk(services, chunk1.headerMetadata.orderedChunkMetadata[chunkIndex].id, this.logger, this.mergeTree.options, this.serializer);
            lengthSofar += chunk.length;
            // Deserialize each chunk segment and append it to the end of the MergeTree.
            segs.push(...chunk.segments.map(this.specToSegment));
        }
        (0, common_utils_1.assert)(lengthSofar === chunk1.headerMetadata.totalLength, 0x063 /* "Mismatch in totalLength" */);
        (0, common_utils_1.assert)(chunk1.segmentCount + segs.length === chunk1.headerMetadata.totalSegmentCount, 0x064 /* "Mismatch in totalSegmentCount" */);
        // Helper to insert segments at the end of the MergeTree.
        const mergeTree = this.mergeTree;
        const append = (segments, cli, seq) => {
            mergeTree.insertSegments(mergeTree.root.cachedLength, segments, 
            /* refSeq: */ constants_1.UniversalSequenceNumber, cli, seq, undefined);
        };
        // Helpers to batch-insert segments that are below the min seq
        const batch = [];
        const flushBatch = () => {
            if (batch.length > 0) {
                append(batch, constants_1.NonCollabClient, constants_1.UniversalSequenceNumber);
            }
        };
        for (const seg of segs) {
            const cli = seg.clientId;
            const seq = seg.seq;
            // If the segment can be batch inserted, add it to the 'batch' array.  Otherwise, flush
            // any batched segments and then insert the current segment individually.
            if (cli === constants_1.NonCollabClient && seq === constants_1.UniversalSequenceNumber) {
                batch.push(seg);
            }
            else {
                flushBatch();
                append([seg], cli, seq);
            }
        }
        flushBatch();
    }
    /**
     * If loading from a snapshot, get the catchup messages.
     * @param rawMessages - The messages in original encoding
     * @returns The decoded messages, but handles aren't parsed.  Matches the format that will be passed in
     * SharedObject.processCore.
     */
    async loadCatchupOps(rawMessages) {
        return JSON.parse((0, common_utils_1.bufferToString)(await rawMessages, "utf8"));
    }
}
exports.SnapshotLoader = SnapshotLoader;

},{"./constants":146,"./snapshotChunks":159,"./snapshotV1":161,"./snapshotlegacy":162,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/telemetry-utils":279}],161:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotV1 = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const constants_1 = require("./constants");
const properties_1 = require("./properties");
const snapshotChunks_1 = require("./snapshotChunks");
const snapshotlegacy_1 = require("./snapshotlegacy");
class SnapshotV1 {
    constructor(mergeTree, logger, getLongClientId, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.getLongClientId = getLongClientId;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotV1.chunkSize;
        const { currentSeq, minSeq } = mergeTree.getCollabWindow();
        this.header = {
            minSequenceNumber: minSeq,
            sequenceNumber: currentSeq,
            orderedChunkMetadata: [],
            totalLength: 0,
            totalSegmentCount: 0,
        };
        this.segments = [];
        this.segmentLengths = [];
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segments = [];
        let length = 0;
        let segmentCount = 0;
        while ((length < approxSequenceLength) && ((startIndex + segmentCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segmentCount];
            segments.push(pseg);
            length += allLengths[startIndex + segmentCount];
            segmentCount++;
        }
        return {
            version: "1",
            segmentCount,
            length,
            segments,
            startIndex,
            headerMetadata: undefined,
        };
    }
    /**
     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when
     * serializing the summary data rather than JSON.stringify.
     */
    emit(serializer, bind) {
        const chunks = [];
        this.header.totalSegmentCount = 0;
        this.header.totalLength = 0;
        do {
            const chunk = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize, this.header.totalSegmentCount);
            chunks.push(chunk);
            this.header.totalSegmentCount += chunk.segmentCount;
            this.header.totalLength += chunk.length;
        } while (this.header.totalSegmentCount < this.segments.length);
        // The do while loop should have added at least one chunk
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const headerChunk = chunks.shift();
        headerChunk.headerMetadata = this.header;
        headerChunk.headerMetadata.orderedChunkMetadata = [{ id: snapshotlegacy_1.SnapshotLegacy.header }];
        const blobs = [];
        chunks.forEach((chunk, index) => {
            const id = `${snapshotlegacy_1.SnapshotLegacy.body}_${index}`;
            this.header.orderedChunkMetadata.push({ id });
            blobs.push([id, (0, snapshotChunks_1.serializeAsMaxSupportedVersion)(id, chunk, this.logger, this.mergeTree.options, serializer, bind)]);
        });
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        builder.addBlob(snapshotlegacy_1.SnapshotLegacy.header, (0, snapshotChunks_1.serializeAsMaxSupportedVersion)(snapshotlegacy_1.SnapshotLegacy.header, headerChunk, this.logger, this.mergeTree.options, serializer, bind));
        blobs.forEach((value) => {
            builder.addBlob(value[0], value[1]);
        });
        return builder.getSummaryTree();
    }
    extractSync() {
        const mergeTree = this.mergeTree;
        const minSeq = this.header.minSequenceNumber;
        // Helper to add the given `MergeTreeChunkV0SegmentSpec` to the snapshot.
        const pushSegRaw = (json, length) => {
            this.segments.push(json);
            this.segmentLengths.push(length);
        };
        // Helper to serialize the given `segment` and add it to the snapshot (if a segment is provided).
        const pushSeg = (segment) => {
            if (segment) {
                pushSegRaw(segment.toJSONObject(), segment.cachedLength);
            }
        };
        let prev;
        const extractSegment = (segment) => {
            var _a;
            // Elide segments that do not need to be included in the snapshot.  A segment may be elided if
            // either condition is true:
            //   a) The segment has not yet been ACKed.  We do not need to snapshot unACKed segments because
            //      there is a pending insert op that will deliver the segment on reconnection.
            //   b) The segment was removed at or below the MSN.  Pending ops can no longer reference this
            //      segment, and therefore we can discard it.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (segment.seq === constants_1.UnassignedSequenceNumber || segment.removedSeq <= minSeq) {
                return true;
            }
            // Next determine if the snapshot needs to preserve information required for merging the segment
            // (seq, client, etc.)  This information is only needed if the segment is above the MSN (and doesn't
            // have a pending remove.)
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if ((segment.seq <= minSeq) // Segment is below the MSN, and...
                && (segment.removedSeq === undefined // .. Segment has not been removed, or...
                    || segment.removedSeq === constants_1.UnassignedSequenceNumber) // .. Removal op to be delivered on reconnect
            ) {
                // This segment is below the MSN, which means that future ops will not reference it.  Attempt to
                // coalesce the new segment with the previous (if any).
                if (!prev) {
                    // We do not have a previous candidate for coalescing.  Make the current segment the new candidate.
                    prev = segment;
                }
                else if (prev.canAppend(segment) && (0, properties_1.matchProperties)(prev.properties, segment.properties)) {
                    // We have a compatible pair.  Replace `prev` with the coalesced segment.  Clone to avoid
                    // modifying the segment instances currently in the MergeTree.
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    // The segment pair could not be coalesced.  Record the `prev` segment in the snapshot
                    // and make the current segment the new candidate for coalescing.
                    pushSeg(prev);
                    prev = segment;
                }
            }
            else {
                // This segment needs to preserve it's metadata as it may be referenced by future ops.  It's ineligible
                // for coalescing, so emit the 'prev' segment now (if any).
                pushSeg(prev);
                prev = undefined;
                const raw = { json: segment.toJSONObject() };
                // If the segment insertion is above the MSN, record the insertion merge info.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                if (segment.seq > minSeq) {
                    raw.seq = segment.seq;
                    raw.client = this.getLongClientId(segment.clientId);
                }
                // We have already dispensed with removed segments below the MSN and removed segments with unassigned
                // sequence numbers.  Any remaining removal info should be preserved.
                if (segment.removedSeq !== undefined) {
                    (0, common_utils_1.assert)(segment.removedSeq !== constants_1.UnassignedSequenceNumber && segment.removedSeq > minSeq, 0x065 /* "On removal info preservation, segment has invalid removed sequence number!" */);
                    raw.removedSeq = segment.removedSeq;
                    // back compat for when we split overlap and removed client
                    raw.removedClient =
                        segment.removedClientIds !== undefined
                            ? this.getLongClientId(segment.removedClientIds[0])
                            : undefined;
                    raw.removedClientIds = (_a = segment.removedClientIds) === null || _a === void 0 ? void 0 : _a.map((id) => this.getLongClientId(id));
                }
                // Sanity check that we are preserving either the seq < minSeq or a removed segment's info.
                (0, common_utils_1.assert)(raw.seq !== undefined && raw.client !== undefined
                    || raw.removedSeq !== undefined && raw.removedClient !== undefined, 0x066 /* "Corrupted preservation of segment metadata!" */);
                // Record the segment with it's required metadata.
                pushSegRaw(raw, segment.cachedLength);
            }
            return true;
        };
        mergeTree.walkAllSegments(mergeTree.root, extractSegment, this);
        // If the last segment in the walk was coalescable, push it now.
        pushSeg(prev);
        return this.segments;
    }
    static async loadChunk(storage, path, logger, options, serializer) {
        const blob = await storage.readBlob(path);
        const chunkAsString = (0, common_utils_1.bufferToString)(blob, "utf8");
        return SnapshotV1.processChunk(path, chunkAsString, logger, options, serializer);
    }
    static processChunk(path, chunk, logger, options, serializer) {
        const chunkObj = serializer ? serializer.parse(chunk) : JSON.parse(chunk);
        return (0, snapshotChunks_1.toLatestVersion)(path, chunkObj, logger, options);
    }
}
exports.SnapshotV1 = SnapshotV1;
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotV1.chunkSize = 10000;

},{"./constants":146,"./properties":155,"./snapshotChunks":159,"./snapshotlegacy":162,"@fluidframework/common-utils":29,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279}],162:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SnapshotLegacy = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const constants_1 = require("./constants");
const properties_1 = require("./properties");
const snapshotChunks_1 = require("./snapshotChunks");
class SnapshotLegacy {
    constructor(mergeTree, logger, filename, onCompletion) {
        var _a, _b;
        this.mergeTree = mergeTree;
        this.filename = filename;
        this.onCompletion = onCompletion;
        this.logger = telemetry_utils_1.ChildLogger.create(logger, "Snapshot");
        this.chunkSize = (_b = (_a = mergeTree === null || mergeTree === void 0 ? void 0 : mergeTree.options) === null || _a === void 0 ? void 0 : _a.mergeTreeSnapshotChunkSize) !== null && _b !== void 0 ? _b : SnapshotLegacy.sizeOfFirstChunk;
    }
    getSeqLengthSegs(allSegments, allLengths, approxSequenceLength, startIndex = 0) {
        const segs = [];
        let sequenceLength = 0;
        let segCount = 0;
        while ((sequenceLength < approxSequenceLength) && ((startIndex + segCount) < allSegments.length)) {
            const pseg = allSegments[startIndex + segCount];
            segs.push(pseg);
            sequenceLength += allLengths[startIndex + segCount];
            segCount++;
        }
        return {
            version: undefined,
            chunkStartSegmentIndex: startIndex,
            chunkSegmentCount: segCount,
            chunkLengthChars: sequenceLength,
            totalLengthChars: this.header.segmentsTotalLength,
            totalSegmentCount: allSegments.length,
            chunkSequenceNumber: this.header.seq,
            segmentTexts: segs,
        };
    }
    /**
     * Emits the snapshot to an ISummarizeResult. If provided the optional IFluidSerializer will be used when
     * serializing the summary data rather than JSON.stringify.
     */
    emit(catchUpMsgs, serializer, bind) {
        var _a, _b;
        const chunk1 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.chunkSize);
        let length = chunk1.chunkLengthChars;
        let segments = chunk1.chunkSegmentCount;
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        builder.addBlob(SnapshotLegacy.header, (0, snapshotChunks_1.serializeAsMinSupportedVersion)(SnapshotLegacy.header, chunk1, this.logger, this.mergeTree.options, serializer, bind));
        if (chunk1.chunkSegmentCount < chunk1.totalSegmentCount) {
            const chunk2 = this.getSeqLengthSegs(this.segments, this.segmentLengths, this.header.segmentsTotalLength, chunk1.chunkSegmentCount);
            length += chunk2.chunkLengthChars;
            segments += chunk2.chunkSegmentCount;
            builder.addBlob(SnapshotLegacy.body, (0, snapshotChunks_1.serializeAsMinSupportedVersion)(SnapshotLegacy.body, chunk2, this.logger, this.mergeTree.options, serializer, bind));
        }
        (0, common_utils_1.assert)(length === this.header.segmentsTotalLength, 0x05d /* "emit: mismatch in segmentsTotalLength" */);
        (0, common_utils_1.assert)(segments === chunk1.totalSegmentCount, 0x05e /* "emit: mismatch in totalSegmentCount" */);
        if (catchUpMsgs !== undefined && catchUpMsgs.length > 0) {
            builder.addBlob((_b = (_a = this.mergeTree.options) === null || _a === void 0 ? void 0 : _a.catchUpBlobName) !== null && _b !== void 0 ? _b : SnapshotLegacy.catchupOps, serializer ? serializer.stringify(catchUpMsgs, bind) : JSON.stringify(catchUpMsgs));
        }
        return builder.getSummaryTree();
    }
    extractSync() {
        const collabWindow = this.mergeTree.getCollabWindow();
        this.seq = collabWindow.minSeq;
        this.header = {
            segmentsTotalLength: this.mergeTree.getLength(this.mergeTree.collabWindow.minSeq, constants_1.NonCollabClient),
            seq: this.mergeTree.collabWindow.minSeq,
        };
        const segs = [];
        let prev;
        const extractSegment = 
        // eslint-disable-next-line max-len
        (segment, pos, refSeq, clientId, start, end) => {
            if ((segment.seq !== constants_1.UnassignedSequenceNumber) && (segment.seq <= this.seq) &&
                ((segment.removedSeq === undefined) || (segment.removedSeq === constants_1.UnassignedSequenceNumber) ||
                    (segment.removedSeq > this.seq))) {
                if ((prev === null || prev === void 0 ? void 0 : prev.canAppend(segment))
                    && (0, properties_1.matchProperties)(prev.properties, segment.properties)) {
                    prev = prev.clone();
                    prev.append(segment.clone());
                }
                else {
                    if (prev) {
                        segs.push(prev);
                    }
                    prev = segment;
                }
            }
            return true;
        };
        this.mergeTree.map({ leaf: extractSegment }, this.seq, constants_1.NonCollabClient, undefined);
        if (prev) {
            segs.push(prev);
        }
        this.segments = [];
        this.segmentLengths = [];
        let totalLength = 0;
        segs.map((segment) => {
            totalLength += segment.cachedLength;
            this.segments.push(segment.toJSONObject());
            this.segmentLengths.push(segment.cachedLength);
        });
        // We observed this.header.segmentsTotalLength < totalLength to happen in some cases
        // When this condition happens, we might not write out all segments in getSeqLengthSegs()
        // when writing out "body". Issue #1995 tracks following up on the core of the problem.
        // In the meantime, this code makes sure we will write out all segments properly
        if (this.header.segmentsTotalLength !== totalLength) {
            this.logger.sendErrorEvent({
                eventName: "SegmentsTotalLengthMismatch",
                totalLength,
                segmentsTotalLength: this.header.segmentsTotalLength,
            });
            this.header.segmentsTotalLength = totalLength;
        }
        return this.segments;
    }
}
exports.SnapshotLegacy = SnapshotLegacy;
SnapshotLegacy.header = "header";
SnapshotLegacy.body = "body";
SnapshotLegacy.catchupOps = "catchupOps";
// Split snapshot into two entries - headers (small) and body (overflow) for faster loading initial content
// Please note that this number has no direct relationship to anything other than size of raw text (characters).
// As we produce json for the blob (and then send over the wire compressed), this number
// is really hard to correlate with any actual metric that matters (like bytes over the wire).
// For test with small number of chunks it would be closer to blob size,
// for very chunky text, blob size can easily be 4x-8x of that number.
SnapshotLegacy.sizeOfFirstChunk = 10000;

},{"./constants":146,"./properties":155,"./snapshotChunks":159,"@fluidframework/common-utils":29,"@fluidframework/runtime-utils":213,"@fluidframework/telemetry-utils":279}],163:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortedSegmentSet = void 0;
/**
 * Stores a unique and sorted set of segments, or objects with segments
 *
 * This differs from a normal sorted set in that the keys are not fixed.
 * The segments are sorted via their ordinals which can change as the merge tree is modified.
 * Even though the values of the ordinals can change their ordering and uniqueness cannot, so the order of a set of
 * segments ordered by their ordinals will always have the same order even if the ordinal values on
 * the segments changes. This invariant allows ensure the segments stay ordered and unique, and that new segments
 * can be inserted into that order.
 */
class SortedSegmentSet {
    constructor() {
        this.ordinalSortedItems = [];
    }
    get size() {
        return this.ordinalSortedItems.length;
    }
    get items() {
        return this.ordinalSortedItems;
    }
    addOrUpdate(newItem, update) {
        const position = this.findOrdinalPosition(this.getOrdinal(newItem));
        if (position.exists) {
            if (update) {
                update(this.ordinalSortedItems[position.index], newItem);
            }
        }
        else {
            this.ordinalSortedItems.splice(position.index, 0, newItem);
        }
    }
    remove(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        if (position.exists) {
            this.ordinalSortedItems.splice(position.index, 1);
            return true;
        }
        return false;
    }
    has(item) {
        const position = this.findOrdinalPosition(this.getOrdinal(item));
        return position.exists;
    }
    getOrdinal(item) {
        const maybeObject = item;
        if (maybeObject === null || maybeObject === void 0 ? void 0 : maybeObject.segment) {
            return maybeObject.segment.ordinal;
        }
        const maybeSegment = item;
        return maybeSegment.ordinal;
    }
    findOrdinalPosition(ordinal, start, end) {
        if (this.ordinalSortedItems.length === 0) {
            return { exists: false, index: 0 };
        }
        if (start === undefined || end === undefined) {
            return this.findOrdinalPosition(ordinal, 0, this.ordinalSortedItems.length - 1);
        }
        const index = start + Math.floor((end - start) / 2);
        if (this.getOrdinal(this.ordinalSortedItems[index]) > ordinal) {
            if (start === index) {
                return { exists: false, index };
            }
            return this.findOrdinalPosition(ordinal, start, index - 1);
        }
        else if (this.getOrdinal(this.ordinalSortedItems[index]) < ordinal) {
            if (index === end) {
                return { exists: false, index: index + 1 };
            }
            return this.findOrdinalPosition(ordinal, index + 1, end);
        }
        return { exists: true, index };
    }
}
exports.SortedSegmentSet = SortedSegmentSet;

},{}],164:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergeTreeTextHelper = exports.TextSegment = void 0;
const mergeTree_1 = require("./mergeTree");
const localReference_1 = require("./localReference");
// Maximum length of text segment to be considered to be merged with other segment.
// Maximum segment length is at least 2x of it (not taking into account initial segment creation).
// The bigger it is, the more expensive it is to break segment into sub-segments (on edits)
// The smaller it is, the more segments we have in snapshots (and in memory) - it's more expensive to load snapshots.
// Small number also makes ReplayTool produce false positives ("same" snapshots have slightly different binary
// representations).  More measurements needs to be done, but it's very likely the right spot is somewhere between
// 1K-2K mark.  That said, we also break segments on newline and there are very few segments that are longer than 256
// because of it.  Must be an even number
const TextSegmentGranularity = 256;
class TextSegment extends mergeTree_1.BaseSegment {
    constructor(text) {
        super();
        this.text = text;
        this.type = TextSegment.type;
        this.cachedLength = text.length;
    }
    static is(segment) {
        return segment.type === TextSegment.type;
    }
    static make(text, props) {
        const seg = new TextSegment(text);
        if (props) {
            seg.addProperties(props);
        }
        return seg;
    }
    static fromJSONObject(spec) {
        if (typeof spec === "string") {
            return new TextSegment(spec);
        }
        else if (spec && typeof spec === "object" && "text" in spec) {
            const textSpec = spec;
            return TextSegment.make(textSpec.text, textSpec.props);
        }
        return undefined;
    }
    toJSONObject() {
        // To reduce snapshot/ops size, we serialize a TextSegment as a plain 'string' if it is
        // not annotated.
        return this.properties
            ? { text: this.text, props: this.properties }
            : this.text;
    }
    clone(start = 0, end) {
        const text = this.text.substring(start, end);
        const b = TextSegment.make(text, this.properties);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return !this.text.endsWith("\n")
            && TextSegment.is(segment)
            && (this.cachedLength <= TextSegmentGranularity ||
                segment.cachedLength <= TextSegmentGranularity);
    }
    toString() {
        return this.text;
    }
    append(segment) {
        if (TextSegment.is(segment)) {
            // Note: Must call 'appendLocalRefs' before modifying this segment's length as
            // 'this.cachedLength' is used to adjust the offsets of the local refs.
            localReference_1.LocalReferenceCollection.append(this, segment);
            this.text += segment.text;
            this.cachedLength = this.text.length;
        }
        else {
            throw new Error("can only append text segment");
        }
    }
    // TODO: retain removed text for undo
    // returns true if entire string removed
    removeRange(start, end) {
        let remnantString = "";
        const len = this.text.length;
        if (start > 0) {
            remnantString += this.text.substring(0, start);
        }
        if (end < len) {
            remnantString += this.text.substring(end);
        }
        this.text = remnantString;
        this.cachedLength = remnantString.length;
        return (remnantString.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingText = this.text.substring(pos);
            this.text = this.text.substring(0, pos);
            this.cachedLength = this.text.length;
            const leafSegment = new TextSegment(remainingText);
            return leafSegment;
        }
    }
}
exports.TextSegment = TextSegment;
TextSegment.type = "TextSegment";
function isTextAndMarkerAccumulator(accum) {
    return accum.parallelArrays === true;
}
class MergeTreeTextHelper {
    constructor(mergeTree) {
        this.mergeTree = mergeTree;
        this.gatherText = (segment, pos, refSeq, clientId, start, end, accumText) => {
            var _a, _b;
            let _start = start;
            if (TextSegment.is(segment)) {
                let beginTags = "";
                let endTags = "";
                if (isTextAndMarkerAccumulator(accumText)) {
                    // TODO: let clients pass in function to get tag
                    const tags = [];
                    const initTags = [];
                    if ((_a = segment.properties) === null || _a === void 0 ? void 0 : _a["font-weight"]) {
                        tags.push("b");
                    }
                    if ((_b = segment.properties) === null || _b === void 0 ? void 0 : _b["text-decoration"]) {
                        tags.push("u");
                    }
                    const remTags = [];
                    if (tags.length > 0) {
                        for (const tag of tags) {
                            if (!accumText.tagsInProgress.includes(tag)) {
                                beginTags += `<${tag}>`;
                                initTags.push(tag);
                            }
                        }
                        for (const accumTag of accumText.tagsInProgress) {
                            if (!tags.includes(accumTag)) {
                                endTags += `</${accumTag}>`;
                                remTags.push(accumTag);
                            }
                        }
                        for (const initTag of initTags.reverse()) {
                            accumText.tagsInProgress.push(initTag);
                        }
                    }
                    else {
                        for (const accumTag of accumText.tagsInProgress) {
                            endTags += `</${accumTag}>`;
                            remTags.push(accumTag);
                        }
                    }
                    for (const remTag of remTags) {
                        const remdex = accumText.tagsInProgress.indexOf(remTag);
                        if (remdex >= 0) {
                            accumText.tagsInProgress.splice(remdex, 1);
                        }
                    }
                }
                accumText.textSegment.text += endTags;
                accumText.textSegment.text += beginTags;
                if ((_start <= 0) && (end >= segment.text.length)) {
                    accumText.textSegment.text += segment.text;
                }
                else {
                    if (_start < 0) {
                        _start = 0;
                    }
                    if (end >= segment.text.length) {
                        accumText.textSegment.text += segment.text.substring(_start);
                    }
                    else {
                        accumText.textSegment.text += segment.text.substring(_start, end);
                    }
                }
            }
            else {
                if (accumText.placeholder && (accumText.placeholder.length > 0)) {
                    if (accumText.placeholder === "*") {
                        const marker = segment;
                        accumText.textSegment.text += `\n${marker.toString()}`;
                    }
                    else {
                        for (let i = 0; i < segment.cachedLength; i++) {
                            accumText.textSegment.text += accumText.placeholder;
                        }
                    }
                }
                else if (isTextAndMarkerAccumulator(accumText)) {
                    const marker = segment;
                    if (marker.hasTileLabel(accumText.parallelMarkerLabel)) {
                        accumText.parallelMarkers.push(marker);
                        accumText.parallelText.push(accumText.textSegment.text);
                        accumText.textSegment.text = "";
                    }
                }
            }
            return true;
        };
    }
    getTextAndMarkers(refSeq, clientId, label, start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = {
            parallelArrays: true,
            parallelMarkerLabel: label,
            parallelMarkers: [],
            parallelText: [],
            tagsInProgress: [],
            textSegment: new TextSegment(""),
        };
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return { parallelText: accum.parallelText, parallelMarkers: accum.parallelMarkers };
    }
    getText(refSeq, clientId, placeholder = "", start, end) {
        const range = this.getValidRange(start, end, refSeq, clientId);
        const accum = { textSegment: new TextSegment(""), placeholder };
        this.mergeTree.mapRange({ leaf: this.gatherText }, refSeq, clientId, accum, range.start, range.end);
        return accum.textSegment.text;
    }
    getValidRange(start, end, refSeq, clientId) {
        const range = {
            end: end !== null && end !== void 0 ? end : this.mergeTree.getLength(refSeq, clientId),
            start: start !== null && start !== void 0 ? start : 0,
        };
        return range;
    }
}
exports.MergeTreeTextHelper = MergeTreeTextHelper;

},{"./localReference":148,"./mergeTree":149}],165:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.addBlobToTree = exports.AttachmentTreeEntry = exports.TreeTreeEntry = exports.BlobTreeEntry = exports.buildHierarchy = exports.getGitType = exports.getGitMode = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Take a summary object and returns its git mode.
 *
 * @param value - summary object
 * @returns the git mode of summary object
 */
function getGitMode(value) {
    const type = value.type === protocol_definitions_1.SummaryType.Handle ? value.handleType : value.type;
    switch (type) {
        case protocol_definitions_1.SummaryType.Blob:
        case protocol_definitions_1.SummaryType.Attachment:
            return protocol_definitions_1.FileMode.File;
        case protocol_definitions_1.SummaryType.Tree:
            return protocol_definitions_1.FileMode.Directory;
        default:
            (0, common_utils_1.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
exports.getGitMode = getGitMode;
/**
 * Take a summary object and returns its type.
 *
 * @param value - summary object
 * @returns the type of summary object
 */
function getGitType(value) {
    const type = value.type === protocol_definitions_1.SummaryType.Handle ? value.handleType : value.type;
    switch (type) {
        case protocol_definitions_1.SummaryType.Blob:
        case protocol_definitions_1.SummaryType.Attachment:
            return "blob";
        case protocol_definitions_1.SummaryType.Tree:
            return "tree";
        default:
            (0, common_utils_1.unreachableCase)(type, `Unknown type: ${type}`);
    }
}
exports.getGitType = getGitType;
/**
 * Build a tree hierarchy base on a flat tree
 *
 * @param flatTree - a flat tree
 * @param blobsShaToPathCache - Map with blobs sha as keys and values as path of the blob.
 * @param removeAppTreePrefix - Remove `.app/` from beginning of paths when present
 * @returns the hierarchical tree
 */
function buildHierarchy(flatTree, blobsShaToPathCache = new Map(), removeAppTreePrefix = false) {
    const lookup = {};
    const root = { id: flatTree.sha, blobs: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.tree) {
        const entryPath = removeAppTreePrefix ? entry.path.replace(/^\.app\//, "") : entry.path;
        const lastIndex = entryPath.lastIndexOf("/");
        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entryPath.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { id: entry.sha, blobs: {}, commits: {}, trees: {} };
            node.trees[decodeURIComponent(entryPathBase)] = newTree;
            lookup[entryPath] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[decodeURIComponent(entryPathBase)] = entry.sha;
            blobsShaToPathCache.set(entry.sha, `/${entryPath}`);
        }
        else {
            throw new Error("Unknown entry type!!");
        }
    }
    return root;
}
exports.buildHierarchy = buildHierarchy;
/**
 * Basic implementation of a blob ITreeEntry
 */
class BlobTreeEntry {
    /**
     * Creates a blob ITreeEntry
     * @param path - path of entry
     * @param contents - blob contents
     * @param encoding - encoding of contents; defaults to utf-8
     */
    constructor(path, contents, encoding = "utf-8") {
        this.path = path;
        this.mode = protocol_definitions_1.FileMode.File;
        this.type = protocol_definitions_1.TreeEntry.Blob;
        this.value = { contents, encoding };
    }
}
exports.BlobTreeEntry = BlobTreeEntry;
/**
 * Basic implementation of a tree ITreeEntry
 */
class TreeTreeEntry {
    /**
     * Creates a tree ITreeEntry
     * @param path - path of entry
     * @param value - subtree
     */
    constructor(path, value) {
        this.path = path;
        this.value = value;
        this.mode = protocol_definitions_1.FileMode.Directory;
        this.type = protocol_definitions_1.TreeEntry.Tree;
    }
}
exports.TreeTreeEntry = TreeTreeEntry;
/**
 * Basic implementation of an attachment ITreeEntry
 */
class AttachmentTreeEntry {
    /**
     * Creates an attachment ITreeEntry
     * @param path - path of entry
     * @param id - id of external blob attachment
     */
    constructor(path, id) {
        this.path = path;
        this.id = id;
        this.mode = protocol_definitions_1.FileMode.File;
        this.type = protocol_definitions_1.TreeEntry.Attachment;
        this.value = { id };
    }
}
exports.AttachmentTreeEntry = AttachmentTreeEntry;
// eslint-disable-next-line @typescript-eslint/ban-types
function addBlobToTree(tree, blobName, content) {
    tree.entries.push({
        mode: protocol_definitions_1.FileMode.File,
        path: blobName,
        type: protocol_definitions_1.TreeEntry.Blob,
        value: {
            contents: JSON.stringify(content),
            encoding: "utf-8",
        },
    });
}
exports.addBlobToTree = addBlobToTree;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174}],166:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./blobs"), exports);
__exportStar(require("./protocol"), exports);
__exportStar(require("./quorum"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./scribeHelper"), exports);

},{"./blobs":165,"./protocol":167,"./quorum":168,"./scribeHelper":169,"./utils":170}],167:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolOpHandlerWithClientValidation = exports.ProtocolOpHandler = exports.isSystemMessage = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const quorum_1 = require("./quorum");
function isSystemMessage(message) {
    switch (message.type) {
        case protocol_definitions_1.MessageType.ClientJoin:
        case protocol_definitions_1.MessageType.ClientLeave:
        case protocol_definitions_1.MessageType.Propose:
        case protocol_definitions_1.MessageType.Reject:
        case protocol_definitions_1.MessageType.NoOp:
        case protocol_definitions_1.MessageType.NoClient:
        case protocol_definitions_1.MessageType.Summarize:
        case protocol_definitions_1.MessageType.SummaryAck:
        case protocol_definitions_1.MessageType.SummaryNack:
            return true;
        default:
            return false;
    }
}
exports.isSystemMessage = isSystemMessage;
/**
 * Handles protocol specific ops.
 */
class ProtocolOpHandler {
    constructor(minimumSequenceNumber, sequenceNumber, term, members, proposals, values, sendProposal) {
        this.minimumSequenceNumber = minimumSequenceNumber;
        this.sequenceNumber = sequenceNumber;
        this.term = term !== null && term !== void 0 ? term : 1;
        this._quorum = new quorum_1.Quorum(members, proposals, values, sendProposal);
    }
    get quorum() {
        return this._quorum;
    }
    get attributes() {
        return {
            minimumSequenceNumber: this.minimumSequenceNumber,
            sequenceNumber: this.sequenceNumber,
            term: this.term,
        };
    }
    setConnectionState(connected, clientId) {
        this._quorum.setConnectionState(connected, clientId);
    }
    snapshot() {
        return this._quorum.snapshot();
    }
    close() {
        this._quorum.close();
    }
    processMessage(message, local) {
        // verify it's moving sequentially
        if (message.sequenceNumber !== this.sequenceNumber + 1) {
            throw new Error(`Protocol state is not moving sequentially. ` +
                `Current is ${this.sequenceNumber}. Next is ${message.sequenceNumber}`);
        }
        // Update tracked sequence numbers
        this.sequenceNumber = message.sequenceNumber;
        this.minimumSequenceNumber = message.minimumSequenceNumber;
        let immediateNoOp = false;
        switch (message.type) {
            case protocol_definitions_1.MessageType.ClientJoin:
                const systemJoinMessage = message;
                const join = JSON.parse(systemJoinMessage.data);
                const member = {
                    client: join.detail,
                    sequenceNumber: systemJoinMessage.sequenceNumber,
                };
                this._quorum.addMember(join.clientId, member);
                break;
            case protocol_definitions_1.MessageType.ClientLeave:
                const systemLeaveMessage = message;
                const clientId = JSON.parse(systemLeaveMessage.data);
                this._quorum.removeMember(clientId);
                break;
            case protocol_definitions_1.MessageType.Propose:
                const proposal = message.contents;
                this._quorum.addProposal(proposal.key, proposal.value, message.sequenceNumber, local, message.clientSequenceNumber);
                // On a quorum proposal, immediately send a response to expedite the approval.
                immediateNoOp = true;
                break;
            case protocol_definitions_1.MessageType.Reject:
                throw new Error("Quorum rejection is removed.");
            default:
        }
        // Notify the quorum of the MSN from the message. We rely on it to handle duplicate values but may
        // want to move that logic to this class.
        this._quorum.updateMinimumSequenceNumber(message);
        return { immediateNoOp };
    }
    /**
     * Gets the scribe protocol state
     */
    getProtocolState() {
        // return a new object every time
        // this ensures future state changes will not affect outside callers
        return Object.assign({ sequenceNumber: this.sequenceNumber, minimumSequenceNumber: this.minimumSequenceNumber }, this._quorum.snapshot());
    }
}
exports.ProtocolOpHandler = ProtocolOpHandler;
class ProtocolOpHandlerWithClientValidation extends ProtocolOpHandler {
    processMessage(message, local) {
        const client = this._quorum.getMember(message.clientId);
        // Check and report if we're getting messages from a clientId that we previously
        // flagged as shouldHaveLeft, or from a client that's not in the quorum but should be
        if (message.clientId != null) {
            if (client === undefined && message.type !== protocol_definitions_1.MessageType.ClientJoin) {
                // pre-0.58 error message: messageClientIdMissingFromQuorum
                throw new Error("Remote message's clientId is missing from the quorum");
            }
            if ((client === null || client === void 0 ? void 0 : client.shouldHaveLeft) === true && message.type !== protocol_definitions_1.MessageType.NoOp) {
                // pre-0.58 error message: messageClientIdShouldHaveLeft
                throw new Error("Remote message's clientId already should have left");
            }
        }
        return super.processMessage(message, local);
    }
}
exports.ProtocolOpHandlerWithClientValidation = ProtocolOpHandlerWithClientValidation;

},{"./quorum":168,"@fluidframework/protocol-definitions":174}],168:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quorum = exports.QuorumProposals = exports.QuorumClients = void 0;
const events_1 = require("events");
// eslint-disable-next-line import/no-internal-modules
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Structure for tracking proposals that have been sequenced but not approved yet.
 */
class PendingProposal {
    constructor(sequenceNumber, key, value, local) {
        this.sequenceNumber = sequenceNumber;
        this.key = key;
        this.value = value;
        this.local = local;
    }
}
/**
 * The QuorumClients is used to track members joining and leaving the collaboration session.
 */
class QuorumClients extends common_utils_1.TypedEventEmitter {
    constructor(snapshot) {
        super();
        this.isDisposed = false;
        this.members = new Map(snapshot);
        this.snapshotCache = snapshot;
    }
    get disposed() { return this.isDisposed; }
    /**
     * Snapshots the current state of the QuorumClients
     * @returns a snapshot of the clients in the quorum
     */
    snapshot() {
        var _a;
        (_a = this.snapshotCache) !== null && _a !== void 0 ? _a : (this.snapshotCache = (0, cloneDeep_1.default)(Array.from(this.members)));
        return this.snapshotCache;
    }
    /**
     * Adds a new client to the quorum
     */
    addMember(clientId, details) {
        (0, common_utils_1.assert)(!this.members.has(clientId), 0x1ce /* clientId not found */);
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
        // clear the cache
        this.snapshotCache = undefined;
    }
    /**
     * Removes a client from the quorum
     */
    removeMember(clientId) {
        (0, common_utils_1.assert)(this.members.has(clientId), 0x1cf /* clientId not found */);
        this.members.delete(clientId);
        this.emit("removeMember", clientId);
        // clear the cache
        this.snapshotCache = undefined;
    }
    /**
     * Retrieves all the members in the quorum
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the quorum
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    dispose() {
        this.isDisposed = true;
    }
}
exports.QuorumClients = QuorumClients;
/**
 * The QuorumProposals holds a key/value store.  Proposed values become finalized in the store once all connected
 * clients have seen the proposal.
 */
class QuorumProposals extends common_utils_1.TypedEventEmitter {
    constructor(snapshot, sendProposal) {
        super();
        this.sendProposal = sendProposal;
        this.isDisposed = false;
        // Event emitter for changes to the environment that affect pending proposal promises.
        this.stateEvents = new events_1.EventEmitter();
        this.proposals = new Map(snapshot.proposals.map(([, proposal]) => {
            return [
                proposal.sequenceNumber,
                new PendingProposal(proposal.sequenceNumber, proposal.key, proposal.value, false),
            ];
        }));
        this.values = new Map(snapshot.values);
        this.proposalsSnapshotCache = snapshot.proposals;
        this.valuesSnapshotCache = snapshot.values;
    }
    get disposed() { return this.isDisposed; }
    /**
     * Snapshots the current state of the QuorumProposals
     * @returns deep cloned arrays of proposals and values
     */
    snapshot() {
        var _a, _b;
        (_a = this.proposalsSnapshotCache) !== null && _a !== void 0 ? _a : (this.proposalsSnapshotCache = Array.from(this.proposals).map(([sequenceNumber, proposal]) => [
            sequenceNumber,
            { sequenceNumber, key: proposal.key, value: proposal.value },
            [], // rejections, which has been removed
        ]));
        (_b = this.valuesSnapshotCache) !== null && _b !== void 0 ? _b : (this.valuesSnapshotCache = (0, cloneDeep_1.default)(Array.from(this.values)));
        return {
            proposals: this.proposalsSnapshotCache,
            values: this.valuesSnapshotCache,
        };
    }
    /**
     * Returns whether the quorum has achieved a consensus for the given key.
     */
    has(key) {
        return this.values.has(key);
    }
    /**
     * Returns the consensus value for the given key
     */
    get(key) {
        var _a;
        return (_a = this.values.get(key)) === null || _a === void 0 ? void 0 : _a.value;
    }
    /**
     * Returns additional data about the approved consensus value
     * @deprecated Removed in recent protocol-definitions.  Use get() instead.
     */
    getApprovalData(key) {
        const proposal = this.values.get(key);
        return proposal ? (0, cloneDeep_1.default)(proposal) : undefined;
    }
    /**
     * Proposes a new value. Returns a promise that will either:
     * - Resolve when the proposal is accepted
     * - Reject if the proposal fails to send or if the QuorumProposals is disposed
     */
    async propose(key, value) {
        const clientSequenceNumber = this.sendProposal(key, value);
        if (clientSequenceNumber < 0) {
            this.emit("error", { eventName: "ProposalInDisconnectedState", key });
            throw new Error("Can't propose in disconnected state");
        }
        return new Promise((resolve, reject) => {
            // The sequence number that our proposal was assigned and went pending.
            // If undefined, then it's not sequenced yet.
            let thisProposalSequenceNumber;
            // A proposal goes through two phases before this promise resolves:
            // 1. Sequencing - waiting for the proposal to be ack'd by the server.
            // 2. Approval - waiting for the proposal to be approved by connected clients.
            const localProposalSequencedHandler = (sequencedCSN, sequenceNumber) => {
                if (sequencedCSN === clientSequenceNumber) {
                    thisProposalSequenceNumber = sequenceNumber;
                    this.stateEvents.off("localProposalSequenced", localProposalSequencedHandler);
                    this.stateEvents.off("disconnected", disconnectedHandler);
                    this.stateEvents.on("localProposalApproved", localProposalApprovedHandler);
                }
            };
            const localProposalApprovedHandler = (sequenceNumber) => {
                // Proposals can be uniquely identified by the sequenceNumber they were assigned.
                if (sequenceNumber === thisProposalSequenceNumber) {
                    resolve();
                    removeListeners();
                }
            };
            // There are two error flows we consider:  disconnect and disposal.
            // If we get disconnected before the proposal is sequenced, it has one of two possible futures:
            // 1. We reconnect and see the proposal was sequenced in the meantime.
            //    -> The promise can still resolve, once it is approved.
            // 2. We reconnect and see the proposal was not sequenced in the meantime, so it will never sequence.
            //    -> The promise rejects.
            const disconnectedHandler = () => {
                // If we haven't seen the ack by the time we disconnect, we hope to see it by the time we reconnect.
                if (thisProposalSequenceNumber === undefined) {
                    this.stateEvents.once("connected", () => {
                        // If we don't see the ack by the time reconnection finishes, it failed to send.
                        if (thisProposalSequenceNumber === undefined) {
                            reject(new Error("Client disconnected without successfully sending proposal"));
                            removeListeners();
                        }
                    });
                }
            };
            // If the QuorumProposals is disposed of, we assume something catastrophic has happened
            // All outstanding proposals are considered rejected.
            const disposedHandler = () => {
                reject(new Error("QuorumProposals was disposed"));
                removeListeners();
            };
            // Convenience function to clean up our listeners.
            const removeListeners = () => {
                this.stateEvents.off("localProposalSequenced", localProposalSequencedHandler);
                this.stateEvents.off("localProposalApproved", localProposalApprovedHandler);
                this.stateEvents.off("disconnected", disconnectedHandler);
                this.stateEvents.off("disposed", disposedHandler);
            };
            this.stateEvents.on("localProposalSequenced", localProposalSequencedHandler);
            this.stateEvents.on("disconnected", disconnectedHandler);
            this.stateEvents.on("disposed", disposedHandler);
        });
    }
    /**
     * Begins tracking a new proposal
     */
    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {
        (0, common_utils_1.assert)(!this.proposals.has(sequenceNumber), 0x1d0 /* sequenceNumber not found */);
        const proposal = new PendingProposal(sequenceNumber, key, value, local);
        this.proposals.set(sequenceNumber, proposal);
        // Legacy event, from rejection support.  May still have some use for clients to learn that a proposal is
        // likely to be approved soon.
        this.emit("addProposal", proposal);
        if (local) {
            this.stateEvents.emit("localProposalSequenced", clientSequenceNumber, sequenceNumber);
        }
        // clear the proposal cache
        this.proposalsSnapshotCache = undefined;
    }
    /**
     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it
     * becomes an approved value.
     */
    updateMinimumSequenceNumber(message) {
        const msn = message.minimumSequenceNumber;
        // Accept proposals proposals whose sequenceNumber is <= the minimumSequenceNumber
        // Return a sorted list of approved proposals. We sort so that we apply them in their sequence number order
        // TODO this can be optimized if necessary to avoid the linear search+sort
        const completed = [];
        for (const [sequenceNumber, proposal] of this.proposals) {
            if (sequenceNumber <= msn) {
                completed.push(proposal);
            }
        }
        completed.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        for (const proposal of completed) {
            const committedProposal = {
                approvalSequenceNumber: message.sequenceNumber,
                // No longer used.  We still stamp a -1 for compat with older versions of the quorum.
                // Can be removed after 0.1035 and higher is ubiquitous.
                commitSequenceNumber: -1,
                key: proposal.key,
                sequenceNumber: proposal.sequenceNumber,
                value: proposal.value,
            };
            this.values.set(committedProposal.key, committedProposal);
            // clear the values cache
            this.valuesSnapshotCache = undefined;
            this.emit("approveProposal", committedProposal.sequenceNumber, committedProposal.key, committedProposal.value, committedProposal.approvalSequenceNumber);
            this.proposals.delete(proposal.sequenceNumber);
            // clear the proposals cache
            this.proposalsSnapshotCache = undefined;
            if (proposal.local) {
                this.stateEvents.emit("localProposalApproved", proposal.sequenceNumber);
            }
        }
    }
    setConnectionState(connected) {
        if (connected) {
            this.stateEvents.emit("connected");
        }
        else {
            this.stateEvents.emit("disconnected");
        }
    }
    dispose() {
        this.isDisposed = true;
        this.stateEvents.emit("disposed");
    }
}
exports.QuorumProposals = QuorumProposals;
/**
 * A quorum represents all clients currently within the collaboration window. As well as the values
 * they have agreed upon and any pending proposals.
 */
class Quorum extends common_utils_1.TypedEventEmitter {
    constructor(members, proposals, values, sendProposal) {
        super();
        this.isDisposed = false;
        this.quorumClients = new QuorumClients(members);
        this.quorumClients.on("addMember", (clientId, details) => {
            this.emit("addMember", clientId, details);
        });
        this.quorumClients.on("removeMember", (clientId) => {
            this.emit("removeMember", clientId);
        });
        this.quorumProposals = new QuorumProposals({ proposals, values }, sendProposal);
        this.quorumProposals.on("addProposal", (proposal) => {
            this.emit("addProposal", proposal);
        });
        this.quorumProposals.on("approveProposal", (sequenceNumber, key, value, approvalSequenceNumber) => {
            this.emit("approveProposal", sequenceNumber, key, value, approvalSequenceNumber);
        });
    }
    get disposed() { return this.isDisposed; }
    close() {
        this.removeAllListeners();
    }
    /**
     * Snapshots the entire quorum
     * @returns a quorum snapshot
     */
    snapshot() {
        const members = this.quorumClients.snapshot();
        const { proposals, values } = this.quorumProposals.snapshot();
        return {
            members,
            proposals,
            values,
        };
    }
    /**
     * Returns whether the quorum has achieved a consensus for the given key.
     */
    has(key) {
        return this.quorumProposals.has(key);
    }
    /**
     * Returns the consensus value for the given key
     */
    get(key) {
        return this.quorumProposals.get(key);
    }
    /**
     * Returns additional data about the approved consensus value
     * @deprecated Removed in recent protocol-definitions.  Use get() instead.
     */
    getApprovalData(key) {
        return this.quorumProposals.getApprovalData(key);
    }
    /**
     * Adds a new client to the quorum
     */
    addMember(clientId, details) {
        this.quorumClients.addMember(clientId, details);
    }
    /**
     * Removes a client from the quorum
     */
    removeMember(clientId) {
        this.quorumClients.removeMember(clientId);
    }
    /**
     * Retrieves all the members in the quorum
     */
    getMembers() {
        return this.quorumClients.getMembers();
    }
    /**
     * Retrieves a specific member of the quorum
     */
    getMember(clientId) {
        return this.quorumClients.getMember(clientId);
    }
    /**
     * Proposes a new value. Returns a promise that will resolve when the proposal is either accepted, or reject if
     * the proposal fails to send.
     */
    async propose(key, value) {
        return this.quorumProposals.propose(key, value);
    }
    /**
     * Begins tracking a new proposal
     */
    addProposal(key, value, sequenceNumber, local, clientSequenceNumber) {
        return this.quorumProposals.addProposal(key, value, sequenceNumber, local, clientSequenceNumber);
    }
    /**
     * Updates the minimum sequence number. If the MSN advances past the sequence number for any proposal then it
     * becomes an approved value.
     */
    updateMinimumSequenceNumber(message) {
        this.quorumProposals.updateMinimumSequenceNumber(message);
    }
    setConnectionState(connected, clientId) {
        this.quorumProposals.setConnectionState(connected);
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
}
exports.Quorum = Quorum;

},{"@fluidframework/common-utils":29,"events":562,"lodash/cloneDeep":502}],169:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateServiceProtocolEntries = exports.mergeAppAndProtocolTree = exports.getQuorumTreeEntries = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
function getQuorumTreeEntries(documentId, minimumSequenceNumber, sequenceNumber, term, quorumSnapshot) {
    const documentAttributes = {
        minimumSequenceNumber,
        sequenceNumber,
        term,
    };
    const entries = [
        {
            mode: protocol_definitions_1.FileMode.File,
            path: "quorumMembers",
            type: protocol_definitions_1.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.members),
                encoding: "utf-8",
            },
        },
        {
            mode: protocol_definitions_1.FileMode.File,
            path: "quorumProposals",
            type: protocol_definitions_1.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.proposals),
                encoding: "utf-8",
            },
        },
        {
            mode: protocol_definitions_1.FileMode.File,
            path: "quorumValues",
            type: protocol_definitions_1.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(quorumSnapshot.values),
                encoding: "utf-8",
            },
        },
        {
            mode: protocol_definitions_1.FileMode.File,
            path: "attributes",
            type: protocol_definitions_1.TreeEntry.Blob,
            value: {
                contents: JSON.stringify(documentAttributes),
                encoding: "utf-8",
            },
        },
    ];
    return entries;
}
exports.getQuorumTreeEntries = getQuorumTreeEntries;
function mergeAppAndProtocolTree(appSummaryTree, protocolTree) {
    const newTreeEntries = appSummaryTree.tree
        .filter((value) => !isInvalidPath(value.path))
        .map((value) => {
        const createTreeEntry = {
            mode: value.mode,
            path: value.path,
            sha: value.sha,
            type: value.type,
        };
        return createTreeEntry;
    });
    newTreeEntries.push({
        mode: protocol_definitions_1.FileMode.Directory,
        path: ".protocol",
        sha: protocolTree.sha,
        type: "tree",
    });
    return newTreeEntries;
}
exports.mergeAppAndProtocolTree = mergeAppAndProtocolTree;
function generateServiceProtocolEntries(deli, scribe) {
    const serviceProtocolEntries = [
        {
            mode: protocol_definitions_1.FileMode.File,
            path: "deli",
            type: protocol_definitions_1.TreeEntry.Blob,
            value: {
                contents: deli,
                encoding: "utf-8",
            },
        },
    ];
    serviceProtocolEntries.push({
        mode: protocol_definitions_1.FileMode.File,
        path: "scribe",
        type: protocol_definitions_1.TreeEntry.Blob,
        value: {
            contents: scribe,
            encoding: "utf-8",
        },
    });
    return serviceProtocolEntries;
}
exports.generateServiceProtocolEntries = generateServiceProtocolEntries;
const isInvalidPath = (path) => (path === ".protocol" ||
    path === ".logTail" ||
    path === ".serviceProtocol");

},{"@fluidframework/protocol-definitions":174}],170:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isServiceMessageType = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Check if the string is a service message type, which includes
 * MessageType.ClientJoin, MessageType.ClientLeave, MessageType.Control,
 * MessageType.NoClient, MessageType.SummaryAck, and MessageType.SummaryNack
 *
 * @param type - the type to check
 * @returns true if it is a system message type
 */
const isServiceMessageType = (type) => (type === protocol_definitions_1.MessageType.ClientJoin ||
    type === protocol_definitions_1.MessageType.ClientLeave ||
    type === protocol_definitions_1.MessageType.Control ||
    type === protocol_definitions_1.MessageType.NoClient ||
    type === protocol_definitions_1.MessageType.SummaryAck ||
    type === protocol_definitions_1.MessageType.SummaryNack);
exports.isServiceMessageType = isServiceMessageType;

},{"@fluidframework/protocol-definitions":174}],171:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],172:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],173:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],174:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./clients"), exports);
__exportStar(require("./consensus"), exports);
__exportStar(require("./config"), exports);
__exportStar(require("./protocol"), exports);
__exportStar(require("./storage"), exports);
__exportStar(require("./summary"), exports);
__exportStar(require("./users"), exports);
__exportStar(require("./tokens"), exports);
__exportStar(require("./scopes"), exports);
__exportStar(require("./sockets"), exports);

},{"./clients":171,"./config":172,"./consensus":173,"./protocol":175,"./scopes":176,"./sockets":177,"./storage":178,"./summary":179,"./tokens":180,"./users":181}],175:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NackErrorType = exports.MessageType = void 0;
var MessageType;
(function (MessageType) {
    // Empty operation message. Used to send an updated reference sequence number.
    MessageType["NoOp"] = "noop";
    // System message sent to indicate a new client has joined the collaboration
    MessageType["ClientJoin"] = "join";
    // System message sent to indicate a client has left the collaboration
    MessageType["ClientLeave"] = "leave";
    // Proposes a new consensus value
    MessageType["Propose"] = "propose";
    // Message used to reject a pending proposal
    MessageType["Reject"] = "reject";
    // Summary op
    MessageType["Summarize"] = "summarize";
    // Summary op written
    MessageType["SummaryAck"] = "summaryAck";
    // Summary op write failure
    MessageType["SummaryNack"] = "summaryNack";
    // Channel operation.
    MessageType["Operation"] = "op";
    // Message to indicate the need of a remote agent for a document.
    MessageType["RemoteHelp"] = "remoteHelp";
    // Message to indicate that no active clients are present.
    MessageType["NoClient"] = "noClient";
    // Message to indicate successful round trip.
    MessageType["RoundTrip"] = "tripComplete";
    // Service specific control messages that are never sequenced.
    MessageType["Control"] = "control";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * Type of the Nack.
 * InvalidScopeError: Client's token is not valid for the intended op.
 * ThrottlingError: Retryable after retryAfter number.
 * BadRequestError: Clients op is invalid and should retry immediately with a valid op.
 * LimitExceededError: Service is having issues. Client should not retry.
 */
var NackErrorType;
(function (NackErrorType) {
    NackErrorType["ThrottlingError"] = "ThrottlingError";
    NackErrorType["InvalidScopeError"] = "InvalidScopeError";
    NackErrorType["BadRequestError"] = "BadRequestError";
    NackErrorType["LimitExceededError"] = "LimitExceededError";
})(NackErrorType = exports.NackErrorType || (exports.NackErrorType = {}));

},{}],176:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeType = void 0;
var ScopeType;
(function (ScopeType) {
    ScopeType["DocRead"] = "doc:read";
    ScopeType["DocWrite"] = "doc:write";
    ScopeType["SummaryWrite"] = "summary:write";
})(ScopeType = exports.ScopeType || (exports.ScopeType = {}));

},{}],177:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],178:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeEntry = exports.FileMode = void 0;
var FileMode;
(function (FileMode) {
    FileMode["File"] = "100644";
    FileMode["Executable"] = "100755";
    FileMode["Directory"] = "040000";
    FileMode["Symlink"] = "120000";
})(FileMode = exports.FileMode || (exports.FileMode = {}));
/**
 * Type of entries that can be stored in a tree
 */
var TreeEntry;
(function (TreeEntry) {
    TreeEntry["Blob"] = "Blob";
    TreeEntry["Tree"] = "Tree";
    TreeEntry["Attachment"] = "Attachment";
})(TreeEntry = exports.TreeEntry || (exports.TreeEntry = {}));

},{}],179:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryType = void 0;
/**
 *  Type tag used to distinguish different types of nodes in a {@link ISummaryTree}.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var SummaryType;
(function (SummaryType) {
    /**
     *  Represents a sub-tree in the summary.
     */
    SummaryType.Tree = 1;
    /**
     * Represents a blob of data that is added to the summary.
     * Such as the user data that is added to the DDS or metadata added by runtime
     * such as data store / channel attributes.
     */
    SummaryType.Blob = 2;
    /**
     * Path to a summary tree object from the last successful summary.
     */
    SummaryType.Handle = 3;
    /**
     * Unique identifier to larger blobs uploaded outside of the summary.
     * Ex. DDS has large images or video that will be uploaded by the BlobManager and
     * receive an Id that can be used in the summary.
     */
    SummaryType.Attachment = 4;
})(SummaryType = exports.SummaryType || (exports.SummaryType = {}));

},{}],180:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],181:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],182:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./requestHandlers"), exports);
__exportStar(require("./runtimeRequestHandlerBuilder"), exports);

},{"./requestHandlers":183,"./runtimeRequestHandlerBuilder":184}],183:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleFromLegacyUri = exports.createFluidObjectResponse = exports.rootDataStoreRequestHandler = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
 * A request handler to expose access to all root data stores in the container by id.
 * @param request - the request for the root data store.  The first path part must be the data store's ID.
 * @param runtime - the container runtime
 * @returns the result of the request
 */
const rootDataStoreRequestHandler = async (request, runtime) => {
    var _a;
    const requestParser = runtime_utils_1.RequestParser.create(request);
    const id = requestParser.pathParts[0];
    const wait = typeof ((_a = request.headers) === null || _a === void 0 ? void 0 : _a.wait) === "boolean" ? request.headers.wait : undefined;
    let rootDataStore;
    try {
        // getRootDataStore currently throws if the data store is not found
        rootDataStore = await runtime.getRootDataStore(id, wait);
    }
    catch (error) {
        return undefined; // continue search
    }
    try {
        return rootDataStore.IFluidRouter.request(requestParser.createSubRequest(1));
    }
    catch (error) {
        return { status: 500, mimeType: "fluid/object", value: error };
    }
};
exports.rootDataStoreRequestHandler = rootDataStoreRequestHandler;
const createFluidObjectResponse = (fluidObject) => {
    return { status: 200, mimeType: "fluid/object", value: fluidObject };
};
exports.createFluidObjectResponse = createFluidObjectResponse;
class LegacyUriHandle {
    constructor(absolutePath, runtime) {
        this.absolutePath = absolutePath;
        this.runtime = runtime;
        this.isAttached = true;
    }
    get IFluidHandle() { return this; }
    attachGraph() {
        (0, common_utils_1.assert)(false, 0x0ca /* "Trying to use legacy graph attach!" */);
    }
    async get() {
        const response = await this.runtime.IFluidHandleContext.resolveHandle({ url: this.absolutePath });
        if (response.status === 200 && response.mimeType === "fluid/object") {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return response.value;
        }
        throw new Error(`Failed to resolve container path ${this.absolutePath}`);
    }
    bind(handle) {
        throw new Error("Cannot bind to LegacyUriHandle");
    }
}
function handleFromLegacyUri(uri, runtime) {
    return new LegacyUriHandle(uri, runtime);
}
exports.handleFromLegacyUri = handleFromLegacyUri;

},{"@fluidframework/common-utils":29,"@fluidframework/runtime-utils":213}],184:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildRuntimeRequestHandler = exports.RuntimeRequestHandlerBuilder = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
  * The RuntimeRequestHandlerBuilder creates a runtime request handler based on request handlers.
  * The provided handlers sequentially applied until one is able to satisfy the request.
  */
class RuntimeRequestHandlerBuilder {
    constructor() {
        this.handlers = [];
    }
    pushHandler(...handlers) {
        if (handlers !== undefined) {
            this.handlers.push(...handlers);
        }
    }
    async handleRequest(request, runtime) {
        const parser = runtime_utils_1.RequestParser.create(request);
        for (const handler of this.handlers) {
            const response = await handler(parser, runtime);
            if (response !== undefined) {
                return response;
            }
        }
        return (0, runtime_utils_1.create404Response)(request);
    }
}
exports.RuntimeRequestHandlerBuilder = RuntimeRequestHandlerBuilder;
function buildRuntimeRequestHandler(...handlers) {
    const builder = new RuntimeRequestHandlerBuilder();
    builder.pushHandler(...handlers);
    return async (request, runtime) => builder.handleRequest(request, runtime);
}
exports.buildRuntimeRequestHandler = buildRuntimeRequestHandler;

},{"@fluidframework/runtime-utils":213}],185:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryCache = void 0;
class InMemoryCache {
    constructor() {
        this.cache = new Map();
    }
    async get(key) {
        return this.cache.get(key);
    }
    async put(key, value) {
        this.cache.set(key, value);
    }
}
exports.InMemoryCache = InMemoryCache;

},{}],186:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSummaryToCreateNewSummary = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Utility api to convert ISummaryTree to a summary tree where blob contents are only utf8 strings.
 * @param summary - Summary supplied by the runtime to upload.
 * @returns - Modified summary tree where the blob contents could be utf8 string only.
 */
function convertSummaryToCreateNewSummary(summary) {
    const keys = Object.keys(summary.tree);
    for (const key of keys) {
        const summaryObject = summary.tree[key];
        switch (summaryObject.type) {
            case protocol_definitions_1.SummaryType.Tree: {
                summary.tree[key] = convertSummaryToCreateNewSummary(summaryObject);
                break;
            }
            case protocol_definitions_1.SummaryType.Blob: {
                summaryObject.content = typeof summaryObject.content === "string" ?
                    summaryObject.content : (0, common_utils_1.Uint8ArrayToString)(summaryObject.content, "utf8");
                break;
            }
            case protocol_definitions_1.SummaryType.Handle: {
                throw new Error("No handle should be present for first summary!!");
            }
            default: {
                throw new Error(`Unknown tree type ${summaryObject.type}`);
            }
        }
    }
    return summary;
}
exports.convertSummaryToCreateNewSummary = convertSummaryToCreateNewSummary;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174}],187:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTokenProvider = void 0;
/**
 * Default token provider in case the host does not provide one. It simply caches the provided jwt and returns it back.
 */
class DefaultTokenProvider {
    constructor(jwt) {
        this.jwt = jwt;
    }
    async fetchOrdererToken() {
        return {
            fromCache: true,
            jwt: this.jwt,
        };
    }
    async fetchStorageToken() {
        return {
            fromCache: true,
            jwt: this.jwt,
        };
    }
}
exports.DefaultTokenProvider = DefaultTokenProvider;

},{}],188:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaStorageService = exports.DocumentDeltaStorageService = void 0;
const driver_utils_1 = require("@fluidframework/driver-utils");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const MaxBatchDeltas = 2000; // Maximum number of ops we can fetch at a time
/**
 * Storage service limited to only being able to fetch documents for a specific document
 */
class DocumentDeltaStorageService {
    constructor(tenantId, id, deltaStorageService, documentStorageService) {
        this.tenantId = tenantId;
        this.id = id;
        this.deltaStorageService = deltaStorageService;
        this.documentStorageService = documentStorageService;
        this.logtailSha = this.documentStorageService.logTailSha;
    }
    fetchMessages(from, to, abortSignal, cachedOnly, fetchReason) {
        if (cachedOnly) {
            return driver_utils_1.emptyMessageStream;
        }
        return (0, driver_utils_1.requestOps)(this.getCore.bind(this), 
        // Staging: starting with no concurrency, listening for feedback first.
        // In future releases we will switch to actual concurrency
        1, // concurrency
        from, // inclusive
        to, // exclusive
        MaxBatchDeltas, new common_utils_1.TelemetryNullLogger(), abortSignal, fetchReason);
    }
    async getCore(from, to) {
        const opsFromLogTail = this.logtailSha
            ? await (0, driver_utils_1.readAndParse)(this.documentStorageService, this.logtailSha)
            : [];
        this.logtailSha = undefined;
        if (opsFromLogTail.length > 0) {
            const messages = opsFromLogTail.filter((op) => op.sequenceNumber >= from);
            if (messages.length > 0) {
                return { messages, partialResult: true };
            }
        }
        return this.deltaStorageService.get(this.tenantId, this.id, from, to);
    }
}
exports.DocumentDeltaStorageService = DocumentDeltaStorageService;
/**
 * Provides access to the underlying delta storage on the server for routerlicious driver.
 */
class DeltaStorageService {
    constructor(url, restWrapper, logger, getRestWrapper = async () => this.restWrapper, getDeltaStorageUrl = () => this.url) {
        this.url = url;
        this.restWrapper = restWrapper;
        this.logger = logger;
        this.getRestWrapper = getRestWrapper;
        this.getDeltaStorageUrl = getDeltaStorageUrl;
    }
    async get(tenantId, id, from, // inclusive
    to) {
        const ops = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getDeltas",
            from,
            to,
        }, async (event) => {
            const restWrapper = await this.getRestWrapper();
            const url = this.getDeltaStorageUrl();
            const response = await restWrapper.get(url, { from: from - 1, to });
            event.end({
                count: response.length,
            });
            return response;
        });
        // It is assumed that server always returns all the ops that it has in the range that was requested.
        // This may change in the future, if so, we need to adjust and receive "end" value from server in such case.
        return { messages: ops, partialResult: false };
    }
}
exports.DeltaStorageService = DeltaStorageService;

},{"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279}],189:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.R11sDocumentDeltaConnection = void 0;
const driver_base_1 = require("@fluidframework/driver-base");
const errorUtils_1 = require("./errorUtils");
const packageVersion_1 = require("./packageVersion");
const protocolVersions = ["^0.4.0", "^0.3.0", "^0.2.0", "^0.1.0"];
/**
 * Wrapper over the shared one for driver specific translation.
 */
class R11sDocumentDeltaConnection extends driver_base_1.DocumentDeltaConnection {
    static async create(tenantId, id, token, io, client, url, logger, timeoutMs = 20000) {
        const socket = io(url, {
            query: {
                documentId: id,
                tenantId,
            },
            reconnection: false,
            // Default to websocket connection, with long-polling disabled
            transports: ["websocket"],
            timeout: timeoutMs,
        });
        const connectMessage = {
            client,
            id,
            mode: client.mode,
            tenantId,
            token,
            versions: protocolVersions,
            relayUserAgent: [client.details.environment, ` driverVersion:${packageVersion_1.pkgVersion}`].join(";"),
        };
        // TODO: expose to host at factory level
        const enableLongPollingDowngrades = true;
        const deltaConnection = new R11sDocumentDeltaConnection(socket, id, logger, enableLongPollingDowngrades);
        await deltaConnection.initialize(connectMessage, timeoutMs);
        return deltaConnection;
    }
    /**
     * Error raising for socket.io issues
     */
    createErrorObject(handler, error, canRetry = true) {
        // Note: we suspect the incoming error object is either:
        // - a socketError: add it to the R11sError object for driver to be able to parse it and reason over it.
        // - anything else: let base class handle it
        if (canRetry && Number.isInteger(error === null || error === void 0 ? void 0 : error.code) && typeof (error === null || error === void 0 ? void 0 : error.message) === "string") {
            return (0, errorUtils_1.errorObjectFromSocketError)(error, handler);
        }
        else {
            return super.createErrorObject(handler, error, canRetry);
        }
    }
}
exports.R11sDocumentDeltaConnection = R11sDocumentDeltaConnection;

},{"./errorUtils":193,"./packageVersion":196,"@fluidframework/driver-base":97}],190:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentService = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const api = __importStar(require("@fluidframework/driver-definitions"));
const driver_utils_1 = require("@fluidframework/driver-utils");
const server_services_client_1 = require("@fluidframework/server-services-client");
const socket_io_client_1 = __importDefault(require("socket.io-client"));
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const deltaStorageService_1 = require("./deltaStorageService");
const documentStorageService_1 = require("./documentStorageService");
const documentDeltaConnection_1 = require("./documentDeltaConnection");
const nullBlobStorageService_1 = require("./nullBlobStorageService");
const restWrapper_1 = require("./restWrapper");
/**
 * Amount of time between discoveries within which we don't need to rediscover on re-connect.
 * Currently, R11s defines session length at 10 minutes. To avoid any weird unknown edge-cases though,
 * we set the limit to 5 minutes here.
 * In the future, we likely want to retrieve this information from service's "inactive session" definition.
 */
const RediscoverAfterTimeSinceDiscoveryMs = 5 * 60000; // 5 minute
/**
 * The DocumentService manages the Socket.IO connection and manages routing requests to connected
 * clients.
 */
class DocumentService {
    constructor(_resolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger, tokenProvider, tenantId, documentId, driverPolicies, blobCache, snapshotTreeCache, discoverFluidResolvedUrl) {
        this._resolvedUrl = _resolvedUrl;
        this.ordererUrl = ordererUrl;
        this.deltaStorageUrl = deltaStorageUrl;
        this.storageUrl = storageUrl;
        this.logger = logger;
        this.tokenProvider = tokenProvider;
        this.tenantId = tenantId;
        this.documentId = documentId;
        this.driverPolicies = driverPolicies;
        this.blobCache = blobCache;
        this.snapshotTreeCache = snapshotTreeCache;
        this.discoverFluidResolvedUrl = discoverFluidResolvedUrl;
        this.lastDiscoveredAt = Date.now();
    }
    get resolvedUrl() {
        return this._resolvedUrl;
    }
    dispose() { }
    /**
     * Connects to a storage endpoint for snapshot service.
     *
     * @returns returns the document storage service for routerlicious driver.
     */
    async connectToStorage() {
        if (this.documentStorageService !== undefined) {
            return this.documentStorageService;
        }
        if (this.storageUrl === undefined) {
            return new nullBlobStorageService_1.NullBlobStorageService();
        }
        const getStorageManager = async (disableCache) => {
            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();
            if (shouldUpdateDiscoveredSessionInfo) {
                await this.refreshDiscovery();
            }
            if (!this.storageManager || !this.noCacheStorageManager || shouldUpdateDiscoveredSessionInfo) {
                const rateLimiter = new driver_utils_1.RateLimiter(this.driverPolicies.maxConcurrentStorageRequests);
                const storageRestWrapper = await restWrapper_1.RouterliciousStorageRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess, this.storageUrl);
                const historian = new server_services_client_1.Historian(this.storageUrl, true, false, storageRestWrapper);
                this.storageManager = new server_services_client_1.GitManager(historian);
                const noCacheHistorian = new server_services_client_1.Historian(this.storageUrl, true, true, storageRestWrapper);
                this.noCacheStorageManager = new server_services_client_1.GitManager(noCacheHistorian);
            }
            return disableCache ? this.noCacheStorageManager : this.storageManager;
        };
        // Initialize storageManager and noCacheStorageManager
        const storageManager = await getStorageManager();
        const noCacheStorageManager = await getStorageManager(true);
        const documentStorageServicePolicies = {
            caching: this.driverPolicies.enablePrefetch
                ? api.LoaderCachingPolicy.Prefetch
                : api.LoaderCachingPolicy.NoCaching,
            minBlobSize: this.driverPolicies.aggregateBlobsSmallerThanBytes,
        };
        this.documentStorageService = new documentStorageService_1.DocumentStorageService(this.documentId, storageManager, this.logger, documentStorageServicePolicies, this.driverPolicies, this.blobCache, this.snapshotTreeCache, noCacheStorageManager, getStorageManager);
        return this.documentStorageService;
    }
    /**
     * Connects to a delta storage endpoint for getting ops between a range.
     *
     * @returns returns the document delta storage service for routerlicious driver.
     */
    async connectToDeltaStorage() {
        await this.connectToStorage();
        (0, common_utils_1.assert)(!!this.documentStorageService, 0x0b1 /* "Storage service not initialized" */);
        const getRestWrapper = async () => {
            const shouldUpdateDiscoveredSessionInfo = this.shouldUpdateDiscoveredSessionInfo();
            if (shouldUpdateDiscoveredSessionInfo) {
                await this.refreshDiscovery();
            }
            if (!this.ordererRestWrapper || shouldUpdateDiscoveredSessionInfo) {
                const rateLimiter = new driver_utils_1.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
                this.ordererRestWrapper = await restWrapper_1.RouterliciousOrdererRestWrapper.load(this.tenantId, this.documentId, this.tokenProvider, this.logger, rateLimiter, this.driverPolicies.enableRestLess);
            }
            return this.ordererRestWrapper;
        };
        const restWrapper = await getRestWrapper();
        const deltaStorageService = new deltaStorageService_1.DeltaStorageService(this.deltaStorageUrl, restWrapper, this.logger, getRestWrapper, () => this.deltaStorageUrl);
        return new deltaStorageService_1.DocumentDeltaStorageService(this.tenantId, this.documentId, deltaStorageService, this.documentStorageService);
    }
    /**
     * Connects to a delta stream endpoint for emitting ops.
     *
     * @returns returns the document delta stream service for routerlicious driver.
     */
    async connectToDeltaStream(client) {
        const connect = async (refreshToken) => {
            if (this.shouldUpdateDiscoveredSessionInfo()) {
                await this.refreshDiscovery();
            }
            const ordererToken = await this.tokenProvider.fetchOrdererToken(this.tenantId, this.documentId, refreshToken);
            return documentDeltaConnection_1.R11sDocumentDeltaConnection.create(this.tenantId, this.documentId, ordererToken.jwt, socket_io_client_1.default, client, this.ordererUrl, this.logger);
        };
        // Attempt to establish connection.
        // Retry with new token on authorization error; otherwise, allow container layer to handle.
        try {
            const connection = await connect();
            return connection;
        }
        catch (error) {
            if ((error === null || error === void 0 ? void 0 : error.statusCode) === 401) {
                // Fetch new token and retry once,
                // otherwise 401 will be bubbled up as non-retriable AuthorizationError.
                return connect(true /* refreshToken */);
            }
            throw error;
        }
    }
    /**
     * Re-discover session URLs if necessary.
     */
    async refreshDiscovery() {
        if (!this.discoverP) {
            this.discoverP = telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
                eventName: "refreshSessionDiscovery",
            }, async () => this.refreshDiscoveryCore());
        }
        return this.discoverP;
    }
    async refreshDiscoveryCore() {
        const fluidResolvedUrl = await this.discoverFluidResolvedUrl();
        this._resolvedUrl = fluidResolvedUrl;
        this.storageUrl = fluidResolvedUrl.endpoints.storageUrl;
        this.ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;
        this.deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;
    }
    /**
     * Whether enough time has passed since last disconnect to warrant a new discovery call on reconnect.
     */
    shouldUpdateDiscoveredSessionInfo() {
        if (!this.driverPolicies.enableDiscovery) {
            return false;
        }
        const now = Date.now();
        // When connection is disconnected, we cannot know if session has moved or document has been deleted
        // without re-doing discovery on the next attempt to connect.
        // Disconnect event is not so reliable in local testing. To ensure re-discovery when necessary,
        // re-discover if enough time has passed since last discovery.
        const pastLastDiscoveryTimeThreshold = (now - this.lastDiscoveredAt) > RediscoverAfterTimeSinceDiscoveryMs;
        if (pastLastDiscoveryTimeThreshold) {
            // Reset discover promise and refresh discovery.
            this.lastDiscoveredAt = Date.now();
            this.discoverP = undefined;
            this.refreshDiscovery().catch(() => {
                // Undo discovery time set on failure, so that next check refreshes.
                this.lastDiscoveredAt = 0;
            });
        }
        return pastLastDiscoveryTimeThreshold;
    }
}
exports.DocumentService = DocumentService;

},{"./deltaStorageService":188,"./documentDeltaConnection":189,"./documentStorageService":192,"./nullBlobStorageService":195,"./restWrapper":198,"@fluidframework/common-utils":29,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110,"@fluidframework/server-services-client":245,"@fluidframework/telemetry-utils":279,"socket.io-client":535}],191:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentPostCreateError = exports.RouterliciousDocumentServiceFactory = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const documentService_1 = require("./documentService");
const restWrapper_1 = require("./restWrapper");
const createNewUtils_1 = require("./createNewUtils");
const urlUtils_1 = require("./urlUtils");
const cache_1 = require("./cache");
const packageVersion_1 = require("./packageVersion");
const defaultRouterliciousDriverPolicies = {
    enablePrefetch: true,
    maxConcurrentStorageRequests: 100,
    maxConcurrentOrdererRequests: 100,
    aggregateBlobsSmallerThanBytes: undefined,
    enableDiscovery: false,
    enableWholeSummaryUpload: false,
    enableRestLess: true,
};
/**
 * Factory for creating the routerlicious document service. Use this if you want to
 * use the routerlicious implementation.
 */
class RouterliciousDocumentServiceFactory {
    constructor(tokenProvider, driverPolicies = {}) {
        this.tokenProvider = tokenProvider;
        this.protocolName = "fluid:";
        this.blobCache = new cache_1.InMemoryCache();
        this.snapshotTreeCache = new cache_1.InMemoryCache();
        this.driverPolicies = Object.assign(Object.assign({}, defaultRouterliciousDriverPolicies), driverPolicies);
    }
    /**
     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createContainer}
     *
     * @throws {@link DocumentPostCreateError}
     * If an exception is thrown while invoking the provided {@link ITokenProvider.documentPostCreateCallback}.
     */
    async createContainer(createNewSummary, resolvedUrl, logger, clientIsSummarizer) {
        (0, driver_utils_1.ensureFluidResolvedUrl)(resolvedUrl);
        if (createNewSummary === undefined) {
            throw new Error("Empty file summary creation isn't supported in this driver.");
        }
        (0, common_utils_1.assert)(!!resolvedUrl.endpoints.ordererUrl, 0x0b2 /* "Missing orderer URL!" */);
        let parsedUrl = (0, urlUtils_1.parseFluidUrl)(resolvedUrl.url);
        if (!parsedUrl.pathname) {
            throw new Error("Parsed url should contain tenant and doc Id!!");
        }
        const [, tenantId] = parsedUrl.pathname.split("/");
        const protocolSummary = createNewSummary.tree[".protocol"];
        const appSummary = createNewSummary.tree[".app"];
        if (!(protocolSummary && appSummary)) {
            throw new Error("Protocol and App Summary required in the full summary");
        }
        const documentAttributes = (0, driver_utils_1.getDocAttributesFromProtocolSummary)(protocolSummary);
        const quorumValues = (0, driver_utils_1.getQuorumValuesFromProtocolSummary)(protocolSummary);
        const logger2 = telemetry_utils_1.ChildLogger.create(logger, "RouterliciousDriver");
        const rateLimiter = new driver_utils_1.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
        const ordererRestWrapper = await restWrapper_1.RouterliciousOrdererRestWrapper.load(tenantId, undefined, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);
        // @TODO: Remove returned "string" type when removing back-compat code
        const res = await ordererRestWrapper.post(`/documents/${tenantId}`, {
            summary: (0, createNewUtils_1.convertSummaryToCreateNewSummary)(appSummary),
            sequenceNumber: documentAttributes.sequenceNumber,
            values: quorumValues,
            enableDiscovery: this.driverPolicies.enableDiscovery,
            generateToken: this.tokenProvider.documentPostCreateCallback !== undefined,
        });
        // For supporting backward compatibility, when the request has generateToken === true, it will return
        // an object instead of string
        // @TODO: Remove the logic when no need to support back-compat
        let documentId;
        let token;
        let session;
        if (typeof res === "string") {
            documentId = res;
        }
        else {
            documentId = res.id;
            token = res.token;
            session = this.driverPolicies.enableDiscovery ? res.session : undefined;
        }
        parsedUrl = (0, urlUtils_1.parseFluidUrl)(resolvedUrl.url);
        // @TODO: Remove token from the condition, checking the documentPostCreateCallback !== undefined
        // is sufficient to determine if the token will be undefined or not.
        if (token && this.tokenProvider.documentPostCreateCallback !== undefined) {
            try {
                await this.tokenProvider.documentPostCreateCallback(documentId, token);
            }
            catch (error) {
                throw new DocumentPostCreateError(error);
            }
        }
        parsedUrl.set("pathname", (0, urlUtils_1.replaceDocumentIdInPath)(parsedUrl.pathname, documentId));
        const deltaStorageUrl = resolvedUrl.endpoints.deltaStorageUrl;
        if (!deltaStorageUrl) {
            throw new Error(`All endpoints urls must be provided. [deltaStorageUrl:${deltaStorageUrl}]`);
        }
        const parsedDeltaStorageUrl = new URL(deltaStorageUrl);
        parsedDeltaStorageUrl.pathname = (0, urlUtils_1.replaceDocumentIdInPath)(parsedDeltaStorageUrl.pathname, documentId);
        return this.createDocumentService(Object.assign(Object.assign({}, resolvedUrl), { url: parsedUrl.toString(), id: documentId, endpoints: Object.assign(Object.assign({}, resolvedUrl.endpoints), { deltaStorageUrl: parsedDeltaStorageUrl.toString() }) }), logger, clientIsSummarizer, session);
    }
    /**
     * {@inheritDoc @fluidframework/driver-definitions#IDocumentServiceFactory.createDocumentService}
     *
     * @returns Routerlicious document service.
     */
    async createDocumentService(resolvedUrl, logger, clientIsSummarizer, session) {
        (0, driver_utils_1.ensureFluidResolvedUrl)(resolvedUrl);
        const parsedUrl = (0, urlUtils_1.parseFluidUrl)(resolvedUrl.url);
        const [, tenantId, documentId] = parsedUrl.pathname.split("/");
        if (!documentId || !tenantId) {
            throw new Error(`Couldn't parse documentId and/or tenantId. [documentId:${documentId}][tenantId:${tenantId}]`);
        }
        const logger2 = telemetry_utils_1.ChildLogger.create(logger, "RouterliciousDriver", { all: { driverVersion: packageVersion_1.pkgVersion } });
        const discoverFluidResolvedUrl = async () => {
            if (!this.driverPolicies.enableDiscovery) {
                return resolvedUrl;
            }
            const rateLimiter = new driver_utils_1.RateLimiter(this.driverPolicies.maxConcurrentOrdererRequests);
            const ordererRestWrapper = await restWrapper_1.RouterliciousOrdererRestWrapper.load(tenantId, documentId, this.tokenProvider, logger2, rateLimiter, this.driverPolicies.enableRestLess, resolvedUrl.endpoints.ordererUrl);
            // The service responds with the current document session associated with the container.
            const discoveredSession = await ordererRestWrapper.get(`/documents/${tenantId}/session/${documentId}`);
            return (0, urlUtils_1.getDiscoveredFluidResolvedUrl)(resolvedUrl, discoveredSession);
        };
        const fluidResolvedUrl = session !== undefined
            ? (0, urlUtils_1.getDiscoveredFluidResolvedUrl)(resolvedUrl, session)
            : await discoverFluidResolvedUrl();
        const storageUrl = fluidResolvedUrl.endpoints.storageUrl;
        const ordererUrl = fluidResolvedUrl.endpoints.ordererUrl;
        const deltaStorageUrl = fluidResolvedUrl.endpoints.deltaStorageUrl;
        if (!ordererUrl || !deltaStorageUrl) {
            throw new Error(`All endpoints urls must be provided. [ordererUrl:${ordererUrl}][deltaStorageUrl:${deltaStorageUrl}]`);
        }
        return new documentService_1.DocumentService(fluidResolvedUrl, ordererUrl, deltaStorageUrl, storageUrl, logger2, this.tokenProvider, tenantId, documentId, this.driverPolicies, this.blobCache, this.snapshotTreeCache, discoverFluidResolvedUrl);
    }
}
exports.RouterliciousDocumentServiceFactory = RouterliciousDocumentServiceFactory;
/**
 * Error returned by {@link RouterliciousDocumentServiceFactory.createContainer} when an error is thrown
 * in {@link ITokenProvider.documentPostCreateCallback}.
 * It is the consumer's responsibility to ensure that any state related to container creation is appropriately
 * cleaned up in the event of failure.
 * This includes the document itself, which will have been created by the time this error was thrown.
 *
 * @remarks TODO: examples of suggested actions for recovery.
 * - How would a user delete the created document?
 * - What would a retry pattern look like here?
 */
class DocumentPostCreateError extends Error {
    constructor(
    /**
     * Inner error being wrapped.
     */
    innerError) {
        super(innerError.message);
        this.innerError = innerError;
        this.name = "DocumentPostCreateError";
    }
    get stack() { return this.innerError.stack; }
}
exports.DocumentPostCreateError = DocumentPostCreateError;

},{"./cache":185,"./createNewUtils":186,"./documentService":190,"./packageVersion":196,"./restWrapper":198,"./urlUtils":202,"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279}],192:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentStorageService = void 0;
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const wholeSummaryDocumentStorageService_1 = require("./wholeSummaryDocumentStorageService");
const shreddedSummaryDocumentStorageService_1 = require("./shreddedSummaryDocumentStorageService");
class DocumentStorageService extends driver_utils_1.DocumentStorageServiceProxy {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {
        super(DocumentStorageService.loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager));
        this.id = id;
        this.manager = manager;
        this.noCacheGitManager = noCacheGitManager;
        this._logTailSha = undefined;
    }
    get logTailSha() {
        return this._logTailSha;
    }
    static loadInternalDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) {
        const storageService = (driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) ?
            new wholeSummaryDocumentStorageService_1.WholeSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, noCacheGitManager, getStorageManager) :
            new shreddedSummaryDocumentStorageService_1.ShreddedSummaryDocumentStorageService(id, manager, logger, policies, driverPolicies, blobCache, snapshotTreeCache, getStorageManager);
        // TODO: worth prefetching latest summary making version + snapshot call with WholeSummary storage?
        if (!(driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableWholeSummaryUpload) && policies.caching === driver_definitions_1.LoaderCachingPolicy.Prefetch) {
            return new driver_utils_1.PrefetchDocumentStorageService(storageService);
        }
        return storageService;
    }
    async getSnapshotTree(version) {
        const tree = await this.internalStorageService.getSnapshotTree(version);
        if (tree !== null) {
            this._logTailSha = ".logTail" in tree.trees ? tree.trees[".logTail"].blobs.logTail : undefined;
        }
        return tree;
    }
}
exports.DocumentStorageService = DocumentStorageService;

},{"./shreddedSummaryDocumentStorageService":200,"./wholeSummaryDocumentStorageService":203,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110}],193:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorObjectFromSocketError = exports.throwR11sNetworkError = exports.createR11sNetworkError = exports.R11sErrorType = void 0;
const driver_utils_1 = require("@fluidframework/driver-utils");
const packageVersion_1 = require("./packageVersion");
var R11sErrorType;
(function (R11sErrorType) {
    R11sErrorType["fileNotFoundOrAccessDeniedError"] = "fileNotFoundOrAccessDeniedError";
})(R11sErrorType = exports.R11sErrorType || (exports.R11sErrorType = {}));
function createR11sNetworkError(errorMessage, statusCode, retryAfterMs) {
    const props = { statusCode, driverVersion: packageVersion_1.pkgVersion };
    switch (statusCode) {
        case undefined:
            // If a service is temporarily down or a browser resource limit is reached, RestWrapper will throw
            // a network error with no status code (e.g. err:ERR_CONN_REFUSED or err:ERR_FAILED) and
            // the error message will start with NetworkError as defined in restWrapper.ts
            return new driver_utils_1.GenericNetworkError(errorMessage, errorMessage.startsWith("NetworkError"), props);
        case 401:
        // The first 401 is manually retried in RouterliciousRestWrapper with a refreshed token,
        // so we treat repeat 401s the same as 403.
        case 403:
            return new driver_utils_1.AuthorizationError(errorMessage, undefined, undefined, props);
        case 404:
            const errorType = R11sErrorType.fileNotFoundOrAccessDeniedError;
            return new driver_utils_1.NonRetryableError(errorMessage, errorType, props);
        case 429:
            return (0, driver_utils_1.createGenericNetworkError)(errorMessage, { canRetry: true, retryAfterMs }, props);
        case 500:
        case 502:
            return new driver_utils_1.GenericNetworkError(errorMessage, true, props);
        default:
            const retryInfo = { canRetry: retryAfterMs !== undefined, retryAfterMs };
            return (0, driver_utils_1.createGenericNetworkError)(errorMessage, retryInfo, props);
    }
}
exports.createR11sNetworkError = createR11sNetworkError;
function throwR11sNetworkError(errorMessage, statusCode, retryAfterMs) {
    const networkError = createR11sNetworkError(errorMessage, statusCode, retryAfterMs);
    // eslint-disable-next-line @typescript-eslint/no-throw-literal
    throw networkError;
}
exports.throwR11sNetworkError = throwR11sNetworkError;
/**
 * Returns network error based on error object from R11s socket (IR11sSocketError)
 */
function errorObjectFromSocketError(socketError, handler) {
    // pre-0.58 error message prefix: R11sSocketError
    const message = `R11s socket error (${handler}): ${socketError.message}`;
    return createR11sNetworkError(message, socketError.code, socketError.retryAfterMs);
}
exports.errorObjectFromSocketError = errorObjectFromSocketError;

},{"./packageVersion":196,"@fluidframework/driver-utils":110}],194:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./defaultTokenProvider"), exports);
__exportStar(require("./deltaStorageService"), exports);
__exportStar(require("./documentService"), exports);
__exportStar(require("./documentServiceFactory"), exports);
__exportStar(require("./documentStorageService"), exports);
__exportStar(require("./nullBlobStorageService"), exports);
__exportStar(require("./policies"), exports);
__exportStar(require("./tokens"), exports);

},{"./defaultTokenProvider":187,"./deltaStorageService":188,"./documentService":190,"./documentServiceFactory":191,"./documentStorageService":192,"./nullBlobStorageService":195,"./policies":197,"./tokens":201}],195:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullBlobStorageService = void 0;
/**
 * Document access to underlying storage. It is default implementation of a storage service.
 * Does not read/write anything.
 */
class NullBlobStorageService {
    get repositoryUrl() {
        throw new Error("Invalid operation");
    }
    async getSnapshotTree(version) {
        return version ? Promise.reject(new Error("Invalid operation")) : null;
    }
    async getVersions(versionId, count) {
        return [];
    }
    async uploadSummaryWithContext(summary, context) {
        return Promise.reject(new Error("Invalid operation"));
    }
    async downloadSummary(handle) {
        return Promise.reject(new Error("Invalid operation"));
    }
    async createBlob(file) {
        return Promise.reject(new Error("Null blob storage can not create blob"));
    }
    async readBlob(blobId) {
        return Promise.reject(new Error("Null blob storage can not read blob"));
    }
}
exports.NullBlobStorageService = NullBlobStorageService;

},{}],196:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/routerlicious-driver";
exports.pkgVersion = "1.3.6";

},{}],197:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],198:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterliciousOrdererRestWrapper = exports.RouterliciousStorageRestWrapper = exports.RouterliciousRestWrapper = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const server_services_client_1 = require("@fluidframework/server-services-client");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const json_stringify_safe_1 = __importDefault(require("json-stringify-safe"));
const uuid_1 = require("uuid");
const errorUtils_1 = require("./errorUtils");
const packageVersion_1 = require("./packageVersion");
const axiosRequestConfigToFetchRequestConfig = (requestConfig) => {
    var _a, _b;
    const requestInfo = requestConfig.baseURL !== undefined
        ? `${requestConfig.baseURL}${(_a = requestConfig.url) !== null && _a !== void 0 ? _a : ""}`
        : (_b = requestConfig.url) !== null && _b !== void 0 ? _b : "";
    const requestInit = {
        method: requestConfig.method,
        // NOTE: I believe that although the Axios type permits non-string values in the header, here we are
        // guaranteed the requestConfig only has string values in its header.
        headers: requestConfig.headers,
        body: requestConfig.data,
    };
    return [requestInfo, requestInit];
};
class RouterliciousRestWrapper extends server_services_client_1.RestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(baseurl, defaultQueryString);
        this.rateLimiter = rateLimiter;
        this.getAuthorizationHeader = getAuthorizationHeader;
        this.useRestLess = useRestLess;
        this.restLess = new server_services_client_1.RestLessClient();
    }
    async load() {
        this.authorizationHeader = await this.getAuthorizationHeader();
    }
    async request(requestConfig, statusCode, canRetry = true) {
        var _a;
        const config = Object.assign(Object.assign({}, requestConfig), { headers: this.generateHeaders(requestConfig.headers) });
        const translatedConfig = this.useRestLess ? this.restLess.translate(config) : config;
        const fetchRequestConfig = axiosRequestConfigToFetchRequestConfig(translatedConfig);
        const response = await this.rateLimiter.schedule(async () => (0, cross_fetch_1.default)(...fetchRequestConfig)
            .catch(async (error) => {
            // Browser Fetch throws a TypeError on network error, `node-fetch` throws a FetchError
            const isNetworkError = ["TypeError", "FetchError"].includes(error === null || error === void 0 ? void 0 : error.name);
            (0, errorUtils_1.throwR11sNetworkError)(isNetworkError ? `NetworkError: ${error.message}` : (0, json_stringify_safe_1.default)(error));
        }));
        const responseBody = ((_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.includes("application/json"))
            ? await response.json()
            : await response.text();
        // Success
        if (response.ok || response.status === statusCode) {
            const result = responseBody;
            return result;
        }
        // Failure
        if (response.status === 401 && canRetry) {
            // Refresh Authorization header and retry once
            this.authorizationHeader = await this.getAuthorizationHeader(true /* refreshToken */);
            return this.request(config, statusCode, false);
        }
        if (response.status === 429 && (responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter) > 0) {
            // Retry based on retryAfter[Seconds]
            return new Promise((resolve, reject) => setTimeout(() => {
                this.request(config, statusCode)
                    .then(resolve)
                    .catch(reject);
            }, responseBody.retryAfter * 1000));
        }
        const responseSummary = responseBody !== undefined
            ? typeof responseBody === "string" ? responseBody : (0, json_stringify_safe_1.default)(responseBody)
            : response.statusText;
        (0, errorUtils_1.throwR11sNetworkError)(`R11s fetch error: ${responseSummary}`, response.status, responseBody === null || responseBody === void 0 ? void 0 : responseBody.retryAfter);
    }
    generateHeaders(requestHeaders) {
        const correlationId = (requestHeaders === null || requestHeaders === void 0 ? void 0 : requestHeaders["x-correlation-id"]) || (0, uuid_1.v4)();
        return Object.assign(Object.assign({}, requestHeaders), { 
            // TODO: replace header names with CorrelationIdHeaderName and DriverVersionHeaderName from services-client
            // NOTE: Can correlationId actually be number | true?
            "x-correlation-id": correlationId, "x-driver-version": packageVersion_1.pkgVersion, 
            // NOTE: If this.authorizationHeader is undefined, should "Authorization" be removed entirely?
            "Authorization": this.authorizationHeader });
    }
}
exports.RouterliciousRestWrapper = RouterliciousRestWrapper;
class RouterliciousStorageRestWrapper extends RouterliciousRestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
    }
    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {
        const defaultQueryString = {
            token: `${(0, common_utils_1.fromUtf8ToBase64)(tenantId)}`,
        };
        const getAuthorizationHeader = async (refreshToken) => {
            // Craft credentials using tenant id and token
            const storageToken = await tokenProvider.fetchStorageToken(tenantId, documentId, refreshToken);
            const credentials = {
                password: storageToken.jwt,
                user: tenantId,
            };
            return (0, server_services_client_1.getAuthorizationTokenFromCredentials)(credentials);
        };
        const restWrapper = new RouterliciousStorageRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
        try {
            await restWrapper.load();
        }
        catch (e) {
            logger.sendErrorEvent({
                eventName: "R11sRestWrapperLoadFailure",
            }, e);
            await restWrapper.load();
        }
        return restWrapper;
    }
}
exports.RouterliciousStorageRestWrapper = RouterliciousStorageRestWrapper;
class RouterliciousOrdererRestWrapper extends RouterliciousRestWrapper {
    constructor(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString = {}) {
        super(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl, defaultQueryString);
    }
    static async load(tenantId, documentId, tokenProvider, logger, rateLimiter, useRestLess, baseurl) {
        const getAuthorizationHeader = async (refreshToken) => {
            const ordererToken = await tokenProvider.fetchOrdererToken(tenantId, documentId, refreshToken);
            return `Basic ${ordererToken.jwt}`;
        };
        const restWrapper = new RouterliciousOrdererRestWrapper(logger, rateLimiter, getAuthorizationHeader, useRestLess, baseurl);
        try {
            await restWrapper.load();
        }
        catch (e) {
            logger.sendErrorEvent({
                eventName: "R11sRestWrapperLoadFailure",
            }, e);
            await restWrapper.load();
        }
        return restWrapper;
    }
}
exports.RouterliciousOrdererRestWrapper = RouterliciousOrdererRestWrapper;

},{"./errorUtils":193,"./packageVersion":196,"@fluidframework/common-utils":29,"@fluidframework/server-services-client":245,"cross-fetch":345,"json-stringify-safe":395,"uuid":544}],199:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetriableGitManager = void 0;
const driver_utils_1 = require("@fluidframework/driver-utils");
class RetriableGitManager {
    constructor(internalGitManager, logger) {
        this.internalGitManager = internalGitManager;
        this.logger = logger;
    }
    async getHeader(id, sha) {
        return this.runWithRetry(async () => this.internalGitManager.getHeader(id, sha), "gitManager_getHeader");
    }
    async getFullTree(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getFullTree(sha), "gitManager_getFullTree");
    }
    async getCommit(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getCommit(sha), "gitManager_getCommit");
    }
    async getCommits(sha, count) {
        return this.runWithRetry(async () => this.internalGitManager.getCommits(sha, count), "gitManager_getCommits");
    }
    async getTree(root, recursive) {
        return this.runWithRetry(async () => this.internalGitManager.getTree(root, recursive), "gitManager_getTree");
    }
    async getBlob(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getBlob(sha), "gitManager_getBlob");
    }
    getRawUrl(sha) {
        return this.internalGitManager.getRawUrl(sha);
    }
    async getContent(commit, path) {
        return this.runWithRetry(async () => this.internalGitManager.getContent(commit, path), "gitManager_getContent");
    }
    async createBlob(content, encoding) {
        return this.runWithRetry(async () => this.internalGitManager.createBlob(content, encoding), "gitManager_createBlob");
    }
    async createGitTree(params) {
        return this.runWithRetry(async () => this.internalGitManager.createGitTree(params), "gitManager_createGitTree");
    }
    async createTree(files) {
        return this.runWithRetry(async () => this.internalGitManager.createTree(files), "gitManager_createTree");
    }
    async createCommit(commit) {
        return this.runWithRetry(async () => this.internalGitManager.createCommit(commit), "gitManager_createCommit");
    }
    async getRef(ref) {
        return this.runWithRetry(async () => this.internalGitManager.getRef(ref), "gitManager_getRef");
    }
    async createRef(branch, sha) {
        return this.runWithRetry(async () => this.internalGitManager.createRef(branch, sha), "gitManager_createRef");
    }
    async upsertRef(branch, commitSha) {
        return this.runWithRetry(async () => this.internalGitManager.upsertRef(branch, commitSha), "gitManager_upsertRef");
    }
    async write(branch, inputTree, parents, message) {
        return this.runWithRetry(async () => this.internalGitManager.write(branch, inputTree, parents, message), "gitManager_write");
    }
    async createSummary(summary) {
        return this.runWithRetry(async () => this.internalGitManager.createSummary(summary), "gitManager_createSummary");
    }
    async deleteSummary(softDelete) {
        return this.runWithRetry(async () => this.internalGitManager.deleteSummary(softDelete), "gitManager_deleteSummary");
    }
    async getSummary(sha) {
        return this.runWithRetry(async () => this.internalGitManager.getSummary(sha), "gitManager_getSummary");
    }
    async runWithRetry(api, callName) {
        return (0, driver_utils_1.runWithRetry)(api, callName, this.logger, {});
    }
}
exports.RetriableGitManager = RetriableGitManager;

},{"@fluidframework/driver-utils":110}],200:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShreddedSummaryDocumentStorageService = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const server_services_client_1 = require("@fluidframework/server-services-client");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const cache_1 = require("./cache");
const retriableGitManager_1 = require("./retriableGitManager");
const isNode = typeof window === "undefined";
/**
 * Document access to underlying storage for routerlicious driver.
 * Uploads summaries piece-by-piece traversing the tree recursively.
 * Downloads summaries piece-by-piece on-demand, or up-front when prefetch is enabled.
 */
class ShreddedSummaryDocumentStorageService {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache, snapshotTreeCache, getStorageManager = async () => this.manager) {
        this.id = id;
        this.manager = manager;
        this.logger = logger;
        this.policies = policies;
        this.getStorageManager = getStorageManager;
        // The values of this cache is useless. We only need the keys. So we are always putting
        // empty strings as values.
        this.blobsShaCache = new Map();
        if ((driverPolicies === null || driverPolicies === void 0 ? void 0 : driverPolicies.enableRestLess) === true || isNode) {
            this.blobCache = blobCache !== null && blobCache !== void 0 ? blobCache : new cache_1.InMemoryCache();
            this.snapshotTreeCache = snapshotTreeCache !== null && snapshotTreeCache !== void 0 ? snapshotTreeCache : new cache_1.InMemoryCache();
        }
    }
    get repositoryUrl() {
        return "";
    }
    async getSummaryUploadManager() {
        const manager = await this.getStorageManager();
        return new server_services_client_1.SummaryTreeUploadManager(new retriableGitManager_1.RetriableGitManager(manager, this.logger), this.blobsShaCache, this.getPreviousFullSnapshot.bind(this));
    }
    async getVersions(versionId, count) {
        const id = versionId ? versionId : this.id;
        const commits = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getVersions",
            versionId: id,
            count,
        }, async () => {
            const manager = await this.getStorageManager();
            return manager.getCommits(id, count);
        });
        return commits.map((commit) => ({
            date: commit.commit.author.date,
            id: commit.sha,
            treeId: commit.commit.tree.sha,
        }));
    }
    async getSnapshotTree(version) {
        var _a, _b;
        let requestVersion = version;
        if (!requestVersion) {
            const versions = await this.getVersions(this.id, 1);
            if (versions.length === 0) {
                return null;
            }
            requestVersion = versions[0];
        }
        const cachedSnapshotTree = await ((_a = this.snapshotTreeCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(requestVersion.treeId)));
        if (cachedSnapshotTree) {
            return cachedSnapshotTree.snapshotTree;
        }
        const rawTree = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getSnapshotTree",
            treeId: requestVersion.treeId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getTree(requestVersion.treeId);
            event.end({
                size: response.tree.length,
            });
            return response;
        });
        const tree = (0, protocol_base_1.buildHierarchy)(rawTree, this.blobsShaCache, true);
        await ((_b = this.snapshotTreeCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(tree.id), { id: requestVersion.id, snapshotTree: tree }));
        return tree;
    }
    async readBlob(blobId) {
        var _a, _b;
        const cachedBlob = await ((_a = this.blobCache) === null || _a === void 0 ? void 0 : _a.get(this.getCacheKey(blobId)));
        if (cachedBlob) {
            return cachedBlob;
        }
        const value = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "readBlob",
            blobId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getBlob(blobId);
            event.end({
                size: response.size,
            });
            return response;
        });
        this.blobsShaCache.set(value.sha, "");
        const bufferContent = (0, common_utils_1.stringToBuffer)(value.content, value.encoding);
        await ((_b = this.blobCache) === null || _b === void 0 ? void 0 : _b.put(this.getCacheKey(value.sha), bufferContent));
        return bufferContent;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryHandle = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "uploadSummaryWithContext",
        }, async () => {
            var _a;
            const summaryUploadManager = await this.getSummaryUploadManager();
            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : "", "channel");
        });
        return summaryHandle;
    }
    async downloadSummary(handle) {
        throw new Error("NOT IMPLEMENTED!");
    }
    async createBlob(file) {
        const uint8ArrayFile = new Uint8Array(file);
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "createBlob",
            size: uint8ArrayFile.length,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.createBlob((0, common_utils_1.Uint8ArrayToString)(uint8ArrayFile, "base64"), "base64").then((r) => ({ id: r.sha, url: r.url }));
            event.end({
                blobId: response.id,
            });
            return response;
        });
    }
    async getPreviousFullSnapshot(parentHandle) {
        return parentHandle
            ? this.getVersions(parentHandle, 1)
                .then(async (versions) => {
                // Clear the cache as the getSnapshotTree call will fill the cache.
                this.blobsShaCache.clear();
                return this.getSnapshotTree(versions[0]);
            })
            : undefined;
    }
    getCacheKey(blobId) {
        return `${this.id}:${blobId}`;
    }
}
exports.ShreddedSummaryDocumentStorageService = ShreddedSummaryDocumentStorageService;

},{"./cache":185,"./retriableGitManager":199,"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/server-services-client":245,"@fluidframework/telemetry-utils":279}],201:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"dup":180}],202:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDiscoveredFluidResolvedUrl = exports.replaceDocumentIdInPath = exports.parseFluidUrl = void 0;
const url_parse_1 = __importDefault(require("url-parse"));
const parseFluidUrl = (fluidUrl) => {
    return new url_parse_1.default(fluidUrl, true);
};
exports.parseFluidUrl = parseFluidUrl;
/**
 * Assume documentId is at end of url path.
 * This is true for Routerlicious' and Tinylicious' documentUrl and deltaStorageUrl.
 * Routerlicious and Tinylicious do not use documentId in storageUrl nor ordererUrl.
 * TODO: Ideally we would be able to regenerate the resolvedUrl, rather than patching the current one.
 */
const replaceDocumentIdInPath = (urlPath, documentId) => urlPath.split("/").slice(0, -1).concat([documentId]).join("/");
exports.replaceDocumentIdInPath = replaceDocumentIdInPath;
const getDiscoveredFluidResolvedUrl = (resolvedUrl, session) => {
    if (session) {
        const discoveredOrdererUrl = new url_parse_1.default(session.ordererUrl);
        const deltaStorageUrl = new url_parse_1.default(resolvedUrl.endpoints.deltaStorageUrl);
        deltaStorageUrl.set("host", discoveredOrdererUrl.host);
        const discoveredStorageUrl = new url_parse_1.default(session.historianUrl);
        const storageUrl = new url_parse_1.default(resolvedUrl.endpoints.storageUrl);
        storageUrl.set("host", discoveredStorageUrl.host);
        const parsedUrl = (0, exports.parseFluidUrl)(resolvedUrl.url);
        const discoveredResolvedUrl = {
            endpoints: {
                deltaStorageUrl: deltaStorageUrl.toString(),
                ordererUrl: session.ordererUrl,
                storageUrl: storageUrl.toString(),
            },
            id: resolvedUrl.id,
            tokens: resolvedUrl.tokens,
            type: resolvedUrl.type,
            url: new url_parse_1.default(`fluid://${discoveredOrdererUrl.host}${parsedUrl.pathname}`).toString(),
        };
        return discoveredResolvedUrl;
    }
    else {
        return resolvedUrl;
    }
};
exports.getDiscoveredFluidResolvedUrl = getDiscoveredFluidResolvedUrl;

},{"url-parse":543}],203:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WholeSummaryDocumentStorageService = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const server_services_client_1 = require("@fluidframework/server-services-client");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const cache_1 = require("./cache");
const latestSnapshotId = "latest";
class WholeSummaryDocumentStorageService {
    constructor(id, manager, logger, policies = {}, driverPolicies, blobCache = new cache_1.InMemoryCache(), snapshotTreeCache = new cache_1.InMemoryCache(), noCacheGitManager, getStorageManager = async (disableCache) => disableCache && this.noCacheGitManager !== undefined ? this.noCacheGitManager : this.manager) {
        this.id = id;
        this.manager = manager;
        this.logger = logger;
        this.policies = policies;
        this.driverPolicies = driverPolicies;
        this.blobCache = blobCache;
        this.snapshotTreeCache = snapshotTreeCache;
        this.noCacheGitManager = noCacheGitManager;
        this.getStorageManager = getStorageManager;
        this.firstVersionsCall = true;
    }
    get repositoryUrl() {
        return "";
    }
    async getSummaryUploadManager() {
        const manager = await this.getStorageManager();
        return new server_services_client_1.WholeSummaryUploadManager(manager);
    }
    async getVersions(versionId, count) {
        var _a;
        if (versionId !== this.id && versionId !== null) {
            // Blobs/Trees in this scenario will never have multiple versions, so return versionId as is
            return [{
                    id: versionId,
                    treeId: undefined,
                }];
        }
        // If this is the first versions call for the document, we know we will want the latest summary.
        // Fetch latest summary, cache it, and return its id.
        if (this.firstVersionsCall && count === 1) {
            this.firstVersionsCall = false;
            const { id: _id, snapshotTree } = !((_a = this.driverPolicies) === null || _a === void 0 ? void 0 : _a.enableDiscovery) ?
                await this.fetchAndCacheSnapshotTree(latestSnapshotId, false) :
                await this.fetchAndCacheSnapshotTree(latestSnapshotId, true);
            return [{
                    id: _id,
                    treeId: snapshotTree.id,
                }];
        }
        // Otherwise, get the latest version of the document as normal.
        const id = versionId ? versionId : this.id;
        const commits = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getVersions",
            versionId: id,
            count,
        }, async () => {
            const manager = await this.getStorageManager();
            return manager.getCommits(id, count);
        });
        return commits.map((commit) => ({
            date: commit.commit.author.date,
            id: commit.sha,
            treeId: commit.commit.tree.sha,
        }));
    }
    async getSnapshotTree(version) {
        let requestVersion = version;
        if (!requestVersion) {
            const versions = await this.getVersions(this.id, 1);
            if (versions.length === 0) {
                return null;
            }
            requestVersion = versions[0];
        }
        return (await this.fetchAndCacheSnapshotTree(requestVersion.id)).snapshotTree;
    }
    async readBlob(blobId) {
        const cachedBlob = await this.blobCache.get(this.getCacheKey(blobId));
        if (cachedBlob !== undefined) {
            return cachedBlob;
        }
        const blob = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "readBlob",
            blobId,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.getBlob(blobId);
            event.end({
                size: response.size,
            });
            return response;
        });
        const bufferValue = (0, common_utils_1.stringToBuffer)(blob.content, blob.encoding);
        await this.blobCache.put(this.getCacheKey(blob.sha), bufferValue);
        return bufferValue;
    }
    async uploadSummaryWithContext(summary, context) {
        const summaryHandle = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "uploadSummaryWithContext",
        }, async () => {
            var _a;
            const summaryUploadManager = await this.getSummaryUploadManager();
            return summaryUploadManager.writeSummaryTree(summary, (_a = context.ackHandle) !== null && _a !== void 0 ? _a : "", "channel");
        });
        return summaryHandle;
    }
    async downloadSummary(summaryHandle) {
        const wholeFlatSummary = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getWholeFlatSummary",
            treeId: summaryHandle.handle,
        }, async (event) => {
            var _a;
            const manager = await this.getStorageManager();
            const response = await manager.getSummary(summaryHandle.handle);
            event.end({
                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,
            });
            return response;
        });
        const { blobs, snapshotTree } = (0, server_services_client_1.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary, "");
        return (0, driver_utils_1.convertSnapshotAndBlobsToSummaryTree)(snapshotTree, blobs);
    }
    async createBlob(file) {
        const uint8ArrayFile = new Uint8Array(file);
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "createBlob",
            size: uint8ArrayFile.length,
        }, async (event) => {
            const manager = await this.getStorageManager();
            const response = await manager.createBlob((0, common_utils_1.Uint8ArrayToString)(uint8ArrayFile, "base64"), "base64").then((r) => ({ id: r.sha, url: r.url }));
            event.end({
                blobId: response.id,
            });
            return response;
        });
    }
    async fetchAndCacheSnapshotTree(versionId, disableCache) {
        const cachedSnapshotTreeVersion = await this.snapshotTreeCache.get(this.getCacheKey(versionId));
        if (cachedSnapshotTreeVersion !== undefined) {
            return { id: cachedSnapshotTreeVersion.id, snapshotTree: cachedSnapshotTreeVersion.snapshotTree };
        }
        const wholeFlatSummary = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.logger, {
            eventName: "getWholeFlatSummary",
            treeId: versionId,
        }, async (event) => {
            var _a;
            const manager = await this.getStorageManager(disableCache);
            const response = await manager.getSummary(versionId);
            event.end({
                size: (_a = response.trees[0]) === null || _a === void 0 ? void 0 : _a.entries.length,
            });
            return response;
        });
        const normalizedWholeSummary = (0, server_services_client_1.convertWholeFlatSummaryToSnapshotTreeAndBlobs)(wholeFlatSummary);
        const wholeFlatSummaryId = wholeFlatSummary.id;
        const snapshotTreeId = normalizedWholeSummary.snapshotTree.id;
        (0, common_utils_1.assert)(snapshotTreeId !== undefined, 0x275 /* "Root tree should contain the id" */);
        const snapshotTreeVersion = { id: wholeFlatSummaryId, snapshotTree: normalizedWholeSummary.snapshotTree };
        const cachePs = [
            this.snapshotTreeCache.put(this.getCacheKey(snapshotTreeId), snapshotTreeVersion),
            this.initBlobCache(normalizedWholeSummary.blobs),
        ];
        if (snapshotTreeId !== versionId) {
            // versionId could be "latest". When summarizer checks cache for "latest", we want it to be available.
            // TODO: For in-memory cache, <latest,snapshotTree> will be a shared pointer with <snapshotId,snapshotTree>,
            // However, for something like Redis, this will cache the same value twice. Alternatively, could we simply
            // cache with versionId?
            cachePs.push(this.snapshotTreeCache.put(this.getCacheKey(versionId), snapshotTreeVersion));
        }
        await Promise.all(cachePs);
        return snapshotTreeVersion;
    }
    async initBlobCache(blobs) {
        const blobCachePutPs = [];
        blobs.forEach((value, id) => {
            const cacheKey = this.getCacheKey(id);
            blobCachePutPs.push(this.blobCache.put(cacheKey, value));
        });
        await Promise.all(blobCachePutPs);
    }
    getCacheKey(blobId) {
        return `${this.id}:${blobId}`;
    }
}
exports.WholeSummaryDocumentStorageService = WholeSummaryDocumentStorageService;

},{"./cache":185,"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/server-services-client":245,"@fluidframework/telemetry-utils":279}],204:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VisibilityState = exports.FlushMode = void 0;
/**
 * Runtime flush mode handling
 */
var FlushMode;
(function (FlushMode) {
    /**
     * In Immediate flush mode the runtime will immediately send all operations to the driver layer.
     */
    FlushMode[FlushMode["Immediate"] = 0] = "Immediate";
    /**
     * When in TurnBased flush mode the runtime will buffer operations in the current turn and send them as a single
     * batch at the end of the turn. The flush call on the runtime can be used to force send the current batch.
     */
    FlushMode[FlushMode["TurnBased"] = 1] = "TurnBased";
})(FlushMode = exports.FlushMode || (exports.FlushMode = {}));
/**
 * This tells the visibility state of a Fluid object. It basically tracks whether the object is not visible, visible
 * locally within the container only or visible globally to all clients.
 */
exports.VisibilityState = {
    /** Indicates that the object is not visible. This is the state when an object is first created. */
    NotVisible: "NotVisible",
    /**
     * Indicates that the object is visible locally within the container. This is the state when an object is attached
     * to the container's graph but the container itself isn't globally visible. The object's state goes from not
     * visible to locally visible.
     */
    LocallyVisible: "LocallyVisible",
    /**
     * Indicates that the object is visible globally to all clients. This is the state of an object in 2 scenarios:
     * 1. It is attached to the container's graph when the container is globally visible. The object's state goes from
     *    not visible to globally visible.
     * 2. When a container becomes globally visible, all locally visible objects go from locally visible to globally
     *    visible.
     */
    GloballyVisible: "GloballyVisible",
};

},{}],205:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IFluidDataStoreFactory = void 0;
exports.IFluidDataStoreFactory = "IFluidDataStoreFactory";

},{}],206:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IFluidDataStoreRegistry = void 0;
exports.IFluidDataStoreRegistry = "IFluidDataStoreRegistry";

},{}],207:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.gcBlobKey = void 0;
// The key to use for storing garbage collection blob in summary.
exports.gcBlobKey = "gc";

},{}],208:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./dataStoreFactory"), exports);
__exportStar(require("./dataStoreRegistry"), exports);
__exportStar(require("./dataStoreContext"), exports);
__exportStar(require("./garbageCollection"), exports);
__exportStar(require("./protocol"), exports);
__exportStar(require("./summary"), exports);

},{"./dataStoreContext":204,"./dataStoreFactory":205,"./dataStoreRegistry":206,"./garbageCollection":207,"./protocol":209,"./summary":210}],209:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],210:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.totalBlobSizePropertyName = exports.blobCountPropertyName = exports.channelsTreeName = exports.CreateSummarizerNodeSource = void 0;
var CreateSummarizerNodeSource;
(function (CreateSummarizerNodeSource) {
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromSummary"] = 0] = "FromSummary";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["FromAttach"] = 1] = "FromAttach";
    CreateSummarizerNodeSource[CreateSummarizerNodeSource["Local"] = 2] = "Local";
})(CreateSummarizerNodeSource = exports.CreateSummarizerNodeSource || (exports.CreateSummarizerNodeSource = {}));
exports.channelsTreeName = ".channels";
exports.blobCountPropertyName = "BlobCount";
exports.totalBlobSizePropertyName = "TotalBlobSize";

},{}],211:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateHandleContextPath = void 0;
/**
 * Generates the absolute path for a Fluid object given its path and its parent routeContext.
 * @param path - The path to the Fluid object relative to the route context.
 * @param routeContext - The route context that contains the Fluid object.
 * @returns The absolute path to the Fluid object from the root of the Container.
 */
function generateHandleContextPath(path, routeContext) {
    if (path === "") {
        // The `path` is empty.
        // If the routeContext does not exist, this is the root.
        // If the routeContext exists, the absolute path is the same as that of the routeContext.
        return routeContext === undefined ? "" : routeContext.absolutePath;
    }
    else {
        // Remove beginning and trailing slashes, if any, from the path.
        let normalizedPath = path.startsWith("/") ? path.slice(1) : path;
        normalizedPath = normalizedPath.endsWith("/") ? normalizedPath.slice(0, -1) : normalizedPath;
        // If the routeContext does not exist, path is the absolute path.
        // If the routeContext exists, absolute path is routeContext's absolute path plus the path.
        return routeContext === undefined
            ? `/${normalizedPath}`
            : `${routeContext.absolutePath === "/" ? "" : routeContext.absolutePath}/${normalizedPath}`;
    }
}
exports.generateHandleContextPath = generateHandleContextPath;

},{}],212:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataStoreFactory = exports.createResponseError = exports.create404Response = exports.requestFluidObject = exports.responseToException = exports.exceptionToResponse = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
function exceptionToResponse(err) {
    const status = 500;
    if (err !== null && typeof err === "object" && err.errorFromRequestFluidObject === true) {
        const responseErr = err;
        return {
            mimeType: "text/plain",
            status: responseErr.code,
            value: responseErr.message,
            get stack() { return responseErr.stack; },
        };
    }
    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it
    const errWithStack = (0, telemetry_utils_1.generateErrorWithStack)();
    return {
        mimeType: "text/plain",
        status,
        value: `${err}`,
        get stack() { var _a; return (_a = (err === null || err === void 0 ? void 0 : err.stack)) !== null && _a !== void 0 ? _a : errWithStack.stack; },
    };
}
exports.exceptionToResponse = exceptionToResponse;
function responseToException(response, request) {
    const message = response.value;
    const errWithStack = (0, telemetry_utils_1.generateErrorWithStack)();
    const responseErr = {
        errorFromRequestFluidObject: true,
        message,
        name: "Error",
        code: response.status,
        get stack() { var _a; return (_a = response.stack) !== null && _a !== void 0 ? _a : errWithStack.stack; },
    };
    return responseErr;
}
exports.responseToException = responseToException;
async function requestFluidObject(router, url) {
    const request = typeof url === "string" ? { url } : url;
    const response = await router.request(request);
    if (response.status !== 200 || response.mimeType !== "fluid/object") {
        throw responseToException(response, request);
    }
    (0, common_utils_1.assert)(response.value, 0x19a /* "Invalid response value for Fluid object request" */);
    return response.value;
}
exports.requestFluidObject = requestFluidObject;
const create404Response = (request) => createResponseError(404, "not found", request);
exports.create404Response = create404Response;
function createResponseError(status, value, request) {
    var _a;
    (0, common_utils_1.assert)(status !== 200, 0x19b /* "Cannot not create response error on 200 status" */);
    // Omit query string which could contain personal data (aka "PII")
    const urlNoQuery = (_a = request.url) === null || _a === void 0 ? void 0 : _a.split("?")[0];
    // Capture error objects, not stack itself, as stack retrieval is very expensive operation, so we delay it
    const errWithStack = (0, telemetry_utils_1.generateErrorWithStack)();
    return {
        mimeType: "text/plain",
        status,
        value: urlNoQuery === undefined ? value : `${value}: ${urlNoQuery}`,
        get stack() { return errWithStack.stack; },
    };
}
exports.createResponseError = createResponseError;
function createDataStoreFactory(type, factory) {
    return {
        type,
        get IFluidDataStoreFactory() { return this; },
        get IFluidDataStoreRegistry() { return this; },
        instantiateDataStore: async (context, existing) => (await factory).instantiateDataStore(context, existing),
        get: async (name) => { var _a; return (_a = (await factory).IFluidDataStoreRegistry) === null || _a === void 0 ? void 0 : _a.get(name); },
    };
}
exports.createDataStoreFactory = createDataStoreFactory;

},{"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],213:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./dataStoreHandleContextUtils"), exports);
__exportStar(require("./dataStoreHelpers"), exports);
__exportStar(require("./objectstoragepartition"), exports);
__exportStar(require("./objectstorageutils"), exports);
__exportStar(require("./requestParser"), exports);
__exportStar(require("./runtimeFactoryHelper"), exports);
__exportStar(require("./summarizerNode"), exports);
__exportStar(require("./summaryUtils"), exports);
__exportStar(require("./utils"), exports);

},{"./dataStoreHandleContextUtils":211,"./dataStoreHelpers":212,"./objectstoragepartition":214,"./objectstorageutils":215,"./requestParser":216,"./runtimeFactoryHelper":217,"./summarizerNode":218,"./summaryUtils":222,"./utils":223}],214:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectStoragePartition = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Returns a new IChannelStorageService that resolves the given `path` as root.
 */
class ObjectStoragePartition {
    constructor(storage, path) {
        this.storage = storage;
        this.path = path;
        // `path` must not include the trailing separator.
        (0, common_utils_1.assert)(!path.endsWith("/"), 0x19c /* "storage service path has trailing separator" */);
    }
    async readBlob(path) {
        return this.storage.readBlob(`${this.path}/${path}`);
    }
    async contains(path) {
        return this.storage.contains(`${this.path}/${path}`);
    }
    async list(path) {
        return this.storage.list(`${this.path}/${path}`);
    }
}
exports.ObjectStoragePartition = ObjectStoragePartition;

},{"@fluidframework/common-utils":29}],215:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.listBlobsAtTreePath = exports.getNormalizedObjectStoragePathParts = void 0;
function getNormalizedObjectStoragePathParts(path) {
    let normalizePath = path;
    if (normalizePath.startsWith("/")) {
        normalizePath = normalizePath.substr(1);
    }
    if (normalizePath.endsWith("/")) {
        normalizePath = normalizePath.substr(0, normalizePath.length - 1);
    }
    if (normalizePath.length > 0) {
        return normalizePath.split("/");
    }
    return [];
}
exports.getNormalizedObjectStoragePathParts = getNormalizedObjectStoragePathParts;
async function listBlobsAtTreePath(inputTree, path) {
    const pathParts = getNormalizedObjectStoragePathParts(path);
    let tree = inputTree;
    while ((tree === null || tree === void 0 ? void 0 : tree.entries) !== undefined && pathParts.length > 0) {
        const part = pathParts.shift();
        const treeEntry = tree.entries.find((value) => {
            if (value.type === "Tree" && value.path === part) {
                return true;
            }
            else {
                return false;
            }
        });
        // this check is largely superfluous due to the same check being done
        // immediately above. the type system, however, is not aware of this.
        // so we must redundantly determine that the entry's type is "Tree"
        if ((treeEntry === null || treeEntry === void 0 ? void 0 : treeEntry.type) === "Tree") {
            tree = treeEntry.value;
        }
        else {
            tree = undefined;
        }
    }
    if ((tree === null || tree === void 0 ? void 0 : tree.entries) === undefined || pathParts.length !== 0) {
        throw new Error("path does not exist");
    }
    return tree.entries.filter((e) => e.type === "Blob").map((e) => e.path);
}
exports.listBlobsAtTreePath = listBlobsAtTreePath;

},{}],216:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestParser = void 0;
/**
 * The Request Parser takes an IRequest provides parsing and sub request creation
 */
class RequestParser {
    constructor(request) {
        this.request = request;
        const queryStartIndex = this.request.url.indexOf("?");
        if (queryStartIndex >= 0) {
            this.query = this.request.url.substring(queryStartIndex);
        }
        else {
            this.query = "";
        }
    }
    /**
     * Splits the path of the url and decodes each path part
     * @param url - the url to get path parts of
     */
    static getPathParts(url) {
        const queryStartIndex = url.indexOf("?");
        return url
            .substring(0, queryStartIndex < 0 ? url.length : queryStartIndex)
            .split("/")
            .reduce((pv, cv) => {
            if (cv !== undefined && cv.length > 0) {
                pv.push(decodeURIComponent(cv));
            }
            return pv;
        }, []);
    }
    static create(request) {
        // Perf optimizations.
        if (request instanceof RequestParser) {
            return request;
        }
        return new RequestParser(request);
    }
    get url() {
        return this.request.url;
    }
    get headers() {
        return this.request.headers;
    }
    /**
     * Returns the decoded path parts of the request's url
     */
    get pathParts() {
        if (this.requestPathParts === undefined) {
            this.requestPathParts = RequestParser.getPathParts(this.url);
        }
        return this.requestPathParts;
    }
    /**
     * Returns true if it's a terminating path, i.e. no more elements after `elements` entries and empty query.
     * @param elements - number of elements in path
     */
    isLeaf(elements) {
        return this.query === "" && this.pathParts.length === elements;
    }
    /**
     * Creates a sub request starting at a specific path part of this request's url
     * The sub request url always has a leading slash, and always include query params if original url has any
     * e.g. original url is /a/b/?queryParams, createSubRequest(0) is /a/b/?queryParams
     * createSubRequest(1) is /b/?queryParams
     * createSubRequest(2) is /?queryParams
     * createSubRequest(n) where n is bigger than parts length, e.g. 2, or n is less than 0 will throw an exception
     *
     * note: query params are not counted towards path parts.
     *
     * @param startingPathIndex - The index of the first path part of the sub request
     */
    createSubRequest(startingPathIndex) {
        const pathLen = this.pathParts.length;
        if (startingPathIndex < 0 || startingPathIndex > pathLen) {
            throw new Error("incorrect sub-request");
        }
        if (startingPathIndex === pathLen && this.url.includes("?")) {
            return {
                url: `/${this.query}`,
                headers: this.headers,
            };
        }
        const path = `/${this.pathParts.slice(startingPathIndex).join("/")}`;
        return {
            url: this.query === "" ? path : `${path}/${this.query}`,
            headers: this.headers,
        };
    }
}
exports.RequestParser = RequestParser;

},{}],217:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuntimeFactoryHelper = void 0;
class RuntimeFactoryHelper {
    get IRuntimeFactory() { return this; }
    async instantiateRuntime(context, existing) {
        const fromExisting = existing === undefined
            ? context.existing === true
            : existing;
        const runtime = await this.preInitialize(context, fromExisting);
        if (fromExisting) {
            await this.instantiateFromExisting(runtime);
        }
        else {
            await this.instantiateFirstTime(runtime);
        }
        await this.hasInitialized(runtime);
        return runtime;
    }
    async instantiateFirstTime(_runtime) { }
    async instantiateFromExisting(_runtime) { }
    async hasInitialized(_runtime) { }
}
exports.RuntimeFactoryHelper = RuntimeFactoryHelper;

},{}],218:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRootSummarizerNodeWithGC = exports.createRootSummarizerNode = void 0;
var summarizerNode_1 = require("./summarizerNode");
Object.defineProperty(exports, "createRootSummarizerNode", { enumerable: true, get: function () { return summarizerNode_1.createRootSummarizerNode; } });
var summarizerNodeWithGc_1 = require("./summarizerNodeWithGc");
Object.defineProperty(exports, "createRootSummarizerNodeWithGC", { enumerable: true, get: function () { return summarizerNodeWithGc_1.createRootSummarizerNodeWithGC; } });

},{"./summarizerNode":219,"./summarizerNodeWithGc":221}],219:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRootSummarizerNode = exports.SummarizerNode = void 0;
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const common_utils_1 = require("@fluidframework/common-utils");
const summaryUtils_1 = require("../summaryUtils");
const summarizerNodeUtils_1 = require("./summarizerNodeUtils");
/**
 * Encapsulates the summarizing work and state of an individual tree node in the
 * summary tree. It tracks changes and allows for optimizations when unchanged, or
 * can allow for fallback summaries to be generated when an error is encountered.
 * Usage is for the root node to call startSummary first to begin tracking a WIP
 * (work in progress) summary. Then all nodes will call summarize to summaries their
 * individual parts. Once completed and uploaded to storage, the root node will call
 * completeSummary or clearSummary to clear the WIP summary tracking state if something
 * went wrong. The SummarizerNodes will track all pending summaries that have been
 * recorded by the completeSummary call. When one of them is acked, the root node should
 * call refreshLatestSummary to inform the tree of SummarizerNodes of the new baseline
 * latest successful summary.
 */
class SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNode to create root node, or createChild to create child nodes.
     */
    constructor(defaultLogger, summarizeInternalFn, config, _changeSequenceNumber, 
    /** Undefined means created without summary */
    _latestSummary, initialSummary, wipSummaryLogger) {
        var _a;
        this.defaultLogger = defaultLogger;
        this.summarizeInternalFn = summarizeInternalFn;
        this._changeSequenceNumber = _changeSequenceNumber;
        this._latestSummary = _latestSummary;
        this.initialSummary = initialSummary;
        this.wipSummaryLogger = wipSummaryLogger;
        this.children = new Map();
        this.pendingSummaries = new Map();
        this.outstandingOps = [];
        this.wipSkipRecursion = false;
        this.canReuseHandle = (_a = config.canReuseHandle) !== null && _a !== void 0 ? _a : true;
        // BUGBUG: Seeing issues with differential summaries.
        // this will disable them, and throw instead
        // while we continue to investigate
        this.throwOnError = true; // config.throwOnFailure ?? false;
        this.trackingSequenceNumber = this._changeSequenceNumber;
    }
    /**
     * The reference sequence number of the most recent acked summary.
     * Returns 0 if there is not yet an acked summary.
     */
    get referenceSequenceNumber() {
        var _a, _b;
        return (_b = (_a = this._latestSummary) === null || _a === void 0 ? void 0 : _a.referenceSequenceNumber) !== null && _b !== void 0 ? _b : 0;
    }
    startSummary(referenceSequenceNumber, summaryLogger) {
        (0, common_utils_1.assert)(this.wipSummaryLogger === undefined, 0x19f /* "wipSummaryLogger should not be set yet in startSummary" */);
        (0, common_utils_1.assert)(this.wipReferenceSequenceNumber === undefined, 0x1a0 /* "Already tracking a summary" */);
        this.wipSummaryLogger = summaryLogger;
        for (const child of this.children.values()) {
            child.startSummary(referenceSequenceNumber, this.wipSummaryLogger);
        }
        this.wipReferenceSequenceNumber = referenceSequenceNumber;
    }
    async summarize(fullTree, trackState = true, telemetryContext) {
        (0, common_utils_1.assert)(this.isTrackingInProgress(), 0x1a1 /* "summarize should not be called when not tracking the summary" */);
        (0, common_utils_1.assert)(this.wipSummaryLogger !== undefined, 0x1a2 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        // Try to reuse the tree if unchanged
        if (this.canReuseHandle && !fullTree && !this.hasChanged()) {
            const latestSummary = this._latestSummary;
            if (latestSummary !== undefined) {
                this.wipLocalPaths = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
                this.wipSkipRecursion = true;
                const stats = (0, summaryUtils_1.mergeStats)();
                stats.handleNodeCount++;
                return {
                    summary: {
                        type: protocol_definitions_1.SummaryType.Handle,
                        handle: latestSummary.fullPath.path,
                        handleType: protocol_definitions_1.SummaryType.Tree,
                    },
                    stats,
                };
            }
        }
        try {
            const result = await this.summarizeInternalFn(fullTree, true, telemetryContext);
            this.wipLocalPaths = { localPath: summarizerNodeUtils_1.EscapedPath.create(result.id) };
            if (result.pathPartsForChildren !== undefined) {
                this.wipLocalPaths.additionalPath = summarizerNodeUtils_1.EscapedPath.createAndConcat(result.pathPartsForChildren);
            }
            return { summary: result.summary, stats: result.stats };
        }
        catch (error) {
            if (this.throwOnError || this.trackingSequenceNumber < this._changeSequenceNumber) {
                throw error;
            }
            const latestSummary = this._latestSummary;
            const initialSummary = this.initialSummary;
            let encodeParam;
            let localPath;
            if (latestSummary !== undefined) {
                // Create using handle of latest acked summary
                encodeParam = {
                    fromSummary: true,
                    summaryNode: latestSummary,
                };
                localPath = latestSummary.localPath;
            }
            else if ((initialSummary === null || initialSummary === void 0 ? void 0 : initialSummary.summary) !== undefined) {
                // Create using initial summary from attach op
                encodeParam = {
                    fromSummary: false,
                    initialSummary: initialSummary.summary,
                };
                localPath = summarizerNodeUtils_1.EscapedPath.create(initialSummary.id);
            }
            else {
                // No base summary to reference
                throw error;
            }
            this.wipSummaryLogger.sendErrorEvent({
                eventName: "SummarizingWithBasePlusOps",
            }, error);
            const summary = (0, summarizerNodeUtils_1.encodeSummary)(encodeParam, this.outstandingOps);
            this.wipLocalPaths = {
                localPath,
                additionalPath: summary.additionalPath,
            };
            this.wipSkipRecursion = true;
            return { summary: summary.summary, stats: summary.stats };
        }
    }
    /**
     * Complete the WIP summary for the given proposalHandle
     */
    completeSummary(proposalHandle) {
        this.completeSummaryCore(proposalHandle, undefined, false);
    }
    /**
     * Recursive implementation for completeSummary, with additional internal-only parameters
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        (0, common_utils_1.assert)(this.wipSummaryLogger !== undefined, 0x1a3 /* "wipSummaryLogger should have been set in startSummary or ctor" */);
        (0, common_utils_1.assert)(this.wipReferenceSequenceNumber !== undefined, 0x1a4 /* "Not tracking a summary" */);
        let localPathsToUse = this.wipLocalPaths;
        if (parentSkipRecursion) {
            const latestSummary = this._latestSummary;
            if (latestSummary !== undefined) {
                // This case the parent node created a failure summary or was reused.
                // This node and all children should only try to reference their path
                // by its last known good state in the actual summary tree.
                // If parent fails or is reused, the child summarize is not called so
                // it did not get a chance to change its paths.
                // In this case, essentially only propagate the new summary ref seq num.
                localPathsToUse = {
                    localPath: latestSummary.localPath,
                    additionalPath: latestSummary.additionalPath,
                };
            }
            else {
                // This case the child is added after the latest non-failure summary.
                // This node and all children should consider themselves as still not
                // having a successful summary yet.
                // We cannot "reuse" this node if unchanged since that summary, because
                // handles will be unable to point to that node. It never made it to the
                // tree itself, and only exists as an attach op in the _outstandingOps.
                this.clearSummary();
                return;
            }
        }
        // This should come from wipLocalPaths in normal cases, or from the latestSummary
        // if parentIsFailure or parentIsReused is true.
        // If there is no latestSummary, clearSummary and return before reaching this code.
        (0, common_utils_1.assert)(!!localPathsToUse, 0x1a5 /* "Tracked summary local paths not set" */);
        const summary = new summarizerNodeUtils_1.SummaryNode(Object.assign(Object.assign({}, localPathsToUse), { referenceSequenceNumber: this.wipReferenceSequenceNumber, basePath: parentPath }));
        const fullPathForChildren = summary.fullPathForChildren;
        for (const child of this.children.values()) {
            child.completeSummaryCore(proposalHandle, fullPathForChildren, this.wipSkipRecursion || parentSkipRecursion);
        }
        // Note that this overwrites existing pending summary with
        // the same proposalHandle. If proposalHandle is something like
        // a hash or unique identifier, this should be fine. If storage
        // can return the same proposalHandle for a different summary,
        // this should still be okay, because we should be proposing the
        // newer one later which would have to overwrite the previous one.
        this.pendingSummaries.set(proposalHandle, summary);
        this.clearSummary();
    }
    clearSummary() {
        this.wipReferenceSequenceNumber = undefined;
        this.wipLocalPaths = undefined;
        this.wipSkipRecursion = false;
        this.wipSummaryLogger = undefined;
        for (const child of this.children.values()) {
            child.clearSummary();
        }
    }
    /**
     * Refreshes the latest summary tracked by this node. If we have a pending summary for the given proposal handle,
     * it becomes the latest summary. If the current summary is already ahead (e.g., loaded from a service summary),
     * we skip the update. Otherwise, we get the snapshot by calling `getSnapshot` and update latest
     * summary based off of that.
     * @returns A RefreshSummaryResult type which returns information based on the following three scenarios:
     *          1. The latest summary was not udpated.
     *          2. The latest summary was updated and the summary corresponding to the params was being tracked.
     *          3. The latest summary was updated but the summary corresponding to the params was not tracked. In this
     *             case, the latest summary is updated based on the downloaded snapshot which is also returned.
     */
    async refreshLatestSummary(proposalHandle, summaryRefSeq, getSnapshot, readAndParseBlob, correlatedSummaryLogger) {
        if (proposalHandle !== undefined) {
            const maybeSummaryNode = this.pendingSummaries.get(proposalHandle);
            if (maybeSummaryNode !== undefined) {
                this.refreshLatestSummaryFromPending(proposalHandle, maybeSummaryNode.referenceSequenceNumber);
                return { latestSummaryUpdated: true, wasSummaryTracked: true };
            }
        }
        // If we have seen a summary same or later as the current one, ignore it.
        if (this.referenceSequenceNumber >= summaryRefSeq) {
            return { latestSummaryUpdated: false };
        }
        const snapshotTree = await getSnapshot();
        await this.refreshLatestSummaryFromSnapshot(summaryRefSeq, snapshotTree, undefined, summarizerNodeUtils_1.EscapedPath.create(""), correlatedSummaryLogger, readAndParseBlob);
        return { latestSummaryUpdated: true, wasSummaryTracked: false, snapshot: snapshotTree };
    }
    /**
     * Called when we get an ack from the server for a summary we've just sent. Updates the reference state of this node
     * from the state in the pending summary queue.
     * @param proposalHandle - Handle for the current proposal.
     * @param referenceSequenceNumber -  reference sequence number of sent summary.
     */
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        const summaryNode = this.pendingSummaries.get(proposalHandle);
        if (summaryNode === undefined) {
            // This should only happen if parent skipped recursion AND no prior summary existed.
            (0, common_utils_1.assert)(this._latestSummary === undefined, 0x1a6 /* "Not found pending summary, but this node has previously completed a summary" */);
            return;
        }
        else {
            (0, common_utils_1.assert)(referenceSequenceNumber === summaryNode.referenceSequenceNumber, 0x1a7 /* Pending summary reference sequence number should be consistent */);
            // Clear earlier pending summaries
            this.pendingSummaries.delete(proposalHandle);
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        this._latestSummary = summaryNode;
        // Propagate update to all child nodes
        for (const child of this.children.values()) {
            child.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
        }
    }
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
        if (this.referenceSequenceNumber >= referenceSequenceNumber) {
            return;
        }
        this.refreshLatestSummaryCore(referenceSequenceNumber);
        const { baseSummary, pathParts } = (0, summarizerNodeUtils_1.decodeSummary)(snapshotTree, correlatedSummaryLogger);
        this._latestSummary = new summarizerNodeUtils_1.SummaryNode({
            referenceSequenceNumber,
            basePath,
            localPath,
        });
        const { childrenTree, childrenPathPart } = (0, summarizerNodeUtils_1.parseSummaryForSubtrees)(baseSummary);
        if (childrenPathPart !== undefined) {
            pathParts.push(childrenPathPart);
        }
        if (pathParts.length > 0) {
            this._latestSummary.additionalPath = summarizerNodeUtils_1.EscapedPath.createAndConcat(pathParts);
        }
        // Propagate update to all child nodes
        const pathForChildren = this._latestSummary.fullPathForChildren;
        await Promise.all(Array.from(this.children)
            .filter(([id]) => {
            // Assuming subtrees missing from snapshot are newer than the snapshot,
            // but might be nice to assert this using earliest seq for node.
            return childrenTree.trees[id] !== undefined;
        }).map(async ([id, child]) => {
            return child.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, childrenTree.trees[id], pathForChildren, summarizerNodeUtils_1.EscapedPath.create(id), correlatedSummaryLogger, readAndParseBlob);
        }));
    }
    refreshLatestSummaryCore(referenceSequenceNumber) {
        for (const [key, value] of this.pendingSummaries) {
            if (value.referenceSequenceNumber < referenceSequenceNumber) {
                this.pendingSummaries.delete(key);
            }
        }
        // Clear earlier outstanding ops
        while (this.outstandingOps.length > 0
            && this.outstandingOps[0].sequenceNumber <= referenceSequenceNumber) {
            this.outstandingOps.shift();
        }
    }
    loadBaseSummaryWithoutDifferential(snapshot) {
        // Check base summary to see if it has any additional path parts
        // separating child SummarizerNodes. Checks for .channels subtrees.
        const { childrenPathPart } = (0, summarizerNodeUtils_1.parseSummaryForSubtrees)(snapshot);
        if (childrenPathPart !== undefined && this._latestSummary !== undefined) {
            this._latestSummary.additionalPath = summarizerNodeUtils_1.EscapedPath.create(childrenPathPart);
        }
    }
    async loadBaseSummary(snapshot, readAndParseBlob) {
        const decodedSummary = (0, summarizerNodeUtils_1.decodeSummary)(snapshot, this.defaultLogger);
        const outstandingOps = await decodedSummary.getOutstandingOps(readAndParseBlob);
        const { childrenPathPart } = (0, summarizerNodeUtils_1.parseSummaryForSubtrees)(decodedSummary.baseSummary);
        if (childrenPathPart !== undefined) {
            decodedSummary.pathParts.push(childrenPathPart);
        }
        if (decodedSummary.pathParts.length > 0 && this._latestSummary !== undefined) {
            this._latestSummary.additionalPath = summarizerNodeUtils_1.EscapedPath.createAndConcat(decodedSummary.pathParts);
        }
        // Defensive assertion: tracking number should already exceed this number.
        // This is probably a little excessive; can remove when stable.
        if (outstandingOps.length > 0) {
            const newOpsLatestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
            (0, common_utils_1.assert)(newOpsLatestSeq <= this.trackingSequenceNumber, 0x1a9 /* "When loading base summary, expected outstanding ops <= tracking sequence number" */);
        }
        return {
            baseSummary: decodedSummary.baseSummary,
            outstandingOps,
        };
    }
    recordChange(op) {
        const lastOp = this.outstandingOps[this.outstandingOps.length - 1];
        if (lastOp !== undefined) {
            (0, common_utils_1.assert)(lastOp.sequenceNumber < op.sequenceNumber, 0x1aa /* Out of order change recorded */);
        }
        this.invalidate(op.sequenceNumber);
        this.trackingSequenceNumber = op.sequenceNumber;
        this.outstandingOps.push(op);
    }
    invalidate(sequenceNumber) {
        if (sequenceNumber > this._changeSequenceNumber) {
            this._changeSequenceNumber = sequenceNumber;
        }
    }
    /**
     * True if a change has been recorded with sequence number exceeding
     * the latest successfully acked summary reference sequence number.
     * False implies that the previous summary can be reused.
     */
    hasChanged() {
        return this._changeSequenceNumber > this.referenceSequenceNumber;
    }
    get latestSummary() {
        return this._latestSummary;
    }
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}) {
        (0, common_utils_1.assert)(!this.children.has(id), 0x1ab /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNode(this.defaultLogger, summarizeInternalFn, config, createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger);
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too. Same goes for pendingSummaries we might
        // have outstanding on the parent in case we realize nodes in between Summary Op and Summary Ack.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    getChild(id) {
        return this.children.get(id);
    }
    /**
     * Returns the details needed to create a child node.
     * @param id - Initial id or path part of the child node.
     * @param createParam - Information needed to create the node.
     * @returns the details needed to create the child node.
     */
    getCreateDetailsForChild(id, createParam) {
        var _a;
        let initialSummary;
        let latestSummary;
        let changeSequenceNumber;
        const parentLatestSummary = this._latestSummary;
        switch (createParam.type) {
            case runtime_definitions_1.CreateSummarizerNodeSource.FromAttach: {
                if (parentLatestSummary !== undefined
                    && createParam.sequenceNumber <= parentLatestSummary.referenceSequenceNumber) {
                    // Prioritize latest summary if it was after this node was attached.
                    latestSummary = parentLatestSummary.createForChild(id);
                }
                else {
                    const summary = (0, summaryUtils_1.convertToSummaryTree)(createParam.snapshot);
                    initialSummary = {
                        sequenceNumber: createParam.sequenceNumber,
                        id,
                        summary,
                    };
                }
                changeSequenceNumber = createParam.sequenceNumber;
                break;
            }
            case runtime_definitions_1.CreateSummarizerNodeSource.FromSummary: {
                if (this.initialSummary === undefined) {
                    (0, common_utils_1.assert)(!!parentLatestSummary, 0x1ac /* "Cannot create child from summary if parent does not have latest summary" */);
                }
                // fallthrough to local
            }
            case runtime_definitions_1.CreateSummarizerNodeSource.Local: {
                const parentInitialSummary = this.initialSummary;
                if (parentInitialSummary !== undefined) {
                    let childSummary;
                    if (parentInitialSummary.summary !== undefined) {
                        const { childrenTree } = (0, summarizerNodeUtils_1.parseSummaryTreeForSubtrees)(parentInitialSummary.summary.summary);
                        (0, common_utils_1.assert)(childrenTree.type === protocol_definitions_1.SummaryType.Tree, 0x1d6 /* "Parent summary object is not a tree" */);
                        childSummary = childrenTree.tree[id];
                    }
                    if (createParam.type === runtime_definitions_1.CreateSummarizerNodeSource.FromSummary) {
                        // Locally created would not have differential subtree.
                        (0, common_utils_1.assert)(!!childSummary, 0x1ad /* "Missing child summary tree" */);
                    }
                    let childSummaryWithStats;
                    if (childSummary !== undefined) {
                        (0, common_utils_1.assert)(childSummary.type === protocol_definitions_1.SummaryType.Tree, 0x1ae /* "Child summary object is not a tree" */);
                        childSummaryWithStats = {
                            summary: childSummary,
                            stats: (0, summaryUtils_1.calculateStats)(childSummary),
                        };
                    }
                    initialSummary = {
                        sequenceNumber: parentInitialSummary.sequenceNumber,
                        id,
                        summary: childSummaryWithStats,
                    };
                }
                latestSummary = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.createForChild(id);
                changeSequenceNumber = (_a = parentLatestSummary === null || parentLatestSummary === void 0 ? void 0 : parentLatestSummary.referenceSequenceNumber) !== null && _a !== void 0 ? _a : -1;
                break;
            }
            default: {
                const type = createParam.type;
                (0, common_utils_1.unreachableCase)(createParam, `Unexpected CreateSummarizerNodeSource: ${type}`);
            }
        }
        return {
            initialSummary,
            latestSummary,
            changeSequenceNumber,
        };
    }
    /**
     * Updates the state of the child if required. For example, if a summary is currently being  tracked, the child's
     * summary tracking state needs to be updated too.
     * Also, in case a child node gets realized in between Summary Op and Summary Ack, let's initialize the child's
     * pending summary as well.
     * @param child - The child node whose state is to be updated.
     */
    maybeUpdateChildState(child) {
        // If we are tracking a summary, this child was created after the tracking started. So, we need to update the
        // child's tracking state as well.
        if (this.isTrackingInProgress()) {
            child.wipReferenceSequenceNumber = this.wipReferenceSequenceNumber;
        }
        // In case we have pending summaries on the parent, let's initialize it on the child.
        if (child._latestSummary !== undefined) {
            for (const [key, value] of this.pendingSummaries.entries()) {
                const newLatestSummaryNode = new summarizerNodeUtils_1.SummaryNode({
                    referenceSequenceNumber: value.referenceSequenceNumber,
                    basePath: child._latestSummary.basePath,
                    localPath: child._latestSummary.localPath,
                });
                child.addPendingSummary(key, newLatestSummaryNode);
            }
        }
    }
    addPendingSummary(key, summary) {
        this.pendingSummaries.set(key, summary);
    }
    /**
     * Tells whether summary tracking is in progress. True if "startSummary" API is called before summarize.
     */
    isTrackingInProgress() {
        return this.wipReferenceSequenceNumber !== undefined;
    }
}
exports.SummarizerNode = SummarizerNode;
/**
 * Creates a root summarizer node.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 */
const createRootSummarizerNode = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}) => new SummarizerNode(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : summarizerNodeUtils_1.SummaryNode.createForRoot(referenceSequenceNumber));
exports.createRootSummarizerNode = createRootSummarizerNode;

},{"../summaryUtils":222,"./summarizerNodeUtils":220,"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208}],220:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSummaryTreeForSubtrees = exports.parseSummaryForSubtrees = exports.encodeSummary = exports.decodeSummary = exports.SummaryNode = exports.EscapedPath = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const summaryUtils_1 = require("../summaryUtils");
const baseSummaryTreeKey = "_baseSummary";
const outstandingOpsBlobKey = "_outstandingOps";
const maxDecodeDepth = 100;
/** Path for nodes in a tree with escaped special characters */
class EscapedPath {
    constructor(path) {
        this.path = path;
    }
    static create(path) {
        return new EscapedPath(encodeURIComponent(path));
    }
    static createAndConcat(pathParts) {
        var _a;
        let ret = EscapedPath.create((_a = pathParts[0]) !== null && _a !== void 0 ? _a : "");
        for (let i = 1; i < pathParts.length; i++) {
            ret = ret.concat(EscapedPath.create(pathParts[i]));
        }
        return ret;
    }
    toString() {
        return this.path;
    }
    concat(path) {
        return new EscapedPath(`${this.path}/${path.path}`);
    }
}
exports.EscapedPath = EscapedPath;
/** Information about a summary relevant to a specific node in the tree */
class SummaryNode {
    constructor(summary) {
        this.summary = summary;
    }
    /** Creates an instance that is valid for the root with specific basePath and localPath */
    static createForRoot(referenceSequenceNumber) {
        return new SummaryNode({
            referenceSequenceNumber,
            basePath: undefined,
            localPath: EscapedPath.create(""), // root hard-coded to ""
        });
    }
    /** Summary reference sequence number, i.e. last sequence number seen when it was created */
    get referenceSequenceNumber() {
        return this.summary.referenceSequenceNumber;
    }
    /** Full path to parent node, or undefined if this is the root */
    get basePath() {
        return this.summary.basePath;
    }
    /** Relative path to this node from its parent node */
    get localPath() {
        return this.summary.localPath;
    }
    /** Relative path from this node to its node innermost base summary */
    get additionalPath() {
        return this.summary.additionalPath;
    }
    set additionalPath(additionalPath) {
        this.summary.additionalPath = additionalPath;
    }
    /** Gets the full path to this node, to be used when sending a handle */
    get fullPath() {
        var _a, _b;
        return (_b = (_a = this.basePath) === null || _a === void 0 ? void 0 : _a.concat(this.localPath)) !== null && _b !== void 0 ? _b : this.localPath;
    }
    /**
     * Gets the full path to this node's innermost base summary.
     * The children nodes can use this as their basePath to determine their path.
     */
    get fullPathForChildren() {
        return this.additionalPath !== undefined
            ? this.fullPath.concat(this.additionalPath)
            : this.fullPath;
    }
    /**
     * Creates a new node within the same summary for a child of this node.
     * @param id - id of the child node
     */
    createForChild(id) {
        return new SummaryNode({
            referenceSequenceNumber: this.referenceSequenceNumber,
            basePath: this.fullPathForChildren,
            localPath: EscapedPath.create(id),
        });
    }
}
exports.SummaryNode = SummaryNode;
/**
 * Checks if the snapshot is created by referencing a previous successful
 * summary plus outstanding ops. If so, it will recursively "decode" it until
 * it gets to the last successful summary (the base summary) and returns that
 * as well as a function for fetching the outstanding ops. Also returns the
 * full path to the previous base summary for child summarizer nodes to use as
 * their base path when necessary.
 * @param snapshot - snapshot tree to decode
 */
function decodeSummary(snapshot, logger) {
    let baseSummary = snapshot;
    const pathParts = [];
    const opsBlobs = [];
    for (let i = 0;; i++) {
        if (i > maxDecodeDepth) {
            logger.sendTelemetryEvent({
                eventName: "DecodeSummaryMaxDepth",
                maxDecodeDepth,
            });
        }
        const outstandingOpsBlob = baseSummary.blobs[outstandingOpsBlobKey];
        const newBaseSummary = baseSummary.trees[baseSummaryTreeKey];
        if (outstandingOpsBlob === undefined && newBaseSummary === undefined) {
            return {
                baseSummary,
                pathParts,
                async getOutstandingOps(readAndParseBlob) {
                    let outstandingOps = [];
                    for (const opsBlob of opsBlobs) {
                        const newOutstandingOps = await readAndParseBlob(opsBlob);
                        if (outstandingOps.length > 0 && newOutstandingOps.length > 0) {
                            const latestSeq = outstandingOps[outstandingOps.length - 1].sequenceNumber;
                            const newEarliestSeq = newOutstandingOps[0].sequenceNumber;
                            if (newEarliestSeq <= latestSeq) {
                                logger.sendTelemetryEvent({
                                    eventName: "DuplicateOutstandingOps",
                                    // eslint-disable-next-line max-len
                                    message: `newEarliestSeq <= latestSeq in decodeSummary: ${newEarliestSeq} <= ${latestSeq}`,
                                });
                                while (newOutstandingOps.length > 0
                                    && newOutstandingOps[0].sequenceNumber <= latestSeq) {
                                    newOutstandingOps.shift();
                                }
                            }
                        }
                        outstandingOps = outstandingOps.concat(newOutstandingOps);
                    }
                    return outstandingOps;
                },
            };
        }
        (0, common_utils_1.assert)(!!outstandingOpsBlob, 0x1af /* "Outstanding ops blob missing, but base summary tree exists" */);
        (0, common_utils_1.assert)(newBaseSummary !== undefined, 0x1b0 /* "Base summary tree missing, but outstanding ops blob exists" */);
        baseSummary = newBaseSummary;
        pathParts.push(baseSummaryTreeKey);
        opsBlobs.unshift(outstandingOpsBlob);
    }
}
exports.decodeSummary = decodeSummary;
/**
 * Creates a summary tree which is a handle of the previous successfully acked summary
 * and a blob of the outstanding ops since that summary. If there is no acked summary yet,
 * it will create with the tree found in the initial attach op and the blob of outstanding ops.
 * @param summaryParam - information about last acked summary and paths to encode if from summary,
 * otherwise the initial summary from the attach op.
 * @param outstandingOps - outstanding ops since last acked summary
 */
function encodeSummary(summaryParam, outstandingOps) {
    let additionalPath = EscapedPath.create(baseSummaryTreeKey);
    const builder = new summaryUtils_1.SummaryTreeBuilder();
    builder.addBlob(outstandingOpsBlobKey, JSON.stringify(outstandingOps));
    if (summaryParam.fromSummary) {
        // Create using handle of latest acked summary
        const summaryNode = summaryParam.summaryNode;
        if (summaryNode.additionalPath !== undefined) {
            additionalPath = additionalPath.concat(summaryNode.additionalPath);
        }
        builder.addHandle(baseSummaryTreeKey, protocol_definitions_1.SummaryType.Tree, summaryNode.fullPath.path);
    }
    else {
        // Create using initial summary from attach op
        builder.addWithStats(baseSummaryTreeKey, summaryParam.initialSummary);
    }
    const summary = builder.getSummaryTree();
    return Object.assign(Object.assign({}, summary), { additionalPath });
}
exports.encodeSummary = encodeSummary;
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryForSubtrees(baseSummary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = baseSummary.trees[runtime_definitions_1.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: runtime_definitions_1.channelsTreeName,
        };
    }
    return {
        childrenTree: baseSummary,
        childrenPathPart: undefined,
    };
}
exports.parseSummaryForSubtrees = parseSummaryForSubtrees;
/**
 * Checks if the summary contains .channels subtree where the children subtrees
 * would be located if exists.
 * @param baseSummary - summary to check
 */
function parseSummaryTreeForSubtrees(summary) {
    // New versions of snapshots have child nodes isolated in .channels subtree
    const channelsSubtree = summary.tree[runtime_definitions_1.channelsTreeName];
    if (channelsSubtree !== undefined) {
        return {
            childrenTree: channelsSubtree,
            childrenPathPart: runtime_definitions_1.channelsTreeName,
        };
    }
    return {
        childrenTree: summary,
        childrenPathPart: undefined,
    };
}
exports.parseSummaryTreeForSubtrees = parseSummaryTreeForSubtrees;

},{"../summaryUtils":222,"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-definitions":208}],221:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRootSummarizerNodeWithGC = exports.SummarizerNodeWithGC = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const garbage_collector_1 = require("@fluidframework/garbage-collector");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const summarizerNode_1 = require("./summarizerNode");
const summarizerNodeUtils_1 = require("./summarizerNodeUtils");
// Extend SummaryNode to add used routes tracking to it.
class SummaryNodeWithGC extends summarizerNodeUtils_1.SummaryNode {
    constructor(serializedUsedRoutes, summary) {
        super(summary);
        this.serializedUsedRoutes = serializedUsedRoutes;
    }
}
/**
 * Extends the functionality of SummarizerNode to manage this node's garbage collection data:
 * - Adds a new API `getGCData` to return GC data of this node.
 * - Caches the result of `getGCData` to be used if nothing changes between summaries.
 * - Manages the used routes of this node. These are used to identify if this node is referenced in the document
 *   and to determine if the node's used state changed since last summary.
 * - Adds trackState param to summarize. If trackState is false, it bypasses the SummarizerNode and calls
 *   directly into summarizeInternal method.
 */
class SummarizerNodeWithGC extends summarizerNode_1.SummarizerNode {
    /**
     * Do not call constructor directly.
     * Use createRootSummarizerNodeWithGC to create root node, or createChild to create child nodes.
     */
    constructor(logger, summarizeFn, config, changeSequenceNumber, 
    /** Undefined means created without summary */
    latestSummary, initialSummary, wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn) {
        super(logger, async (fullTree, _trackState, telemetryContext) => summarizeFn(fullTree, true /* trackState */, telemetryContext), config, changeSequenceNumber, latestSummary, initialSummary, wipSummaryLogger);
        this.summarizeFn = summarizeFn;
        this.getGCDataFn = getGCDataFn;
        // Keeps track of whether we have loaded the base details to ensure that we on;y do it once.
        this.baseGCDetailsLoaded = false;
        // Set used routes to have self route by default. This makes the node referenced by default. This is done to ensure
        // that this node is not marked as collected when running GC has been disabled. Once, the option to disable GC is
        // removed (from runGC flag in IContainerRuntimeOptions), this should be changed to be have no routes by default.
        this.usedRoutes = [""];
        this.gcDisabled = config.gcDisabled === true;
        this.baseGCDetailsP = new common_utils_1.LazyPromise(async () => {
            var _a;
            return (_a = (await (getBaseGCDetailsFn === null || getBaseGCDetailsFn === void 0 ? void 0 : getBaseGCDetailsFn()))) !== null && _a !== void 0 ? _a : { usedRoutes: [] };
        });
    }
    /**
     * @deprecated - Renamed to getBaseGCDetails.
     */
    getGCSummaryDetails() {
        return this.getBaseGCDetails();
    }
    // Returns the GC details to be added to this node's summary and is used to initialize new nodes' GC state.
    getBaseGCDetails() {
        return {
            gcData: this.gcData,
            usedRoutes: this.usedRoutes,
            unrefTimestamp: this.unreferencedTimestampMs,
        };
    }
    /**
     * Loads state from this node's initial GC summary details. This contains the following data from the last summary
     * seen by the server for this client:
     * - usedRoutes: This is used to figure out if the used state of this node changed since last summary.
     * - gcData: The garbage collection data of this node that is required for running GC.
     */
    async loadBaseGCDetails() {
        var _a;
        const baseGCDetails = await this.baseGCDetailsP;
        // Possible race - If there were parallel calls to loadBaseGCDetails, we want to make sure that we only update
        // the state from the base details only once.
        if (this.baseGCDetailsLoaded) {
            return;
        }
        this.baseGCDetailsLoaded = true;
        // If the GC details has GC data, initialize our GC data from it.
        if (baseGCDetails.gcData !== undefined) {
            this.gcData = (0, garbage_collector_1.cloneGCData)(baseGCDetails.gcData);
        }
        // Sort the used routes because we compare them with the current used routes to check if they changed between
        // summaries. Both are sorted so that the order of elements is the same.
        this.referenceUsedRoutes = (_a = baseGCDetails.usedRoutes) === null || _a === void 0 ? void 0 : _a.sort();
        this.unreferencedTimestampMs = baseGCDetails.unrefTimestamp;
    }
    async summarize(fullTree, trackState = true, telemetryContext) {
        // If GC is not disabled and we are tracking a summary, GC should have run and updated the used routes for this
        // summary by calling updateUsedRoutes which sets wipSerializedUsedRoutes.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            (0, common_utils_1.assert)(this.wipSerializedUsedRoutes !== undefined, 0x1b1 /* "wip used routes should be set if tracking a summary" */);
        }
        // If trackState is true, get summary from base summarizer node which tracks summary state.
        // If trackState is false, get summary from summarizeInternal.
        return trackState
            ? super.summarize(fullTree, true /* trackState */, telemetryContext)
            : this.summarizeFn(fullTree, trackState, telemetryContext);
    }
    /**
     * Returns the GC data of this node. If nothing has changed since last summary, it tries to reuse the data from
     * the previous summary. Else, it gets new GC data from the underlying Fluid object.
     * @param fullGC - true to bypass optimizations and force full generation of GC data.
     */
    async getGCData(fullGC = false) {
        (0, common_utils_1.assert)(!this.gcDisabled, 0x1b2 /* "Getting GC data should not be called when GC is disabled!" */);
        (0, common_utils_1.assert)(this.getGCDataFn !== undefined, 0x1b3 /* "GC data cannot be retrieved without getGCDataFn" */);
        // Load GC details from the initial summary, if not already loaded. If this is the first time this function is
        // called and the node's data has not changed since last summary, the GC data in initial details is returned.
        await this.loadBaseGCDetails();
        // If there is no new data since last summary and we have GC data from the previous run, return it. We may not
        // have data from previous GC run for clients with older summary format before GC was added. They won't have
        // GC details in their initial summary.
        if (!fullGC && !this.hasDataChanged() && this.gcData !== undefined) {
            return (0, garbage_collector_1.cloneGCData)(this.gcData);
        }
        const gcData = await this.getGCDataFn(fullGC);
        this.gcData = (0, garbage_collector_1.cloneGCData)(gcData);
        return gcData;
    }
    /**
     * Called during the start of a summary. Updates the work-in-progress used routes.
     */
    startSummary(referenceSequenceNumber, summaryLogger) {
        // If GC is disabled, skip setting wip used routes since we should not track GC state.
        if (!this.gcDisabled) {
            (0, common_utils_1.assert)(this.wipSerializedUsedRoutes === undefined, 0x1b4 /* "We should not already be tracking used routes when to track a new summary" */);
        }
        super.startSummary(referenceSequenceNumber, summaryLogger);
    }
    /**
     * Called after summary has been uploaded to the server. Add the work-in-progress state to the pending
     * summary queue. We track this until we get an ack from the server for this summary.
     */
    completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion) {
        let wipSerializedUsedRoutes;
        // If GC is disabled, don't set wip used routes.
        if (!this.gcDisabled) {
            wipSerializedUsedRoutes = this.wipSerializedUsedRoutes;
            (0, common_utils_1.assert)(wipSerializedUsedRoutes !== undefined, 0x1b5 /* "We should have been tracking used routes" */);
        }
        super.completeSummaryCore(proposalHandle, parentPath, parentSkipRecursion);
        // If GC is disabled, skip setting pending summary with GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const summaryNodeWithGC = new SummaryNodeWithGC(wipSerializedUsedRoutes, summaryNode);
                this.pendingSummaries.set(proposalHandle, summaryNodeWithGC);
            }
        }
    }
    /**
     * Clears the work-in-progress state.
     */
    clearSummary() {
        this.wipSerializedUsedRoutes = undefined;
        super.clearSummary();
    }
    /**
     * Called when we get an ack from the server for a summary we sent. Update the reference state of this node
     * from the state in the pending summary queue.
     */
    refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const summaryNode = this.pendingSummaries.get(proposalHandle);
            if (summaryNode !== undefined) {
                this.referenceUsedRoutes = JSON.parse(summaryNode.serializedUsedRoutes);
            }
        }
        return super.refreshLatestSummaryFromPending(proposalHandle, referenceSequenceNumber);
    }
    /**
     * Called when we need to upload the reference state from the given summary. Read the GC blob and get the state
     * to upload from it.
     */
    async refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob) {
        // If GC is disabled, skip setting referenced used routes since we are not tracking GC state.
        if (!this.gcDisabled) {
            const gcDetailsBlob = snapshotTree.blobs[runtime_definitions_1.gcBlobKey];
            if (gcDetailsBlob !== undefined) {
                const gcDetails = await readAndParseBlob(gcDetailsBlob);
                // Possible re-entrancy. If we have already seen a summary later than this one, ignore it.
                if (this.referenceSequenceNumber >= referenceSequenceNumber) {
                    return;
                }
                this.referenceUsedRoutes = gcDetails.usedRoutes;
            }
        }
        return super.refreshLatestSummaryFromSnapshot(referenceSequenceNumber, snapshotTree, basePath, localPath, correlatedSummaryLogger, readAndParseBlob);
    }
    /**
     * Override the createChild method to return an instance of SummarizerNodeWithGC.
     */
    createChild(
    /** Summarize function */
    summarizeInternalFn, 
    /** Initial id or path part of this node */
    id, 
    /**
     * Information needed to create the node.
     * If it is from a base summary, it will assert that a summary has been seen.
     * Attach information if it is created from an attach op.
     */
    createParam, config = {}, getGCDataFn, getBaseGCDetailsFn) {
        var _a;
        (0, common_utils_1.assert)(!this.children.has(id), 0x1b6 /* "Create SummarizerNode child already exists" */);
        const createDetails = this.getCreateDetailsForChild(id, createParam);
        const child = new SummarizerNodeWithGC(this.defaultLogger, summarizeInternalFn, Object.assign(Object.assign({}, config), { 
            // Propagate our gcDisabled state to the child if its not explicity specified in child's config.
            gcDisabled: (_a = config.gcDisabled) !== null && _a !== void 0 ? _a : this.gcDisabled }), createDetails.changeSequenceNumber, createDetails.latestSummary, createDetails.initialSummary, this.wipSummaryLogger, getGCDataFn, getBaseGCDetailsFn);
        // There may be additional state that has to be updated in this child. For example, if a summary is being
        // tracked, the child's summary tracking state needs to be updated too.
        this.maybeUpdateChildState(child);
        this.children.set(id, child);
        return child;
    }
    /**
     * Deletes the child node with the given id.
     */
    deleteChild(id) {
        this.children.delete(id);
    }
    /**
     * Override the getChild method to return an instance of SummarizerNodeWithGC.
     */
    getChild(id) {
        return this.children.get(id);
    }
    isReferenced() {
        return this.usedRoutes.includes("") || this.usedRoutes.includes("/");
    }
    updateUsedRoutes(usedRoutes, gcTimestamp) {
        // Sort the given routes before updating. This will ensure that the routes compared in hasUsedStateChanged()
        // are in the same order.
        this.usedRoutes = usedRoutes.sort();
        // If GC is not disabled and we are tracking a summary, update the work-in-progress used routes so that it can
        // be tracked for this summary.
        if (!this.gcDisabled && this.isTrackingInProgress()) {
            this.wipSerializedUsedRoutes = JSON.stringify(this.usedRoutes);
        }
        if (this.isReferenced()) {
            this.unreferencedTimestampMs = undefined;
            return;
        }
        // If this node just became unreferenced, update its unreferencedTimestampMs.
        if (this.unreferencedTimestampMs === undefined) {
            this.unreferencedTimestampMs = gcTimestamp;
        }
    }
    /**
     * Override the hasChanged method. If this node data or its used state changed, the node is considered changed.
     */
    hasChanged() {
        return this.hasDataChanged() || this.hasUsedStateChanged();
    }
    /**
     * This tells whether the data in this node has changed or not.
     */
    hasDataChanged() {
        return super.hasChanged();
    }
    /**
     * This tells whether the used state of this node has changed since last successful summary. If the used routes
     * of this node changed, its used state is considered changed. Basically, if this node or any of its child nodes
     * was previously used and became unused (or vice versa), its used state has changed.
     */
    hasUsedStateChanged() {
        // If GC is disabled, we are not tracking used state, return false.
        if (this.gcDisabled) {
            return false;
        }
        return this.referenceUsedRoutes === undefined ||
            JSON.stringify(this.usedRoutes) !== JSON.stringify(this.referenceUsedRoutes);
    }
}
exports.SummarizerNodeWithGC = SummarizerNodeWithGC;
/**
 * Creates a root summarizer node with GC functionality built-in.
 * @param logger - Logger to use within SummarizerNode
 * @param summarizeInternalFn - Function to generate summary
 * @param changeSequenceNumber - Sequence number of latest change to new node/subtree
 * @param referenceSequenceNumber - Reference sequence number of last acked summary,
 * or undefined if not loaded from summary
 * @param config - Configure behavior of summarizer node
 * @param getGCDataFn - Function to get the GC data of this node
 * @param baseGCDetailsP - Function to get the initial GC details of this node
 */
const createRootSummarizerNodeWithGC = (logger, summarizeInternalFn, changeSequenceNumber, referenceSequenceNumber, config = {}, getGCDataFn, getBaseGCDetailsFn) => new SummarizerNodeWithGC(logger, summarizeInternalFn, config, changeSequenceNumber, referenceSequenceNumber === undefined ? undefined : summarizerNodeUtils_1.SummaryNode.createForRoot(referenceSequenceNumber), undefined /* initialSummary */, undefined /* wipSummaryLogger */, getGCDataFn, getBaseGCDetailsFn);
exports.createRootSummarizerNodeWithGC = createRootSummarizerNodeWithGC;

},{"./summarizerNode":219,"./summarizerNodeUtils":220,"@fluidframework/common-utils":29,"@fluidframework/garbage-collector":133,"@fluidframework/runtime-definitions":208}],222:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryContext = exports.convertSummaryTreeToITree = exports.convertSnapshotTreeToSummaryTree = exports.convertToSummaryTree = exports.convertToSummaryTreeWithStats = exports.SummaryTreeBuilder = exports.addSummarizeResultToSummary = exports.addTreeToSummary = exports.addBlobToSummary = exports.calculateStats = exports.getBlobSize = exports.utf8ByteLength = exports.mergeStats = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Combines summary stats by adding their totals together.
 * Returns empty stats if called without args.
 * @param stats - stats to merge
 */
function mergeStats(...stats) {
    const results = {
        treeNodeCount: 0,
        blobNodeCount: 0,
        handleNodeCount: 0,
        totalBlobSize: 0,
        unreferencedBlobSize: 0,
    };
    for (const stat of stats) {
        results.treeNodeCount += stat.treeNodeCount;
        results.blobNodeCount += stat.blobNodeCount;
        results.handleNodeCount += stat.handleNodeCount;
        results.totalBlobSize += stat.totalBlobSize;
        results.unreferencedBlobSize += stat.unreferencedBlobSize;
    }
    return results;
}
exports.mergeStats = mergeStats;
function utf8ByteLength(str) {
    // returns the byte length of an utf8 string
    let s = str.length;
    for (let i = str.length - 1; i >= 0; i--) {
        const code = str.charCodeAt(i);
        if (code > 0x7f && code <= 0x7ff) {
            s++;
        }
        else if (code > 0x7ff && code <= 0xffff) {
            s += 2;
        }
        if (code >= 0xDC00 && code <= 0xDFFF) {
            i--; // trail surrogate
        }
    }
    return s;
}
exports.utf8ByteLength = utf8ByteLength;
function getBlobSize(content) {
    if (typeof content === "string") {
        return utf8ByteLength(content);
    }
    else {
        return content.byteLength;
    }
}
exports.getBlobSize = getBlobSize;
function calculateStatsCore(summaryObject, stats) {
    switch (summaryObject.type) {
        case protocol_definitions_1.SummaryType.Tree: {
            stats.treeNodeCount++;
            for (const value of Object.values(summaryObject.tree)) {
                calculateStatsCore(value, stats);
            }
            return;
        }
        case protocol_definitions_1.SummaryType.Handle: {
            stats.handleNodeCount++;
            return;
        }
        case protocol_definitions_1.SummaryType.Blob: {
            stats.blobNodeCount++;
            stats.totalBlobSize += getBlobSize(summaryObject.content);
            return;
        }
        default: return;
    }
}
function calculateStats(summary) {
    const stats = mergeStats();
    calculateStatsCore(summary, stats);
    return stats;
}
exports.calculateStats = calculateStats;
function addBlobToSummary(summary, key, content) {
    const blob = {
        type: protocol_definitions_1.SummaryType.Blob,
        content,
    };
    summary.summary.tree[key] = blob;
    summary.stats.blobNodeCount++;
    summary.stats.totalBlobSize += getBlobSize(content);
}
exports.addBlobToSummary = addBlobToSummary;
function addTreeToSummary(summary, key, summarizeResult) {
    summary.summary.tree[key] = summarizeResult.summary;
    summary.stats = mergeStats(summary.stats, summarizeResult.stats);
}
exports.addTreeToSummary = addTreeToSummary;
function addSummarizeResultToSummary(summary, key, summarizeResult) {
    summary.summary.tree[key] = summarizeResult.summary;
    summary.stats = mergeStats(summary.stats, summarizeResult.stats);
}
exports.addSummarizeResultToSummary = addSummarizeResultToSummary;
class SummaryTreeBuilder {
    constructor() {
        this.attachmentCounter = 0;
        this.summaryTree = {};
        this.summaryStats = mergeStats();
        this.summaryStats.treeNodeCount++;
    }
    get summary() {
        return {
            type: protocol_definitions_1.SummaryType.Tree,
            tree: Object.assign({}, this.summaryTree),
        };
    }
    get stats() {
        return Object.assign({}, this.summaryStats);
    }
    addBlob(key, content) {
        // Prevent cloning by directly referencing underlying private properties
        addBlobToSummary({
            summary: {
                type: protocol_definitions_1.SummaryType.Tree,
                tree: this.summaryTree,
            },
            stats: this.summaryStats,
        }, key, content);
    }
    addHandle(key, handleType, handle) {
        this.summaryTree[key] = {
            type: protocol_definitions_1.SummaryType.Handle,
            handleType,
            handle,
        };
        this.summaryStats.handleNodeCount++;
    }
    addWithStats(key, summarizeResult) {
        this.summaryTree[key] = summarizeResult.summary;
        this.summaryStats = mergeStats(this.summaryStats, summarizeResult.stats);
    }
    addAttachment(id) {
        this.summaryTree[this.attachmentCounter++] = { id, type: protocol_definitions_1.SummaryType.Attachment };
    }
    getSummaryTree() {
        return { summary: this.summary, stats: this.stats };
    }
}
exports.SummaryTreeBuilder = SummaryTreeBuilder;
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTreeWithStats(snapshot, fullTree = false) {
    const builder = new SummaryTreeBuilder();
    for (const entry of snapshot.entries) {
        switch (entry.type) {
            case protocol_definitions_1.TreeEntry.Blob: {
                const blob = entry.value;
                let content;
                if (blob.encoding === "base64") {
                    content = common_utils_1.IsoBuffer.from(blob.contents, "base64");
                }
                else {
                    content = blob.contents;
                }
                builder.addBlob(entry.path, content);
                break;
            }
            case protocol_definitions_1.TreeEntry.Tree: {
                const subtree = convertToSummaryTree(entry.value, fullTree);
                builder.addWithStats(entry.path, subtree);
                break;
            }
            case protocol_definitions_1.TreeEntry.Attachment: {
                const id = entry.value.id;
                builder.addAttachment(id);
                break;
            }
            default:
                throw new Error("Unexpected TreeEntry type");
        }
    }
    const summaryTree = builder.getSummaryTree();
    summaryTree.summary.unreferenced = snapshot.unreferenced;
    return summaryTree;
}
exports.convertToSummaryTreeWithStats = convertToSummaryTreeWithStats;
/**
 * Converts snapshot ITree to ISummaryTree format and tracks stats.
 * @param snapshot - snapshot in ITree format
 * @param fullTree - true to never use handles, even if id is specified
 */
function convertToSummaryTree(snapshot, fullTree = false) {
    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
    if (snapshot.id && !fullTree) {
        const stats = mergeStats();
        stats.handleNodeCount++;
        return {
            summary: {
                handle: snapshot.id,
                handleType: protocol_definitions_1.SummaryType.Tree,
                type: protocol_definitions_1.SummaryType.Handle,
            },
            stats,
        };
    }
    else {
        return convertToSummaryTreeWithStats(snapshot, fullTree);
    }
}
exports.convertToSummaryTree = convertToSummaryTree;
/**
 * Converts ISnapshotTree to ISummaryTree format and tracks stats. This snapshot tree was
 * was taken by serialize api in detached container.
 * @param snapshot - snapshot in ISnapshotTree format
 */
function convertSnapshotTreeToSummaryTree(snapshot) {
    const builder = new SummaryTreeBuilder();
    for (const [path, id] of Object.entries(snapshot.blobs)) {
        let decoded;
        if (snapshot.blobsContents !== undefined) {
            const content = snapshot.blobsContents[id];
            if (content !== undefined) {
                decoded = (0, common_utils_1.bufferToString)(content, "utf-8");
            }
            // 0.44 back-compat We still put contents in same blob for back-compat so need to add blob
            // only for blobPath -> blobId mapping and not for blobId -> blob value contents.
        }
        else if (snapshot.blobs[id] !== undefined) {
            decoded = (0, common_utils_1.fromBase64ToUtf8)(snapshot.blobs[id]);
        }
        if (decoded !== undefined) {
            builder.addBlob(path, decoded);
        }
    }
    for (const [key, tree] of Object.entries(snapshot.trees)) {
        const subtree = convertSnapshotTreeToSummaryTree(tree);
        builder.addWithStats(key, subtree);
    }
    const summaryTree = builder.getSummaryTree();
    summaryTree.summary.unreferenced = snapshot.unreferenced;
    return summaryTree;
}
exports.convertSnapshotTreeToSummaryTree = convertSnapshotTreeToSummaryTree;
/**
 * Converts ISummaryTree to ITree format. This is needed for back-compat while we get rid of snapshot.
 * @param summaryTree - summary tree in ISummaryTree format
 */
function convertSummaryTreeToITree(summaryTree) {
    const entries = [];
    for (const [key, value] of Object.entries(summaryTree.tree)) {
        switch (value.type) {
            case protocol_definitions_1.SummaryType.Blob: {
                let parsedContent;
                let encoding = "utf-8";
                if (typeof value.content === "string") {
                    parsedContent = value.content;
                }
                else {
                    parsedContent = (0, common_utils_1.Uint8ArrayToString)(value.content, "base64");
                    encoding = "base64";
                }
                entries.push(new protocol_base_1.BlobTreeEntry(key, parsedContent, encoding));
                break;
            }
            case protocol_definitions_1.SummaryType.Tree: {
                entries.push(new protocol_base_1.TreeTreeEntry(key, convertSummaryTreeToITree(value)));
                break;
            }
            case protocol_definitions_1.SummaryType.Attachment: {
                entries.push(new protocol_base_1.AttachmentTreeEntry(key, value.id));
                break;
            }
            case protocol_definitions_1.SummaryType.Handle: {
                throw new Error("Should not have Handle type in summary tree");
            }
            default:
                (0, common_utils_1.unreachableCase)(value, "Unexpected summary tree type");
        }
    }
    return {
        entries,
        unreferenced: summaryTree.unreferenced,
    };
}
exports.convertSummaryTreeToITree = convertSummaryTreeToITree;
class TelemetryContext {
    constructor() {
        this.telemetry = new Map();
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.set}
     */
    set(prefix, property, value) {
        this.telemetry.set(`${prefix}${property}`, value);
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.get}
     */
    get(prefix, property) {
        return this.telemetry.get(`${prefix}${property}`);
    }
    /**
     * {@inheritDoc @fluidframework/runtime-definitions#ITelemetryContext.serialize}
     */
    serialize() {
        const jsonObject = {};
        this.telemetry.forEach((value, key) => {
            jsonObject[key] = value;
        });
        return JSON.stringify(jsonObject);
    }
}
exports.TelemetryContext = TelemetryContext;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174}],223:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.seqFromTree = void 0;
/**
 * Fetches the sequence number of the snapshot tree by examining the protocol.
 * @param tree - snapshot tree to examine
 * @param readAndParseBlob - function to read blob contents from storage
 * and parse the result from JSON.
 */
async function seqFromTree(tree, readAndParseBlob) {
    const attributesHash = tree.trees[".protocol"].blobs.attributes;
    const attrib = await readAndParseBlob(attributesHash);
    return attrib.sequenceNumber;
}
exports.seqFromTree = seqFromTree;

},{}],224:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultMap = void 0;
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const common_utils_1 = require("@fluidframework/common-utils");
const localValues_1 = require("./localValues");
/**
 * A DefaultMap is a map-like distributed data structure, supporting operations on values stored by
 * string key locations.
 *
 * Creation of values is implicit on access (either via `get` or a remote op application referring to
 * a collection that wasn't previously known)
 */
class DefaultMap {
    /**
     * Create a new default map.
     * @param serializer - The serializer to serialize / parse handles
     * @param handle - The handle of the shared object using the kernel
     * @param submitMessage - A callback to submit a message through the shared object
     * @param type - The value type to create at values of this map
     * @param eventEmitter - The object that will emit map events
     */
    constructor(serializer, handle, submitMessage, type, eventEmitter = new common_utils_1.TypedEventEmitter()) {
        this.serializer = serializer;
        this.handle = handle;
        this.submitMessage = submitMessage;
        this.type = type;
        this.eventEmitter = eventEmitter;
        /**
         * Mapping of op types to message handlers.
         */
        this.messageHandlers = new Map();
        /**
         * The in-memory data the map is storing.
         */
        this.data = new Map();
        this.messageHandlers = this.getMessageHandlers();
    }
    /**
     * The number of key/value pairs stored in the map.
     */
    get size() {
        return this.data.size;
    }
    /**
     * Get an iterator over the keys in this map.
     * @returns The iterator
     */
    keys() {
        return this.data.keys();
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    entries() {
        const localEntriesIterator = this.data.entries();
        const iterator = {
            next() {
                const nextVal = localEntriesIterator.next();
                return nextVal.done
                    ? { value: undefined, done: true }
                    : { value: [nextVal.value[0], nextVal.value[1].value], done: false }; // Unpack the stored value
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the values in this map.
     * @returns The iterator
     */
    values() {
        const localValuesIterator = this.data.values();
        const iterator = {
            next() {
                const nextVal = localValuesIterator.next();
                return nextVal.done
                    ? { value: undefined, done: true }
                    : { value: nextVal.value.value, done: false }; // Unpack the stored value
            },
            [Symbol.iterator]() {
                return this;
            },
        };
        return iterator;
    }
    /**
     * Get an iterator over the entries in this map.
     * @returns The iterator
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * Executes the given callback on each entry in the map.
     * @param callbackFn - Callback function
     */
    forEach(callbackFn) {
        this.data.forEach((localValue, key, m) => {
            callbackFn(localValue.value, key, m);
        });
    }
    /**
     * {@inheritDoc ISharedMap.get}
     */
    get(key) {
        var _a;
        const localValue = (_a = this.data.get(key)) !== null && _a !== void 0 ? _a : this.createCore(key, true);
        return localValue.value;
    }
    /**
     * Check if a key exists in the map.
     * @param key - The key to check
     * @returns True if the key exists, false otherwise
     */
    has(key) {
        return this.data.has(key);
    }
    /**
     * Serializes the data stored in the shared map to a JSON string
     * @param serializer - The serializer to use to serialize handles in its values.
     * @returns A JSON string containing serialized map data
     */
    getSerializedStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = localValue.makeSerialized(serializer, this.handle);
        });
        return serializableMapData;
    }
    getSerializableStorage(serializer) {
        const serializableMapData = {};
        this.data.forEach((localValue, key) => {
            serializableMapData[key] = (0, localValues_1.makeSerializable)(localValue, serializer, this.handle);
        });
        return serializableMapData;
    }
    serialize(serializer) {
        return JSON.stringify(this.getSerializableStorage(serializer));
    }
    /**
     * Populate the kernel with the given map data.
     * @param data - A JSON string containing serialized map data
     */
    populateFromSerializable(json) {
        for (const [key, serializable] of Object.entries(json)) {
            // Back-compat: legacy documents may have handles to an intervalCollection map kernel.
            // These collections should be empty, and ValueTypes are no longer supported.
            if (serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain]
                || serializable.type === shared_object_base_1.ValueType[shared_object_base_1.ValueType.Shared]) {
                continue;
            }
            // Back-compat: Sequence previously arbitrarily prefixed all interval collection keys with
            // "intervalCollections/". This would burden users trying to iterate the collection and
            // access its value, as well as those trying to match a create message to its underlying
            // collection. See https://github.com/microsoft/FluidFramework/issues/10557 for more context.
            const normalizedKey = key.startsWith("intervalCollections/") ? key.substring(20) : key;
            const localValue = {
                key: normalizedKey,
                value: this.makeLocal(key, serializable),
            };
            this.data.set(localValue.key, localValue.value);
        }
    }
    populate(json) {
        this.populateFromSerializable(JSON.parse(json));
    }
    /**
     * Submit the given op if a handler is registered.
     * @param op - The operation to attempt to submit
     * @param localOpMetadata - The local metadata associated with the op. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     * @returns True if the operation was submitted, false otherwise.
     */
    tryResubmitMessage(op, localOpMetadata) {
        const type = op.type;
        const handler = this.messageHandlers.get(type);
        if (handler !== undefined) {
            handler.resubmit(op, localOpMetadata);
            return true;
        }
        return false;
    }
    tryGetStashedOpLocalMetadata(op) {
        const type = op.type;
        if (this.messageHandlers.has(type)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.messageHandlers.get(type).getStashedOpLocalMetadata(op);
        }
        throw new Error("no apply stashed op handler");
    }
    /**
     * Process the given op if a handler is registered.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     * @returns True if the operation was processed, false otherwise.
     */
    tryProcessMessage(op, local, message, localOpMetadata) {
        const handler = this.messageHandlers.get(op.type);
        if (handler !== undefined) {
            handler.process(op, local, message, localOpMetadata);
            return true;
        }
        return false;
    }
    /**
     * Initializes a default ValueType at the provided key.
     * Should be used when a map operation incurs creation.
     * @param key - The key being initialized
     * @param local - Whether the message originated from the local client
     */
    createCore(key, local) {
        const localValue = new localValues_1.ValueTypeLocalValue(this.type.factory.load(this.makeMapValueOpEmitter(key), undefined), this.type);
        const previousValue = this.data.get(key);
        this.data.set(key, localValue);
        const event = { key, previousValue };
        this.eventEmitter.emit("create", event, local, this.eventEmitter);
        return localValue;
    }
    /**
     * The remote ISerializableValue we're receiving (either as a result of a load or an incoming set op) will
     * have the information we need to create a real object, but will not be the real object yet.  For example,
     * we might know it's a map and the map's ID but not have the actual map or its data yet.  makeLocal's
     * job is to convert that information into a real object for local usage.
     * @param key - The key that the caller intends to store the local value into (used for ops later).  But
     * doesn't actually store the local value into that key.  So better not lie!
     * @param serializable - The remote information that we can convert into a real object
     * @returns The local value that was produced
     */
    makeLocal(key, serializable) {
        (0, common_utils_1.assert)(serializable.type !== shared_object_base_1.ValueType[shared_object_base_1.ValueType.Plain] && serializable.type !== shared_object_base_1.ValueType[shared_object_base_1.ValueType.Shared], 0x2e1 /* "Support for plain value types removed." */);
        serializable.value = (0, shared_object_base_1.parseHandles)(serializable.value, this.serializer);
        const localValue = this.type.factory.load(this.makeMapValueOpEmitter(key), serializable.value);
        return new localValues_1.ValueTypeLocalValue(localValue, this.type);
    }
    /**
     * Get the message handlers for the map.
     * @returns A map of string op names to IMapMessageHandlers for those ops
     */
    getMessageHandlers() {
        const messageHandlers = new Map();
        // Ops with type "act" describe actions taken by custom value type handlers of whatever item is
        // being addressed.  These custom handlers can be retrieved from the ValueTypeLocalValue which has
        // stashed its valueType (and therefore its handlers).  We also emit a valueChanged for anyone
        // watching for manipulations of that item.
        messageHandlers.set("act", {
            process: (op, local, message, localOpMetadata) => {
                var _a;
                const localValue = (_a = this.data.get(op.key)) !== null && _a !== void 0 ? _a : this.createCore(op.key, local);
                const handler = localValue.getOpHandler(op.value.opName);
                const previousValue = localValue.value;
                const translatedValue = (0, shared_object_base_1.parseHandles)(op.value.value, this.serializer);
                handler.process(previousValue, translatedValue, local, message, localOpMetadata);
                const event = { key: op.key, previousValue };
                this.eventEmitter.emit("valueChanged", event, local, message, this.eventEmitter);
            },
            submit: (op, localOpMetadata) => {
                this.submitMessage(op, localOpMetadata);
            },
            resubmit: (op, localOpMetadata) => {
                const localValue = this.data.get(op.key);
                const handler = localValue.getOpHandler(op.value.opName);
                const { rebasedOp, rebasedLocalOpMetadata, } = handler.rebase(localValue.value, op.value, localOpMetadata);
                this.submitMessage(Object.assign(Object.assign({}, op), { value: rebasedOp }), rebasedLocalOpMetadata);
            },
            getStashedOpLocalMetadata: (op) => {
                (0, common_utils_1.assert)(false, 0x016 /* "apply stashed op not implemented for custom value type ops" */);
            },
        });
        return messageHandlers;
    }
    /**
     * Create an emitter for a value type to emit ops from the given key.
     * @alpha
     * @param key - The key of the map that the value type will be stored on
     * @returns A value op emitter for the given key
     */
    makeMapValueOpEmitter(key) {
        const emit = (opName, previousValue, params, localOpMetadata) => {
            const translatedParams = (0, shared_object_base_1.makeHandlesSerializable)(params, this.serializer, this.handle);
            const op = {
                key,
                type: "act",
                value: {
                    opName,
                    value: translatedParams,
                },
            };
            this.submitMessage(op, localOpMetadata);
            const event = { key, previousValue };
            this.eventEmitter.emit("valueChanged", event, true, null, this.eventEmitter);
        };
        return { emit };
    }
}
exports.DefaultMap = DefaultMap;

},{"./localValues":227,"@fluidframework/common-utils":29,"@fluidframework/shared-object-base":261}],225:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequenceInterval = exports.IntervalType = exports.IntervalCollectionIterator = exports.IntervalCollection = exports.Interval = void 0;
/**
 * Supports distributed data structures which are list-like.
 *
 * This package's main export is {@link SharedSequence}, a DDS for storing and simultaneously editing a sequence of
 * text.
 *
 * @remarks Note that SharedString is a sequence DDS but it has additional specialized features and behaviors for
 * working with text.
 *
 * @packageDocumentation
 */
var intervalCollection_1 = require("./intervalCollection");
Object.defineProperty(exports, "Interval", { enumerable: true, get: function () { return intervalCollection_1.Interval; } });
Object.defineProperty(exports, "IntervalCollection", { enumerable: true, get: function () { return intervalCollection_1.IntervalCollection; } });
Object.defineProperty(exports, "IntervalCollectionIterator", { enumerable: true, get: function () { return intervalCollection_1.IntervalCollectionIterator; } });
Object.defineProperty(exports, "IntervalType", { enumerable: true, get: function () { return intervalCollection_1.IntervalType; } });
Object.defineProperty(exports, "SequenceInterval", { enumerable: true, get: function () { return intervalCollection_1.SequenceInterval; } });
__exportStar(require("./sharedString"), exports);
__exportStar(require("./sequence"), exports);
__exportStar(require("./sequenceFactory"), exports);
__exportStar(require("./sequenceDeltaEvent"), exports);
__exportStar(require("./sharedSequence"), exports);
__exportStar(require("./sharedObjectSequence"), exports);
__exportStar(require("./sharedNumberSequence"), exports);
__exportStar(require("./sparsematrix"), exports);
__exportStar(require("./sharedIntervalCollection"), exports);

},{"./intervalCollection":226,"./sequence":229,"./sequenceDeltaEvent":230,"./sequenceFactory":231,"./sharedIntervalCollection":232,"./sharedNumberSequence":233,"./sharedObjectSequence":234,"./sharedSequence":235,"./sharedString":236,"./sparsematrix":237}],226:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntervalCollection = exports.IntervalCollectionIterator = exports.IntervalCollectionValueType = exports.SequenceIntervalCollectionValueType = exports.LocalIntervalCollection = exports.createIntervalIndex = exports.defaultIntervalConflictResolver = exports.SequenceInterval = exports.Interval = exports.IntervalType = void 0;
/* eslint-disable no-bitwise */
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const merge_tree_1 = require("@fluidframework/merge-tree");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const uuid_1 = require("uuid");
const reservedIntervalIdKey = "intervalId";
var IntervalType;
(function (IntervalType) {
    IntervalType[IntervalType["Simple"] = 0] = "Simple";
    IntervalType[IntervalType["Nest"] = 1] = "Nest";
    /**
     * SlideOnRemove indicates that the ends of the interval will slide if the segment
     * they reference is removed and acked.
     * See `packages\dds\merge-tree\REFERENCEPOSITIONS.md` for details
     * SlideOnRemove is the default interval behavior and does not need to be specified.
     */
    IntervalType[IntervalType["SlideOnRemove"] = 2] = "SlideOnRemove";
    /**
     * @internal
     * A temporary interval, used internally
     */
    IntervalType[IntervalType["Transient"] = 4] = "Transient";
})(IntervalType = exports.IntervalType || (exports.IntervalType = {}));
/**
 * Decompress an interval after loading a summary from JSON. The exact format
 * of this compression is unspecified and subject to change
 */
function decompressInterval(interval, label) {
    return {
        start: interval[0],
        end: interval[1],
        sequenceNumber: interval[2],
        intervalType: interval[3],
        properties: Object.assign(Object.assign({}, interval[4]), { [merge_tree_1.reservedRangeLabelsKey]: label }),
    };
}
/**
 * Compress an interval prior to serialization as JSON. The exact format of this
 * compression is unspecified and subject to change
 */
function compressInterval(interval) {
    const { start, end, sequenceNumber, intervalType, properties } = interval;
    return [
        start,
        end,
        sequenceNumber,
        intervalType,
        Object.assign(Object.assign({}, properties), { [merge_tree_1.reservedRangeLabelsKey]: undefined }),
    ];
}
class Interval {
    constructor(start, end, props) {
        this.start = start;
        this.end = end;
        this.propertyManager = new merge_tree_1.PropertiesManager();
        this.properties = {};
        if (props) {
            this.addProperties(props);
        }
    }
    getIntervalId() {
        var _a;
        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            return undefined;
        }
        return `${id}`;
    }
    getAdditionalPropertySets() {
        return this.auxProps;
    }
    addPropertySet(props) {
        if (this.auxProps === undefined) {
            this.auxProps = [];
        }
        this.auxProps.push(props);
    }
    serialize(client) {
        let seq = 0;
        if (client) {
            seq = client.getCurrentSeq();
        }
        const serializedInterval = {
            end: this.end,
            intervalType: 0,
            sequenceNumber: seq,
            start: this.start,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new Interval(this.start, this.end, this.properties);
    }
    compare(b) {
        const startResult = this.compareStart(b);
        if (startResult === 0) {
            const endResult = this.compareEnd(b);
            if (endResult === 0) {
                const thisId = this.getIntervalId();
                if (thisId) {
                    const bId = b.getIntervalId();
                    if (bId) {
                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;
                    }
                    return 0;
                }
                return 0;
            }
            else {
                return endResult;
            }
        }
        else {
            return startResult;
        }
    }
    compareStart(b) {
        return this.start - b.start;
    }
    compareEnd(b) {
        return this.end - b.end;
    }
    overlaps(b) {
        const result = (this.start <= b.end) &&
            (this.end >= b.start);
        return result;
    }
    union(b) {
        return new Interval(Math.min(this.start, b.start), Math.max(this.end, b.end), this.properties);
    }
    getProperties() {
        return this.properties;
    }
    addProperties(newProps, collaborating = false, seq, op) {
        if (newProps) {
            this.initializeProperties();
            return this.propertyManager.addProperties(this.properties, newProps, op, seq, collaborating);
        }
    }
    modify(label, start, end, op) {
        const startPos = start !== null && start !== void 0 ? start : this.start;
        const endPos = end !== null && end !== void 0 ? end : this.end;
        if (this.start === startPos && this.end === endPos) {
            // Return undefined to indicate that no change is necessary.
            return;
        }
        const newInterval = new Interval(startPos, endPos);
        if (this.properties) {
            newInterval.initializeProperties();
            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);
        }
        return newInterval;
    }
    initializeProperties() {
        if (!this.propertyManager) {
            this.propertyManager = new merge_tree_1.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0, merge_tree_1.createMap)();
        }
    }
}
exports.Interval = Interval;
class SequenceInterval {
    constructor(start, end, intervalType, props) {
        this.start = start;
        this.end = end;
        this.intervalType = intervalType;
        this.propertyManager = new merge_tree_1.PropertiesManager();
        this.properties = {};
        if (props) {
            this.addProperties(props);
        }
    }
    /**
     * @internal
     * Subscribes to position change events on this interval if there are no current listeners.
     */
    addPositionChangeListeners(beforePositionChange, afterPositionChange) {
        var _a, _b;
        var _c, _d;
        if (this.callbacks === undefined) {
            this.callbacks = {
                beforePositionChange,
                afterPositionChange,
            };
            const startCbs = (_a = (_c = this.start).callbacks) !== null && _a !== void 0 ? _a : (_c.callbacks = {});
            const endCbs = (_b = (_d = this.end).callbacks) !== null && _b !== void 0 ? _b : (_d.callbacks = {});
            startCbs.beforeSlide = endCbs.beforeSlide = beforePositionChange;
            startCbs.afterSlide = endCbs.afterSlide = afterPositionChange;
        }
    }
    /**
     * @internal
     * Removes the currently subscribed position change listeners.
     */
    removePositionChangeListeners() {
        if (this.callbacks) {
            this.callbacks = undefined;
            this.start.callbacks = undefined;
            this.end.callbacks = undefined;
        }
    }
    serialize(client) {
        const startPosition = this.start.toPosition();
        const endPosition = this.end.toPosition();
        const serializedInterval = {
            end: endPosition,
            intervalType: this.intervalType,
            sequenceNumber: client.getCurrentSeq(),
            start: startPosition,
        };
        if (this.properties) {
            serializedInterval.properties = this.properties;
        }
        return serializedInterval;
    }
    clone() {
        return new SequenceInterval(this.start, this.end, this.intervalType, this.properties);
    }
    compare(b) {
        const startResult = this.compareStart(b);
        if (startResult === 0) {
            const endResult = this.compareEnd(b);
            if (endResult === 0) {
                const thisId = this.getIntervalId();
                if (thisId) {
                    const bId = b.getIntervalId();
                    if (bId) {
                        return thisId > bId ? 1 : thisId < bId ? -1 : 0;
                    }
                    return 0;
                }
                return 0;
            }
            else {
                return endResult;
            }
        }
        else {
            return startResult;
        }
    }
    compareStart(b) {
        return this.start.compare(b.start);
    }
    compareEnd(b) {
        return this.end.compare(b.end);
    }
    overlaps(b) {
        const result = (this.start.compare(b.end) <= 0) &&
            (this.end.compare(b.start) >= 0);
        return result;
    }
    getIntervalId() {
        var _a;
        const id = (_a = this.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            return undefined;
        }
        return `${id}`;
    }
    union(b) {
        return new SequenceInterval(this.start.min(b.start), this.end.max(b.end), this.intervalType);
    }
    addProperties(newProps, collab = false, seq, op) {
        this.initializeProperties();
        return this.propertyManager.addProperties(this.properties, newProps, op, seq, collab);
    }
    overlapsPos(bstart, bend) {
        const startPos = this.start.toPosition();
        const endPos = this.start.toPosition();
        return (endPos > bstart) && (startPos < bend);
    }
    modify(label, start, end, op) {
        const getRefType = (baseType) => {
            let refType = baseType;
            if (op === undefined) {
                refType &= ~merge_tree_1.ReferenceType.SlideOnRemove;
                refType |= merge_tree_1.ReferenceType.StayOnRemove;
            }
            return refType;
        };
        let startRef = this.start;
        if (start !== undefined) {
            startRef = createPositionReference(this.start.getClient(), start, getRefType(this.start.refType), op);
            startRef.addProperties(this.start.properties);
        }
        let endRef = this.end;
        if (end !== undefined) {
            endRef = createPositionReference(this.end.getClient(), end, getRefType(this.end.refType), op);
            endRef.addProperties(this.end.properties);
        }
        startRef.pairedRef = endRef;
        endRef.pairedRef = startRef;
        const newInterval = new SequenceInterval(startRef, endRef, this.intervalType);
        if (this.properties) {
            newInterval.initializeProperties();
            this.propertyManager.copyTo(this.properties, newInterval.properties, newInterval.propertyManager);
        }
        return newInterval;
    }
    initializeProperties() {
        if (!this.propertyManager) {
            this.propertyManager = new merge_tree_1.PropertiesManager();
        }
        if (!this.properties) {
            this.properties = (0, merge_tree_1.createMap)();
        }
    }
}
exports.SequenceInterval = SequenceInterval;
function createPositionReferenceFromSegoff(client, segoff, refType, op) {
    if (segoff.segment) {
        const ref = client.createLocalReferencePosition(segoff.segment, segoff.offset, refType, undefined);
        return ref;
    }
    else {
        if (!op && !(0, merge_tree_1.refTypeIncludesFlag)(refType, merge_tree_1.ReferenceType.Transient)) {
            throw new container_utils_1.UsageError("Non-transient references need segment");
        }
        return new merge_tree_1.LocalReference(client, undefined, 0, refType);
    }
}
function createPositionReference(client, pos, refType, op) {
    let segoff;
    if (op) {
        (0, common_utils_1.assert)((refType & merge_tree_1.ReferenceType.SlideOnRemove) !== 0, 0x2f5 /* op create references must be SlideOnRemove */);
        segoff = client.getContainingSegment(pos, op);
        segoff = client.getSlideToSegment(segoff);
    }
    else {
        (0, common_utils_1.assert)((refType & merge_tree_1.ReferenceType.SlideOnRemove) === 0, 0x2f6 /* SlideOnRemove references must be op created */);
        segoff = client.getContainingSegment(pos);
    }
    return createPositionReferenceFromSegoff(client, segoff, refType, op);
}
function createSequenceInterval(label, start, end, client, intervalType, op) {
    let beginRefType = merge_tree_1.ReferenceType.RangeBegin;
    let endRefType = merge_tree_1.ReferenceType.RangeEnd;
    if (intervalType === IntervalType.Transient) {
        beginRefType = merge_tree_1.ReferenceType.Transient;
        endRefType = merge_tree_1.ReferenceType.Transient;
    }
    else {
        if (intervalType === IntervalType.Nest) {
            beginRefType = merge_tree_1.ReferenceType.NestBegin;
            endRefType = merge_tree_1.ReferenceType.NestEnd;
        }
        // All non-transient interval references must eventually be SlideOnRemove
        // To ensure eventual consistency, they must start as StayOnRemove when
        // pending (created locally and creation op is not acked)
        if (op) {
            beginRefType |= merge_tree_1.ReferenceType.SlideOnRemove;
            endRefType |= merge_tree_1.ReferenceType.SlideOnRemove;
        }
        else {
            beginRefType |= merge_tree_1.ReferenceType.StayOnRemove;
            endRefType |= merge_tree_1.ReferenceType.StayOnRemove;
        }
    }
    const startLref = createPositionReference(client, start, beginRefType, op);
    const endLref = createPositionReference(client, end, endRefType, op);
    startLref.pairedRef = endLref;
    endLref.pairedRef = startLref;
    const rangeProp = {
        [merge_tree_1.reservedRangeLabelsKey]: [label],
    };
    startLref.addProperties(rangeProp);
    endLref.addProperties(rangeProp);
    const ival = new SequenceInterval(startLref, endLref, intervalType, rangeProp);
    return ival;
}
function defaultIntervalConflictResolver(a, b) {
    a.addPropertySet(b.properties);
    return a;
}
exports.defaultIntervalConflictResolver = defaultIntervalConflictResolver;
function createIntervalIndex(conflict) {
    const helpers = {
        compareEnds: compareIntervalEnds,
        create: createInterval,
    };
    const lc = new LocalIntervalCollection(undefined, "", helpers);
    if (conflict) {
        lc.addConflictResolver(conflict);
    }
    else {
        lc.addConflictResolver(defaultIntervalConflictResolver);
    }
    return lc;
}
exports.createIntervalIndex = createIntervalIndex;
class LocalIntervalCollection {
    constructor(client, label, helpers, 
    /** Callback invoked each time one of the endpoints of an interval slides. */
    onPositionChange) {
        this.client = client;
        this.label = label;
        this.helpers = helpers;
        this.onPositionChange = onPositionChange;
        this.intervalTree = new merge_tree_1.IntervalTree();
        this.intervalIdMap = new Map();
        // eslint-disable-next-line @typescript-eslint/unbound-method
        this.endIntervalTree = new merge_tree_1.RedBlackTree(helpers.compareEnds);
    }
    addConflictResolver(conflictResolver) {
        this.conflictResolver = conflictResolver;
        this.endConflictResolver =
            (key, currentKey) => {
                const ival = conflictResolver(key, currentKey);
                return {
                    data: ival,
                    key: ival,
                };
            };
    }
    map(fn) {
        this.intervalTree.map(fn);
    }
    createLegacyId(start, end) {
        // Create a non-unique ID based on start and end to be used on intervals that come from legacy clients
        // without ID's.
        return `${LocalIntervalCollection.legacyIdPrefix}${start}-${end}`;
    }
    /**
     * Validates that a serialized interval has the ID property. Creates an ID
     * if one does not already exist
     *
     * @param serializedInterval - The interval to be checked
     * @returns The interval's existing or newly created id
     */
    ensureSerializedId(serializedInterval) {
        var _a;
        let id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (id === undefined) {
            // An interval came over the wire without an ID, so create a non-unique one based on start/end.
            // This will allow all clients to refer to this interval consistently.
            id = this.createLegacyId(serializedInterval.start, serializedInterval.end);
            const newProps = {
                [reservedIntervalIdKey]: id,
            };
            serializedInterval.properties = (0, merge_tree_1.addProperties)(serializedInterval.properties, newProps);
        }
        // Make the ID immutable for safety's sake.
        Object.defineProperty(serializedInterval.properties, reservedIntervalIdKey, {
            configurable: false,
            enumerable: true,
            writable: false,
        });
        return id;
    }
    mapUntil(fn) {
        this.intervalTree.mapUntil(fn);
    }
    gatherIterationResults(results, iteratesForward, start, end) {
        if (this.intervalTree.intervals.isEmpty()) {
            return;
        }
        if (start === undefined && end === undefined) {
            // No start/end provided. Gather the whole tree in the specified order.
            if (iteratesForward) {
                this.intervalTree.map((interval) => {
                    results.push(interval);
                });
            }
            else {
                this.intervalTree.mapBackward((interval) => {
                    results.push(interval);
                });
            }
        }
        else {
            const transientInterval = this.helpers.create("transient", start, end, this.client, IntervalType.Transient);
            if (start === undefined) {
                // Only end position provided. Since the tree is not sorted by end position,
                // walk the whole tree in the specified order, gathering intervals that match the end.
                if (iteratesForward) {
                    this.intervalTree.map((interval) => {
                        if (transientInterval.compareEnd(interval) === 0) {
                            results.push(interval);
                        }
                    });
                }
                else {
                    this.intervalTree.mapBackward((interval) => {
                        if (transientInterval.compareEnd(interval) === 0) {
                            results.push(interval);
                        }
                    });
                }
            }
            else {
                // Start and (possibly) end provided. Walk the subtrees that may contain
                // this start position.
                const compareFn = end === undefined ?
                    (node) => {
                        return transientInterval.compareStart(node.key);
                    } :
                    (node) => {
                        return transientInterval.compare(node.key);
                    };
                const continueLeftFn = (cmpResult) => cmpResult <= 0;
                const continueRightFn = (cmpResult) => cmpResult >= 0;
                const actionFn = (node) => {
                    results.push(node.key);
                };
                if (iteratesForward) {
                    this.intervalTree.intervals.walkExactMatchesForward(compareFn, actionFn, continueLeftFn, continueRightFn);
                }
                else {
                    this.intervalTree.intervals.walkExactMatchesBackward(compareFn, actionFn, continueLeftFn, continueRightFn);
                }
            }
        }
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (endPosition < startPosition || this.intervalTree.intervals.isEmpty()) {
            return [];
        }
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, IntervalType.Transient);
        const overlappingIntervalNodes = this.intervalTree.match(transientInterval);
        return overlappingIntervalNodes.map((node) => node.key);
    }
    previousInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, IntervalType.Transient);
        const rbNode = this.endIntervalTree.floor(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    nextInterval(pos) {
        const transientInterval = this.helpers.create("transient", pos, pos, this.client, IntervalType.Transient);
        const rbNode = this.endIntervalTree.ceil(transientInterval);
        if (rbNode) {
            return rbNode.data;
        }
    }
    removeInterval(startPosition, endPosition) {
        const transientInterval = this.helpers.create("transient", startPosition, endPosition, this.client, IntervalType.Transient);
        this.intervalTree.remove(transientInterval);
        this.endIntervalTree.remove(transientInterval);
        return transientInterval;
    }
    removeIntervalFromIndex(interval) {
        this.intervalTree.removeExisting(interval);
        this.endIntervalTree.remove(interval);
        const id = interval.getIntervalId();
        (0, common_utils_1.assert)(id !== undefined, 0x311 /* expected id to exist on interval */);
        this.intervalIdMap.delete(id);
    }
    removeExistingInterval(interval) {
        this.removeIntervalFromIndex(interval);
        this.removeIntervalListeners(interval);
    }
    createInterval(start, end, intervalType, op) {
        return this.helpers.create(this.label, start, end, this.client, intervalType, op);
    }
    addInterval(start, end, intervalType, props, op) {
        const interval = this.createInterval(start, end, intervalType, op);
        if (interval) {
            if (!interval.properties) {
                interval.properties = (0, merge_tree_1.createMap)();
            }
            if (props) {
                interval.addProperties(props);
            }
            if (interval.properties[reservedIntervalIdKey] === undefined) {
                // Create a new ID.
                interval.properties[reservedIntervalIdKey] = (0, uuid_1.v4)();
            }
            this.add(interval);
        }
        return interval;
    }
    addIntervalToIndex(interval) {
        const id = interval.getIntervalId();
        (0, common_utils_1.assert)(id !== undefined, 0x2c0 /* "ID must be created before adding interval to collection" */);
        // Make the ID immutable.
        Object.defineProperty(interval.properties, reservedIntervalIdKey, {
            configurable: false,
            enumerable: true,
            writable: false,
        });
        this.intervalTree.put(interval, this.conflictResolver);
        this.endIntervalTree.put(interval, interval, this.endConflictResolver);
        this.intervalIdMap.set(id, interval);
    }
    add(interval) {
        this.addIntervalToIndex(interval);
        this.addIntervalListeners(interval);
    }
    getIntervalById(id) {
        return this.intervalIdMap.get(id);
    }
    changeInterval(interval, start, end, op) {
        const newInterval = interval.modify(this.label, start, end, op);
        if (newInterval) {
            this.removeExistingInterval(interval);
            this.add(newInterval);
        }
        return newInterval;
    }
    serialize() {
        const client = this.client;
        const intervals = this.intervalTree.intervals.keys();
        return {
            label: this.label,
            intervals: intervals.map((interval) => compressInterval(interval.serialize(client))),
            version: 2,
        };
    }
    addIntervalListeners(interval) {
        if (interval instanceof SequenceInterval) {
            interval.addPositionChangeListeners(() => this.removeIntervalFromIndex(interval), () => {
                var _a;
                this.addIntervalToIndex(interval);
                (_a = this.onPositionChange) === null || _a === void 0 ? void 0 : _a.call(this, interval);
            });
        }
    }
    removeIntervalListeners(interval) {
        if (interval instanceof SequenceInterval) {
            interval.removePositionChangeListeners();
        }
    }
}
exports.LocalIntervalCollection = LocalIntervalCollection;
LocalIntervalCollection.legacyIdPrefix = "legacy";
const compareSequenceIntervalEnds = (a, b) => a.end.compare(b.end);
class SequenceIntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareSequenceIntervalEnds,
            create: createSequenceInterval,
        };
        return new IntervalCollection(helpers, true, emitter, raw);
    }
    store(value) {
        return value.serializeInternal();
    }
}
class SequenceIntervalCollectionValueType {
    get name() {
        return SequenceIntervalCollectionValueType.Name;
    }
    get factory() {
        return SequenceIntervalCollectionValueType._factory;
    }
    get ops() {
        return SequenceIntervalCollectionValueType._ops;
    }
}
exports.SequenceIntervalCollectionValueType = SequenceIntervalCollectionValueType;
SequenceIntervalCollectionValueType.Name = "sharedStringIntervalCollection";
SequenceIntervalCollectionValueType._factory = new SequenceIntervalCollectionFactory();
SequenceIntervalCollectionValueType._ops = makeOpsMap();
const compareIntervalEnds = (a, b) => a.end - b.end;
function createInterval(label, start, end, client) {
    const rangeProp = {};
    if (label && label.length > 0) {
        rangeProp[merge_tree_1.reservedRangeLabelsKey] = [label];
    }
    return new Interval(start, end, rangeProp);
}
class IntervalCollectionFactory {
    load(emitter, raw = []) {
        const helpers = {
            compareEnds: compareIntervalEnds,
            create: createInterval,
        };
        const collection = new IntervalCollection(helpers, false, emitter, raw);
        collection.attachGraph(undefined, "");
        return collection;
    }
    store(value) {
        return value.serializeInternal();
    }
}
class IntervalCollectionValueType {
    get name() {
        return IntervalCollectionValueType.Name;
    }
    get factory() {
        return IntervalCollectionValueType._factory;
    }
    get ops() {
        return IntervalCollectionValueType._ops;
    }
}
exports.IntervalCollectionValueType = IntervalCollectionValueType;
IntervalCollectionValueType.Name = "sharedIntervalCollection";
IntervalCollectionValueType._factory = new IntervalCollectionFactory();
IntervalCollectionValueType._ops = makeOpsMap();
function makeOpsMap() {
    const rebase = (collection, op, localOpMetadata) => {
        const { localSeq } = localOpMetadata;
        const rebasedValue = collection.rebaseLocalInterval(op.opName, op.value, localSeq);
        const rebasedOp = Object.assign(Object.assign({}, op), { value: rebasedValue });
        return { rebasedOp, rebasedLocalOpMetadata: localOpMetadata };
    };
    return new Map([[
            "add",
            {
                process: (collection, params, local, op) => {
                    collection.ackAdd(params, local, op);
                },
                rebase,
            },
        ],
        [
            "delete",
            {
                process: (collection, params, local, op) => {
                    collection.ackDelete(params, local, op);
                },
                rebase: (collection, op, localOpMetadata) => {
                    // Deletion of intervals is based on id, so requires no rebasing.
                    return { rebasedOp: op, rebasedLocalOpMetadata: localOpMetadata };
                },
            },
        ],
        [
            "change",
            {
                process: (collection, params, local, op) => {
                    collection.ackChange(params, local, op);
                },
                rebase,
            },
        ]]);
}
class IntervalCollectionIterator {
    constructor(collection, iteratesForward = true, start, end) {
        this.results = [];
        this.index = 0;
        collection.gatherIterationResults(this.results, iteratesForward, start, end);
    }
    next() {
        let _value;
        let _done = true;
        if (this.index < this.results.length) {
            _value = this.results[this.index++];
            _done = false;
        }
        return {
            value: _value,
            done: _done,
        };
    }
}
exports.IntervalCollectionIterator = IntervalCollectionIterator;
class IntervalCollection extends common_utils_1.TypedEventEmitter {
    /** @internal */
    constructor(helpers, requiresClient, emitter, serializedIntervals) {
        super();
        this.helpers = helpers;
        this.requiresClient = requiresClient;
        this.emitter = emitter;
        this.pendingChangesStart = new Map();
        this.pendingChangesEnd = new Map();
        if (Array.isArray(serializedIntervals)) {
            this.savedSerializedIntervals = serializedIntervals;
        }
        else {
            this.savedSerializedIntervals =
                serializedIntervals.intervals.map((i) => decompressInterval(i, serializedIntervals.label));
        }
    }
    get attached() {
        return !!this.localCollection;
    }
    attachGraph(client, label) {
        if (this.attached) {
            throw new telemetry_utils_1.LoggingError("Only supports one Sequence attach");
        }
        if ((client === undefined) && (this.requiresClient)) {
            throw new telemetry_utils_1.LoggingError("Client required for this collection");
        }
        // Instantiate the local interval collection based on the saved intervals
        this.client = client;
        this.localCollection = new LocalIntervalCollection(client, label, this.helpers, (interval) => this.emit("changeInterval", interval, true, undefined));
        if (this.savedSerializedIntervals) {
            for (const serializedInterval of this.savedSerializedIntervals) {
                this.localCollection.ensureSerializedId(serializedInterval);
                this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties);
            }
        }
        this.savedSerializedIntervals = undefined;
    }
    /**
     * Gets the next local sequence number, modifying this client's collab window in doing so.
     */
    getNextLocalSeq() {
        return ++this.client.getCollabWindow().localSeq;
    }
    getIntervalById(id) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attach must be called before accessing intervals");
        }
        return this.localCollection.getIntervalById(id);
    }
    /**
     * Create a new interval and add it to the collection
     * @param start - interval start position
     * @param end - interval end position
     * @param intervalType - type of the interval. All intervals are SlideOnRemove. Intervals may not be Transient.
     * @param props - properties of the interval
     * @returns - the created interval
     */
    add(start, end, intervalType, props) {
        var _a, _b;
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attach must be called prior to adding intervals");
        }
        if (intervalType & IntervalType.Transient) {
            throw new telemetry_utils_1.LoggingError("Can not add transient intervals");
        }
        const interval = this.localCollection.addInterval(start, end, intervalType, props);
        if (interval) {
            const serializedInterval = {
                end,
                intervalType,
                properties: interval.properties,
                sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,
                start,
            };
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            this.emitter.emit("add", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
        }
        this.emit("addInterval", interval, true, undefined);
        return interval;
    }
    deleteExistingInterval(interval, local, op) {
        // The given interval is known to exist in the collection.
        this.localCollection.removeExistingInterval(interval);
        if (interval) {
            // Local ops get submitted to the server. Remote ops have the deserializer run.
            if (local) {
                this.emitter.emit("delete", undefined, interval.serialize(this.client), { localSeq: this.getNextLocalSeq() });
            }
            else {
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
            }
        }
        this.emit("deleteInterval", interval, local, op);
    }
    removeIntervalById(id) {
        const interval = this.localCollection.getIntervalById(id);
        if (interval) {
            this.deleteExistingInterval(interval, true, undefined);
        }
        return interval;
    }
    changeProperties(id, props) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("Attach must be called before accessing intervals");
        }
        if (typeof (id) !== "string") {
            throw new telemetry_utils_1.LoggingError("Change API requires an ID that is a string");
        }
        if (!props) {
            throw new telemetry_utils_1.LoggingError("changeProperties should be called with a property set");
        }
        const interval = this.getIntervalById(id);
        if (interval) {
            // Pass Unassigned as the sequence number to indicate that this is a local op that is waiting for an ack.
            const deltaProps = interval.addProperties(props, true, merge_tree_1.UnassignedSequenceNumber);
            const serializedInterval = interval.serialize(this.client);
            // Emit a change op that will only change properties. Add the ID to
            // the property bag provided by the caller.
            serializedInterval.start = undefined;
            serializedInterval.end = undefined;
            serializedInterval.properties = props;
            serializedInterval.properties[reservedIntervalIdKey] = interval.getIntervalId();
            this.emitter.emit("change", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
            this.emit("propertyChanged", interval, deltaProps);
        }
        this.emit("changeInterval", interval, true, undefined);
    }
    change(id, start, end) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("Attach must be called before accessing intervals");
        }
        // Force id to be a string.
        if (typeof (id) !== "string") {
            throw new telemetry_utils_1.LoggingError("Change API requires an ID that is a string");
        }
        const interval = this.getIntervalById(id);
        if (interval) {
            const newInterval = this.localCollection.changeInterval(interval, start, end);
            const serializedInterval = interval.serialize(this.client);
            serializedInterval.start = start;
            serializedInterval.end = end;
            // Emit a property bag containing only the ID, as we don't intend for this op to change any properties.
            serializedInterval.properties =
                {
                    [reservedIntervalIdKey]: interval.getIntervalId(),
                };
            this.emitter.emit("change", undefined, serializedInterval, { localSeq: this.getNextLocalSeq() });
            this.addPendingChange(id, serializedInterval);
            this.emit("changeInterval", newInterval, true, undefined);
            return newInterval;
        }
        // No interval to change
        return undefined;
    }
    addPendingChange(id, serializedInterval) {
        if (serializedInterval.start !== undefined) {
            this.addPendingChangeHelper(id, this.pendingChangesStart, serializedInterval);
        }
        if (serializedInterval.end !== undefined) {
            this.addPendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);
        }
    }
    addPendingChangeHelper(id, pendingChanges, serializedInterval) {
        let entries = pendingChanges.get(id);
        if (!entries) {
            entries = [];
            pendingChanges.set(id, entries);
        }
        entries.push(serializedInterval);
    }
    removePendingChange(serializedInterval) {
        var _a;
        // Change ops always have an ID.
        const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
        if (serializedInterval.start !== undefined) {
            this.removePendingChangeHelper(id, this.pendingChangesStart, serializedInterval);
        }
        if (serializedInterval.end !== undefined) {
            this.removePendingChangeHelper(id, this.pendingChangesEnd, serializedInterval);
        }
    }
    removePendingChangeHelper(id, pendingChanges, serializedInterval) {
        const entries = pendingChanges.get(id);
        if (entries) {
            const pendingChange = entries.shift();
            if (entries.length === 0) {
                pendingChanges.delete(id);
            }
            if ((pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.start) !== serializedInterval.start ||
                (pendingChange === null || pendingChange === void 0 ? void 0 : pendingChange.end) !== serializedInterval.end) {
                throw new telemetry_utils_1.LoggingError("Mismatch in pending changes");
            }
        }
    }
    hasPendingChangeStart(id) {
        const entries = this.pendingChangesStart.get(id);
        return entries && entries.length !== 0;
    }
    hasPendingChangeEnd(id) {
        const entries = this.pendingChangesEnd.get(id);
        return entries && entries.length !== 0;
    }
    /** @deprecated - use ackChange */
    changeInterval(serializedInterval, local, op) {
        return this.ackChange(serializedInterval, local, op);
    }
    /** @internal */
    ackChange(serializedInterval, local, op) {
        var _a, _b, _c, _d;
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("Attach must be called before accessing intervals");
        }
        let interval;
        if (local) {
            // This is an ack from the server. Remove the pending change.
            this.removePendingChange(serializedInterval);
            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
            interval = this.getIntervalById(id);
            if (interval) {
                // Let the propertyManager prune its pending change-properties set.
                (_b = interval.propertyManager) === null || _b === void 0 ? void 0 : _b.ackPendingProperties({
                    type: merge_tree_1.MergeTreeDeltaType.ANNOTATE,
                    props: (_c = serializedInterval.properties) !== null && _c !== void 0 ? _c : {},
                });
                this.ackInterval(interval, op);
            }
        }
        else {
            // If there are pending changes with this ID, don't apply the remote start/end change, as the local ack
            // should be the winning change.
            // Note that the ID is in the property bag only to allow us to find the interval.
            // This API cannot change the ID, and writing to the ID property will result in an exception. So we
            // strip it out of the properties here.
            const _e = serializedInterval.properties, _f = reservedIntervalIdKey, id = _e[_f], newProps = __rest(_e, [typeof _f === "symbol" ? _f : _f + ""]);
            interval = this.getIntervalById(id);
            if (interval) {
                let start;
                let end;
                // Track pending start/end independently of one another.
                if (!this.hasPendingChangeStart(id)) {
                    start = serializedInterval.start;
                }
                if (!this.hasPendingChangeEnd(id)) {
                    end = serializedInterval.end;
                }
                if (start !== undefined || end !== undefined) {
                    // If changeInterval gives us a new interval, work with that one. Otherwise keep working with
                    // the one we originally found in the tree.
                    interval = (_d = this.localCollection.changeInterval(interval, start, end, op)) !== null && _d !== void 0 ? _d : interval;
                }
                const deltaProps = interval.addProperties(newProps, true, op.sequenceNumber);
                if (this.onDeserialize) {
                    this.onDeserialize(interval);
                }
                this.emit("propertyChanged", interval, deltaProps);
            }
        }
        if (interval) {
            this.emit("changeInterval", interval, local, op);
        }
    }
    addConflictResolver(conflictResolver) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        this.localCollection.addConflictResolver(conflictResolver);
    }
    attachDeserializer(onDeserialize) {
        // If no deserializer is specified can skip all processing work
        if (!onDeserialize) {
            return;
        }
        // Start by storing the callbacks so that any subsequent modifications make use of them
        this.onDeserialize = onDeserialize;
        // Trigger the async prepare work across all values in the collection
        this.localCollection.map((interval) => {
            onDeserialize(interval);
        });
    }
    /** @internal */
    rebaseLocalInterval(opName, serializedInterval, localSeq) {
        var _a, _b;
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        const { start, end, intervalType, properties, sequenceNumber } = serializedInterval;
        const startRebased = start === undefined ? undefined :
            this.client.rebasePosition(start, sequenceNumber, localSeq);
        const endRebased = end === undefined ? undefined :
            this.client.rebasePosition(end, sequenceNumber, localSeq);
        const intervalId = properties === null || properties === void 0 ? void 0 : properties[reservedIntervalIdKey];
        const rebased = {
            start: startRebased,
            end: endRebased,
            intervalType,
            sequenceNumber: (_b = (_a = this.client) === null || _a === void 0 ? void 0 : _a.getCurrentSeq()) !== null && _b !== void 0 ? _b : 0,
            properties,
        };
        if (opName === "change" && (this.hasPendingChangeStart(intervalId) || this.hasPendingChangeEnd(intervalId))) {
            this.removePendingChange(serializedInterval);
            this.addPendingChange(intervalId, rebased);
        }
        return rebased;
    }
    getSlideToSegment(lref) {
        const segoff = { segment: lref.segment, offset: lref.offset };
        const newSegoff = this.client.getSlideToSegment(segoff);
        const value = (segoff.segment === newSegoff.segment && segoff.offset === newSegoff.offset) ? undefined : newSegoff;
        return value;
    }
    setSlideOnRemove(lref) {
        let refType = lref.refType;
        refType = refType & ~merge_tree_1.ReferenceType.StayOnRemove;
        refType = refType | merge_tree_1.ReferenceType.SlideOnRemove;
        lref.refType = refType;
    }
    ackInterval(interval, op) {
        // in current usage, interval is always a SequenceInterval
        if (!(interval instanceof SequenceInterval)) {
            return;
        }
        if (!(0, merge_tree_1.refTypeIncludesFlag)(interval.start, merge_tree_1.ReferenceType.StayOnRemove) &&
            !(0, merge_tree_1.refTypeIncludesFlag)(interval.end, merge_tree_1.ReferenceType.StayOnRemove)) {
            return;
        }
        const newStart = this.getSlideToSegment(interval.start);
        const newEnd = this.getSlideToSegment(interval.end);
        const id = interval.properties[reservedIntervalIdKey];
        const hasPendingStartChange = this.hasPendingChangeStart(id);
        const hasPendingEndChange = this.hasPendingChangeEnd(id);
        if (!hasPendingStartChange) {
            this.setSlideOnRemove(interval.start);
        }
        if (!hasPendingEndChange) {
            this.setSlideOnRemove(interval.end);
        }
        const needsStartUpdate = newStart !== undefined && !hasPendingStartChange;
        const needsEndUpdate = newEnd !== undefined && !hasPendingEndChange;
        if (needsStartUpdate || needsEndUpdate) {
            // In this case, where we change the start or end of an interval,
            // it is necessary to remove and re-add the interval listeners.
            // This ensures that the correct listeners are added to the ReferencePosition.
            this.localCollection.removeExistingInterval(interval);
            if (needsStartUpdate) {
                const props = interval.start.properties;
                this.client.removeLocalReferencePosition(interval.start);
                interval.start = createPositionReferenceFromSegoff(this.client, newStart, interval.start.refType, op);
                if (props) {
                    interval.start.addProperties(props);
                }
            }
            if (needsEndUpdate) {
                const props = interval.end.properties;
                this.client.removeLocalReferencePosition(interval.end);
                interval.end = createPositionReferenceFromSegoff(this.client, newEnd, interval.end.refType, op);
                if (props) {
                    interval.end.addProperties(props);
                }
            }
            this.localCollection.add(interval);
        }
    }
    /** @deprecated - use ackAdd */
    addInternal(serializedInterval, local, op) {
        return this.ackAdd(serializedInterval, local, op);
    }
    /** @internal */
    ackAdd(serializedInterval, local, op) {
        var _a;
        if (local) {
            const id = (_a = serializedInterval.properties) === null || _a === void 0 ? void 0 : _a[reservedIntervalIdKey];
            const localInterval = this.getIntervalById(id);
            if (localInterval) {
                this.ackInterval(localInterval, op);
            }
            return;
        }
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        this.localCollection.ensureSerializedId(serializedInterval);
        const interval = this.localCollection.addInterval(serializedInterval.start, serializedInterval.end, serializedInterval.intervalType, serializedInterval.properties, op);
        if (interval) {
            if (this.onDeserialize) {
                this.onDeserialize(interval);
            }
        }
        this.emit("addInterval", interval, local, op);
        return interval;
    }
    /** @deprecated - use ackDelete */
    deleteInterval(serializedInterval, local, op) {
        return this.ackDelete(serializedInterval, local, op);
    }
    /** @internal */
    ackDelete(serializedInterval, local, op) {
        if (local) {
            // Local ops were applied when the message was created and there's no "pending delete"
            // state to bookkeep: remote operation application takes into account possibility of
            // locally deleted interval whenever a lookup happens.
            return;
        }
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attach must be called prior to deleting intervals");
        }
        const id = this.localCollection.ensureSerializedId(serializedInterval);
        const interval = this.localCollection.getIntervalById(id);
        if (interval) {
            this.deleteExistingInterval(interval, local, op);
        }
    }
    /**
     * @internal
     */
    serializeInternal() {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        return this.localCollection.serialize();
    }
    [Symbol.iterator]() {
        const iterator = new IntervalCollectionIterator(this);
        return iterator;
    }
    CreateForwardIteratorWithStartPosition(startPosition) {
        const iterator = new IntervalCollectionIterator(this, true, startPosition);
        return iterator;
    }
    CreateBackwardIteratorWithStartPosition(startPosition) {
        const iterator = new IntervalCollectionIterator(this, false, startPosition);
        return iterator;
    }
    CreateForwardIteratorWithEndPosition(endPosition) {
        const iterator = new IntervalCollectionIterator(this, true, undefined, endPosition);
        return iterator;
    }
    CreateBackwardIteratorWithEndPosition(endPosition) {
        const iterator = new IntervalCollectionIterator(this, false, undefined, endPosition);
        return iterator;
    }
    gatherIterationResults(results, iteratesForward, start, end) {
        if (!this.attached) {
            return;
        }
        this.localCollection.gatherIterationResults(results, iteratesForward, start, end);
    }
    findOverlappingIntervals(startPosition, endPosition) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        return this.localCollection.findOverlappingIntervals(startPosition, endPosition);
    }
    map(fn) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        this.localCollection.map(fn);
    }
    previousInterval(pos) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        return this.localCollection.previousInterval(pos);
    }
    nextInterval(pos) {
        if (!this.attached) {
            throw new telemetry_utils_1.LoggingError("attachSequence must be called");
        }
        return this.localCollection.nextInterval(pos);
    }
}
exports.IntervalCollection = IntervalCollection;

},{"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/merge-tree":147,"@fluidframework/telemetry-utils":279,"uuid":544}],227:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueTypeLocalValue = exports.makeSerializable = void 0;
const shared_object_base_1 = require("@fluidframework/shared-object-base");
function makeSerializable(localValue, serializer, bind) {
    const value = localValue.makeSerialized(serializer, bind);
    return {
        type: value.type,
        value: value.value && JSON.parse(value.value),
    };
}
exports.makeSerializable = makeSerializable;
/**
 * Manages a contained value type.
 *
 * @alpha
 */
class ValueTypeLocalValue {
    /**
     * Create a new ValueTypeLocalValue.
     * @param value - The instance of the value type stored within
     * @param valueType - The type object of the value type stored within
     */
    constructor(value, valueType) {
        this.value = value;
        this.valueType = valueType;
    }
    /**
     * {@inheritDoc ILocalValue."type"}
     */
    get type() {
        return this.valueType.name;
    }
    /**
     * {@inheritDoc ILocalValue.makeSerialized}
     */
    makeSerialized(serializer, bind) {
        const storedValueType = this.valueType.factory.store(this.value);
        const value = (0, shared_object_base_1.serializeHandles)(storedValueType, serializer, bind);
        return {
            type: this.type,
            value,
        };
    }
    /**
     * Get the handler for a given op of this value type.
     * @param opName - The name of the operation that needs processing
     * @returns The object which can process the given op
     */
    getOpHandler(opName) {
        const handler = this.valueType.ops.get(opName);
        if (!handler) {
            throw new Error("Unknown type message");
        }
        return handler;
    }
}
exports.ValueTypeLocalValue = ValueTypeLocalValue;

},{"@fluidframework/shared-object-base":261}],228:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/sequence";
exports.pkgVersion = "1.3.6";

},{}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSegmentSequence = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const merge_tree_1 = require("@fluidframework/merge-tree");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const intervalCollection_1 = require("./intervalCollection");
const defaultMap_1 = require("./defaultMap");
const sequenceDeltaEvent_1 = require("./sequenceDeltaEvent");
const snapshotFileName = "header";
const contentPath = "content";
class SharedSegmentSequence extends shared_object_base_1.SharedObject {
    constructor(dataStoreRuntime, id, attributes, segmentFromSpec) {
        super(id, dataStoreRuntime, attributes, "fluid_sequence_");
        this.dataStoreRuntime = dataStoreRuntime;
        this.id = id;
        this.segmentFromSpec = segmentFromSpec;
        // Deferred that triggers once the object is loaded
        this.loadedDeferred = new common_utils_1.Deferred();
        // cache out going ops created when partial loading
        this.loadedDeferredOutgoingOps = [];
        // cache incoming ops that arrive when partial loading
        this.deferIncomingOps = true;
        this.loadedDeferredIncomingOps = [];
        this.messagesSinceMSNChange = [];
        this.loadedDeferred.promise.catch((error) => {
            this.logger.sendErrorEvent({ eventName: "SequenceLoadFailed" }, error);
        });
        this.client = new merge_tree_1.Client(segmentFromSpec, telemetry_utils_1.ChildLogger.create(this.logger, "SharedSegmentSequence.MergeTreeClient"), dataStoreRuntime.options);
        super.on("newListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (!this.client.mergeTreeDeltaCallback) {
                        this.client.mergeTreeDeltaCallback = (opArgs, deltaArgs) => {
                            this.emit("sequenceDelta", new sequenceDeltaEvent_1.SequenceDeltaEvent(opArgs, deltaArgs, this.client), this);
                        };
                    }
                    break;
                case "maintenance":
                    if (!this.client.mergeTreeMaintenanceCallback) {
                        this.client.mergeTreeMaintenanceCallback = (args, opArgs) => {
                            this.emit("maintenance", new sequenceDeltaEvent_1.SequenceMaintenanceEvent(opArgs, args, this.client), this);
                        };
                    }
                    break;
                default:
            }
        });
        super.on("removeListener", (event) => {
            switch (event) {
                case "sequenceDelta":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeDeltaCallback = undefined;
                    }
                    break;
                case "maintenance":
                    if (super.listenerCount(event) === 0) {
                        this.client.mergeTreeMaintenanceCallback = undefined;
                    }
                    break;
                default:
                    break;
            }
        });
        this.intervalCollections = new defaultMap_1.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new intervalCollection_1.SequenceIntervalCollectionValueType());
    }
    get loaded() {
        return this.loadedDeferred.promise;
    }
    static createOpsFromDelta(event) {
        var _a, _b;
        const ops = [];
        for (const r of event.ranges) {
            switch (event.deltaOperation) {
                case merge_tree_1.MergeTreeDeltaType.ANNOTATE: {
                    const lastAnnotate = ops[ops.length - 1];
                    const props = {};
                    for (const key of Object.keys(r.propertyDeltas)) {
                        props[key] = (_b = (_a = r.segment.properties) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : null;
                    }
                    if (lastAnnotate && lastAnnotate.pos2 === r.position &&
                        (0, merge_tree_1.matchProperties)(lastAnnotate.props, props)) {
                        lastAnnotate.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push((0, merge_tree_1.createAnnotateRangeOp)(r.position, r.position + r.segment.cachedLength, props, undefined));
                    }
                    break;
                }
                case merge_tree_1.MergeTreeDeltaType.INSERT:
                    ops.push((0, merge_tree_1.createInsertOp)(r.position, r.segment.clone().toJSONObject()));
                    break;
                case merge_tree_1.MergeTreeDeltaType.REMOVE: {
                    const lastRem = ops[ops.length - 1];
                    if ((lastRem === null || lastRem === void 0 ? void 0 : lastRem.pos1) === r.position) {
                        lastRem.pos2 += r.segment.cachedLength;
                    }
                    else {
                        ops.push((0, merge_tree_1.createRemoveRangeOp)(r.position, r.position + r.segment.cachedLength));
                    }
                    break;
                }
                default:
            }
        }
        return ops;
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    removeRange(start, end) {
        const removeOp = this.client.removeRangeLocal(start, end);
        if (removeOp) {
            this.submitSequenceMessage(removeOp);
        }
        return removeOp;
    }
    groupOperation(groupOp) {
        this.client.localTransaction(groupOp);
        this.submitSequenceMessage(groupOp);
    }
    getContainingSegment(pos) {
        return this.client.getContainingSegment(pos);
    }
    /**
     * Returns the length of the current sequence for the client
     */
    getLength() {
        return this.client.getLength();
    }
    /**
     * Returns the current position of a segment, and -1 if the segment
     * does not exist in this sequence
     * @param segment - The segment to get the position of
     */
    getPosition(segment) {
        return this.client.getPosition(segment);
    }
    /**
     * Annotates the range with the provided properties
     *
     * @param start - The inclusive start position of the range to annotate
     * @param end - The exclusive end position of the range to annotate
     * @param props - The properties to annotate the range with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     *
     */
    annotateRange(start, end, props, combiningOp) {
        const annotateOp = this.client.annotateRangeLocal(start, end, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    getPropertiesAtPosition(pos) {
        return this.client.getPropertiesAtPosition(pos);
    }
    getRangeExtentsOfPosition(pos) {
        return this.client.getRangeExtentsOfPosition(pos);
    }
    /**
     * @deprecated - use createLocalReferencePosition
     */
    createPositionReference(segment, offset, refType) {
        const lref = new merge_tree_1.LocalReference(this.client, segment, offset, refType);
        if (refType !== merge_tree_1.ReferenceType.Transient) {
            this.addLocalReference(lref);
        }
        return lref;
    }
    createLocalReferencePosition(segment, offset, refType, properties) {
        return this.client.createLocalReferencePosition(segment, offset, refType, properties);
    }
    /**
     * @deprecated - use localReferencePositionToPosition
     */
    localRefToPos(localRef) {
        return this.client.localReferencePositionToPosition(localRef);
    }
    localReferencePositionToPosition(lref) {
        return this.client.localReferencePositionToPosition(lref);
    }
    /**
     * Resolves a remote client's position against the local sequence
     * and returns the remote client's position relative to the local
     * sequence. The client ref seq must be above the minimum sequence number
     * or the return value will be undefined.
     * Generally this method is used in conjunction with signals which provide
     * point in time values for the below parameters, and is useful for things
     * like displaying user position. It should not be used with persisted values
     * as persisted values will quickly become invalid as the remoteClientRefSeq
     * moves below the minimum sequence number
     * @param remoteClientPosition - The remote client's position to resolve
     * @param remoteClientRefSeq - The reference sequence number of the remote client
     * @param remoteClientId - The client id of the remote client
     */
    resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId) {
        return this.client.resolveRemoteClientPosition(remoteClientPosition, remoteClientRefSeq, remoteClientId);
    }
    submitSequenceMessage(message) {
        if (!this.isAttached()) {
            return;
        }
        const translated = (0, shared_object_base_1.makeHandlesSerializable)(message, this.serializer, this.handle);
        const metadata = this.client.peekPendingSegmentGroups(message.type === merge_tree_1.MergeTreeDeltaType.GROUP ? message.ops.length : 1);
        // if loading isn't complete, we need to cache
        // local ops until loading is complete, and then
        // they will be resent
        if (!this.loadedDeferred.isCompleted) {
            this.loadedDeferredOutgoingOps.push([translated, metadata]);
        }
        else {
            this.submitLocalMessage(translated, metadata);
        }
    }
    /**
     * @deprecated - use createLocalReferencePosition
     */
    addLocalReference(lref) {
        return this.client.addLocalReference(lref);
    }
    /**
     * @deprecated - use removeLocalReferencePosition
     */
    removeLocalReference(lref) {
        return this.client.removeLocalReferencePosition(lref);
    }
    removeLocalReferencePosition(lref) {
        return this.client.removeLocalReferencePosition(lref);
    }
    /**
     * Given a position specified relative to a marker id, lookup the marker
     * and convert the position to a character position.
     * @param relativePos - Id of marker (may be indirect) and whether position is before or after marker.
     */
    posFromRelativePos(relativePos) {
        return this.client.posFromRelativePos(relativePos);
    }
    /**
     * Walk the underlying segments of the sequence.
     * The walked segments may extend beyond the range
     * if the segments cross the ranges start or end boundaries.
     * Set split range to true to ensure only segments within the
     * range are walked.
     *
     * @param handler - The function to handle each segment
     * @param start - Optional. The start of range walk.
     * @param end - Optional. The end of range walk
     * @param accum - Optional. An object that will be passed to the handler for accumulation
     * @param splitRange - Optional. Splits boundary segments on the range boundaries
     */
    walkSegments(handler, start, end, accum, splitRange = false) {
        return this.client.walkSegments(handler, start, end, accum, splitRange);
    }
    getStackContext(startPos, rangeLabels) {
        return this.client.getStackContext(startPos, rangeLabels);
    }
    getCurrentSeq() {
        return this.client.getCurrentSeq();
    }
    insertAtReferencePosition(pos, segment) {
        const insertOp = this.client.insertAtReferencePositionLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates
     * are supported. Use `getIntervalCollection` instead.
     */
    async waitIntervalCollection(label) {
        return this.intervalCollections.get(label);
    }
    getIntervalCollection(label) {
        return this.intervalCollections.get(label);
    }
    /**
     * @returns an iterable object that enumerates the IntervalCollection labels
     * Usage:
     * const iter = this.getIntervalCollectionKeys();
     * for (key of iter)
     *     const collection = this.getIntervalCollection(key);
     *     ...
    */
    getIntervalCollectionLabels() {
        return this.intervalCollections.keys();
    }
    summarizeCore(serializer, telemetryContext) {
        const builder = new runtime_utils_1.SummaryTreeBuilder();
        // conditionally write the interval collection blob
        // only if it has entries
        if (this.intervalCollections.size > 0) {
            builder.addBlob(snapshotFileName, this.intervalCollections.serialize(serializer));
        }
        builder.addWithStats(contentPath, this.summarizeMergeTree(serializer));
        return builder.getSummaryTree();
    }
    /**
     * Runs serializer over the GC data for this SharedMatrix.
     * All the IFluidHandle's represent routes to other objects.
     */
    processGCDataCore(serializer) {
        if (this.intervalCollections.size > 0) {
            this.intervalCollections.serialize(serializer);
        }
        this.client.serializeGCData(this.handle, serializer);
    }
    /**
     * Replace the range specified from start to end with the provided segment
     * This is done by inserting the segment at the end of the range, followed
     * by removing the contents of the range
     * For a zero or reverse range (start \>= end), insert at end do not remove anything
     * @param start - The start of the range to replace
     * @param end - The end of the range to replace
     * @param segment - The segment that will replace the range
     */
    replaceRange(start, end, segment) {
        // Insert at the max end of the range when start > end, but still remove the range later
        const insertIndex = Math.max(start, end);
        // Insert first, so local references can slide to the inserted seg if any
        const insert = this.client.insertSegmentLocal(insertIndex, segment);
        if (insert) {
            if (start < end) {
                const remove = this.client.removeRangeLocal(start, end);
                this.submitSequenceMessage((0, merge_tree_1.createGroupOp)(insert, remove));
            }
            else {
                this.submitSequenceMessage(insert);
            }
        }
    }
    onConnect() {
        // Update merge tree collaboration information with new client ID and then resend pending ops
        this.client.startOrUpdateCollaboration(this.runtime.clientId);
    }
    onDisconnect() { }
    reSubmitCore(content, localOpMetadata) {
        if (!this.intervalCollections.tryResubmitMessage(content, localOpMetadata)) {
            this.submitSequenceMessage(this.client.regeneratePendingOp(content, localOpMetadata));
        }
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        var _a;
        if (await storage.contains(snapshotFileName)) {
            const blob = await storage.readBlob(snapshotFileName);
            const header = (0, common_utils_1.bufferToString)(blob, "utf8");
            this.intervalCollections.populate(header);
        }
        try {
            // this will load the header, and return a promise
            // that will resolve when the body is loaded
            // and the catchup ops are available.
            const { catchupOpsP } = await this.client.load(this.runtime, new runtime_utils_1.ObjectStoragePartition(storage, contentPath), this.serializer);
            // setup a promise to process the
            // catch up ops, and finishing the loading process
            const loadCatchUpOps = catchupOpsP
                .then((msgs) => {
                msgs.forEach((m) => {
                    const collabWindow = this.client.getCollabWindow();
                    if (m.minimumSequenceNumber < collabWindow.minSeq
                        || m.referenceSequenceNumber < collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.minSeq
                        || m.sequenceNumber <= collabWindow.currentSeq) {
                        throw new Error(`Invalid catchup operations in snapshot: ${JSON.stringify({
                            op: {
                                seq: m.sequenceNumber,
                                minSeq: m.minimumSequenceNumber,
                                refSeq: m.referenceSequenceNumber,
                            },
                            collabWindow: {
                                seq: collabWindow.currentSeq,
                                minSeq: collabWindow.minSeq,
                            },
                        })}`);
                    }
                    this.processMergeTreeMsg(m);
                });
                this.loadFinished();
            })
                .catch((error) => {
                this.loadFinished(error);
            });
            if (((_a = this.dataStoreRuntime.options) === null || _a === void 0 ? void 0 : _a.sequenceInitializeFromHeaderOnly) !== true) {
                // if we not doing partial load, await the catch up ops,
                // and the finalization of the load
                await loadCatchUpOps;
            }
        }
        catch (error) {
            this.loadFinished(error);
        }
    }
    processCore(message, local, localOpMetadata) {
        // if loading isn't complete, we need to cache all
        // incoming ops to be applied after loading is complete
        if (this.deferIncomingOps) {
            (0, common_utils_1.assert)(!local, 0x072 /* "Unexpected local op when loading not finished" */);
            this.loadedDeferredIncomingOps.push(message);
        }
        else {
            (0, common_utils_1.assert)(message.type === protocol_definitions_1.MessageType.Operation, 0x073 /* "Sequence message not operation" */);
            const handled = this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);
            if (!handled) {
                this.processMergeTreeMsg(message, local);
            }
        }
    }
    didAttach() {
        var _a;
        // If we are not local, and we've attached we need to start generating and sending ops
        // so start collaboration and provide a default client id incase we are not connected
        if (this.isAttached()) {
            this.client.startOrUpdateCollaboration((_a = this.runtime.clientId) !== null && _a !== void 0 ? _a : "attached");
        }
    }
    initializeLocalCore() {
        super.initializeLocalCore();
        this.loadFinished();
    }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObjectCore.applyStashedOp}
     */
    applyStashedOp(content) {
        return this.client.applyStashedOp(content);
    }
    summarizeMergeTree(serializer) {
        // Are we fully loaded? If not, things will go south
        (0, common_utils_1.assert)(this.loadedDeferred.isCompleted, 0x074 /* "Snapshot called when not fully loaded" */);
        const minSeq = this.runtime.deltaManager.minimumSequenceNumber;
        this.processMinSequenceNumberChanged(minSeq);
        this.messagesSinceMSNChange.forEach((m) => { m.minimumSequenceNumber = minSeq; });
        return this.client.summarize(this.runtime, this.handle, serializer, this.messagesSinceMSNChange);
    }
    processMergeTreeMsg(rawMessage, local) {
        var _a, _b;
        const message = (0, shared_object_base_1.parseHandles)(rawMessage, this.serializer);
        const ops = [];
        function transformOps(event) {
            ops.push(...SharedSegmentSequence.createOpsFromDelta(event));
        }
        const needsTransformation = message.referenceSequenceNumber !== message.sequenceNumber - 1;
        let stashMessage = message;
        if (((_a = this.runtime.options) === null || _a === void 0 ? void 0 : _a.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.on("sequenceDelta", transformOps);
            }
        }
        this.client.applyMsg(message, local);
        if (((_b = this.runtime.options) === null || _b === void 0 ? void 0 : _b.newMergeTreeSnapshotFormat) !== true) {
            if (needsTransformation) {
                this.removeListener("sequenceDelta", transformOps);
                // shallow clone the message as we only overwrite top level properties,
                // like referenceSequenceNumber and content only
                stashMessage = Object.assign(Object.assign({}, message), { referenceSequenceNumber: stashMessage.sequenceNumber - 1, contents: ops.length !== 1 ? (0, merge_tree_1.createGroupOp)(...ops) : ops[0] });
            }
            this.messagesSinceMSNChange.push(stashMessage);
            // Do GC every once in a while...
            if (this.messagesSinceMSNChange.length > 20
                && this.messagesSinceMSNChange[20].sequenceNumber < message.minimumSequenceNumber) {
                this.processMinSequenceNumberChanged(message.minimumSequenceNumber);
            }
        }
    }
    processMinSequenceNumberChanged(minSeq) {
        let index = 0;
        for (; index < this.messagesSinceMSNChange.length; index++) {
            if (this.messagesSinceMSNChange[index].sequenceNumber > minSeq) {
                break;
            }
        }
        if (index !== 0) {
            this.messagesSinceMSNChange = this.messagesSinceMSNChange.slice(index);
        }
    }
    loadFinished(error) {
        if (!this.loadedDeferred.isCompleted) {
            // Initialize the interval collections
            this.initializeIntervalCollections();
            if (error) {
                this.loadedDeferred.reject(error);
                throw error;
            }
            else {
                // it is important this series remains synchronous
                // first we stop deferring incoming ops, and apply then all
                this.deferIncomingOps = false;
                for (const message of this.loadedDeferredIncomingOps) {
                    this.processCore(message, false, undefined);
                }
                this.loadedDeferredIncomingOps.length = 0;
                // then resolve the loaded promise
                // and resubmit all the outstanding ops, as the snapshot
                // is fully loaded, and all outstanding ops are applied
                this.loadedDeferred.resolve();
                for (const [messageContent, opMetadata] of this.loadedDeferredOutgoingOps) {
                    this.reSubmitCore(messageContent, opMetadata);
                }
                this.loadedDeferredOutgoingOps.length = 0;
            }
        }
    }
    initializeIntervalCollections() {
        // Listen and initialize new SharedIntervalCollections
        this.intervalCollections.eventEmitter.on("create", ({ key, previousValue }, local) => {
            const intervalCollection = this.intervalCollections.get(key);
            if (!intervalCollection.attached) {
                intervalCollection.attachGraph(this.client, key);
            }
            (0, common_utils_1.assert)(previousValue === undefined, 0x2c1 /* "Creating an interval collection that already exists?" */);
            this.emit("createIntervalCollection", key, local, this);
        });
        // Initialize existing SharedIntervalCollections
        for (const key of this.intervalCollections.keys()) {
            const intervalCollection = this.intervalCollections.get(key);
            intervalCollection.attachGraph(this.client, key);
        }
    }
}
exports.SharedSegmentSequence = SharedSegmentSequence;

},{"./defaultMap":224,"./intervalCollection":226,"./sequenceDeltaEvent":230,"@fluidframework/common-utils":29,"@fluidframework/merge-tree":147,"@fluidframework/protocol-definitions":174,"@fluidframework/runtime-utils":213,"@fluidframework/shared-object-base":261,"@fluidframework/telemetry-utils":279}],230:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequenceMaintenanceEvent = exports.SequenceDeltaEvent = exports.SequenceEvent = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const merge_tree_1 = require("@fluidframework/merge-tree");
/**
 * Base class for SequenceDeltaEvent and SequenceMaintenanceEvent.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into any future modifications performed to the underlying sequence and merge tree.
 */
class SequenceEvent {
    constructor(deltaArgs, mergeTreeClient) {
        this.deltaArgs = deltaArgs;
        this.mergeTreeClient = mergeTreeClient;
        (0, common_utils_1.assert)(deltaArgs.deltaSegments.length > 0, 0x2d8 /* "Empty change event should not be emitted." */);
        this.isEmpty = false;
        this.deltaOperation = deltaArgs.operation;
        this.sortedRanges = new Lazy(() => {
            const set = new merge_tree_1.SortedSegmentSet();
            this.deltaArgs.deltaSegments.forEach((delta) => {
                const newRange = {
                    operation: this.deltaArgs.operation,
                    position: this.mergeTreeClient.getPosition(delta.segment),
                    propertyDeltas: delta.propertyDeltas,
                    segment: delta.segment,
                };
                set.addOrUpdate(newRange);
            });
            return set;
        });
        this.pFirst = new Lazy(() => this.sortedRanges.value.items[0]);
        this.pLast = new Lazy(() => this.sortedRanges.value.items[this.sortedRanges.value.size - 1]);
    }
    /**
     * The in-order ranges affected by this delta.
     * These may not be continuous.
     */
    get ranges() {
        return this.sortedRanges.value.items;
    }
    /**
     * The client id of the client that made the change which caused the delta event
     */
    get clientId() {
        return this.mergeTreeClient.longClientId;
    }
    /**
     * The first of the modified ranges.
     */
    get first() {
        return this.pFirst.value;
    }
    /**
     * The last of the modified ranges.
     */
    get last() {
        return this.pLast.value;
    }
}
exports.SequenceEvent = SequenceEvent;
/**
 * The event object returned on sequenceDelta events.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.
 *
 * For group ops, each op will get its own event, and the group op property will be set on the op args.
 *
 * Ops may get multiple events. For instance, an insert-replace will get a remove then an insert event.
 */
class SequenceDeltaEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
        this.isLocal = opArgs.sequencedMessage === undefined;
    }
}
exports.SequenceDeltaEvent = SequenceDeltaEvent;
/**
 * The event object returned on maintenance events.
 *
 * The properties of this object and its sub-objects represent the state of the sequence at the
 * point in time at which the operation was applied.
 * They will not take into consideration any future modifications performed to the underlying sequence and merge tree.
 */
class SequenceMaintenanceEvent extends SequenceEvent {
    constructor(opArgs, deltaArgs, mergeTreeClient) {
        super(deltaArgs, mergeTreeClient);
        this.opArgs = opArgs;
    }
}
exports.SequenceMaintenanceEvent = SequenceMaintenanceEvent;
class Lazy {
    constructor(valueGenerator) {
        this.valueGenerator = valueGenerator;
        this.pEvaluated = false;
    }
    get evaluated() {
        return this.pEvaluated;
    }
    get value() {
        if (!this.pEvaluated) {
            this.pEvaluated = true;
            this.pValue = this.valueGenerator();
        }
        return this.pValue;
    }
}

},{"@fluidframework/common-utils":29,"@fluidframework/merge-tree":147}],231:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedNumberSequenceFactory = exports.SharedObjectSequenceFactory = exports.SharedStringFactory = void 0;
const merge_tree_1 = require("@fluidframework/merge-tree");
const packageVersion_1 = require("./packageVersion");
const sharedNumberSequence_1 = require("./sharedNumberSequence");
const sharedObjectSequence_1 = require("./sharedObjectSequence");
const sharedSequence_1 = require("./sharedSequence");
const sharedString_1 = require("./sharedString");
class SharedStringFactory {
    static segmentFromSpec(spec) {
        const maybeText = merge_tree_1.TextSegment.fromJSONObject(spec);
        if (maybeText) {
            return maybeText;
        }
        const maybeMarker = merge_tree_1.Marker.fromJSONObject(spec);
        if (maybeMarker) {
            return maybeMarker;
        }
    }
    get type() {
        return SharedStringFactory.Type;
    }
    get attributes() {
        return SharedStringFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedString = new sharedString_1.SharedString(runtime, id, attributes);
        await sharedString.load(services);
        return sharedString;
    }
    create(document, id) {
        const sharedString = new sharedString_1.SharedString(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
exports.SharedStringFactory = SharedStringFactory;
// TODO rename back to https://graph.microsoft.com/types/mergeTree/string once paparazzi is able to dynamically
// load code
SharedStringFactory.Type = "https://graph.microsoft.com/types/mergeTree";
SharedStringFactory.Attributes = {
    type: SharedStringFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedObjectSequenceFactory {
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static segmentFromSpec(segSpec) {
        const runSegment = segSpec;
        if (runSegment.items) {
            const seg = new sharedSequence_1.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get type() {
        return SharedObjectSequenceFactory.Type;
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get attributes() {
        return SharedObjectSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    async load(runtime, id, services, attributes) {
        const sharedSeq = new sharedObjectSequence_1.SharedObjectSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    create(document, id) {
        const sharedString = new sharedObjectSequence_1.SharedObjectSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
exports.SharedObjectSequenceFactory = SharedObjectSequenceFactory;
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedObjectSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/object-sequence";
/**
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedObjectSequenceFactory.Attributes = {
    type: SharedObjectSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedNumberSequenceFactory {
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static segmentFromSpec(segSpec) {
        const runSegment = segSpec;
        if (runSegment.items) {
            const seg = new sharedSequence_1.SubSequence(runSegment.items);
            if (runSegment.props) {
                seg.addProperties(runSegment.props);
            }
            return seg;
        }
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get type() {
        return SharedNumberSequenceFactory.Type;
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    get attributes() {
        return SharedNumberSequenceFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    async load(runtime, id, services, attributes) {
        const sharedSeq = new sharedNumberSequence_1.SharedNumberSequence(runtime, id, attributes);
        await sharedSeq.load(services);
        return sharedSeq;
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    create(document, id) {
        const sharedString = new sharedNumberSequence_1.SharedNumberSequence(document, id, this.attributes);
        sharedString.initializeLocal();
        return sharedString;
    }
}
exports.SharedNumberSequenceFactory = SharedNumberSequenceFactory;
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedNumberSequenceFactory.Type = "https://graph.microsoft.com/types/mergeTree/number-sequence";
/**
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
SharedNumberSequenceFactory.Attributes = {
    type: SharedNumberSequenceFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};

},{"./packageVersion":228,"./sharedNumberSequence":233,"./sharedObjectSequence":234,"./sharedSequence":235,"./sharedString":236,"@fluidframework/merge-tree":147}],232:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedIntervalCollection = exports.SharedIntervalCollectionFactory = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const shared_object_base_1 = require("@fluidframework/shared-object-base");
const intervalCollection_1 = require("./intervalCollection");
const defaultMap_1 = require("./defaultMap");
const packageVersion_1 = require("./packageVersion");
const snapshotFileName = "header";
/**
 * The factory that defines the SharedIntervalCollection
 * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.
 */
class SharedIntervalCollectionFactory {
    get type() {
        return SharedIntervalCollectionFactory.Type;
    }
    get attributes() {
        return SharedIntervalCollectionFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const map = new SharedIntervalCollection(id, runtime, attributes);
        await map.load(services);
        return map;
    }
    create(runtime, id) {
        const map = new SharedIntervalCollection(id, runtime, this.attributes);
        map.initializeLocal();
        return map;
    }
}
exports.SharedIntervalCollectionFactory = SharedIntervalCollectionFactory;
SharedIntervalCollectionFactory.Type = "https://graph.microsoft.com/types/sharedIntervalCollection";
SharedIntervalCollectionFactory.Attributes = {
    type: SharedIntervalCollectionFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};
/**
 * @deprecated - SharedIntervalCollection is not maintained and is planned to be removed.
 */
class SharedIntervalCollection extends shared_object_base_1.SharedObject {
    /**
     * Constructs a new shared SharedIntervalCollection. If the object is non-local an id and service interfaces will
     * be provided
     */
    constructor(id, runtime, attributes) {
        super(id, runtime, attributes, "fluid_sharedIntervalCollection_");
        this[_a] = "SharedIntervalCollection";
        this.intervalCollections = new defaultMap_1.DefaultMap(this.serializer, this.handle, (op, localOpMetadata) => this.submitLocalMessage(op, localOpMetadata), new intervalCollection_1.IntervalCollectionValueType());
    }
    /**
     * Create a SharedIntervalCollection
     *
     * @param runtime - data store runtime the new shared map belongs to
     * @param id - optional name of the shared map
     * @returns newly create shared map (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, SharedIntervalCollectionFactory.Type);
    }
    /**
     * Get a factory for SharedIntervalCollection to register with the data store.
     *
     * @returns a factory that creates and load SharedIntervalCollection
     */
    static getFactory() {
        return new SharedIntervalCollectionFactory();
    }
    /**
     * @deprecated - IntervalCollections are created on a first-write wins basis, and concurrent creates
     * are supported. Use `getIntervalCollection` instead.
     */
    async waitIntervalCollection(label) {
        return this.intervalCollections.get(this.getIntervalCollectionPath(label));
    }
    getIntervalCollection(label) {
        const realLabel = this.getIntervalCollectionPath(label);
        const sharedCollection = this.intervalCollections.get(realLabel);
        return sharedCollection;
    }
    summarizeCore(serializer) {
        return (0, shared_object_base_1.createSingleBlobSummary)(snapshotFileName, this.intervalCollections.serialize(serializer));
    }
    reSubmitCore(content, localOpMetadata) {
        this.intervalCollections.tryResubmitMessage(content, localOpMetadata);
    }
    onDisconnect() { }
    /**
     * {@inheritDoc @fluidframework/shared-object-base#SharedObject.loadCore}
     */
    async loadCore(storage) {
        const blob = await storage.readBlob(snapshotFileName);
        const header = (0, common_utils_1.bufferToString)(blob, "utf8");
        this.intervalCollections.populate(header);
    }
    processCore(message, local, localOpMetadata) {
        if (message.type === protocol_definitions_1.MessageType.Operation) {
            this.intervalCollections.tryProcessMessage(message.contents, local, message, localOpMetadata);
        }
    }
    /**
     * Creates the full path of the intervalCollection label
     * @param label - the incoming label
     */
    getIntervalCollectionPath(label) {
        return label;
    }
    applyStashedOp() {
        throw new Error("not implemented");
    }
}
exports.SharedIntervalCollection = SharedIntervalCollection;
_a = Symbol.toStringTag;

},{"./defaultMap":224,"./intervalCollection":226,"./packageVersion":228,"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/shared-object-base":261}],233:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedNumberSequence = void 0;
const sequenceFactory_1 = require("./sequenceFactory");
const sharedSequence_1 = require("./sharedSequence");
/**
 * The SharedNumberSequence holds a sequence of numbers. Each number will be stored
 * at a position within the sequence. See the
 * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}
 * for details on working with sequences.
 *
 * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedNumberSequence extends sharedSequence_1.SharedSequence {
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    constructor(document, id, attributes) {
        super(document, id, attributes, sequenceFactory_1.SharedNumberSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared number sequence
     *
     * @param runtime - data store runtime the new shared number sequence belongs to
     * @param id - optional name of the shared number sequence
     * @returns newly create shared number sequence (but not attached yet)
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, sequenceFactory_1.SharedNumberSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedNumberSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedNumberSequence
     *
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static getFactory() {
        return new sequenceFactory_1.SharedNumberSequenceFactory();
    }
    /**
     * @deprecated SharedNumberSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
exports.SharedNumberSequence = SharedNumberSequence;

},{"./sequenceFactory":231,"./sharedSequence":235}],234:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedObjectSequence = void 0;
const sequenceFactory_1 = require("./sequenceFactory");
const sharedSequence_1 = require("./sharedSequence");
/**
 * The SharedObjectSequence holds a sequence of serializable objects. Each object will be stored
 * at a position within the sequence. See the
 * {@link https://fluidframework.com/docs/data-structures/sequences/ | sequence documentation}
 * for details on working with sequences.
 *
 * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
 * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
 */
class SharedObjectSequence extends sharedSequence_1.SharedSequence {
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    constructor(document, id, attributes) {
        super(document, id, attributes, sequenceFactory_1.SharedObjectSequenceFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new shared object sequence
     *
     * @param runtime - data store runtime the new shared object sequence belongs to
     * @param id - optional name of the shared object sequence
     * @returns newly create shared object sequence (but not attached yet)
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, sequenceFactory_1.SharedObjectSequenceFactory.Type);
    }
    /**
     * Get a factory for SharedObjectSequence to register with the data store.
     *
     * @returns a factory that creates and load SharedObjectSequence
     *
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    static getFactory() {
        return new sequenceFactory_1.SharedObjectSequenceFactory();
    }
    /**
     * @deprecated SharedObjectSequence is not recommended for use and will be removed in an upcoming release.
     * For more info, please see [Github issue 8526](https://github.com/microsoft/FluidFramework/issues/8526)
     */
    getRange(start, end) {
        return this.getItems(start, end);
    }
}
exports.SharedObjectSequence = SharedObjectSequence;

},{"./sequenceFactory":231,"./sharedSequence":235}],235:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedSequence = exports.SubSequence = void 0;
const merge_tree_1 = require("@fluidframework/merge-tree");
const sequence_1 = require("./sequence");
const MaxRun = 128;
class SubSequence extends merge_tree_1.BaseSegment {
    constructor(items) {
        super();
        this.items = items;
        this.type = SubSequence.typeString;
        this.cachedLength = items.length;
    }
    static is(segment) {
        return segment.type === SubSequence.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "items" in spec) {
            const segment = new SubSequence(spec.items);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    toJSONObject() {
        const obj = { items: this.items };
        super.addSerializedProps(obj);
        return obj;
    }
    clone(start = 0, end) {
        const clonedItems = this.items.slice(start, end);
        const b = new SubSequence(clonedItems);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return SubSequence.is(segment)
            && (this.cachedLength <= MaxRun || segment.cachedLength <= MaxRun);
    }
    toString() {
        return this.items.toString();
    }
    append(segment) {
        if (!SubSequence.is(segment)) {
            throw new Error("can only append another run segment");
        }
        // Note: Must call 'appendLocalRefs' before modifying this segment's length as
        //       'this.cachedLength' is used to adjust the offsets of the local refs.
        merge_tree_1.LocalReferenceCollection.append(this, segment);
        this.items = this.items.concat(segment.items);
        this.cachedLength = this.items.length;
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        let remnantItems = [];
        const len = this.items.length;
        if (start > 0) {
            remnantItems = remnantItems.concat(this.items.slice(0, start));
        }
        if (end < len) {
            remnantItems = remnantItems.concat(this.items.slice(end));
        }
        this.items = remnantItems;
        this.cachedLength = this.items.length;
        return (this.items.length === 0);
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new SubSequence(remainingItems);
            return leafSegment;
        }
    }
}
exports.SubSequence = SubSequence;
SubSequence.typeString = "SubSequence";
class SharedSequence extends sequence_1.SharedSegmentSequence {
    constructor(document, id, attributes, specToSegment) {
        super(document, id, attributes, specToSegment);
        this.id = id;
    }
    /**
     * @param pos - The position to insert the items at.
     * @param items - The items to insert.
     * @param props - Optional. Properties to set on the inserted items.
     */
    insert(pos, items, props) {
        const segment = new SubSequence(items);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to remove
     */
    remove(start, end) {
        this.removeRange(start, end);
    }
    /**
     * Returns the total count of items in the sequence
     */
    getItemCount() {
        return this.getLength();
    }
    /**
     * Gets the items in the specified range
     *
     * @param start - The inclusive start of the range
     * @param end - The exclusive end of the range
     */
    getItems(start, end) {
        const items = [];
        let firstSegment;
        // Return if the range is incorrect.
        if (end !== undefined && end <= start) {
            return items;
        }
        this.walkSegments((segment) => {
            if (SubSequence.is(segment)) {
                if (firstSegment === undefined) {
                    firstSegment = segment;
                }
                items.push(...segment.items);
            }
            return true;
        }, start, end);
        // The above call to walkSegments adds all the items in the walked
        // segments. However, we only want items beginning at |start| in
        // the first segment. Similarly, if |end| is passed in, we only
        // want items until |end| in the last segment. Remove the rest of
        // the items.
        if (firstSegment !== undefined) {
            items.splice(0, start - this.getPosition(firstSegment));
        }
        if (end !== undefined) {
            items.splice(end - start);
        }
        return items;
    }
}
exports.SharedSequence = SharedSequence;

},{"./sequence":229,"@fluidframework/merge-tree":147}],236:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedString = void 0;
const merge_tree_1 = require("@fluidframework/merge-tree");
const sequence_1 = require("./sequence");
const sequenceFactory_1 = require("./sequenceFactory");
/**
 * The Shared String is a specialized data structure for handling collaborative
 * text. It is based on a more general Sequence data structure but has
 * additional features that make working with text easier.
 *
 * In addition to text, a Shared String can also contain markers. Markers can be
 * used to store metadata at positions within the text, like the details of an
 * image or Fluid object that should be rendered with the text.
 *
 */
class SharedString extends sequence_1.SharedSegmentSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, sequenceFactory_1.SharedStringFactory.segmentFromSpec);
        this.id = id;
        this.mergeTreeTextHelper = this.client.createTextHelper();
    }
    /**
     * Create a new shared string.
     * @param runtime - data store runtime the new shared string belongs to
     * @param id - optional name of the shared string
     * @returns newly create shared string (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, sequenceFactory_1.SharedStringFactory.Type);
    }
    /**
     * Get a factory for SharedString to register with the data store.
     * @returns a factory that creates and load SharedString
     */
    static getFactory() {
        return new sequenceFactory_1.SharedStringFactory();
    }
    get ISharedString() {
        return this;
    }
    /**
     * Inserts a marker at a relative position.
     * @param relativePos1 - The relative position to insert the marker at
     * @param refType - The reference type of the marker
     * @param props - The properties of the marker
     */
    insertMarkerRelative(relativePos1, refType, props) {
        const segment = new merge_tree_1.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * {@inheritDoc ISharedString.insertMarker}
     */
    insertMarker(pos, refType, props) {
        const segment = new merge_tree_1.Marker(refType);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
        return insertOp;
    }
    /**
     * Inserts the text at the position.
     * @param relativePos1 - The relative position to insert the text at
     * @param text - The text to insert
     * @param props - The properties of text
     */
    insertTextRelative(relativePos1, text, props) {
        const segment = new merge_tree_1.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const pos = this.posFromRelativePos(relativePos1);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * {@inheritDoc ISharedString.insertText}
     */
    insertText(pos, text, props) {
        const segment = new merge_tree_1.TextSegment(text);
        if (props) {
            segment.addProperties(props);
        }
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    /**
     * Replaces a range with the provided text.
     * @param start - The inclusive start of the range to replace
     * @param end - The exclusive end of the range to replace
     * @param text - The text to replace the range with
     * @param props - Optional. The properties of the replacement text
     */
    replaceText(start, end, text, props) {
        this.replaceRange(start, end, merge_tree_1.TextSegment.make(text, props));
    }
    /**
     * Removes the text in the given range.
     * @param start - The inclusive start of the range to remove
     * @param end - The exclusive end of the range to replace
     * @returns the message sent.
     */
    removeText(start, end) {
        return this.removeRange(start, end);
    }
    /**
     * Annotates the marker with the provided properties and calls the callback on consensus.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param consensusCallback - The callback called when consensus is reached
     */
    annotateMarkerNotifyConsensus(marker, props, callback) {
        const annotateOp = this.client.annotateMarkerNotifyConsensus(marker, props, callback);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    /**
     * Annotates the marker with the provided properties.
     * @param marker - The marker to annotate
     * @param props - The properties to annotate the marker with
     * @param combiningOp - Optional. Specifies how to combine values for the property, such as "incr" for increment.
     */
    annotateMarker(marker, props, combiningOp) {
        const annotateOp = this.client.annotateMarker(marker, props, combiningOp);
        if (annotateOp) {
            this.submitSequenceMessage(annotateOp);
        }
    }
    findTile(startPos, tileLabel, preceding = true) {
        return this.client.findTile(startPos, tileLabel, preceding);
    }
    getTextAndMarkers(label) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getTextAndMarkers(segmentWindow.currentSeq, segmentWindow.clientId, label);
    }
    /**
     * Retrieve text from the SharedString in string format.
     * @param start - The starting index of the text to retrieve, or 0 if omitted.
     * @param end - The ending index of the text to retrieve, or the end of the string if omitted
     * @returns The requested text content as a string.
     */
    getText(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "", start, end);
    }
    /**
     * Adds spaces for markers and handles, so that position calculations account for them.
     */
    getTextWithPlaceholders() {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ");
    }
    getTextRangeWithPlaceholders(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, " ", start, end);
    }
    getTextRangeWithMarkers(start, end) {
        const segmentWindow = this.client.getCollabWindow();
        return this.mergeTreeTextHelper.getText(segmentWindow.currentSeq, segmentWindow.clientId, "*", start, end);
    }
    getMarkerFromId(id) {
        return this.client.getMarkerFromId(id);
    }
}
exports.SharedString = SharedString;

},{"./sequence":229,"./sequenceFactory":231,"@fluidframework/merge-tree":147}],237:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparseMatrixFactory = exports.SparseMatrix = exports.positionToRowCol = exports.rowColToPosition = exports.maxCellPosition = exports.maxRows = exports.maxRow = exports.maxCols = exports.maxCol = exports.RunSegment = exports.PaddingSegment = void 0;
const merge_tree_1 = require("@fluidframework/merge-tree");
const packageVersion_1 = require("./packageVersion");
const _1 = require("./");
/**
 * An empty segment that occupies 'cachedLength' positions.  SparseMatrix uses PaddingSegment
 * to "pad" a run of unoccupied cells.
 *
 * @deprecated PaddingSegment is part of an abandoned prototype.  Use SharedMatrix instead.
 */
class PaddingSegment extends merge_tree_1.BaseSegment {
    constructor(size) {
        super();
        this.type = PaddingSegment.typeString;
        this.cachedLength = size;
    }
    static is(segment) {
        return segment.type === PaddingSegment.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "pad" in spec) {
            const segment = new PaddingSegment(spec.pad);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    toJSONObject() {
        return { pad: this.cachedLength, props: this.properties };
    }
    clone(start = 0, end) {
        const b = new PaddingSegment(this.cachedLength);
        this.cloneInto(b);
        return b;
    }
    canAppend(segment) {
        return PaddingSegment.is(segment);
    }
    toString() {
        return `[padding: ${this.cachedLength}]`;
    }
    append(segment) {
        if (!PaddingSegment.is(segment)) {
            throw new Error("can only append padding segment");
        }
        // Note: Must call 'appendLocalRefs' before modifying this segment's length as
        //       'this.cachedLength' is used to adjust the offsets of the local refs.
        merge_tree_1.LocalReferenceCollection.append(this, segment);
        this.cachedLength += segment.cachedLength;
    }
    // Returns true if entire run removed
    removeRange(start, end) {
        this.cachedLength -= (end - start);
        return (this.cachedLength === 0);
    }
    createSplitSegmentAt(pos) {
        const leftLength = pos;
        const rightLength = this.cachedLength - pos;
        this.cachedLength = leftLength;
        return new PaddingSegment(rightLength);
    }
}
exports.PaddingSegment = PaddingSegment;
PaddingSegment.typeString = "PaddingSegment";
/**
 * @deprecated RunSegment is part of an abandoned prototype.  Use SharedMatrix instead.
 */
class RunSegment extends _1.SubSequence {
    constructor(items) {
        super(items);
        this.items = items;
        this.type = RunSegment.typeString;
        this.tags = new Array(items.length).fill(undefined);
    }
    static is(segment) {
        return segment.type === RunSegment.typeString;
    }
    static fromJSONObject(spec) {
        if (spec && typeof spec === "object" && "items" in spec) {
            const segment = new RunSegment(spec.items);
            if (spec.props) {
                segment.addProperties(spec.props);
            }
            return segment;
        }
        return undefined;
    }
    clone(start = 0, end) {
        const b = new RunSegment(this.items.slice(start, end));
        if (this.tags) {
            b.tags = this.tags.slice(start, end);
        }
        this.cloneInto(b);
        return b;
    }
    append(segment) {
        super.append(segment);
        const asRun = segment;
        if (asRun.tags) {
            if (this.tags) {
                this.tags.splice(this.items.length, 0, ...asRun.tags);
            }
        }
        return this;
    }
    // TODO: retain removed items for undo
    // returns true if entire run removed
    removeRange(start, end) {
        this.tags.splice(start, end - start);
        return super.removeRange(start, end);
    }
    getTag(pos) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.tags[pos];
    }
    setTag(pos, tag) {
        this.tags[pos] = tag;
    }
    createSplitSegmentAt(pos) {
        if (pos > 0) {
            const remainingItems = this.items.slice(pos);
            this.items = this.items.slice(0, pos);
            this.cachedLength = this.items.length;
            const leafSegment = new RunSegment(remainingItems);
            leafSegment.tags = this.tags.slice(pos);
            this.tags.length = pos;
            return leafSegment;
        }
    }
}
exports.RunSegment = RunSegment;
RunSegment.typeString = "RunSegment";
/**
 * @deprecated maxCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
exports.maxCol = 0x200000; // X128 Excel maximum of 16,384 columns
/**
 * @deprecated maxCols is part of an abandoned prototype.  Use SharedMatrix instead.
 */
exports.maxCols = exports.maxCol + 1;
/**
 * @deprecated maxRow is part of an abandoned prototype.  Use SharedMatrix instead.
 */
exports.maxRow = 0xFFFFFFFF; // X4096 Excel maximum of 1,048,576 rows
/**
 * @deprecated maxRows is part of an abandoned prototype.  Use SharedMatrix instead.
 */
exports.maxRows = exports.maxRow + 1;
/**
 * @deprecated maxCellPosition is part of an abandoned prototype.  Use SharedMatrix instead.
 */
exports.maxCellPosition = exports.maxCol * exports.maxRow;
/**
 * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
const rowColToPosition = (row, col) => row * exports.maxCols + col;
exports.rowColToPosition = rowColToPosition;
/**
 * @deprecated positionToRowCol is part of an abandoned prototype.  Use SharedMatrix instead.
 */
function positionToRowCol(position) {
    const row = Math.floor(position / exports.maxCols);
    const col = position - (row * exports.maxCols);
    return { row, col };
}
exports.positionToRowCol = positionToRowCol;
/**
 * @deprecated SparseMatrix is an abandoned prototype.  Use SharedMatrix instead.
 */
class SparseMatrix extends _1.SharedSegmentSequence {
    constructor(document, id, attributes) {
        super(document, id, attributes, SparseMatrixFactory.segmentFromSpec);
        this.id = id;
    }
    /**
     * Create a new sparse matrix
     *
     * @param runtime - data store runtime the new sparse matrix belongs to
     * @param id - optional name of the sparse matrix
     * @returns newly create sparse matrix (but not attached yet)
     */
    static create(runtime, id) {
        return runtime.createChannel(id, SparseMatrixFactory.Type);
    }
    /**
     * Get a factory for SharedMap to register with the data store.
     *
     * @returns a factory that creates and load SharedMap
     */
    static getFactory() {
        return new SparseMatrixFactory();
    }
    get numRows() {
        return positionToRowCol(this.getLength()).row;
    }
    setItems(row, col, values, props) {
        const start = (0, exports.rowColToPosition)(row, col);
        const end = start + values.length;
        const segment = new RunSegment(values);
        if (props) {
            segment.addProperties(props);
        }
        this.replaceRange(start, end, segment);
    }
    getItem(row, col) {
        const pos = (0, exports.rowColToPosition)(row, col);
        const { segment, offset } = this.getContainingSegment(pos);
        if (segment && RunSegment.is(segment)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return segment.items[offset];
        }
        else if (segment && PaddingSegment.is(segment)) {
            return undefined;
        }
        throw new Error(`Unrecognized Segment type`);
    }
    getTag(row, col) {
        const { segment, offset } = this.getSegment(row, col);
        if (RunSegment.is(segment)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return segment.getTag(offset);
        }
        return undefined;
    }
    setTag(row, col, tag) {
        const { segment, offset } = this.getSegment(row, col);
        if (RunSegment.is(segment)) {
            segment.setTag(offset, tag);
        }
        else if (tag !== undefined) {
            throw new Error(`Must not attempt to set tags on '${segment.constructor.name}'.`);
        }
    }
    insertRows(row, numRows) {
        const pos = (0, exports.rowColToPosition)(row, 0);
        const size = exports.maxCols * numRows;
        const segment = new PaddingSegment(size);
        const insertOp = this.client.insertSegmentLocal(pos, segment);
        if (insertOp) {
            this.submitSequenceMessage(insertOp);
        }
    }
    removeRows(row, numRows) {
        const pos = (0, exports.rowColToPosition)(row, 0);
        const size = exports.maxCols * numRows;
        this.removeRange(pos, pos + size);
    }
    insertCols(col, numCols) {
        this.moveAsPadding(exports.maxCol - numCols, col, numCols);
    }
    removeCols(col, numCols) {
        this.moveAsPadding(col, exports.maxCol - numCols, numCols);
    }
    annotatePosition(row, col, props) {
        const pos = (0, exports.rowColToPosition)(row, col);
        this.annotateRange(pos, pos + 1, props);
    }
    getPositionProperties(row, col) {
        const pos = (0, exports.rowColToPosition)(row, col);
        return this.getPropertiesAtPosition(pos);
    }
    // For each row, moves 'numCols' items starting from 'srcCol' and inserts 'numCols' padding
    // at 'destCol'.  Used by insertCols and removeCols.
    moveAsPadding(srcCol, destCol, numCols) {
        const removeColStart = srcCol;
        const removeColEnd = srcCol + numCols;
        const ops = [];
        for (let r = 0, rowStart = 0; r < this.numRows; r++, rowStart += exports.maxCols) {
            ops.push(this.client.removeRangeLocal(rowStart + removeColStart, rowStart + removeColEnd));
            const insertPos = rowStart + destCol;
            const segment = new PaddingSegment(numCols);
            ops.push(this.client.insertSegmentLocal(insertPos, segment));
        }
        this.submitSequenceMessage((0, merge_tree_1.createGroupOp)(...ops));
    }
    getSegment(row, col) {
        const pos = (0, exports.rowColToPosition)(row, col);
        return this.getContainingSegment(pos);
    }
}
exports.SparseMatrix = SparseMatrix;
/**
 * @deprecated SparseMatrixFactory is an abandoned prototype.  Use SharedMatrixFactory instead.
 */
class SparseMatrixFactory {
    static segmentFromSpec(spec) {
        const maybePadding = PaddingSegment.fromJSONObject(spec);
        if (maybePadding) {
            return maybePadding;
        }
        const maybeRun = RunSegment.fromJSONObject(spec);
        if (maybeRun) {
            return maybeRun;
        }
        throw new Error(`Unrecognized IJSONObject: '${JSON.stringify(spec)}'`);
    }
    get type() {
        return SparseMatrixFactory.Type;
    }
    get attributes() {
        return SparseMatrixFactory.Attributes;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#IChannelFactory.load}
     */
    async load(runtime, id, services, attributes) {
        const sharedObject = new SparseMatrix(runtime, id, attributes);
        await sharedObject.load(services);
        return sharedObject;
    }
    create(document, id) {
        const sharedObject = new SparseMatrix(document, id, this.attributes);
        sharedObject.initializeLocal();
        return sharedObject;
    }
}
exports.SparseMatrixFactory = SparseMatrixFactory;
SparseMatrixFactory.Type = "https://graph.microsoft.com/types/mergeTree/sparse-matrix";
SparseMatrixFactory.Attributes = {
    type: SparseMatrixFactory.Type,
    snapshotFormatVersion: "0.1",
    packageVersion: packageVersion_1.pkgVersion,
};

},{"./":225,"./packageVersion":228,"@fluidframework/merge-tree":147}],238:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUser = exports.generateToken = exports.validateTokenClaimsExpiration = exports.validateTokenClaims = void 0;
const jsrsasign_1 = require("jsrsasign");
const jwt_decode_1 = __importDefault(require("jwt-decode"));
const uuid_1 = require("uuid");
const error_1 = require("./error");
/**
 * Validates a JWT token to authorize routerlicious.
 * Throws NetworkError if claims are invalid.
 * @returns - decoded claims.
 */
function validateTokenClaims(token, documentId, tenantId) {
    if (typeof token !== "string") {
        throw new error_1.NetworkError(403, `Token must be a string. Received: ${typeof token}`);
    }
    const claims = (0, jwt_decode_1.default)(token);
    if (!claims || claims.documentId !== documentId || claims.tenantId !== tenantId) {
        throw new error_1.NetworkError(403, "DocumentId and/or TenantId in token claims do not match requested resource");
    }
    if (claims.scopes === undefined || claims.scopes.length === 0) {
        throw new error_1.NetworkError(403, "Missing scopes in token claims");
    }
    return claims;
}
exports.validateTokenClaims = validateTokenClaims;
/**
 * Validates token claims' iat and exp properties to ensure valid token expiration.
 * Throws NetworkError if expiry is invalid.
 * @returns token lifetime in milliseconds.
 */
function validateTokenClaimsExpiration(claims, maxTokenLifetimeSec) {
    if (!claims.exp || !claims.iat || claims.exp - claims.iat > maxTokenLifetimeSec) {
        throw new error_1.NetworkError(403, "Invalid token expiry");
    }
    const lifeTimeMSec = (claims.exp * 1000) - (new Date()).getTime();
    if (lifeTimeMSec < 0) {
        throw new error_1.NetworkError(401, "Expired token");
    }
    return lifeTimeMSec;
}
exports.validateTokenClaimsExpiration = validateTokenClaimsExpiration;
/**
 * Generates a JWT token to authorize routerlicious. This function uses a browser friendly auth library (jsrsasign)
 * and should only be used in client context.
 */
// TODO: We should use this library in all client code rather than using jsrsasign directly.
function generateToken(tenantId, documentId, key, scopes, user, lifetime = 60 * 60, ver = "1.0") {
    let userClaim = (user) ? user : generateUser();
    if (userClaim.id === "" || userClaim.id === undefined) {
        userClaim = generateUser();
    }
    // Current time in seconds
    const now = Math.round((new Date()).getTime() / 1000);
    const claims = {
        documentId,
        scopes,
        tenantId,
        user: userClaim,
        iat: now,
        exp: now + lifetime,
        ver,
        jti: (0, uuid_1.v4)(),
    };
    const utf8Key = { utf8: key };
    return jsrsasign_1.KJUR.jws.JWS.sign(null, JSON.stringify({ alg: "HS256", typ: "JWT" }), claims, utf8Key);
}
exports.generateToken = generateToken;
function generateUser() {
    const randomUser = {
        id: (0, uuid_1.v4)(),
        name: (0, uuid_1.v4)(),
    };
    return randomUser;
}
exports.generateUser = generateUser;

},{"./error":241,"jsrsasign":396,"jwt-decode":259,"uuid":544}],239:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverVersionHeaderName = exports.CorrelationIdHeaderName = void 0;
exports.CorrelationIdHeaderName = "x-correlation-id";
exports.DriverVersionHeaderName = "x-driver-version";

},{}],240:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = void 0;
const debug_1 = require("debug");
const packageVersion_1 = require("./packageVersion");
exports.debug = (0, debug_1.debug)("fluid:services-client");
(0, exports.debug)(`Package: ${packageVersion_1.pkgName} - Version: ${packageVersion_1.pkgVersion}`);

},{"./packageVersion":247,"debug":346}],241:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwFluidServiceNetworkError = exports.createFluidServiceNetworkError = exports.isNetworkError = exports.NetworkError = void 0;
/**
 * Represents errors associated with network communication.
 *
 * @remarks
 * The Fluid Framework server implementation includes a collection of services that communicate with each other
 * over the network. Network communication is subject to a diverse range of errors. {@link NetworkError} helps
 * convey more information than a simple HTTP status code, allowing services to be aware of the context of a
 * network error and making those services more prepared to react to such kinds of errors.
 */
class NetworkError extends Error {
    constructor(
    /**
     * HTTP status code that describes the error.
     * @public
     */
    code, 
    /**
     * The message associated with the error.
     * @public
     */
    message, 
    /**
     * Optional boolean indicating whether this is an error that can be retried.
     * Only relevant when {@link NetworkError.isFatal} is false.
     * @public
     */
    canRetry, 
    /**
     * Optional boolean indicating whether this error is fatal. This generally indicates that the error causes
     * negative, non-recoverable impact to the component/caller and cannot be ignored.
     * @public
     */
    isFatal, 
    /**
     * Optional value representing the time in milliseconds that should be waited before retrying.
     * @public
     */
    retryAfterMs) {
        super(message);
        this.code = code;
        this.canRetry = canRetry;
        this.isFatal = isFatal;
        this.retryAfterMs = retryAfterMs;
        this.name = "NetworkError";
        this.retryAfter = retryAfterMs !== undefined ? retryAfterMs / 1000 : undefined;
    }
    /**
     * Gets the details associated with this {@link NetworkError}.
     * @returns A simple string conveying the message if no other details are included in this {@link NetworkError},
     * or an {@link INetworkErrorDetails} object otherwise.
     * @public
     */
    get details() {
        if (this.canRetry === undefined && this.isFatal === undefined && this.retryAfterMs === undefined) {
            return this.message;
        }
        return {
            message: this.message,
            canRetry: this.canRetry,
            isFatal: this.isFatal,
            retryAfter: this.retryAfter,
            retryAfterMs: this.retryAfterMs,
        };
    }
    /**
     * Explicitly define how to serialize as JSON so that socket.io can emit relevant info.
     * @public
     */
    toJSON() {
        return {
            code: this.code,
            message: this.message,
            canRetry: this.canRetry,
            isFatal: this.isFatal,
            retryAfterMs: this.retryAfterMs,
            retryAfter: this.retryAfter,
        };
    }
}
exports.NetworkError = NetworkError;
function isNetworkError(error) {
    return error.name === "NetworkError" &&
        typeof error.code === "number" &&
        typeof error.message === "string";
}
exports.isNetworkError = isNetworkError;
/**
 * Convenience function for generating a {@link NetworkError}.
 * @remarks Generates a {@link NetworkError} instance appropriately configured given the status code and error data
 * provided. This function is intended to be used in situations where a {@link NetworkError} is dynamically created
 * based variable parameters. That is, when it is not known whether the status code can be 404 or 500.
 * @param statusCode - HTTP status code that describes the error.
 * @param errorData - Optional additional data associated with the error. Can either be a simple string representing
 *  the message, or an {@link INetworkErrorDetails} object.
 * @returns A {@link NetworkError} instance properly configured according to the parameters provided.
 * @public
 */
function createFluidServiceNetworkError(statusCode, errorData) {
    var _a;
    let message;
    let canRetry;
    let isFatal;
    let retryAfter;
    if (errorData && typeof errorData === "object") {
        message = (_a = errorData.message) !== null && _a !== void 0 ? _a : "Unknown Error";
        canRetry = errorData.canRetry;
        isFatal = errorData.isFatal;
        retryAfter = errorData.retryAfter;
    }
    else if (errorData && typeof errorData === "string") {
        message = errorData;
    }
    else {
        message = "Unknown Error";
    }
    switch (statusCode) {
        case 401:
        case 403:
        case 404:
            return new NetworkError(statusCode, message, false, /* canRetry */ false); /* isFatal */
        case 413:
        case 422:
            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : false, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);
        case 429:
            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);
        case 500: {
            return new NetworkError(statusCode, message, canRetry !== null && canRetry !== void 0 ? canRetry : true, /* canRetry */ isFatal !== null && isFatal !== void 0 ? isFatal : false, /* isFatal */ canRetry ? retryAfter : undefined);
        }
        case 502:
        case 503:
        case 504:
            return new NetworkError(statusCode, message, true, /* canRetry */ false, /* isFatal */ retryAfter);
        default:
            return new NetworkError(statusCode, message, false, /* canRetry */ true); /* isFatal */
    }
}
exports.createFluidServiceNetworkError = createFluidServiceNetworkError;
/**
 * Convenience function to both generate and throw a {@link NetworkError}.
 * @remarks Similarly to {@link createFluidServiceNetworkError}, this function generates a {@link NetworkError}
 * instance appropriately configured given the status code and error data provided. The difference is that this
 * function also throws the {@link NetworkError}.
 * @param statusCode - HTTP status code that describes the error.
 * @param errorData - Optional additional data associated with the error. Can either be a simple string representing
 *  the message, or an {@link INetworkErrorDetails} object.
 * @public
 */
function throwFluidServiceNetworkError(statusCode, errorData) {
    const networkError = createFluidServiceNetworkError(statusCode, errorData);
    throw networkError;
}
exports.throwFluidServiceNetworkError = throwFluidServiceNetworkError;

},{}],242:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.choose = exports.getRandomName = void 0;
const sillyname_1 = __importDefault(require("sillyname"));
function getRandomName(connector = "_", capitalize = false) {
    let [first, last] = (0, sillyname_1.default)().split(" ");
    // sillyname output is capitalized by default
    if (!capitalize) {
        first = first.toLowerCase();
        last = last.toLowerCase();
    }
    return `${first}${connector}${last}`;
}
exports.getRandomName = getRandomName;
// Exposing a choose() function to align with moniker's API. Moniker is
// server-only, and we can swap it out with this function for the browser.
const choose = () => getRandomName();
exports.choose = choose;

},{"sillyname":533}],243:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitManager = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const api = __importStar(require("@fluidframework/protocol-definitions"));
const debug_1 = require("./debug");
class GitManager {
    constructor(historian) {
        this.historian = historian;
        this.blobCache = new Map();
        this.commitCache = new Map();
        this.treeCache = new Map();
        this.refCache = new Map();
    }
    async getHeader(id, sha) {
        const header = await this.historian.getHeader(sha);
        // Cache blobs that were sent in the header
        for (const blob of header.blobs) {
            this.blobCache.set(blob.sha, blob);
        }
        return (0, protocol_base_1.buildHierarchy)(header.tree);
    }
    async getFullTree(sha) {
        return this.historian.getFullTree(sha);
    }
    async getCommit(sha) {
        if (this.commitCache.has(sha)) {
            (0, debug_1.debug)(`Cache hit on ${sha}`);
            return this.commitCache.get(sha);
        }
        return this.historian.getCommit(sha);
    }
    /**
     * Reads the object with the given ID. We defer to the client implementation to do the actual read.
     */
    async getCommits(shaOrRef, count) {
        let sha = shaOrRef;
        // See if the sha is really a ref and convert
        if (this.refCache.has(shaOrRef)) {
            (0, debug_1.debug)(`Commit cache hit on ${shaOrRef}`);
            sha = this.refCache.get(shaOrRef);
            // Delete refcache after first use
            this.refCache.delete(shaOrRef);
            // If null is stored for the ref then there are no commits - return an empty array
            if (!sha) {
                return [];
            }
        }
        // See if the commit sha is hashed and return it if so
        if (this.commitCache.has(sha)) {
            const commit = this.commitCache.get(sha);
            return [{
                    commit: {
                        author: commit.author,
                        committer: commit.committer,
                        message: commit.message,
                        tree: commit.tree,
                        url: commit.url,
                    },
                    parents: commit.parents,
                    sha: commit.sha,
                    url: commit.url,
                }];
        }
        // Otherwise fall back to the historian
        return this.historian.getCommits(sha, count);
    }
    /**
     * Reads the object with the given ID. We defer to the client implementation to do the actual read.
     */
    async getTree(root, recursive = true) {
        if (this.treeCache.has(root)) {
            (0, debug_1.debug)(`Tree cache hit on ${root}`);
            return this.treeCache.get(root);
        }
        return this.historian.getTree(root, recursive);
    }
    async getBlob(sha) {
        if (this.blobCache.has(sha)) {
            (0, debug_1.debug)(`Blob cache hit on ${sha}`);
            return this.blobCache.get(sha);
        }
        return this.historian.getBlob(sha);
    }
    getRawUrl(sha) {
        return `${this.historian.endpoint}/git/blobs/raw/${sha}`;
    }
    /**
     * Retrieves the object at the given revision number
     */
    async getContent(commit, path) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.historian.getContent(path, commit);
    }
    async createBlob(content, encoding) {
        const blob = {
            content,
            encoding,
        };
        return this.historian.createBlob(blob);
    }
    async createGitTree(params) {
        const treeP = this.historian.createTree(params);
        return treeP;
    }
    async createTree(files) {
        return this.createTreeCore(files, 0);
    }
    async createCommit(commit) {
        return this.historian.createCommit(commit);
    }
    async createSummary(summary) {
        return this.historian.createSummary(summary);
    }
    async deleteSummary(softDelete) {
        return this.historian.deleteSummary(softDelete);
    }
    async getSummary(sha) {
        return this.historian.getSummary(sha);
    }
    async getRef(ref) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.historian
            .getRef(`heads/${ref}`)
            .catch((error) => {
            if (error === 400 || error === 404) {
                return null;
            }
            else {
                throw error;
            }
        });
    }
    async createRef(branch, sha) {
        const createRefParams = {
            ref: `refs/heads/${branch}`,
            sha,
            config: { enabled: true },
        };
        return this.historian.createRef(createRefParams);
    }
    async upsertRef(branch, commitSha) {
        // Update (force) the ref to the new commit
        const ref = {
            force: true,
            sha: commitSha,
            config: { enabled: true },
        };
        return this.historian.updateRef(`heads/${branch}`, ref);
    }
    addRef(ref, sha) {
        this.refCache.set(ref, sha);
    }
    addCommit(commit) {
        this.commitCache.set(commit.sha, commit);
    }
    addTree(tree) {
        this.treeCache.set(tree.sha, tree);
    }
    addBlob(blob) {
        this.blobCache.set(blob.sha, blob);
    }
    /**
     * Writes to the object with the given ID
     */
    async write(branch, inputTree, parents, message) {
        const tree = await this.createTree(inputTree);
        // Construct a commit for the tree
        const commitParams = {
            author: {
                date: new Date().toISOString(),
                email: "kurtb@microsoft.com",
                name: "Kurt Berglund",
            },
            message,
            parents,
            tree: tree.sha,
        };
        const commit = await this.historian.createCommit(commitParams);
        // Create or update depending on if ref exists.
        // TODO optimize the update to know up front if the ref exists
        const existingRef = await this.getRef(branch);
        if (existingRef) {
            await this.upsertRef(branch, commit.sha);
        }
        else {
            await this.createRef(branch, commit.sha);
        }
        return commit;
    }
    async createTreeCore(files, depth) {
        // If a id is specified use it rather than creating new
        if (files.id) {
            return this.getTree(files.id);
        }
        // Kick off the work to create all the tree values
        const entriesP = [];
        for (const entry of files.entries) {
            switch (api.TreeEntry[entry.type]) {
                case api.TreeEntry.Blob: {
                    const entryAsBlob = entry.value;
                    // Symlinks currently directly references a folder off the root of the tree. We adjust
                    // the path based on the depth of the tree
                    if (entry.mode === api.FileMode.Symlink) {
                        entryAsBlob.contents = this.translateSymlink(entryAsBlob.contents, depth);
                    }
                    const blobP = this.createBlob(entryAsBlob.contents, entryAsBlob.encoding);
                    entriesP.push(blobP);
                    break;
                }
                case api.TreeEntry.Tree: {
                    const entryAsTree = entry.value;
                    const treeBlobP = this.createTreeCore(entryAsTree, depth + 1);
                    entriesP.push(treeBlobP);
                    break;
                }
                default:
                    throw new Error("Unknown entry type");
            }
        }
        // Wait for them all to resolve
        const entries = await Promise.all(entriesP);
        const tree = [];
        (0, common_utils_1.assert)(entries.length === files.entries.length, "File entries length is not correct");
        // Construct a new tree from the collection of hashes
        for (let i = 0; i < files.entries.length; i++) {
            const type = files.entries[i].type === api.TreeEntry.Tree
                ? "tree"
                : (files.entries[i].type === api.TreeEntry.Blob ? "blob" : "commit");
            tree.push({
                mode: files.entries[i].mode,
                path: files.entries[i].path,
                sha: entries[i].sha,
                type,
            });
        }
        const requestBody = {
            tree,
        };
        const treeP = this.historian.createTree(requestBody);
        return treeP;
    }
    translateSymlink(link, depth) {
        let prefix = "";
        for (let i = 0; i <= depth; i++) {
            prefix += "../";
        }
        return `${prefix}${link}`;
    }
}
exports.GitManager = GitManager;

},{"./debug":240,"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174}],244:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Historian = exports.getAuthorizationTokenFromCredentials = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const restWrapper_1 = require("./restWrapper");
function endsWith(value, endings) {
    for (const ending of endings) {
        if (value.endsWith(ending)) {
            return true;
        }
    }
    return false;
}
const getAuthorizationTokenFromCredentials = (credentials) => `Basic ${(0, common_utils_1.fromUtf8ToBase64)(`${credentials.user}:${credentials.password}`)}`;
exports.getAuthorizationTokenFromCredentials = getAuthorizationTokenFromCredentials;
/**
 * Implementation of the IHistorian interface that calls out to a REST interface
 */
class Historian {
    constructor(endpoint, historianApi, disableCache, restWrapper) {
        this.endpoint = endpoint;
        this.historianApi = historianApi;
        this.restWrapper = restWrapper;
        this.defaultQueryString = {};
        if (disableCache && this.historianApi) {
            this.defaultQueryString.disableCache = disableCache;
            this.cacheBust = false;
        }
        else {
            this.cacheBust = disableCache;
        }
        if (this.restWrapper === undefined) {
            this.restWrapper = new restWrapper_1.BasicRestWrapper(this.endpoint);
        }
    }
    async getHeader(sha) {
        if (this.historianApi) {
            return this.restWrapper.get(`/headers/${encodeURIComponent(sha)}`, this.getQueryString());
        }
        else {
            return this.getHeaderDirect(sha);
        }
    }
    async getFullTree(sha) {
        return this.restWrapper.get(`/tree/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async getBlob(sha) {
        return this.restWrapper.get(`/git/blobs/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async createBlob(blob) {
        return this.restWrapper.post(`/git/blobs`, blob, this.getQueryString());
    }
    async getContent(path, ref) {
        return this.restWrapper.get(`/contents/${path}`, this.getQueryString({ ref }));
    }
    async getCommits(sha, count) {
        return this.restWrapper.get(`/commits`, this.getQueryString({ count, sha }))
            .catch((error) => (error === 400 || error === 404) ?
            [] : Promise.reject(error));
    }
    async getCommit(sha) {
        return this.restWrapper.get(`/git/commits/${encodeURIComponent(sha)}`, this.getQueryString());
    }
    async createCommit(commit) {
        return this.restWrapper.post(`/git/commits`, commit, this.getQueryString());
    }
    async getRefs() {
        return this.restWrapper.get(`/git/refs`, this.getQueryString());
    }
    async getRef(ref) {
        return this.restWrapper.get(`/git/refs/${ref}`, this.getQueryString());
    }
    async createRef(params) {
        return this.restWrapper.post(`/git/refs`, params, this.getQueryString());
    }
    async updateRef(ref, params) {
        return this.restWrapper.patch(`/git/refs/${ref}`, params, this.getQueryString());
    }
    async deleteRef(ref) {
        await this.restWrapper.delete(`/git/refs/${ref}`, this.getQueryString());
    }
    async createTag(tag) {
        return this.restWrapper.post(`/git/tags`, tag, this.getQueryString());
    }
    async getTag(tag) {
        return this.restWrapper.get(`/git/tags/${tag}`, this.getQueryString());
    }
    async createTree(tree) {
        return this.restWrapper.post(`/git/trees`, tree, this.getQueryString());
    }
    async getTree(sha, recursive) {
        return this.restWrapper.get(`/git/trees/${encodeURIComponent(sha)}`, this.getQueryString({ recursive: recursive ? 1 : 0 }));
    }
    async createSummary(summary) {
        return this.restWrapper.post(`/git/summaries`, summary, this.getQueryString());
    }
    async deleteSummary(softDelete) {
        const headers = { "Soft-Delete": softDelete };
        return this.restWrapper.delete(`/git/summaries`, this.getQueryString(), headers);
    }
    async getSummary(sha) {
        return this.restWrapper.get(`/git/summaries/${sha}`, this.getQueryString());
    }
    async getHeaderDirect(sha) {
        const tree = await this.getTree(sha, true);
        const includeBlobs = [".attributes", ".blobs", ".messages", "header"];
        const blobsP = [];
        for (const entry of tree.tree) {
            if (entry.type === "blob" && endsWith(entry.path, includeBlobs)) {
                const blobP = this.getBlob(entry.sha);
                blobsP.push(blobP);
            }
        }
        const blobs = await Promise.all(blobsP);
        return {
            blobs,
            tree,
        };
    }
    getQueryString(queryString) {
        if (this.cacheBust) {
            return Object.assign(Object.assign({ cacheBust: Date.now() }, this.defaultQueryString), queryString);
        }
        return Object.assign(Object.assign({}, this.defaultQueryString), queryString);
    }
}
exports.Historian = Historian;

},{"./restWrapper":250,"@fluidframework/common-utils":29}],245:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./auth"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./error"), exports);
__exportStar(require("./generateNames"), exports);
__exportStar(require("./gitManager"), exports);
__exportStar(require("./historian"), exports);
__exportStar(require("./interfaces"), exports);
__exportStar(require("./promiseTimeout"), exports);
__exportStar(require("./restLessClient"), exports);
__exportStar(require("./restWrapper"), exports);
__exportStar(require("./rollingHash"), exports);
__exportStar(require("./scopes"), exports);
__exportStar(require("./storage"), exports);
__exportStar(require("./storageContracts"), exports);
__exportStar(require("./storageUtils"), exports);
__exportStar(require("./summaryTreeUploadManager"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./wholeSummaryUploadManager"), exports);

},{"./auth":238,"./constants":239,"./error":241,"./generateNames":242,"./gitManager":243,"./historian":244,"./interfaces":246,"./promiseTimeout":248,"./restLessClient":249,"./restWrapper":250,"./rollingHash":251,"./scopes":252,"./storage":253,"./storageContracts":254,"./storageUtils":255,"./summaryTreeUploadManager":256,"./utils":257,"./wholeSummaryUploadManager":258}],246:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134}],247:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/server-services-client";
exports.pkgVersion = "0.1036.5001";

},{}],248:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.promiseTimeout = void 0;
/*
 * Rejects if a promise is not fulfilled within <mSec> milliseconds.
*/
async function promiseTimeout(mSec, promise) {
    const timeout = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            clearTimeout(id);
            reject(new Error(`Timed out in ${mSec} milliseconds.`));
        }, mSec);
    });
    return Promise.race([
        promise,
        timeout,
    ]);
}
exports.promiseTimeout = promiseTimeout;

},{}],249:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RestLessClient = exports.RestLessFieldNames = void 0;
var RestLessFieldNames;
(function (RestLessFieldNames) {
    RestLessFieldNames["Method"] = "method";
    RestLessFieldNames["Header"] = "header";
    RestLessFieldNames["Body"] = "body";
})(RestLessFieldNames = exports.RestLessFieldNames || (exports.RestLessFieldNames = {}));
const encodeHeader = (headerKey, headerValue) => {
    return `${headerKey}: ${headerValue}`;
};
/**
 * Client for communicating with a "RestLess" server.
 * Translates a typical RESTful HTTP request into "RestLess" HTTP format:
 *
 * POST \<path\> HTTP/\<1.1|2\>
 *
 * HOST \<hostname\>
 *
 * Content-Type: application/x-www-form-urlencoded
 *
 * <url-encoded-headers-body-and-method>
 */
class RestLessClient {
    /**
     * Translates request from REST to "RestLess" out-of-place.
     */
    translate(request) {
        var _a, _b;
        const newRequest = Object.assign({}, request);
        const body = new URLSearchParams();
        body.append(RestLessFieldNames.Method, (_a = newRequest.method) !== null && _a !== void 0 ? _a : "GET");
        if (newRequest.headers) {
            for (const [headerKey, headerValue] of Object.entries(newRequest.headers)) {
                const encodedHeader = encodeHeader(headerKey, headerValue);
                body.append(RestLessFieldNames.Header, encodedHeader);
            }
        }
        if (newRequest.data && ["post", "put", "patch"].includes((_b = newRequest.method) === null || _b === void 0 ? void 0 : _b.toLowerCase())) {
            const stringifiedBody = JSON.stringify(newRequest.data);
            body.append(RestLessFieldNames.Body, stringifiedBody);
        }
        newRequest.data = body.toString();
        newRequest.method = "POST";
        newRequest.headers = {
            // TODO: when we support blob/file uploads, we should potentially add compatibility with multipart/form-data
            "Content-Type": "application/x-www-form-urlencoded;restless",
        };
        return newRequest;
    }
}
exports.RestLessClient = RestLessClient;

},{}],250:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicRestWrapper = exports.RestWrapper = void 0;
const querystring = __importStar(require("querystring"));
const json_stringify_safe_1 = __importDefault(require("json-stringify-safe"));
const axios_1 = __importDefault(require("axios"));
const uuid_1 = require("uuid");
const debug_1 = require("./debug");
const error_1 = require("./error");
const constants_1 = require("./constants");
class RestWrapper {
    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024) {
        this.baseurl = baseurl;
        this.defaultQueryString = defaultQueryString;
        this.maxBodyLength = maxBodyLength;
        this.maxContentLength = maxContentLength;
    }
    async get(url, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "GET",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 200);
    }
    async post(url, requestBody, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            data: requestBody,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "POST",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 201);
    }
    async delete(url, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "DELETE",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 204);
    }
    async patch(url, requestBody, queryString, headers) {
        const options = {
            baseURL: this.baseurl,
            data: requestBody,
            headers,
            maxBodyLength: this.maxBodyLength,
            maxContentLength: this.maxContentLength,
            method: "PATCH",
            url: `${url}${this.generateQueryString(queryString)}`,
        };
        return this.request(options, 200);
    }
    generateQueryString(queryStringValues) {
        if (this.defaultQueryString || queryStringValues) {
            const queryStringMap = Object.assign(Object.assign({}, this.defaultQueryString), queryStringValues);
            const queryString = querystring.stringify(queryStringMap);
            if (queryString !== "") {
                return `?${queryString}`;
            }
        }
        return "";
    }
}
exports.RestWrapper = RestWrapper;
class BasicRestWrapper extends RestWrapper {
    constructor(baseurl, defaultQueryString = {}, maxBodyLength = 1000 * 1024 * 1024, maxContentLength = 1000 * 1024 * 1024, defaultHeaders = {}, axios = axios_1.default, refreshDefaultQueryString, refreshDefaultHeaders, getCorrelationId) {
        super(baseurl, defaultQueryString, maxBodyLength, maxContentLength);
        this.defaultHeaders = defaultHeaders;
        this.axios = axios;
        this.refreshDefaultQueryString = refreshDefaultQueryString;
        this.refreshDefaultHeaders = refreshDefaultHeaders;
        this.getCorrelationId = getCorrelationId;
    }
    async request(requestConfig, statusCode, canRetry = true) {
        var _a, _b;
        const options = Object.assign({}, requestConfig);
        options.headers = this.generateHeaders(options.headers, (_b = (_a = this.getCorrelationId) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : (0, uuid_1.v4)());
        return new Promise((resolve, reject) => {
            this.axios.request(options)
                .then((response) => { resolve(response.data); })
                .catch((error) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                if (((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) === statusCode) {
                    // Axios misinterpreted as error, return as successful response
                    resolve((_b = error === null || error === void 0 ? void 0 : error.response) === null || _b === void 0 ? void 0 : _b.data);
                }
                if (error === null || error === void 0 ? void 0 : error.config) {
                    // eslint-disable-next-line max-len
                    (0, debug_1.debug)(`[${error.config.method}] request to [${(_c = error.config.baseURL) !== null && _c !== void 0 ? _c : ""}${(_d = error.config.url) !== null && _d !== void 0 ? _d : ""}] failed with [${(_e = error.response) === null || _e === void 0 ? void 0 : _e.status}] [${(0, json_stringify_safe_1.default)((_f = error.response) === null || _f === void 0 ? void 0 : _f.data, undefined, 2)}]`);
                }
                else {
                    (0, debug_1.debug)(`request to ${options.url} failed ${error ? error.message : ""}`);
                }
                if (((_g = error === null || error === void 0 ? void 0 : error.response) === null || _g === void 0 ? void 0 : _g.status) === 429 && ((_j = (_h = error === null || error === void 0 ? void 0 : error.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.retryAfter) > 0 && canRetry) {
                    setTimeout(() => {
                        this.request(options, statusCode)
                            .then(resolve)
                            .catch(reject);
                    }, error.response.data.retryAfter * 1000);
                }
                else if (((_k = error === null || error === void 0 ? void 0 : error.response) === null || _k === void 0 ? void 0 : _k.status) === 401 && canRetry && this.refreshOnAuthError()) {
                    const retryConfig = Object.assign({}, requestConfig);
                    retryConfig.headers = this.generateHeaders(retryConfig.headers, options.headers[constants_1.CorrelationIdHeaderName]);
                    this.request(retryConfig, statusCode, false)
                        .then(resolve)
                        .catch(reject);
                }
                else {
                    // From https://axios-http.com/docs/handling_errors
                    if (error === null || error === void 0 ? void 0 : error.response) {
                        // The request was made and the server responded with a status code
                        // that falls out of the range of 2xx
                        reject((0, error_1.createFluidServiceNetworkError)((_l = error === null || error === void 0 ? void 0 : error.response) === null || _l === void 0 ? void 0 : _l.status, (_m = error === null || error === void 0 ? void 0 : error.response) === null || _m === void 0 ? void 0 : _m.data));
                    }
                    else if (error === null || error === void 0 ? void 0 : error.request) {
                        // The request was made but no response was received. That can happen if a service is
                        // temporarily down or inaccessible due to network failures. We leverage that in here
                        // to detect network failures and transform them into a NetworkError with code 502,
                        // which can be retried and is not fatal.
                        reject((0, error_1.createFluidServiceNetworkError)(502, `Network Error: ${(_o = error === null || error === void 0 ? void 0 : error.message) !== null && _o !== void 0 ? _o : "undefined"}`));
                    }
                    else {
                        // Something happened in setting up the request that triggered an Error
                        const details = {
                            canRetry: false,
                            isFatal: false,
                            message: (_p = error === null || error === void 0 ? void 0 : error.message) !== null && _p !== void 0 ? _p : "Unknown Error",
                        };
                        reject((0, error_1.createFluidServiceNetworkError)(500, details));
                    }
                }
            });
        });
    }
    generateHeaders(headers, fallbackCorrelationId) {
        let result = headers !== null && headers !== void 0 ? headers : {};
        if (this.defaultHeaders) {
            result = Object.assign(Object.assign({}, this.defaultHeaders), headers);
        }
        if (result[constants_1.CorrelationIdHeaderName]) {
            return result;
        }
        return Object.assign({ [constants_1.CorrelationIdHeaderName]: fallbackCorrelationId }, result);
    }
    refreshOnAuthError() {
        if (this.refreshDefaultQueryString === undefined && this.refreshDefaultHeaders === undefined) {
            // retry will not succeed with the same params and headers
            return false;
        }
        if (this.refreshDefaultHeaders !== undefined) {
            this.defaultHeaders = this.refreshDefaultHeaders();
        }
        if (this.refreshDefaultQueryString !== undefined) {
            this.defaultQueryString = this.refreshDefaultQueryString();
        }
        return true;
    }
}
exports.BasicRestWrapper = BasicRestWrapper;

},{"./constants":239,"./debug":240,"./error":241,"axios":313,"json-stringify-safe":395,"querystring":568,"uuid":544}],251:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextHash = exports.defaultHash = void 0;
const crc_32_1 = require("crc-32");
// default hash/seed value.
exports.defaultHash = "00000000";
const clientIdProperty = "clientId";
const sequenceNumberProperty = "sequenceNumber";
const minimumSequenceNumberProperty = "minimumSequenceNumber";
const clientSequenceNumberProperty = "clientSequenceNumber";
const referenceSequenceNumberProperty = "referenceSequenceNumber";
const typeProperty = "type";
const timestampProperty = "timestamp";
const dataProperty = "data";
// Ordering of these fields decides the ordering of serialized message.
const fields = [
    clientIdProperty,
    sequenceNumberProperty,
    minimumSequenceNumberProperty,
    clientSequenceNumberProperty,
    referenceSequenceNumberProperty,
    typeProperty,
    timestampProperty,
    dataProperty,
];
function getNextHash(message, lastHash) {
    const messageWithData = message;
    // Should we just use stringified JSON or come up with our own serialization of values?
    const serializedMessage = JSON.stringify(messageWithData, fields);
    const hash = (0, crc_32_1.str)(serializedMessage, parseInt(lastHash, 16));
    return hash.toString(16);
}
exports.getNextHash = getNextHash;

},{"crc-32":344}],252:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.canSummarize = exports.canWrite = exports.canRead = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const canRead = (scopes) => scopes.includes(protocol_definitions_1.ScopeType.DocRead);
exports.canRead = canRead;
const canWrite = (scopes) => scopes.includes(protocol_definitions_1.ScopeType.DocWrite);
exports.canWrite = canWrite;
const canSummarize = (scopes) => scopes.includes(protocol_definitions_1.ScopeType.SummaryWrite);
exports.canSummarize = canSummarize;

},{"@fluidframework/protocol-definitions":174}],253:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });

},{}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],255:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertWholeFlatSummaryToSnapshotTreeAndBlobs = exports.convertSummaryTreeToWholeSummaryTree = exports.buildTreePath = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Convert a list of nodes to a tree path.
 * If a node is empty (blank) it will be removed.
 * If a node's name begins and/or ends with a "/", it will be removed.
 * @param nodeNames - node names in path
 */
const buildTreePath = (...nodeNames) => nodeNames
    .map((nodeName) => nodeName.replace(/^\//, "").replace(/\/$/, ""))
    .filter((nodeName) => !!nodeName)
    .join("/");
exports.buildTreePath = buildTreePath;
/**
 * Converts the summary tree to a whole summary tree to be uploaded. Always upload full whole summary tree.
 * @param parentHandle - Handle of the last uploaded summary or detach new summary.
 * @param tree - Summary Tree which will be converted to whole summary tree to be uploaded.
 * @param path - Current path of node which is getting evaluated.
 */
function convertSummaryTreeToWholeSummaryTree(parentHandle, tree, path = "", rootNodeName = "") {
    const wholeSummaryTree = {
        type: "tree",
        entries: [],
    };
    const keys = Object.keys(tree.tree);
    for (const key of keys) {
        const summaryObject = tree.tree[key];
        let id;
        let value;
        let unreferenced;
        const currentPath = path === ""
            ? (0, exports.buildTreePath)(rootNodeName, key)
            : (0, exports.buildTreePath)(path, key);
        switch (summaryObject.type) {
            case protocol_definitions_1.SummaryType.Tree: {
                const result = convertSummaryTreeToWholeSummaryTree(parentHandle, summaryObject, currentPath, rootNodeName);
                value = result;
                unreferenced = summaryObject.unreferenced || undefined;
                break;
            }
            case protocol_definitions_1.SummaryType.Blob: {
                if (typeof summaryObject.content === "string") {
                    value = {
                        type: "blob",
                        content: summaryObject.content,
                        encoding: "utf-8",
                    };
                }
                else {
                    value = {
                        type: "blob",
                        content: (0, common_utils_1.Uint8ArrayToString)(summaryObject.content, "base64"),
                        encoding: "base64",
                    };
                }
                break;
            }
            case protocol_definitions_1.SummaryType.Handle: {
                const handleValue = summaryObject;
                if (handleValue.embedded) {
                    id = summaryObject.handle;
                }
                else {
                    if (!parentHandle) {
                        throw Error("Parent summary does not exist to reference by handle.");
                    }
                    id = (0, exports.buildTreePath)(parentHandle, rootNodeName, summaryObject.handle);
                }
                break;
            }
            case protocol_definitions_1.SummaryType.Attachment: {
                id = summaryObject.id;
                break;
            }
            default: {
                (0, common_utils_1.unreachableCase)(summaryObject, `Unknown type: ${summaryObject.type}`);
            }
        }
        const baseEntry = {
            path: encodeURIComponent(key),
            type: (0, protocol_base_1.getGitType)(summaryObject),
        };
        let entry;
        if (value) {
            (0, common_utils_1.assert)(id === undefined, 0x0ad /* "Snapshot entry has both a tree value and a referenced id!" */);
            entry = Object.assign({ value,
                unreferenced }, baseEntry);
        }
        else if (id) {
            entry = Object.assign(Object.assign({}, baseEntry), { id });
        }
        else {
            throw new Error(`Invalid tree entry for ${summaryObject.type}`);
        }
        wholeSummaryTree.entries.push(entry);
    }
    return wholeSummaryTree;
}
exports.convertSummaryTreeToWholeSummaryTree = convertSummaryTreeToWholeSummaryTree;
/**
 * Build a tree heirarchy from a flat tree.
 *
 * @param flatTree - a flat tree
 * @param treePrefixToRemove - tree prefix to strip
 * @returns the heirarchical tree
 */
function buildHierarchy(flatTree, treePrefixToRemove) {
    const lookup = {};
    // Root tree id will be used to determine which version was downloaded.
    const root = { id: flatTree.id, blobs: {}, trees: {} };
    lookup[""] = root;
    for (const entry of flatTree.entries) {
        // Strip the `treePrefixToRemove` path from tree entries such that they are stored under root.
        const entryPath = entry.path.replace(new RegExp(`^${treePrefixToRemove}/`), "");
        const lastIndex = entryPath.lastIndexOf("/");
        const entryPathDir = entryPath.slice(0, Math.max(0, lastIndex));
        const entryPathBase = entryPath.slice(lastIndex + 1);
        // The flat output is breadth-first so we can assume we see tree nodes prior to their contents
        const node = lookup[entryPathDir];
        // Add in either the blob or tree
        if (entry.type === "tree") {
            const newTree = { blobs: {}, trees: {}, unreferenced: entry.unreferenced };
            node.trees[decodeURIComponent(entryPathBase)] = newTree;
            lookup[entryPath] = newTree;
        }
        else if (entry.type === "blob") {
            node.blobs[decodeURIComponent(entryPathBase)] = entry.id;
        }
        else {
            throw new Error(`Unknown entry type!!`);
        }
    }
    return root;
}
/**
 * Converts existing IWholeFlatSummary to snapshot tree, blob array, and sequence number.
 *
 * @param flatSummary - flat summary
 * @param treePrefixToRemove - tree prefix to strip. By default we are stripping ".app" prefix
 * @returns snapshot tree, blob array, and sequence number
 */
function convertWholeFlatSummaryToSnapshotTreeAndBlobs(flatSummary, treePrefixToRemove = ".app") {
    var _a;
    const blobs = new Map();
    if (flatSummary.blobs) {
        flatSummary.blobs.forEach((blob) => {
            var _a;
            blobs.set(blob.id, (0, common_utils_1.stringToBuffer)(blob.content, (_a = blob.encoding) !== null && _a !== void 0 ? _a : "utf-8"));
        });
    }
    const flatSummaryTree = (_a = flatSummary.trees) === null || _a === void 0 ? void 0 : _a[0];
    const sequenceNumber = flatSummaryTree === null || flatSummaryTree === void 0 ? void 0 : flatSummaryTree.sequenceNumber;
    const snapshotTree = buildHierarchy(flatSummaryTree, treePrefixToRemove);
    return {
        blobs,
        snapshotTree,
        sequenceNumber,
    };
}
exports.convertWholeFlatSummaryToSnapshotTreeAndBlobs = convertWholeFlatSummaryToSnapshotTreeAndBlobs;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174}],256:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummaryTreeUploadManager = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
/**
 * Recursively writes summary tree as individual summary blobs.
 */
class SummaryTreeUploadManager {
    constructor(manager, blobsShaCache, getPreviousFullSnapshot) {
        this.manager = manager;
        this.blobsShaCache = blobsShaCache;
        this.getPreviousFullSnapshot = getPreviousFullSnapshot;
    }
    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {
        const previousFullSnapshot = await this.getPreviousFullSnapshot(parentHandle);
        return this.writeSummaryTreeCore(summaryTree, previousFullSnapshot !== null && previousFullSnapshot !== void 0 ? previousFullSnapshot : undefined);
    }
    async writeSummaryTreeCore(summaryTree, previousFullSnapshot) {
        const entries = await Promise.all(Object.keys(summaryTree.tree).map(async (key) => {
            const entry = summaryTree.tree[key];
            const pathHandle = await this.writeSummaryTreeObject(entry, previousFullSnapshot);
            const treeEntry = {
                mode: (0, protocol_base_1.getGitMode)(entry),
                path: encodeURIComponent(key),
                sha: pathHandle,
                type: (0, protocol_base_1.getGitType)(entry),
            };
            return treeEntry;
        }));
        const treeHandle = await this.manager.createGitTree({ tree: entries });
        return treeHandle.sha;
    }
    async writeSummaryTreeObject(object, previousFullSnapshot) {
        switch (object.type) {
            case protocol_definitions_1.SummaryType.Blob: {
                return this.writeSummaryBlob(object.content);
            }
            case protocol_definitions_1.SummaryType.Handle: {
                if (previousFullSnapshot === undefined) {
                    throw Error("Parent summary does not exist to reference by handle.");
                }
                return this.getIdFromPath(object.handleType, object.handle, previousFullSnapshot);
            }
            case protocol_definitions_1.SummaryType.Tree: {
                return this.writeSummaryTreeCore(object, previousFullSnapshot);
            }
            case protocol_definitions_1.SummaryType.Attachment: {
                return object.id;
            }
            default:
                (0, common_utils_1.unreachableCase)(object, `Unknown type: ${object.type}`);
        }
    }
    async writeSummaryBlob(content) {
        const { parsedContent, encoding } = typeof content === "string"
            ? { parsedContent: content, encoding: "utf-8" }
            : { parsedContent: (0, common_utils_1.Uint8ArrayToString)(content, "base64"), encoding: "base64" };
        // The gitHashFile would return the same hash as returned by the server as blob.sha
        const hash = await (0, common_utils_1.gitHashFile)(common_utils_1.IsoBuffer.from(parsedContent, encoding));
        if (!this.blobsShaCache.has(hash)) {
            this.blobsShaCache.set(hash, "");
            const blob = await this.manager.createBlob(parsedContent, encoding);
            (0, common_utils_1.assert)(hash === blob.sha, 0x0b6 /* "Blob.sha and hash do not match!!" */);
        }
        return hash;
    }
    getIdFromPath(handleType, handlePath, previousFullSnapshot) {
        const path = handlePath.split("/").map((part) => decodeURIComponent(part));
        if (path[0] === "") {
            // root of tree should be unnamed
            path.shift();
        }
        if (path.length === 0) {
            return previousFullSnapshot.id;
        }
        return this.getIdFromPathCore(handleType, path, previousFullSnapshot);
    }
    getIdFromPathCore(handleType, path, 
    /** Previous snapshot, subtree relative to this path part */
    previousSnapshot) {
        var _a;
        (0, common_utils_1.assert)(path.length > 0, 0x0b3 /* "Expected at least 1 path part" */);
        const key = path[0];
        if (path.length === 1) {
            switch (handleType) {
                case protocol_definitions_1.SummaryType.Blob: {
                    const tryId = previousSnapshot.blobs[key];
                    (0, common_utils_1.assert)(!!tryId, 0x0b4 /* "Parent summary does not have blob handle for specified path." */);
                    return tryId;
                }
                case protocol_definitions_1.SummaryType.Tree: {
                    const tryId = (_a = previousSnapshot.trees[key]) === null || _a === void 0 ? void 0 : _a.id;
                    (0, common_utils_1.assert)(!!tryId, 0x0b5 /* "Parent summary does not have tree handle for specified path." */);
                    return tryId;
                }
                default:
                    throw Error(`Unexpected handle summary object type: "${handleType}".`);
            }
        }
        return this.getIdFromPathCore(handleType, path.slice(1), previousSnapshot.trees[key]);
    }
}
exports.SummaryTreeUploadManager = SummaryTreeUploadManager;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174}],257:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrCreateRepository = void 0;
const axios_1 = __importDefault(require("axios"));
async function getOrCreateRepository(endpoint, owner, repository, headers) {
    console.log(`Get Repo: ${endpoint}/${owner}/${repository}`);
    const details = await axios_1.default.get(`${endpoint}/repos/${owner}/${repository}`, { headers })
        .catch((error) => {
        if (error.response && error.response.status === 400) {
            return null;
        }
        else {
            throw error;
        }
    });
    if (!details || details.status === 400) {
        console.log(`Create Repo: ${endpoint}/${owner}/${repository}`);
        const createParams = {
            name: repository,
        };
        await axios_1.default.post(`${endpoint}/${owner}/repos`, createParams, { headers });
    }
}
exports.getOrCreateRepository = getOrCreateRepository;

},{"axios":313}],258:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WholeSummaryUploadManager = void 0;
const storageUtils_1 = require("./storageUtils");
/**
 * Converts summary to snapshot tree and uploads with single snaphot tree payload.
 */
class WholeSummaryUploadManager {
    constructor(manager) {
        this.manager = manager;
    }
    async writeSummaryTree(summaryTree, parentHandle, summaryType, sequenceNumber) {
        const id = await this.writeSummaryTreeCore(parentHandle, summaryTree, summaryType, sequenceNumber !== null && sequenceNumber !== void 0 ? sequenceNumber : 0);
        if (!id) {
            throw new Error(`Failed to write summary tree`);
        }
        return id;
    }
    async writeSummaryTreeCore(parentHandle, tree, type, sequenceNumber) {
        const snapshotTree = (0, storageUtils_1.convertSummaryTreeToWholeSummaryTree)(parentHandle, tree, "", type === "channel" ? ".app" : "");
        const snapshotPayload = {
            entries: snapshotTree.entries,
            message: undefined,
            sequenceNumber,
            type,
        };
        return this.manager.createSummary(snapshotPayload).then((response) => response.id);
    }
}
exports.WholeSummaryUploadManager = WholeSummaryUploadManager;

},{"./storageUtils":255}],259:[function(require,module,exports){
"use strict";function e(e){this.message=e}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r="undefined"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,"");if(t.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var n,o,a=0,i=0,c="";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o);return c};function t(e){var t=e.replace(/-/g,"+").replace(/_/g,"/");switch(t.length%4){case 0:break;case 2:t+="==";break;case 3:t+="=";break;default:throw"Illegal base64url string!"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t="0"+t),"%"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if("string"!=typeof e)throw new n("Invalid token specified");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(".")[o]))}catch(e){throw new n("Invalid token specified: "+e.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";const a=o;a.default=o,a.InvalidTokenError=n,module.exports=a;


},{}],260:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedObjectHandle = void 0;
const datastore_1 = require("@fluidframework/datastore");
/**
 * Handle for shared object
 * This object is used for already loaded (in-memory) shared object
 * and is used only for serialization purposes.
 * De-serialization process goes through FluidObjectHandle and request flow:
 * FluidDataStoreRuntime.request() recognizes requests in the form of '/\<shared object id\>'
 * and loads shared object.
 */
class SharedObjectHandle extends datastore_1.FluidObjectHandle {
    /**
     * Whether services have been attached for the associated shared object.
     */
    get isAttached() {
        return this.value.isAttached();
    }
    /**
     * Creates a new SharedObjectHandle.
     * @param value - The shared object this handle is for.
     * @param path - The id of the shared object. It is also the path to this object relative to the routeContext.
     * @param routeContext - The parent IFluidHandleContext that has a route to this handle.
     */
    constructor(value, path, routeContext) {
        super(value, path, routeContext);
    }
    /**
     * Attaches all bound handles first (which may in turn attach further handles), then attaches this handle.
     * When attaching the handle, it registers the associated shared object.
     */
    attachGraph() {
        this.value.bindToContext();
        super.attachGraph();
    }
}
exports.SharedObjectHandle = SharedObjectHandle;

},{"@fluidframework/datastore":93}],261:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./serializer"), exports);
__exportStar(require("./sharedObject"), exports);
__exportStar(require("./summarySerializer"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./valueType"), exports);

},{"./serializer":263,"./sharedObject":264,"./summarySerializer":265,"./types":266,"./utils":267,"./valueType":268}],262:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteFluidObjectHandle = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_runtime_1 = require("@fluidframework/container-runtime");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
 * This handle is used to dynamically load a Fluid object on a remote client and is created on parsing a serialized
 * FluidObjectHandle.
 * This class is used to generate an IFluidHandle when de-serializing any all handles (including handles to DDSes,
 * custom objects) that are stored in SharedObjects. The Data Store or SharedObject corresponding to the
 * IFluidHandle can be retrieved by calling `get` on it.
 */
class RemoteFluidObjectHandle {
    /**
     * Creates a new RemoteFluidObjectHandle when parsing an IFluidHandle.
     * @param absolutePath - The absolute path to the handle from the container runtime.
     * @param routeContext - The root IFluidHandleContext that has a route to this handle.
     */
    constructor(absolutePath, routeContext) {
        this.absolutePath = absolutePath;
        this.routeContext = routeContext;
        this.isAttached = true;
        (0, common_utils_1.assert)(absolutePath.startsWith("/"), 0x19d /* "Handles should always have absolute paths" */);
    }
    get IFluidRouter() { return this; }
    get IFluidHandleContext() { return this; }
    get IFluidHandle() { return this; }
    async get() {
        if (this.objectP === undefined) {
            // Add `viaHandle` header to distinguish from requests from non-handle paths.
            const request = { url: this.absolutePath, headers: { [container_runtime_1.RuntimeHeaders.viaHandle]: true } };
            this.objectP = this.routeContext.resolveHandle(request)
                .then((response) => {
                if (response.mimeType === "fluid/object") {
                    const fluidObject = response.value;
                    return fluidObject;
                }
                throw (0, runtime_utils_1.responseToException)(response, request);
            });
        }
        return this.objectP;
    }
    attachGraph() {
        return;
    }
    bind(handle) {
        handle.attachGraph();
    }
    async request(request) {
        try {
            const object = await this.get();
            const router = object.IFluidRouter;
            return router !== undefined
                ? router.request(request)
                : (0, runtime_utils_1.create404Response)(request);
        }
        catch (error) {
            return (0, runtime_utils_1.exceptionToResponse)(error);
        }
    }
}
exports.RemoteFluidObjectHandle = RemoteFluidObjectHandle;

},{"@fluidframework/common-utils":29,"@fluidframework/container-runtime":68,"@fluidframework/runtime-utils":213}],263:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FluidSerializer = exports.isSerializedHandle = void 0;
// RATIONALE: Many methods consume and return 'any' by necessity.
/* eslint-disable @typescript-eslint/no-unsafe-return */
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const remoteObjectHandle_1 = require("./remoteObjectHandle");
const isSerializedHandle = (value) => (value === null || value === void 0 ? void 0 : value.type) === "__fluid_handle__";
exports.isSerializedHandle = isSerializedHandle;
/**
 * Data Store serializer implementation
 */
class FluidSerializer {
    constructor(context, 
    // To be called whenever a handle is parsed by this serializer.
    handleParsedCb) {
        this.context = context;
        this.handleParsedCb = handleParsedCb;
        // If the given 'value' is an IFluidHandle, returns the encoded IFluidHandle.
        // Otherwise returns the original 'value'.  Used by 'encode()' and 'stringify()'.
        this.encodeValue = (value, bind) => {
            // Detect if 'value' is an IFluidHandle.
            const handle = value === null || value === void 0 ? void 0 : value.IFluidHandle;
            // If 'value' is an IFluidHandle return its encoded form.
            return handle !== undefined
                ? this.serializeHandle(handle, bind)
                : value;
        };
        // If the given 'value' is an encoded IFluidHandle, returns the decoded IFluidHandle.
        // Otherwise returns the original 'value'.  Used by 'decode()' and 'parse()'.
        this.decodeValue = (value) => {
            // If 'value' is a serialized IFluidHandle return the deserialized result.
            if ((0, exports.isSerializedHandle)(value)) {
                // Old documents may have handles with relative path in their summaries. Convert these to absolute
                // paths. This will ensure that future summaries will have absolute paths for these handles.
                const absolutePath = value.url.startsWith("/")
                    ? value.url
                    : (0, runtime_utils_1.generateHandleContextPath)(value.url, this.context);
                const parsedHandle = new remoteObjectHandle_1.RemoteFluidObjectHandle(absolutePath, this.root);
                this.handleParsedCb(parsedHandle);
                return parsedHandle;
            }
            else {
                return value;
            }
        };
        this.root = this.context;
        while (this.root.routeContext !== undefined) {
            this.root = this.root.routeContext;
        }
    }
    get IFluidSerializer() { return this; }
    /**
     * Given a mostly-jsonable object tree that may have handle objects embedded within, will return a
     * fully-jsonable object tree where any embedded IFluidHandles have been replaced with a serializable form.
     *
     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from
     * the root to any replaced handles.  (If no handles are found, returns the original object.)
     *
     * Any unbound handles encountered are bound to the provided IFluidHandle.
     */
    encode(input, bind) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyReplace()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyReplace(input, this.encodeValue, bind)
            : input;
    }
    /**
     * Given a fully-jsonable object tree that may have encoded handle objects embedded within, will return an
     * equivalent object tree where any encoded IFluidHandles have been replaced with their decoded form.
     *
     * The original `input` object is not mutated.  This method will shallowly clone all objects in the path from
     * the root to any replaced handles.  (If no handles are found, returns the original object.)
     *
     * The decoded handles are implicitly bound to the handle context of this serializer.
     */
    decode(input) {
        // If the given 'input' cannot contain handles, return it immediately.  Otherwise,
        // return the result of 'recursivelyReplace()'.
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        return !!input && typeof input === "object"
            ? this.recursivelyReplace(input, this.decodeValue)
            : input;
    }
    stringify(input, bind) {
        return JSON.stringify(input, (key, value) => this.encodeValue(value, bind));
    }
    // Parses the serialized data - context must match the context with which the JSON was stringified
    parse(input) {
        return JSON.parse(input, (key, value) => this.decodeValue(value));
    }
    // Invoked for non-null objects to recursively replace references to IFluidHandles.
    // Clones as-needed to avoid mutating the `input` object.  If no IFluidHandes are present,
    // returns the original `input`.
    recursivelyReplace(input, replacer, context) {
        // Note: Caller is responsible for ensuring that `input` is defined / non-null.
        //       (Required for Object.keys() below.)
        // Execute the `replace` on the current input.  Note that Caller is responsible for ensuring that `input`
        // is a non-null object.
        const maybeReplaced = replacer(input, context);
        // If the replacer made a substitution there is no need to decscend further. IFluidHandles are always
        // leaves in the object graph.
        if (maybeReplaced !== input) {
            return maybeReplaced;
        }
        // Otherwise descend into the object graph looking for IFluidHandle instances.
        let clone;
        for (const key of Object.keys(input)) {
            const value = input[key];
            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
            if (!!value && typeof value === "object") {
                // Note: Except for IFluidHandle, `input` must not contain circular references (as object must
                //       be JSON serializable.)  Therefore, guarding against infinite recursion here would only
                //       lead to a later error when attempting to stringify().
                const replaced = this.recursivelyReplace(value, replacer, context);
                // If the `replaced` object is different than the original `value` then the subgraph contained one
                // or more handles.  If this happens, we need to return a clone of the `input` object where the
                // current property is replaced by the `replaced` value.
                if (replaced !== value) {
                    // Lazily create a shallow clone of the `input` object if we haven't done so already.
                    clone = clone !== null && clone !== void 0 ? clone : (Array.isArray(input)
                        ? [...input]
                        : Object.assign({}, input));
                    // Overwrite the current property `key` in the clone with the `replaced` value.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    clone[key] = replaced;
                }
            }
        }
        return clone !== null && clone !== void 0 ? clone : input;
    }
    serializeHandle(handle, bind) {
        bind.bind(handle);
        return {
            type: "__fluid_handle__",
            url: handle.absolutePath,
        };
    }
}
exports.FluidSerializer = FluidSerializer;

},{"./remoteObjectHandle":262,"@fluidframework/runtime-utils":213}],264:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SharedObject = exports.SharedObjectCore = void 0;
const uuid_1 = require("uuid");
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const runtime_definitions_1 = require("@fluidframework/runtime-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const serializer_1 = require("./serializer");
const handle_1 = require("./handle");
const summarySerializer_1 = require("./summarySerializer");
/**
 *  Base class from which all shared objects derive
 */
class SharedObjectCore extends telemetry_utils_1.EventEmitterWithErrorHandling {
    /**
     * @param id - The id of the shared object
     * @param runtime - The IFluidDataStoreRuntime which contains the shared object
     * @param attributes - Attributes of the shared object
     */
    constructor(id, runtime, attributes) {
        super((event, e) => this.eventListenerErrorHandler(event, e));
        this.id = id;
        this.runtime = runtime;
        this.attributes = attributes;
        /**
         * Connection state
         */
        this._connected = false;
        /**
         * True if the dds is bound to its parent.
         */
        this._isBoundToContext = false;
        (0, common_utils_1.assert)(!id.includes("/"), 0x304 /* Id cannot contain slashes */);
        this.handle = new handle_1.SharedObjectHandle(this, id, runtime.IFluidHandleContext);
        this.logger = telemetry_utils_1.ChildLogger.create(runtime.logger, undefined, {
            all: {
                sharedObjectId: (0, uuid_1.v4)(),
                ddsType: {
                    value: this.attributes.type,
                    tag: telemetry_utils_1.TelemetryDataTag.CodeArtifact,
                },
            },
        });
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(this.logger);
        [this.opProcessingHelper, this.callbacksHelper] = this.setUpSampledTelemetryHelpers();
        this.attachListeners();
    }
    get IFluidLoadable() { return this; }
    /**
     * Gets the connection state
     * @returns The state of the connection
     */
    get connected() {
        return this._connected;
    }
    /**
     * This function is only supposed to be called from SharedObjectCore's constructor and
     * depends on a few things being set already. assert() calls make sure of it.
     * @returns The telemetry sampling helpers, so the constructor can be the one to assign them
     * to variables to avoid complaints from TypeScript.
     */
    setUpSampledTelemetryHelpers() {
        var _a, _b;
        (0, common_utils_1.assert)(this.mc !== undefined && this.logger !== undefined, "this.mc and/or this.logger has not been set");
        const opProcessingHelper = new telemetry_utils_1.SampledTelemetryHelper({
            eventName: "ddsOpProcessing",
            category: "performance",
        }, this.logger, (_a = this.mc.config.getNumber("Fluid.SharedObject.OpProcessingTelemetrySampling")) !== null && _a !== void 0 ? _a : 100, true, new Map([
            ["local", { localOp: true }],
            ["remote", { localOp: false }],
        ]));
        const callbacksHelper = new telemetry_utils_1.SampledTelemetryHelper({
            eventName: "ddsEventCallbacks",
            category: "performance",
        }, this.logger, (_b = this.mc.config.getNumber("Fluid.SharedObject.DdsCallbacksTelemetrySampling")) !== null && _b !== void 0 ? _b : 100, true);
        this.runtime.once("dispose", () => {
            this.callbacksHelper.dispose();
            this.opProcessingHelper.dispose();
        });
        return [opProcessingHelper, callbacksHelper];
    }
    /**
     * Marks this objects as closed. Any attempt to change it (local changes or processing remote ops)
     * would result in same error thrown. If called multiple times, only first error is remembered.
     * @param error - error object that is thrown whenever an attempt is made to modify this object
     */
    closeWithError(error) {
        if (this.closeError === undefined) {
            this.closeError = error;
        }
    }
    /**
     * Verifies that this object is not closed via closeWithError(). If it is, throws an error used to close it.
     */
    verifyNotClosed() {
        if (this.closeError !== undefined) {
            throw this.closeError;
        }
    }
    /**
     * Event listener handler helper that can be used to react to exceptions thrown from event listeners
     * It wraps error with DataProcessingError, closes this object and throws resulting error.
     * See closeWithError() for more details
     * Ideally such situation never happens, as consumers of DDS should never throw exceptions
     * in event listeners (i.e. catch any of the issues and make determination on how to handle it).
     * When such exceptions propagate through, most likely data model is no longer consistent, i.e.
     * DDS state does not match what user sees. Because of it DDS moves to "corrupted state" and does not
     * allow processing of ops or local changes, which very quickly results in container closure.
     */
    eventListenerErrorHandler(event, e) {
        const error = container_utils_1.DataProcessingError.wrapIfUnrecognized(e, "SharedObjectEventListenerException");
        error.addTelemetryProperties({ emittedEventName: String(event) });
        this.closeWithError(error);
        throw error;
    }
    attachListeners() {
        // Only listen to these events if not attached.
        if (!this.isAttached()) {
            this.runtime.once("attaching", () => {
                // Calling this will let the dds to do any custom processing based on attached
                // like starting generating ops.
                this.didAttach();
            });
        }
    }
    /**
     * A shared object, after construction, can either be loaded in the case that it is already part of
     * a shared document. Or later attached if it is being newly added.
     * @param services - Services used by the shared object
     */
    async load(services) {
        if (this.runtime.attachState !== container_definitions_1.AttachState.Detached) {
            this.services = services;
        }
        await this.loadCore(services.objectStorage);
        if (this.runtime.attachState !== container_definitions_1.AttachState.Detached) {
            this.attachDeltaHandler();
        }
    }
    /**
     * Initializes the object as a local, non-shared object. This object can become shared after
     * it is attached to the document.
     */
    initializeLocal() {
        this.initializeLocalCore();
    }
    /**
     * {@inheritDoc (ISharedObject:interface).bindToContext}
     */
    bindToContext() {
        if (this._isBoundToContext) {
            return;
        }
        this._isBoundToContext = true;
        this.runtime.bindChannel(this);
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).connect}
     */
    connect(services) {
        this.services = services;
        this.attachDeltaHandler();
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).isAttached}
     */
    isAttached() {
        return this.services !== undefined && this.runtime.attachState !== container_definitions_1.AttachState.Detached;
    }
    /**
     * Called when a handle is decoded by this object. A handle in the object's data represents an outbound reference
     * to another object in the container.
     * @param decodedHandle - The handle of the Fluid object that is decoded.
     */
    handleDecoded(decodedHandle) {
        var _a, _b, _c;
        if (this.isAttached()) {
            // This represents an outbound reference from this object to the node represented by decodedHandle.
            (_c = (_a = this.services) === null || _a === void 0 ? void 0 : (_b = _a.deltaConnection).addedGCOutboundReference) === null || _c === void 0 ? void 0 : _c.call(_b, this.handle, decodedHandle);
        }
    }
    /**
     * Allows the distributed data type to perform custom local loading.
     */
    initializeLocalCore() {
        return;
    }
    /**
     * Allows the distributive data type the ability to perform custom processing once an attach has happened.
     * Also called after non-local data type get loaded.
     */
    didAttach() {
        return;
    }
    /**
     * Submits a message by the local client to the runtime.
     * @param content - Content of the message
     * @param localOpMetadata - The local metadata associated with the message. This is kept locally by the runtime
     * and not sent to the server. This will be sent back when this message is received back from the server. This is
     * also sent if we are asked to resubmit the message.
     */
    submitLocalMessage(content, localOpMetadata = undefined) {
        this.verifyNotClosed();
        if (this.isAttached()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.services.deltaConnection.submit(content, localOpMetadata);
        }
    }
    /**
     * Marks this object as dirty so that it is part of the next summary. It is called by a SharedSummaryBlock
     * that want to be part of summary but does not generate ops.
     */
    dirty() {
        if (!this.isAttached()) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.services.deltaConnection.dirty();
    }
    /**
     * Called when the object has fully connected to the delta stream
     * Default implementation for DDS, override if different behavior is required.
     */
    onConnect() { }
    /**
     * Called when a message has to be resubmitted. This typically happens after a reconnection for unacked messages.
     * The default implementation here is to resubmit the same message. The client can override if different behavior
     * is required. It can choose to resubmit the same message, submit different / multiple messages or not submit
     * anything at all.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmitCore(content, localOpMetadata) {
        this.submitLocalMessage(content, localOpMetadata);
    }
    /**
     * Promises that are waiting for an ack from the server before resolving should use this instead of new Promise.
     * It ensures that if something changes that will interrupt that ack (e.g. the FluidDataStoreRuntime disposes),
     * the Promise will reject.
     * If runtime is disposed when this call is made, executor is not run and promise is rejected right away.
     */
    async newAckBasedPromise(executor) {
        let rejectBecauseDispose;
        return new Promise((resolve, reject) => {
            rejectBecauseDispose =
                () => reject(new Error("FluidDataStoreRuntime disposed while this ack-based Promise was pending"));
            if (this.runtime.disposed) {
                rejectBecauseDispose();
                return;
            }
            this.runtime.on("dispose", rejectBecauseDispose);
            executor(resolve, reject);
        }).finally(() => {
            // Note: rejectBecauseDispose will never be undefined here
            this.runtime.off("dispose", rejectBecauseDispose);
        });
    }
    attachDeltaHandler() {
        // Services should already be there in case we are attaching delta handler.
        (0, common_utils_1.assert)(this.services !== undefined, 0x07a /* "Services should be there to attach delta handler" */);
        this._isBoundToContext = true;
        // Allows objects to do any custom processing if it is attached.
        this.didAttach();
        // attachDeltaHandler is only called after services is assigned
        this.services.deltaConnection.attach({
            process: (message, local, localOpMetadata) => {
                this.process(message, local, localOpMetadata);
            },
            setConnectionState: (connected) => {
                this.setConnectionState(connected);
            },
            reSubmit: (content, localOpMetadata) => {
                this.reSubmit(content, localOpMetadata);
            },
            applyStashedOp: (content) => {
                return this.applyStashedOp(content);
            },
            rollback: (content, localOpMetadata) => {
                this.rollback(content, localOpMetadata);
            },
        });
        // Trigger initial state
        // attachDeltaHandler is only called after services is assigned
        this.setConnectionState(this.services.deltaConnection.connected);
    }
    /**
     * Set the state of connection to services.
     * @param connected - true if connected, false otherwise.
     */
    setConnectionState(connected) {
        if (this._connected === connected) {
            // Not changing state, nothing the same.
            return;
        }
        // Should I change the state at the end? So that we *can't* send new stuff before we send old?
        this._connected = connected;
        if (!connected) {
            // Things that are true now...
            // - if we had a connection we can no longer send messages over it
            // - if we had outbound messages some may or may not be ACK'd. Won't know until next message
            //
            // - nack could get a new msn - but might as well do it in the join?
            this.onDisconnect();
        }
        else {
            // Call this for now so that DDSes like ConsensusOrderedCollection that maintain their own pending
            // messages will work.
            this.onConnect();
        }
    }
    /**
     * Handles a message being received from the remote delta server.
     * @param message - The message to process
     * @param local - Whether the message originated from the local client
     * @param localOpMetadata - For local client messages, this is the metadata that was submitted with the message.
     * For messages from a remote client, this will be undefined.
     */
    process(message, local, localOpMetadata) {
        this.verifyNotClosed(); // This will result in container closure.
        this.emitInternal("pre-op", message, local, this);
        this.opProcessingHelper.measure(() => { this.processCore(message, local, localOpMetadata); }, local ? "local" : "remote");
        this.emitInternal("op", message, local, this);
    }
    /**
     * Called when a message has to be resubmitted. This typically happens for unacked messages after a
     * reconnection.
     * @param content - The content of the original message.
     * @param localOpMetadata - The local metadata associated with the original message.
     */
    reSubmit(content, localOpMetadata) {
        this.reSubmitCore(content, localOpMetadata);
    }
    /**
     * Revert an op
     */
    rollback(content, localOpMetadata) {
        throw new Error("rollback not supported");
    }
    /**
     * Emit an event. This function is only intended for use by DDS classes that extend SharedObject/SharedObjectCore,
     * specifically to emit events that are part of the public interface of the DDS (i.e. those that can have listeners
     * attached to them by the consumers of the DDS). It should not be called from outside the class or to emit events
     * which are only internal to the DDS. Support for calling it from outside the DDS instance might be removed in the
     * future.
     *
     * @internal
     *
     * @param event - The event to emit.
     * @param args - Arguments to pass to the event listeners.
     * @returns `true` if the event had listeners, `false` otherwise.
     */
    emit(event, ...args) {
        return this.callbacksHelper.measure(() => super.emit(event, ...args));
    }
    /**
     * Use to emit events inside {@link SharedObjectCore}, with no telemetry measurement
     * done on the duration of the callbacks. Simply calls `super.emit()`.
     * @param event - Event to emit
     * @param args - Arguments for the event
     * @returns Whatever `super.emit()` returns.
     */
    emitInternal(event, ...args) {
        return super.emit(event, ...args);
    }
}
exports.SharedObjectCore = SharedObjectCore;
/**
 * SharedObject with simplified, synchronous summarization and GC.
 * DDS implementations with async and incremental summarization should extend SharedObjectCore directly instead.
 */
class SharedObject extends SharedObjectCore {
    /**
     * @param id - The id of the shared object
     * @param runtime - The IFluidDataStoreRuntime which contains the shared object
     * @param attributes - Attributes of the shared object
     */
    constructor(id, runtime, attributes, telemetryContextPrefix) {
        super(id, runtime, attributes);
        this.telemetryContextPrefix = telemetryContextPrefix;
        /**
         * True while we are garbage collecting this object's data.
         */
        this._isGCing = false;
        this._serializer = new serializer_1.FluidSerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));
    }
    get serializer() {
        /**
         * During garbage collection, the SummarySerializer keeps track of IFluidHandles that are serialized. These
         * handles represent references to other Fluid objects.
         *
         * This is fine for now. However, if we implement delay loading in DDss, they may load and de-serialize content
         * in summarize. When that happens, they may incorrectly hit this assert and we will have to change this.
         */
        (0, common_utils_1.assert)(!this._isGCing, 0x075 /* "SummarySerializer should be used for serializing data during summary." */);
        return this._serializer;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).getAttachSummary}
     */
    getAttachSummary(fullTree = false, trackState = false, telemetryContext) {
        const result = this.summarizeCore(this.serializer, telemetryContext);
        this.incrementTelemetryMetric(runtime_definitions_1.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);
        this.incrementTelemetryMetric(runtime_definitions_1.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);
        return result;
    }
    /**
     * {@inheritDoc @fluidframework/datastore-definitions#(IChannel:interface).summarize}
     */
    async summarize(fullTree = false, trackState = false, telemetryContext) {
        const result = this.summarizeCore(this.serializer, telemetryContext);
        this.incrementTelemetryMetric(runtime_definitions_1.blobCountPropertyName, result.stats.blobNodeCount, telemetryContext);
        this.incrementTelemetryMetric(runtime_definitions_1.totalBlobSizePropertyName, result.stats.totalBlobSize, telemetryContext);
        return result;
    }
    /**
     * {@inheritDoc (ISharedObject:interface).getGCData}
     */
    getGCData(fullGC = false) {
        // Set _isGCing to true. This flag is used to ensure that we only use SummarySerializer to serialize handles
        // in this object's data.
        (0, common_utils_1.assert)(!this._isGCing, 0x078 /* "Possible re-entrancy! Summary should not already be in progress." */);
        this._isGCing = true;
        let gcData;
        try {
            const serializer = new summarySerializer_1.SummarySerializer(this.runtime.channelsRoutingContext, (handle) => this.handleDecoded(handle));
            this.processGCDataCore(serializer);
            // The GC data for this shared object contains a single GC node. The outbound routes of this node are the
            // routes of handles serialized during summarization.
            gcData = { gcNodes: { "/": serializer.getSerializedRoutes() } };
            (0, common_utils_1.assert)(this._isGCing, 0x079 /* "Possible re-entrancy! Summary should have been in progress." */);
        }
        finally {
            this._isGCing = false;
        }
        return gcData;
    }
    /**
     * Calls the serializer over all data in this object that reference other GC nodes.
     * Derived classes must override this to provide custom list of references to other GC nodes.
     */
    processGCDataCore(serializer) {
        // We run the full summarize logic to get the list of outbound routes from this object. This is a little
        // expensive but its okay for now. It will be updated to not use full summarize and make it more efficient.
        // See: https://github.com/microsoft/FluidFramework/issues/4547
        this.summarizeCore(serializer);
    }
    incrementTelemetryMetric(propertyName, incrementBy, telemetryContext) {
        var _a;
        const prevTotal = ((_a = telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.get(this.telemetryContextPrefix, propertyName)) !== null && _a !== void 0 ? _a : 0);
        telemetryContext === null || telemetryContext === void 0 ? void 0 : telemetryContext.set(this.telemetryContextPrefix, propertyName, prevTotal + incrementBy);
    }
}
exports.SharedObject = SharedObject;

},{"./handle":260,"./serializer":263,"./summarySerializer":265,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/runtime-definitions":208,"@fluidframework/telemetry-utils":279,"uuid":544}],265:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SummarySerializer = void 0;
const serializer_1 = require("./serializer");
/**
 * Serializer implementation for serializing handles during summary.
 */
class SummarySerializer extends serializer_1.FluidSerializer {
    constructor() {
        super(...arguments);
        this.serializedRoutes = new Set();
    }
    getSerializedRoutes() {
        return Array.from(this.serializedRoutes);
    }
    serializeHandle(handle, bind) {
        this.serializedRoutes.add(handle.absolutePath);
        return super.serializeHandle(handle, bind);
    }
}
exports.SummarySerializer = SummarySerializer;

},{"./serializer":263}],266:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],267:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSingleBlobSummary = exports.parseHandles = exports.makeHandlesSerializable = exports.serializeHandles = void 0;
const runtime_utils_1 = require("@fluidframework/runtime-utils");
/**
 * Given a mostly-plain object that may have handle objects embedded within, return a string representation of an object
 * where the handle objects have been replaced with a serializable form.
 * @param value - The mostly-plain object
 * @param serializer - The serializer that knows how to convert handles into serializable format
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns Result of strigifying an object
 */
function serializeHandles(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined
        ? serializer.stringify(value, bind)
        : value;
}
exports.serializeHandles = serializeHandles;
/**
 * Given a mostly-plain object that may have handle objects embedded within, will return a fully-plain object
 * where any embedded IFluidHandles have been replaced with a serializable form.
 *
 * The original `input` object is not mutated.  This method will shallowly clones all objects in the path from
 * the root to any replaced handles.  (If no handles are found, returns the original object.)
 *
 * @param input - The mostly-plain object
 * @param context - The handle context for the container
 * @param bind - Bind any other handles we find in the object against this given handle.
 * @returns The fully-plain object
 */
function makeHandlesSerializable(value, serializer, bind) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return serializer.encode(value, bind);
}
exports.makeHandlesSerializable = makeHandlesSerializable;
/**
 * Given a fully-plain object that may have serializable-form handles within, will return the mostly-plain object
 * with handle objects created instead.
 * @param value - The fully-plain object
 * @param serializer - The serializer that knows how to convert serializable-form handles into handle objects
 * @param context - The handle context for the container
 * @returns The mostly-plain object with handle objects within
 */
function parseHandles(value, serializer) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return value !== undefined ? serializer.parse(JSON.stringify(value)) : value;
}
exports.parseHandles = parseHandles;
/**
 * Create a new summary containing one blob
 * @param key - the key for the blob in the summary
 * @param content - blob content
 * @returns The summary containing the blob
 */
function createSingleBlobSummary(key, content) {
    const builder = new runtime_utils_1.SummaryTreeBuilder();
    builder.addBlob(key, content);
    return builder.getSummaryTree();
}
exports.createSingleBlobSummary = createSingleBlobSummary;

},{"@fluidframework/runtime-utils":213}],268:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = void 0;
/**
 * enum representing the possible types of a shared object
 */
var ValueType;
(function (ValueType) {
    /**
     * The value is a shared object
     * @deprecated Instead store the handle of the shared object, rather than the shared object itself.
     */
    ValueType[ValueType["Shared"] = 0] = "Shared";
    /**
     * The value is a plain JavaScript object or handle.  If a plain object, it may contain handles deeper within.
     */
    ValueType[ValueType["Plain"] = 1] = "Plain";
})(ValueType = exports.ValueType || (exports.ValueType = {}));

},{}],269:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IFluidDependencySynthesizer = void 0;
exports.IFluidDependencySynthesizer = "IFluidDependencySynthesizer";

},{}],270:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyContainer = void 0;
const IFluidDependencySynthesizer_1 = require("./IFluidDependencySynthesizer");
/**
 * DependencyContainer is similar to a IoC Container. It takes providers and will
 * synthesize an object based on them when requested.
 */
class DependencyContainer {
    constructor(...parents) {
        this.providers = new Map();
        this.parents = parents.filter((v) => v !== undefined);
    }
    get IFluidDependencySynthesizer() { return this; }
    /**
     * Add a new provider
     * @param type - Name of the Type T being provided
     * @param provider - A provider that will resolve the T correctly when asked
     * @throws - If passing a type that's already registered
     */
    register(type, provider) {
        if (this.providers.has(type)) {
            throw new Error(`Attempting to register a provider of type ${type} that already exists`);
        }
        this.providers.set(type, provider);
    }
    /**
     * Remove a provider
     * @param type - Name of the provider to remove
     */
    unregister(type) {
        if (this.providers.has(type)) {
            this.providers.delete(type);
        }
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).synthesize}
     */
    synthesize(optionalTypes, requiredTypes) {
        const base = {};
        this.generateRequired(base, requiredTypes);
        this.generateOptional(base, optionalTypes);
        Object.defineProperty(base, IFluidDependencySynthesizer_1.IFluidDependencySynthesizer, { get: () => this });
        return base;
    }
    /**
     * {@inheritDoc (IFluidDependencySynthesizer:interface).has}
     * @param excludeParents - If true, exclude checking parent registries
     */
    has(type, excludeParents) {
        if (this.providers.has(type)) {
            return true;
        }
        if (excludeParents !== true) {
            return this.parents.some((p) => p.has(type));
        }
        return false;
    }
    /**
     * @deprecated - Needed for back compat
     */
    getProvider(provider) {
        // this was removed, but some partners have trouble with back compat where they
        // use invalid patterns with FluidObject and IFluidDependencySynthesizer
        // this is just for back compat until those are removed
        if (this.has(provider)) {
            if (this.providers.has(provider)) {
                return this.providers.get(provider);
            }
            for (const parent of this.parents) {
                if (parent instanceof DependencyContainer) {
                    return parent.getProvider(provider);
                }
                else {
                    // older implementations of the IFluidDependencySynthesizer exposed getProvider
                    const maybeGetProvider = parent;
                    if ((maybeGetProvider === null || maybeGetProvider === void 0 ? void 0 : maybeGetProvider.getProvider) !== undefined) {
                        return maybeGetProvider.getProvider(provider);
                    }
                }
            }
        }
    }
    generateRequired(base, types) {
        if (types === undefined) {
            return;
        }
        for (const key of Object.keys(types)) {
            const provider = this.resolveProvider(key);
            if (provider === undefined) {
                throw new Error(`Object attempted to be created without registered required provider ${key}`);
            }
            Object.defineProperty(base, key, provider);
        }
    }
    generateOptional(base, types) {
        var _a;
        if (types === undefined) {
            return;
        }
        for (const key of Object.keys(types)) {
            // back-compat: in 0.56 we allow undefined in the types, but we didn't before
            // this will keep runtime back compat, eventually we should support undefined properties
            // rather than properties that return promises that resolve to undefined
            const provider = (_a = this.resolveProvider(key)) !== null && _a !== void 0 ? _a : { get: async () => undefined };
            Object.defineProperty(base, key, provider);
        }
    }
    resolveProvider(t) {
        // If we have the provider return it
        const provider = this.providers.get(t);
        if (provider === undefined) {
            for (const parent of this.parents) {
                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                const sp = { [t]: t };
                const syn = parent.synthesize(sp, {});
                const descriptor = Object.getOwnPropertyDescriptor(syn, t);
                if (descriptor !== undefined) {
                    return descriptor;
                }
            }
            return undefined;
        }
        // The double nested gets are required for lazy loading the provider resolution
        if (typeof provider === "function") {
            return {
                get() {
                    if (provider && typeof provider === "function") {
                        return Promise.resolve(this[IFluidDependencySynthesizer_1.IFluidDependencySynthesizer])
                            .then(async (fds) => provider(fds))
                            .then((p) => p === null || p === void 0 ? void 0 : p[t]);
                    }
                },
            };
        }
        return {
            get() {
                if (provider) {
                    return Promise.resolve(provider).then((p) => {
                        if (p) {
                            return p[t];
                        }
                    });
                }
            },
        };
    }
}
exports.DependencyContainer = DependencyContainer;

},{"./IFluidDependencySynthesizer":269}],271:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./dependencyContainer"), exports);
__exportStar(require("./IFluidDependencySynthesizer"), exports);
__exportStar(require("./types"), exports);

},{"./IFluidDependencySynthesizer":269,"./dependencyContainer":270,"./types":272}],272:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],273:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mixinMonitoringContext = exports.loggerToMonitoringContext = exports.loggerIsMonitoringContext = exports.CachedConfigProvider = exports.inMemoryConfigProvider = exports.sessionStorageConfigProvider = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Creates a base configuration provider based on `sessionStorage`
 *
 * @returns A lazy initialized base configuration provider with `sessionStorage` as the underlying config store
 */
exports.sessionStorageConfigProvider = new common_utils_1.Lazy(() => (0, exports.inMemoryConfigProvider)(safeSessionStorage()));
const NullConfigProvider = {
    getRawConfig: () => undefined,
};
/**
 * Creates a base configuration provider based on the supplied `Storage` instance
 *
 * @param storage - instance of `Storage` to be used as storage media for the config
 * @returns A base configuration provider with
 * the supplied `Storage` instance as the underlying config store
 */
const inMemoryConfigProvider = (storage) => {
    if (storage !== undefined && storage !== null) {
        return new CachedConfigProvider({
            getRawConfig: (name) => {
                var _a, _b;
                try {
                    return (_b = stronglyTypedParse((_a = storage.getItem(name)) !== null && _a !== void 0 ? _a : undefined)) === null || _b === void 0 ? void 0 : _b.raw;
                }
                catch (_c) { }
                return undefined;
            },
        });
    }
    return NullConfigProvider;
};
exports.inMemoryConfigProvider = inMemoryConfigProvider;
function isPrimitiveType(type) {
    switch (type) {
        case "boolean":
        case "number":
        case "string":
            return true;
        default:
            return false;
    }
}
/**
 * Takes any supported config type, and returns the value with a strong type. If the type of
 * the config is not a supported type undefined will be returned.
 * The user of this function should cache the result to avoid duplicated work.
 *
 * Strings will be attempted to be parsed and coerced into a strong config type.
 * if it is not possible to parsed and coerce a string to a strong config type the original string
 * will be return with a string type for the consumer to handle further if necessary.
 */
function stronglyTypedParse(input) {
    let output = input;
    let defaultReturn;
    // we do special handling for strings to try and coerce
    // them into a config type if we can. This makes it easy
    // for config sources like sessionStorage which only
    // holds strings
    if (typeof input === "string") {
        try {
            output = JSON.parse(input);
            // we succeeded in parsing, but we don't support parsing
            // for any object as we can't do it type safely
            // so in this case, the default return will be string
            // rather than undefined, and the consumer
            // can parse, as we don't want to provide
            // a false sense of security by just
            // casting.
            defaultReturn = { raw: input, string: input };
        }
        catch (_a) { }
    }
    if (output === undefined) {
        return defaultReturn;
    }
    const outputType = typeof output;
    if (isPrimitiveType(outputType)) {
        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [outputType]: output });
    }
    if (Array.isArray(output)) {
        const firstType = typeof output[0];
        // ensure the first elements is a primitive type
        if (!isPrimitiveType(firstType)) {
            return defaultReturn;
        }
        // ensue all the elements types are homogeneous
        // aka they all have the same type as the first
        for (const v of output) {
            if (typeof v !== firstType) {
                return defaultReturn;
            }
        }
        return Object.assign(Object.assign({}, defaultReturn), { raw: input, [`${firstType}[]`]: output });
    }
    return defaultReturn;
}
/** Referencing the `sessionStorage` variable can throw in some environments such as Node */
const safeSessionStorage = () => {
    try {
        return sessionStorage !== null ? sessionStorage : undefined;
    }
    catch (_a) {
        return undefined;
    }
};
/**
 * Implementation of {@link IConfigProvider} which contains nested {@link IConfigProviderBase} instances
 */
class CachedConfigProvider {
    constructor(...orderedBaseProviders) {
        this.configCache = new Map();
        this.orderedBaseProviders = [];
        const knownProviders = new Set();
        const candidateProviders = [...orderedBaseProviders];
        while (candidateProviders.length > 0) {
            const baseProvider = candidateProviders.shift();
            if (baseProvider !== undefined
                && isConfigProviderBase(baseProvider)
                && !knownProviders.has(baseProvider)) {
                knownProviders.add(baseProvider);
                if (baseProvider instanceof CachedConfigProvider) {
                    candidateProviders.push(...baseProvider.orderedBaseProviders);
                }
                else {
                    this.orderedBaseProviders.push(baseProvider);
                }
            }
        }
    }
    getBoolean(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.boolean;
    }
    getNumber(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.number;
    }
    getString(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.string;
    }
    getBooleanArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["boolean[]"];
    }
    getNumberArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["number[]"];
    }
    getStringArray(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a["string[]"];
    }
    getRawConfig(name) {
        var _a;
        return (_a = this.getCacheEntry(name)) === null || _a === void 0 ? void 0 : _a.raw;
    }
    getCacheEntry(name) {
        if (!this.configCache.has(name)) {
            for (const provider of this.orderedBaseProviders) {
                const parsed = stronglyTypedParse(provider === null || provider === void 0 ? void 0 : provider.getRawConfig(name));
                if (parsed !== undefined) {
                    this.configCache.set(name, parsed);
                    return parsed;
                }
            }
            // configs are immutable, if the first lookup returned no results, all lookups should
            this.configCache.set(name, { raw: undefined });
        }
        return this.configCache.get(name);
    }
}
exports.CachedConfigProvider = CachedConfigProvider;
function loggerIsMonitoringContext(obj) {
    const maybeConfig = obj;
    return isConfigProviderBase(maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.config) && (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.logger) !== undefined;
}
exports.loggerIsMonitoringContext = loggerIsMonitoringContext;
function loggerToMonitoringContext(logger) {
    if (loggerIsMonitoringContext(logger)) {
        return logger;
    }
    return mixinMonitoringContext(logger, exports.sessionStorageConfigProvider.value);
}
exports.loggerToMonitoringContext = loggerToMonitoringContext;
function mixinMonitoringContext(logger, ...configs) {
    if (loggerIsMonitoringContext(logger)) {
        throw new Error("Logger is already a monitoring context");
    }
    /**
     * this is the tricky bit we use for now to smuggle monitoring context around.
     * To the logger we mixin both config and  itself, so mc.logger === logger as it is self-referential.
     * We then expose it as a Monitoring context, so via types we hide the outer logger methods.
     * To layers that expect just a logger we can pass mc.logger, but this is still a MonitoringContext
     * so if a deeper layer then converts that logger to a monitoring context it can find the smuggled properties
     * of the MonitoringContext and get the config provider.
     */
    const mc = logger;
    mc.config = new CachedConfigProvider(...configs);
    mc.logger = logger;
    return mc;
}
exports.mixinMonitoringContext = mixinMonitoringContext;
function isConfigProviderBase(obj) {
    const maybeConfig = obj;
    return typeof (maybeConfig === null || maybeConfig === void 0 ? void 0 : maybeConfig.getRawConfig) === "function";
}

},{"@fluidframework/common-utils":29}],274:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DebugLogger = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const debug_1 = require("debug");
const logger_1 = require("./logger");
/**
 * Implementation of debug logger
 */
class DebugLogger extends logger_1.TelemetryLogger {
    constructor(debug, debugErr, properties) {
        super(undefined, properties);
        this.debug = debug;
        this.debugErr = debugErr;
    }
    /**
     * Create debug logger - all events are output to debug npm library
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(namespace, properties) {
        // Setup base logger upfront, such that host can disable it (if needed)
        const debug = (0, debug_1.debug)(namespace);
        const debugErr = (0, debug_1.debug)(namespace);
        debugErr.log = console.error.bind(console);
        debugErr.enabled = true;
        return new DebugLogger(debug, debugErr, properties);
    }
    /**
     * Mix in debug logger with another logger.
     * Returned logger will output events to both newly created debug logger, as well as base logger
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     * @param baseLogger - Base logger to output events (in addition to debug logger being created). Can be undefined.
     */
    static mixinDebugLogger(namespace, baseLogger, properties) {
        if (!baseLogger) {
            return DebugLogger.create(namespace, properties);
        }
        const multiSinkLogger = new logger_1.MultiSinkLogger(undefined, properties);
        multiSinkLogger.addLogger(DebugLogger.create(namespace, this.tryGetBaseLoggerProps(baseLogger)));
        multiSinkLogger.addLogger(logger_1.ChildLogger.create(baseLogger, namespace));
        return multiSinkLogger;
    }
    static tryGetBaseLoggerProps(baseLogger) {
        if (baseLogger instanceof logger_1.TelemetryLogger) {
            return baseLogger.properties;
        }
        return undefined;
    }
    /**
     * Send an event to debug loggers
     *
     * @param event - the event to send
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        const isError = newEvent.category === "error";
        let logger = isError ? this.debugErr : this.debug;
        // Use debug's coloring schema for base of the event
        const index = event.eventName.lastIndexOf(logger_1.TelemetryLogger.eventNamespaceSeparator);
        const name = event.eventName.substring(index + 1);
        if (index > 0) {
            logger = logger.extend(event.eventName.substring(0, index));
        }
        newEvent.eventName = undefined;
        let tick = "";
        tick = `tick=${logger_1.TelemetryLogger.formatTick(common_utils_1.performance.now())}`;
        // Extract stack to put it last, but also to avoid escaping '\n' in it by JSON.stringify below
        const stack = newEvent.stack ? newEvent.stack : "";
        newEvent.stack = undefined;
        // Watch out for circular references - they can come from two sources
        // 1) error object - we do not control it and should remove it and retry
        // 2) properties supplied by telemetry caller - that's a bug that should be addressed!
        let payload;
        try {
            payload = JSON.stringify(newEvent);
        }
        catch (error) {
            newEvent.error = undefined;
            payload = JSON.stringify(newEvent);
        }
        if (payload === "{}") {
            payload = "";
        }
        // Force errors out, to help with diagnostics
        if (isError) {
            logger.enabled = true;
        }
        // Print multi-line.
        logger(`${name} ${payload} ${tick} ${stack}`);
    }
}
exports.DebugLogger = DebugLogger;

},{"./logger":280,"@fluidframework/common-utils":29,"debug":346}],275:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingError = exports.getCircularReplacer = exports.isTaggedTelemetryPropertyValue = exports.isExternalError = exports.wrapErrorAndLog = exports.wrapError = exports.generateStack = exports.generateErrorWithStack = exports.normalizeError = exports.isILoggingError = exports.extractLogSafeErrorProperties = void 0;
const uuid_1 = require("uuid");
const fluidErrorBase_1 = require("./fluidErrorBase");
/** @returns true if value is an object but neither null nor an array */
const isRegularObject = (value) => {
    return value !== null && !Array.isArray(value) && typeof value === "object";
};
/** Inspect the given error for common "safe" props and return them */
function extractLogSafeErrorProperties(error, sanitizeStack) {
    const removeMessageFromStack = (stack, errorName) => {
        if (!sanitizeStack) {
            return stack;
        }
        const stackFrames = stack.split("\n");
        stackFrames.shift(); // Remove "[ErrorName]: [ErrorMessage]"
        if (errorName !== undefined) {
            stackFrames.unshift(errorName); // Add "[ErrorName]"
        }
        return stackFrames.join("\n");
    };
    const message = (typeof (error === null || error === void 0 ? void 0 : error.message) === "string")
        ? error.message
        : String(error);
    const safeProps = {
        message,
    };
    if (isRegularObject(error)) {
        const { errorType, stack, name } = error;
        if (typeof errorType === "string") {
            safeProps.errorType = errorType;
        }
        if (typeof stack === "string") {
            const errorName = (typeof name === "string") ? name : undefined;
            safeProps.stack = removeMessageFromStack(stack, errorName);
        }
    }
    return safeProps;
}
exports.extractLogSafeErrorProperties = extractLogSafeErrorProperties;
/** type guard for ILoggingError interface */
const isILoggingError = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === "function";
exports.isILoggingError = isILoggingError;
/** Copy props from source onto target, but do not overwrite an existing prop that matches */
function copyProps(target, source) {
    for (const key of Object.keys(source)) {
        if (target[key] === undefined) {
            target[key] = source[key];
        }
    }
}
/** For backwards compatibility with pre-errorInstanceId valid errors */
function patchLegacyError(legacyError) {
    const patchMe = legacyError;
    if (patchMe.errorInstanceId === undefined) {
        patchMe.errorInstanceId = (0, uuid_1.v4)();
    }
}
/**
 * Normalize the given error yielding a valid Fluid Error
 * @returns A valid Fluid Error with any provided annotations applied
 * @param error - The error to normalize
 * @param annotations - Annotations to apply to the normalized error
 */
function normalizeError(error, annotations = {}) {
    var _a;
    // Back-compat, while IFluidErrorBase is rolled out
    if ((0, fluidErrorBase_1.isValidLegacyError)(error)) {
        patchLegacyError(error);
    }
    if ((0, fluidErrorBase_1.isFluidError)(error)) {
        // We can simply add the telemetry props to the error and return it
        error.addTelemetryProperties((_a = annotations.props) !== null && _a !== void 0 ? _a : {});
        return error;
    }
    // We have to construct a new Fluid Error, copying safe properties over
    const { message, stack } = extractLogSafeErrorProperties(error, false /* sanitizeStack */);
    const fluidError = new NormalizedExternalError({
        message,
        stack,
    });
    // We need to preserve these properties which are used in a non-typesafe way throughout driver code (see #8743)
    // Anywhere they are set should be on a valid Fluid Error that would have been returned above,
    // but we can't prove it with the types, so adding this defensive measure.
    if (typeof error === "object" && error !== null) {
        const { canRetry, retryAfterSeconds } = error;
        Object.assign(normalizeError, { canRetry, retryAfterSeconds });
    }
    if (typeof (error) !== "object") {
        // This is only interesting for non-objects
        fluidError.addTelemetryProperties({ typeofError: typeof (error) });
    }
    const originalErrorTelemetryProps = (0, exports.isILoggingError)(error) ? error.getTelemetryProperties() : {};
    fluidError.addTelemetryProperties(Object.assign(Object.assign(Object.assign({}, originalErrorTelemetryProps), annotations.props), { untrustedOrigin: 1 }));
    return fluidError;
}
exports.normalizeError = normalizeError;
let stackPopulatedOnCreation;
/**
 * The purpose of this function is to provide ability to capture stack context quickly.
 * Accessing new Error().stack is slow, and the slowest part is accessing stack property itself.
 * There are scenarios where we generate error with stack, but error is handled in most cases and
 * stack property is not accessed.
 * For such cases it's better to not read stack property right away, but rather delay it until / if it's needed
 * Some browsers will populate stack right away, others require throwing Error, so we do auto-detection on the fly.
 * @returns Error object that has stack populated.
 */
function generateErrorWithStack() {
    const err = new Error("<<generated stack>>");
    if (stackPopulatedOnCreation === undefined) {
        stackPopulatedOnCreation = (err.stack !== undefined);
    }
    if (stackPopulatedOnCreation) {
        return err;
    }
    try {
        throw err;
    }
    catch (e) {
        return e;
    }
}
exports.generateErrorWithStack = generateErrorWithStack;
function generateStack() {
    return generateErrorWithStack().stack;
}
exports.generateStack = generateStack;
/**
 * Create a new error using newErrorFn, wrapping and caused by the given unknown error.
 * Copies the inner error's stack, errorInstanceId and telemetry props over to the new error if present
 * @param innerError - An error from untrusted/unknown origins
 * @param newErrorFn - callback that will create a new error given the original error's message
 * @returns A new error object "wrapping" the given error
 */
function wrapError(innerError, newErrorFn) {
    const { message, stack, } = extractLogSafeErrorProperties(innerError, false /* sanitizeStack */);
    const newError = newErrorFn(message);
    if (stack !== undefined) {
        overwriteStack(newError, stack);
    }
    // Mark external errors with untrustedOrigin flag
    if (isExternalError(innerError)) {
        newError.addTelemetryProperties({ untrustedOrigin: 1 });
    }
    // Reuse errorInstanceId
    if ((0, fluidErrorBase_1.hasErrorInstanceId)(innerError)) {
        newError.overwriteErrorInstanceId(innerError.errorInstanceId);
        // For "back-compat" in the logs
        newError.addTelemetryProperties({ innerErrorInstanceId: innerError.errorInstanceId });
    }
    // Lastly, copy over all other telemetry properties. Note these will not overwrite existing properties
    // This will include the untrustedOrigin property if the inner error itself was created from an external error
    if ((0, exports.isILoggingError)(innerError)) {
        newError.addTelemetryProperties(innerError.getTelemetryProperties());
    }
    return newError;
}
exports.wrapError = wrapError;
/** The same as wrapError, but also logs the innerError, including the wrapping error's instance id */
function wrapErrorAndLog(innerError, newErrorFn, logger) {
    const newError = wrapError(innerError, newErrorFn);
    // This will match innerError.errorInstanceId if present (see wrapError)
    const errorInstanceId = newError.errorInstanceId;
    // For "back-compat" in the logs
    const wrappedByErrorInstanceId = errorInstanceId;
    logger.sendTelemetryEvent({
        eventName: "WrapError",
        errorInstanceId,
        wrappedByErrorInstanceId,
    }, innerError);
    return newError;
}
exports.wrapErrorAndLog = wrapErrorAndLog;
function overwriteStack(error, stack) {
    // supposedly setting stack on an Error can throw.
    try {
        Object.assign(error, { stack });
    }
    catch (errorSettingStack) {
        error.addTelemetryProperties({ stack2: stack });
    }
}
/**
 * True for any error object that is an (optionally normalized) external error
 * False for any error we created and raised within the FF codebase, or wrapped in a well-known error type
 */
function isExternalError(e) {
    return !(0, fluidErrorBase_1.isValidLegacyError)(e) ||
        (e.getTelemetryProperties().untrustedOrigin === 1 &&
            e.errorType === NormalizedExternalError.normalizedErrorType);
}
exports.isExternalError = isExternalError;
/**
 * Type guard to identify if a particular value (loosely) appears to be a tagged telemetry property
 */
function isTaggedTelemetryPropertyValue(x) {
    return (typeof (x === null || x === void 0 ? void 0 : x.value) !== "object" && typeof (x === null || x === void 0 ? void 0 : x.tag) === "string");
}
exports.isTaggedTelemetryPropertyValue = isTaggedTelemetryPropertyValue;
/**
 * Walk an object's enumerable properties to find those fit for telemetry.
 */
function getValidTelemetryProps(obj, keysToOmit) {
    const props = {};
    for (const key of Object.keys(obj)) {
        if (keysToOmit.has(key)) {
            continue;
        }
        const val = obj[key];
        switch (typeof val) {
            case "string":
            case "number":
            case "boolean":
            case "undefined":
                props[key] = val;
                break;
            default: {
                if (isTaggedTelemetryPropertyValue(val)) {
                    props[key] = val;
                }
                else {
                    // We don't support logging arbitrary objects
                    props[key] = "REDACTED (arbitrary object)";
                }
                break;
            }
        }
    }
    return props;
}
/**
 * Borrowed from
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value#examples}
 * Avoids runtime errors with circular references.
 * Not ideal, as will cut values that are not necessarily circular references.
 * Could be improved by implementing Node's util.inspect() for browser (minus all the coloring code)
*/
const getCircularReplacer = () => {
    const seen = new WeakSet();
    return (key, value) => {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "<removed/circular>";
            }
            seen.add(value);
        }
        return value;
    };
};
exports.getCircularReplacer = getCircularReplacer;
/**
 * Base class for "trusted" errors we create, whose properties can generally be logged to telemetry safely.
 * All properties set on the object, or passed in (via the constructor or addTelemetryProperties),
 * will be logged in accordance with their tag, if present.
 *
 * PLEASE take care to avoid setting sensitive data on this object without proper tagging!
 */
class LoggingError extends Error {
    /**
     * Create a new LoggingError
     * @param message - Error message to use for Error base class
     * @param props - telemetry props to include on the error for when it's logged
     * @param omitPropsFromLogging - properties by name to omit from telemetry props
     */
    constructor(message, props, omitPropsFromLogging = new Set()) {
        super(message);
        this.omitPropsFromLogging = omitPropsFromLogging;
        this._errorInstanceId = (0, uuid_1.v4)();
        /** Back-compat to appease isFluidError typeguard in old code that may handle this error */
        // @ts-expect-error - This field shouldn't be referenced in the current version, but needs to exist at runtime.
        this.fluidErrorCode = "-";
        // Don't log this list itself, or the private _errorInstanceId
        omitPropsFromLogging.add("omitPropsFromLogging");
        omitPropsFromLogging.add("_errorInstanceId");
        if (props) {
            this.addTelemetryProperties(props);
        }
    }
    get errorInstanceId() { return this._errorInstanceId; }
    overwriteErrorInstanceId(id) { this._errorInstanceId = id; }
    /**
     * Add additional properties to be logged
     */
    addTelemetryProperties(props) {
        copyProps(this, props);
    }
    /**
     * Get all properties fit to be logged to telemetry for this error
     */
    getTelemetryProperties() {
        const taggableProps = getValidTelemetryProps(this, this.omitPropsFromLogging);
        // Include non-enumerable props that are not returned by getValidTelemetryProps
        return Object.assign(Object.assign({}, taggableProps), { stack: this.stack, message: this.message, errorInstanceId: this._errorInstanceId });
    }
}
exports.LoggingError = LoggingError;
/** The Error class used when normalizing an external error */
class NormalizedExternalError extends LoggingError {
    constructor(errorProps) {
        super(errorProps.message);
        this.errorType = NormalizedExternalError.normalizedErrorType;
        if (errorProps.stack !== undefined) {
            overwriteStack(this, errorProps.stack);
        }
    }
}
// errorType "genericError" is used as a default value throughout the code.
// Note that this matches ContainerErrorType/DriverErrorType's genericError
NormalizedExternalError.normalizedErrorType = "genericError";

},{"./fluidErrorBase":278,"uuid":544}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEmitterWithErrorHandling = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Event Emitter helper class
 * Any exceptions thrown by listeners will be caught and raised through "error" event.
 * Any exception thrown by "error" listeners will propagate to the caller.
 */
class EventEmitterWithErrorHandling extends common_utils_1.TypedEventEmitter {
    constructor(errorHandler) {
        super();
        this.errorHandler = errorHandler;
    }
    emit(event, ...args) {
        try {
            return super.emit(event, ...args);
        }
        catch (error) {
            this.errorHandler(event, error);
            return true;
        }
    }
}
exports.EventEmitterWithErrorHandling = EventEmitterWithErrorHandling;

},{"@fluidframework/common-utils":29}],277:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.raiseConnectedEvent = exports.safeRaiseEvent = exports.disconnectedEventName = exports.connectedEventName = void 0;
exports.connectedEventName = "connected";
exports.disconnectedEventName = "disconnected";
function safeRaiseEvent(emitter, logger, event, ...args) {
    try {
        emitter.emit(event, ...args);
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseEventError", event }, error);
    }
}
exports.safeRaiseEvent = safeRaiseEvent;
function raiseConnectedEvent(logger, emitter, connected, clientId) {
    try {
        if (connected) {
            emitter.emit(exports.connectedEventName, clientId);
        }
        else {
            emitter.emit(exports.disconnectedEventName);
        }
    }
    catch (error) {
        logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
    }
}
exports.raiseConnectedEvent = raiseConnectedEvent;

},{}],278:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidLegacyError = exports.isFluidError = exports.hasErrorInstanceId = void 0;
const hasTelemetryPropFunctions = (x) => typeof (x === null || x === void 0 ? void 0 : x.getTelemetryProperties) === "function" &&
    typeof (x === null || x === void 0 ? void 0 : x.addTelemetryProperties) === "function";
const hasErrorInstanceId = (x) => typeof (x === null || x === void 0 ? void 0 : x.errorInstanceId) === "string";
exports.hasErrorInstanceId = hasErrorInstanceId;
/** type guard for IFluidErrorBase interface */
function isFluidError(e) {
    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === "string" &&
        typeof (e === null || e === void 0 ? void 0 : e.message) === "string" &&
        (0, exports.hasErrorInstanceId)(e) &&
        hasTelemetryPropFunctions(e);
}
exports.isFluidError = isFluidError;
/** type guard for old standard of valid/known errors */
function isValidLegacyError(e) {
    return typeof (e === null || e === void 0 ? void 0 : e.errorType) === "string" &&
        typeof (e === null || e === void 0 ? void 0 : e.message) === "string" &&
        hasTelemetryPropFunctions(e);
}
exports.isValidLegacyError = isValidLegacyError;

},{}],279:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loggerToMonitoringContext = exports.mixinMonitoringContext = exports.sessionStorageConfigProvider = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
__exportStar(require("./debugLogger"), exports);
__exportStar(require("./errorLogging"), exports);
__exportStar(require("./eventEmitterWithErrorHandling"), exports);
__exportStar(require("./events"), exports);
__exportStar(require("./fluidErrorBase"), exports);
__exportStar(require("./logger"), exports);
__exportStar(require("./mockLogger"), exports);
__exportStar(require("./thresholdCounter"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./sampledTelemetryHelper"), exports);
var config_1 = require("./config");
Object.defineProperty(exports, "sessionStorageConfigProvider", { enumerable: true, get: function () { return config_1.sessionStorageConfigProvider; } });
Object.defineProperty(exports, "mixinMonitoringContext", { enumerable: true, get: function () { return config_1.mixinMonitoringContext; } });
Object.defineProperty(exports, "loggerToMonitoringContext", { enumerable: true, get: function () { return config_1.loggerToMonitoringContext; } });

},{"./config":273,"./debugLogger":274,"./errorLogging":275,"./eventEmitterWithErrorHandling":276,"./events":277,"./fluidErrorBase":278,"./logger":280,"./mockLogger":281,"./sampledTelemetryHelper":282,"./thresholdCounter":283,"./utils":284}],280:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelemetryUTLogger = exports.PerformanceEvent = exports.MultiSinkLogger = exports.ChildLogger = exports.TaggedLoggerAdapter = exports.TelemetryLogger = exports.TelemetryDataTag = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const config_1 = require("./config");
const errorLogging_1 = require("./errorLogging");
/**
 * Broad classifications to be applied to individual properties as they're prepared to be logged to telemetry.
 * Please do not modify existing entries for backwards compatibility.
 */
var TelemetryDataTag;
(function (TelemetryDataTag) {
    /**
     * Data containing terms from code packages that may have been dynamically loaded
     * @deprecated 1.0, will be removed in next release (see issue #6603). Use `TelemetryDataTag.CodeArtifact` instead.
     */
    TelemetryDataTag["PackageData"] = "PackageData";
    /** Data containing terms or IDs from code packages that may have been dynamically loaded */
    TelemetryDataTag["CodeArtifact"] = "CodeArtifact";
    /** Personal data of a variety of classifications that pertains to the user */
    TelemetryDataTag["UserData"] = "UserData";
})(TelemetryDataTag = exports.TelemetryDataTag || (exports.TelemetryDataTag = {}));
/**
 * TelemetryLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class TelemetryLogger {
    constructor(namespace, properties) {
        this.namespace = namespace;
        this.properties = properties;
    }
    static formatTick(tick) {
        return Math.floor(tick);
    }
    /**
     * Attempts to parse number from string.
     * If fails,returns original string.
     * Used to make telemetry data typed (and support math operations, like comparison),
     * in places where we do expect numbers (like contentsize/duration property in http header)
     */
    static numberFromString(str) {
        if (str === undefined || str === null) {
            return undefined;
        }
        const num = Number(str);
        return Number.isNaN(num) ? str : num;
    }
    static sanitizePkgName(name) {
        return name.replace("@", "").replace("/", "-");
    }
    /**
     * Take an unknown error object and add the appropriate info from it to the event. Message and stack will be copied
     * over from the error object, along with other telemetry properties if it's an ILoggingError.
     * @param event - Event being logged
     * @param error - Error to extract info from
     * @param fetchStack - Whether to fetch the current callstack if error.stack is undefined
     */
    static prepareErrorObject(event, error, fetchStack) {
        const { message, errorType, stack } = (0, errorLogging_1.extractLogSafeErrorProperties)(error, true /* sanitizeStack */);
        // First, copy over error message, stack, and errorType directly (overwrite if present on event)
        event.stack = stack;
        event.error = message; // Note that the error message goes on the 'error' field
        event.errorType = errorType;
        if ((0, errorLogging_1.isILoggingError)(error)) {
            // Add any other telemetry properties from the LoggingError
            const telemetryProp = error.getTelemetryProperties();
            for (const key of Object.keys(telemetryProp)) {
                if (event[key] !== undefined) {
                    // Don't overwrite existing properties on the event
                    continue;
                }
                event[key] = telemetryProp[key];
            }
        }
        // Collect stack if we were not able to extract it from error
        if (event.stack === undefined && fetchStack) {
            event.stack = (0, errorLogging_1.generateStack)();
        }
    }
    /**
     * Send a telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendTelemetryEvent(event, error) {
        var _a;
        this.sendTelemetryEventCore(Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : "generic" }), error);
    }
    /**
     * Send a telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendTelemetryEventCore(event, error) {
        const newEvent = Object.assign({}, event);
        if (error !== undefined) {
            TelemetryLogger.prepareErrorObject(newEvent, error, false);
        }
        // Will include Nan & Infinity, but probably we do not care
        if (typeof newEvent.duration === "number") {
            newEvent.duration = TelemetryLogger.formatTick(newEvent.duration);
        }
        this.send(newEvent);
    }
    /**
     * Send an error telemetry event with the logger
     *
     * @param event - the event to send
     * @param error - optional error object to log
     */
    sendErrorEvent(event, error) {
        this.sendTelemetryEventCore(Object.assign(Object.assign({ 
            // ensure the error field has some value,
            // this can and will be overridden by event, or error
            error: event.eventName }, event), { category: "error" }), error);
    }
    /**
     * Send a performance telemetry event with the logger
     *
     * @param event - Event to send
     * @param error - optional error object to log
     */
    sendPerformanceEvent(event, error) {
        var _a;
        const perfEvent = Object.assign(Object.assign({}, event), { category: (_a = event.category) !== null && _a !== void 0 ? _a : "performance" });
        this.sendTelemetryEventCore(perfEvent, error);
    }
    prepareEvent(event) {
        const includeErrorProps = event.category === "error" || event.error !== undefined;
        const newEvent = Object.assign({}, event);
        if (this.namespace !== undefined) {
            newEvent.eventName = `${this.namespace}${TelemetryLogger.eventNamespaceSeparator}${newEvent.eventName}`;
        }
        if (this.properties) {
            const properties = [];
            properties.push(this.properties.all);
            if (includeErrorProps) {
                properties.push(this.properties.error);
            }
            for (const props of properties) {
                if (props !== undefined) {
                    for (const key of Object.keys(props)) {
                        if (event[key] !== undefined) {
                            continue;
                        }
                        const getterOrValue = props[key];
                        // If this throws, hopefully it is handled elsewhere
                        const value = typeof getterOrValue === "function" ? getterOrValue() : getterOrValue;
                        if (value !== undefined) {
                            newEvent[key] = value;
                        }
                    }
                }
            }
        }
        return newEvent;
    }
}
exports.TelemetryLogger = TelemetryLogger;
TelemetryLogger.eventNamespaceSeparator = ":";
/**
 * @deprecated 0.56, remove TaggedLoggerAdapter once its usage is removed from
 * container-runtime. Issue: #8191
 * TaggedLoggerAdapter class can add tag handling to your logger.
 */
class TaggedLoggerAdapter {
    constructor(logger) {
        this.logger = logger;
    }
    send(eventWithTagsMaybe) {
        const newEvent = {
            category: eventWithTagsMaybe.category,
            eventName: eventWithTagsMaybe.eventName,
        };
        for (const key of Object.keys(eventWithTagsMaybe)) {
            const taggableProp = eventWithTagsMaybe[key];
            const { value, tag } = (typeof taggableProp === "object")
                ? taggableProp
                : { value: taggableProp, tag: undefined };
            switch (tag) {
                case undefined:
                    // No tag means we can log plainly
                    newEvent[key] = value;
                    break;
                case TelemetryDataTag.PackageData:
                    // For Microsoft applications, PackageData is safe for now
                    // (we don't load 3P code in 1P apps)
                    newEvent[key] = value;
                    break;
                case TelemetryDataTag.UserData:
                    // Strip out anything tagged explicitly as PII.
                    // Alternate strategy would be to hash these props
                    newEvent[key] = "REDACTED (UserData)";
                    break;
                default:
                    // If we encounter a tag we don't recognize
                    // then we must assume we should scrub.
                    newEvent[key] = "REDACTED (unknown tag)";
                    break;
            }
        }
        this.logger.send(newEvent);
    }
}
exports.TaggedLoggerAdapter = TaggedLoggerAdapter;
/**
 * ChildLogger class contains various helper telemetry methods,
 * encoding in one place schemas for various types of Fluid telemetry events.
 * Creates sub-logger that appends properties to all events
 */
class ChildLogger extends TelemetryLogger {
    constructor(baseLogger, namespace, properties) {
        super(namespace, properties);
        this.baseLogger = baseLogger;
        // propagate the monitoring context
        if ((0, config_1.loggerIsMonitoringContext)(baseLogger)) {
            (0, config_1.mixinMonitoringContext)(this, new config_1.CachedConfigProvider(baseLogger.config));
        }
    }
    /**
     * Create child logger
     * @param baseLogger - Base logger to use to output events. If undefined, proper child logger
     * is created, but it does not sends telemetry events anywhere.
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    static create(baseLogger, namespace, properties) {
        // if we are creating a child of a child, rather than nest, which will increase
        // the callstack overhead, just generate a new logger that includes everything from the previous
        if (baseLogger instanceof ChildLogger) {
            const combinedProperties = {};
            for (const extendedProps of [baseLogger.properties, properties]) {
                if (extendedProps !== undefined) {
                    if (extendedProps.all !== undefined) {
                        combinedProperties.all = Object.assign(Object.assign({}, combinedProperties.all), extendedProps.all);
                    }
                    if (extendedProps.error !== undefined) {
                        combinedProperties.error = Object.assign(Object.assign({}, combinedProperties.error), extendedProps.error);
                    }
                }
            }
            const combinedNamespace = baseLogger.namespace === undefined
                ? namespace
                : namespace === undefined
                    ? baseLogger.namespace
                    : `${baseLogger.namespace}${TelemetryLogger.eventNamespaceSeparator}${namespace}`;
            return new ChildLogger(baseLogger.baseLogger, combinedNamespace, combinedProperties);
        }
        return new ChildLogger(baseLogger ? baseLogger : new common_utils_1.BaseTelemetryNullLogger(), namespace, properties);
    }
    /**
     * Send an event with the logger
     *
     * @param event - the event to send
     */
    send(event) {
        this.baseLogger.send(this.prepareEvent(event));
    }
}
exports.ChildLogger = ChildLogger;
/**
 * Multi-sink logger
 * Takes multiple ITelemetryBaseLogger objects (sinks) and logs all events into each sink
 * Implements ITelemetryBaseLogger (through static create() method)
 */
class MultiSinkLogger extends TelemetryLogger {
    /**
     * Create multiple sink logger (i.e. logger that sends events to multiple sinks)
     * @param namespace - Telemetry event name prefix to add to all events
     * @param properties - Base properties to add to all events
     * @param propertyGetters - Getters to add additional properties to all events
     */
    constructor(namespace, properties) {
        super(namespace, properties);
        this.loggers = [];
    }
    /**
     * Add logger to send all events to
     * @param logger - Logger to add
     */
    addLogger(logger) {
        if (logger !== undefined && logger !== null) {
            this.loggers.push(logger);
        }
    }
    /**
     * Send an event to the loggers
     *
     * @param event - the event to send to all the registered logger
     */
    send(event) {
        const newEvent = this.prepareEvent(event);
        this.loggers.forEach((logger) => {
            logger.send(newEvent);
        });
    }
}
exports.MultiSinkLogger = MultiSinkLogger;
/**
 * Helper class to log performance events
 */
class PerformanceEvent {
    constructor(logger, event, markers = { end: true, cancel: "generic" }) {
        this.logger = logger;
        this.markers = markers;
        this.startTime = common_utils_1.performance.now();
        this.event = Object.assign({}, event);
        if (this.markers.start) {
            this.reportEvent("start");
        }
        if (typeof window === "object" && window != null && window.performance) {
            this.startMark = `${event.eventName}-start`;
            window.performance.mark(this.startMark);
        }
    }
    static start(logger, event, markers) {
        return new PerformanceEvent(logger, event, markers);
    }
    static timedExec(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = callback(perfEvent);
            perfEvent.autoEnd();
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    static async timedExecAsync(logger, event, callback, markers) {
        const perfEvent = PerformanceEvent.start(logger, event, markers);
        try {
            const ret = await callback(perfEvent);
            perfEvent.autoEnd();
            return ret;
        }
        catch (error) {
            perfEvent.cancel(undefined, error);
            throw error;
        }
    }
    get duration() { return common_utils_1.performance.now() - this.startTime; }
    reportProgress(props, eventNameSuffix = "update") {
        this.reportEvent(eventNameSuffix, props);
    }
    autoEnd() {
        // Event might have been cancelled or ended in the callback
        if (this.event && this.markers.end) {
            this.reportEvent("end");
        }
        this.performanceEndMark();
        this.event = undefined;
    }
    end(props) {
        this.reportEvent("end", props);
        this.performanceEndMark();
        this.event = undefined;
    }
    performanceEndMark() {
        if (this.startMark && this.event) {
            const endMark = `${this.event.eventName}-end`;
            window.performance.mark(endMark);
            window.performance.measure(`${this.event.eventName}`, this.startMark, endMark);
            this.startMark = undefined;
        }
    }
    cancel(props, error) {
        if (this.markers.cancel !== undefined) {
            this.reportEvent("cancel", Object.assign({ category: this.markers.cancel }, props), error);
        }
        this.event = undefined;
    }
    /**
     * Report the event, if it hasn't already been reported.
     */
    reportEvent(eventNameSuffix, props, error) {
        // There are strange sequences involving multiple Promise chains
        // where the event can be cancelled and then later a callback is invoked
        // and the caller attempts to end directly, e.g. issue #3936. Just return.
        if (!this.event) {
            return;
        }
        const event = Object.assign(Object.assign({}, this.event), props);
        event.eventName = `${event.eventName}_${eventNameSuffix}`;
        if (eventNameSuffix !== "start") {
            event.duration = this.duration;
        }
        this.logger.sendPerformanceEvent(event, error);
    }
}
exports.PerformanceEvent = PerformanceEvent;
/**
 * Logger that is useful for UT
 * It can be used in places where logger instance is required, but events should be not send over.
 */
class TelemetryUTLogger {
    send(event) {
    }
    sendTelemetryEvent(event, error) {
    }
    sendErrorEvent(event, error) {
        this.reportError("errorEvent in UT logger!", event, error);
    }
    sendPerformanceEvent(event, error) {
    }
    logGenericError(eventName, error) {
        this.reportError(`genericError in UT logger!`, { eventName }, error);
    }
    logException(event, exception) {
        this.reportError("exception in UT logger!", event, exception);
    }
    debugAssert(condition, event) {
        this.reportError("debugAssert in UT logger!");
    }
    shipAssert(condition, event) {
        this.reportError("shipAssert in UT logger!");
    }
    reportError(message, event, err) {
        const error = new Error(message);
        error.error = error;
        error.event = event;
        // report to console as exception can be eaten
        console.error(message);
        console.error(error);
        throw error;
    }
}
exports.TelemetryUTLogger = TelemetryUTLogger;

},{"./config":273,"./errorLogging":275,"@fluidframework/common-utils":29}],281:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockLogger = void 0;
const logger_1 = require("./logger");
/**
 * The MockLogger records events sent to it, and then can walk back over those events
 * searching for a set of expected events to match against the logged events.
 */
class MockLogger extends logger_1.TelemetryLogger {
    constructor() {
        super();
        this.events = [];
    }
    clear() {
        this.events = [];
    }
    send(event) {
        this.events.push(event);
    }
    /**
     * Search events logged since the last time matchEvents was called, looking for the given expected
     * events in order.
     * @param expectedEvents - events in order that are expected to appear in the recorded log.
     * These event objects may be subsets of the logged events.
     * Note: category is ommitted from the type because it's usually uninteresting and tedious to type.
     */
    matchEvents(expectedEvents) {
        const matchedExpectedEventCount = this.getMatchedEventsCount(expectedEvents);
        // How many expected events were left over? Hopefully none.
        const unmatchedExpectedEventCount = expectedEvents.length - matchedExpectedEventCount;
        return unmatchedExpectedEventCount === 0;
    }
    /** Asserts that matchEvents is true, and prints the actual/expected output if not */
    assertMatch(expectedEvents, message) {
        const actualEvents = this.events;
        if (!this.matchEvents(expectedEvents)) {
            throw new Error(`${message}
expected:
${JSON.stringify(expectedEvents)}

actual:
${JSON.stringify(actualEvents)}`);
        }
    }
    /**
     * Search events logged since the last time matchEvents was called, looking for any of the given
     * expected events.
     * @param expectedEvents - events that are expected to appear in the recorded log.
     * These event objects may be subsets of the logged events.
     * Note: category is ommitted from the type because it's usually uninteresting and tedious to type.
     * @returns if any of the expected events is found.
     */
    matchAnyEvent(expectedEvents) {
        const matchedExpectedEventCount = this.getMatchedEventsCount(expectedEvents);
        return matchedExpectedEventCount > 0;
    }
    /** Asserts that matchAnyEvent is true, and prints the actual/expected output if not */
    assertMatchAny(expectedEvents, message) {
        const actualEvents = this.events;
        if (!this.matchAnyEvent(expectedEvents)) {
            throw new Error(`${message}
expected:
${JSON.stringify(expectedEvents)}

actual:
${JSON.stringify(actualEvents)}`);
        }
    }
    getMatchedEventsCount(expectedEvents) {
        let iExpectedEvent = 0;
        this.events.forEach((event) => {
            if (iExpectedEvent < expectedEvents.length &&
                MockLogger.eventsMatch(event, expectedEvents[iExpectedEvent])) {
                // We found the next expected event; increment
                ++iExpectedEvent;
            }
        });
        // Remove the events so far; next call will just compare subsequent events from here
        this.events = [];
        // Return the count of matched events.
        return iExpectedEvent;
    }
    /**
     * Ensure the expected event is a strict subset of the actual event
     */
    static eventsMatch(actual, expected) {
        const masked = Object.assign(Object.assign({}, actual), expected);
        return JSON.stringify(masked) === JSON.stringify(actual);
    }
}
exports.MockLogger = MockLogger;

},{"./logger":280}],282:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SampledTelemetryHelper = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Helper class that executes a specified code block and writes an
 * {@link @fluidframework/common-definitions#ITelemetryPerformanceEvent} to a specified logger every time a specified
 * number of executions is reached (or when the class is disposed). The `duration` field in the telemetry event is
 * the duration of the latest execution (sample) of the specified function. See the documentation of the
 * `includeAggregateMetrics` parameter for additional details that can be included.
 */
class SampledTelemetryHelper {
    /**
     * @param eventBase -
     * Custom properties to include in the telemetry performance event when it is written.
     * @param logger -
     * The logger to use to write the telemetry performance event.
     * @param sampleThreshold -
     * Telemetry performance events will be generated every time we hit this many executions of the code block.
     * @param includeAggregateMetrics -
     * If set to `true`, the telemetry performance event will include aggregated metrics (total duration, min duration,
     * max duration) for all the executions in between generated events.
     * @param perBucketProperties -
     * Map of strings that represent different buckets (which can be specified when calling the 'measure' method), to
     * properties which should be added to the telemetry event for that bucket. If a bucket being measured does not
     * have an entry in this map, no additional properties will be added to its telemetry events. The following keys are
     * reserved for use by this class: "duration", "count", "totalDuration", "minDuration", "maxDuration". If any of
     * them is specified as a key in one of the ITelemetryProperties objects in this map, that key-value pair will be
     * ignored.
     */
    constructor(eventBase, logger, sampleThreshold, includeAggregateMetrics = false, perBucketProperties = new Map()) {
        this.eventBase = eventBase;
        this.logger = logger;
        this.sampleThreshold = sampleThreshold;
        this.includeAggregateMetrics = includeAggregateMetrics;
        this.perBucketProperties = perBucketProperties;
        this.disposed = false;
        this.measurementsMap = new Map();
    }
    /**
     * @param codeToMeasure -
     * The code to be executed and measured.
     * @param bucket -
     * A key to track executions of the code block separately. Each different value of this parameter has a separate
     * set of executions and metrics tracked by the class. If no such distinction needs to be made, do not provide a
     * value.
     * @returns Whatever the passed-in code block returns.
     */
    measure(codeToMeasure, bucket = "") {
        var _a, _b, _c;
        const start = common_utils_1.performance.now();
        const returnValue = codeToMeasure();
        const duration = common_utils_1.performance.now() - start;
        let m = this.measurementsMap.get(bucket);
        if (m === undefined) {
            m = { count: 0, duration: -1 };
            this.measurementsMap.set(bucket, m);
        }
        m.count++;
        m.duration = duration;
        if (this.includeAggregateMetrics) {
            m.totalDuration = ((_a = m.totalDuration) !== null && _a !== void 0 ? _a : 0) + duration;
            m.minDuration = Math.min((_b = m.minDuration) !== null && _b !== void 0 ? _b : duration, duration);
            m.maxDuration = Math.max((_c = m.maxDuration) !== null && _c !== void 0 ? _c : 0, duration);
        }
        if (m.count >= this.sampleThreshold) {
            this.flushBucket(bucket);
        }
        return returnValue;
    }
    flushBucket(bucket) {
        const measurements = this.measurementsMap.get(bucket);
        if (measurements === undefined) {
            return;
        }
        if (measurements.count !== 0) {
            const bucketProperties = this.perBucketProperties.get(bucket);
            const telemetryEvent = Object.assign(Object.assign(Object.assign({}, this.eventBase), bucketProperties), measurements);
            this.logger.sendPerformanceEvent(telemetryEvent);
            this.measurementsMap.delete(bucket);
        }
    }
    dispose(error) {
        this.measurementsMap.forEach((_, k) => this.flushBucket(k));
    }
}
exports.SampledTelemetryHelper = SampledTelemetryHelper;

},{"@fluidframework/common-utils":29}],283:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThresholdCounter = void 0;
/**
 * Utility counter which will send event only if the provided value
 * is above a configured threshold
 */
class ThresholdCounter {
    constructor(threshold, logger, thresholdMultiple = threshold) {
        this.threshold = threshold;
        this.logger = logger;
        this.thresholdMultiple = thresholdMultiple;
    }
    /**
     * Sends the value if it's above the treshold.
     */
    send(eventName, value) {
        if (value < this.threshold) {
            return;
        }
        this.logger.sendPerformanceEvent({
            eventName,
            value,
        });
    }
    /**
     * Sends the value if it's above the treshold
     * and a multiple of the threshold.
     *
     * To be used in scenarios where we'd like to record a
     * threshold violation while reducing telemetry noise.
     */
    sendIfMultiple(eventName, value) {
        if (value === this.thresholdMultiple) {
            this.logger.sendPerformanceEvent({
                eventName,
                value,
            });
            // reduce number of "multiple" events.
            this.thresholdMultiple = this.thresholdMultiple * 2;
        }
    }
}
exports.ThresholdCounter = ThresholdCounter;

},{}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logIfFalse = void 0;
/**
 * Like assert, but logs only if the condition is false, rather than throwing
 * @param condition - The condition to attest too
 * @param logger - The logger to log with
 * @param event - The string or event to log
 * @returns - The outcome of the condition
 */
function logIfFalse(condition, logger, event) {
    if (condition) {
        return true;
    }
    const newEvent = typeof event === "string"
        ? { eventName: event, category: "error" }
        : Object.assign({ category: "error" }, event);
    logger.send(newEvent);
    return false;
}
exports.logIfFalse = logIfFalse;

},{}],285:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinyliciousAudience = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const fluid_static_1 = require("@fluidframework/fluid-static");
/**
 * {@inheritDoc ITinyliciousAudience}
 */
class TinyliciousAudience extends fluid_static_1.ServiceAudience {
    /**
     * @internal
     */
    createServiceMember(audienceMember) {
        const tinyliciousUser = audienceMember.user;
        (0, common_utils_1.assert)(tinyliciousUser !== undefined && typeof tinyliciousUser.name === "string", 0x313 /* Specified user was not of type "TinyliciousUser". */);
        return {
            userId: tinyliciousUser.id,
            userName: tinyliciousUser.name,
            connections: [],
        };
    }
}
exports.TinyliciousAudience = TinyliciousAudience;

},{"@fluidframework/common-utils":29,"@fluidframework/fluid-static":127}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinyliciousClient = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const container_loader_1 = require("@fluidframework/container-loader");
const container_definitions_1 = require("@fluidframework/container-definitions");
const routerlicious_driver_1 = require("@fluidframework/routerlicious-driver");
const tinylicious_driver_1 = require("@fluidframework/tinylicious-driver");
const runtime_utils_1 = require("@fluidframework/runtime-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const fluid_static_1 = require("@fluidframework/fluid-static");
const TinyliciousAudience_1 = require("./TinyliciousAudience");
/**
 * Provides the ability to have a Fluid object backed by a Tinylicious service.
 *
 * See {@link https://fluidframework.com/docs/testing/tinylicious/}
 */
class TinyliciousClient {
    /**
     * Creates a new client instance using configuration parameters.
     * @param props - Optional. Properties for initializing a new TinyliciousClient instance
     */
    constructor(props) {
        var _a, _b, _c, _d;
        this.props = props;
        const tokenProvider = new tinylicious_driver_1.InsecureTinyliciousTokenProvider();
        this.urlResolver = new tinylicious_driver_1.InsecureTinyliciousUrlResolver((_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.port, (_d = (_c = this.props) === null || _c === void 0 ? void 0 : _c.connection) === null || _d === void 0 ? void 0 : _d.domain);
        this.documentServiceFactory = new routerlicious_driver_1.RouterliciousDocumentServiceFactory(tokenProvider);
    }
    /**
     * Creates a new detached container instance in Tinylicious server.
     * @param containerSchema - Container schema for the new container.
     * @returns New detached container instance along with associated services.
     */
    async createContainer(containerSchema) {
        const loader = this.createLoader(containerSchema);
        // We're not actually using the code proposal (our code loader always loads the same module
        // regardless of the proposal), but the Container will only give us a NullRuntime if there's
        // no proposal.  So we'll use a fake proposal.
        const container = await loader.createDetachedContainer({
            package: "no-dynamic-package",
            config: {},
        });
        const rootDataObject = await (0, runtime_utils_1.requestFluidObject)(container, "/");
        const fluidContainer = new (class extends fluid_static_1.FluidContainer {
            async attach() {
                if (this.attachState !== container_definitions_1.AttachState.Detached) {
                    throw new Error("Cannot attach container. Container is not in detached state");
                }
                const request = (0, tinylicious_driver_1.createTinyliciousCreateNewRequest)();
                await container.attach(request);
                const resolved = container.resolvedUrl;
                (0, driver_utils_1.ensureFluidResolvedUrl)(resolved);
                return resolved.id;
            }
        })(container, rootDataObject);
        const services = this.getContainerServices(container);
        return { container: fluidContainer, services };
    }
    /**
     * Accesses the existing container given its unique ID in the tinylicious server.
     * @param id - Unique ID of the container.
     * @param containerSchema - Container schema used to access data objects in the container.
     * @returns Existing container instance along with associated services.
     */
    async getContainer(id, containerSchema) {
        const loader = this.createLoader(containerSchema);
        const container = await loader.resolve({ url: id });
        const rootDataObject = await (0, runtime_utils_1.requestFluidObject)(container, "/");
        const fluidContainer = new fluid_static_1.FluidContainer(container, rootDataObject);
        const services = this.getContainerServices(container);
        return { container: fluidContainer, services };
    }
    // #region private
    getContainerServices(container) {
        return {
            audience: new TinyliciousAudience_1.TinyliciousAudience(container),
        };
    }
    createLoader(containerSchema) {
        var _a;
        const containerRuntimeFactory = new fluid_static_1.DOProviderContainerRuntimeFactory(containerSchema);
        const load = async () => {
            return {
                module: { fluidExport: containerRuntimeFactory },
                details: { package: "no-dynamic-package", config: {} },
            };
        };
        const codeLoader = { load };
        const loader = new container_loader_1.Loader({
            urlResolver: this.urlResolver,
            documentServiceFactory: this.documentServiceFactory,
            codeLoader,
            logger: (_a = this.props) === null || _a === void 0 ? void 0 : _a.logger,
        });
        return loader;
    }
}
exports.TinyliciousClient = TinyliciousClient;

},{"./TinyliciousAudience":285,"@fluidframework/container-definitions":50,"@fluidframework/container-loader":301,"@fluidframework/driver-utils":110,"@fluidframework/fluid-static":127,"@fluidframework/routerlicious-driver":194,"@fluidframework/runtime-utils":213,"@fluidframework/tinylicious-driver":308}],287:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The **tinylicious-client** package provides a simple and powerful way to consume collaborative Fluid data with the
 * Tinylicious service.
 *
 * The Tinylicious service is a local, in-memory Fluid service intended for prototyping and development purposes.
 *
 * See {@link https://fluidframework.com/docs/testing/tinylicious/}
 *
 * @packageDocumentation
 */
const TinyliciousClient_1 = require("./TinyliciousClient");
__exportStar(require("./interfaces"), exports);
__exportStar(require("./TinyliciousAudience"), exports);
__exportStar(require("./TinyliciousClient"), exports);
// eslint-disable-next-line import/no-default-export
exports.default = TinyliciousClient_1.TinyliciousClient;

},{"./TinyliciousAudience":285,"./TinyliciousClient":286,"./interfaces":288}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Audience = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const events_1 = require("events");
/**
 * Audience represents all clients connected to the op stream.
 */
class Audience extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.members = new Map();
    }
    on(event, listener) {
        return super.on(event, listener);
    }
    /**
     * Adds a new client to the audience
     */
    addMember(clientId, details) {
        this.members.set(clientId, details);
        this.emit("addMember", clientId, details);
    }
    /**
     * Removes a client from the audience. Only emits an event if a client is actually removed
     * @returns if a client was removed from the audience
     */
    removeMember(clientId) {
        const removedClient = this.members.get(clientId);
        if (removedClient !== undefined) {
            this.members.delete(clientId);
            this.emit("removeMember", clientId, removedClient);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Retrieves all the members in the audience
     */
    getMembers() {
        return new Map(this.members);
    }
    /**
     * Retrieves a specific member of the audience
     */
    getMember(clientId) {
        return this.members.get(clientId);
    }
    /**
     * Clears the audience
     */
    clear() {
        const clientIds = this.members.keys();
        for (const clientId of clientIds) {
            this.removeMember(clientId);
        }
    }
}
exports.Audience = Audience;

},{"events":562}],290:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollabWindowTracker = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const defaultNoopTimeFrequency = 2000;
const defaultNoopCountFrequency = 50;
// Here are key considerations when deciding conditions for when to send non-immediate noops:
// 1. Sending them too often results in increase in file size and bandwidth, as well as catch up performance
// 2. Sending too infrequently ensures that collab window is large, and as result Sequence DDS would have
//    large catchUp blobs - see Issue #6364
// 3. Similarly, processes that rely on "core" snapshot (and can't parse trailing ops, including above), like search
//    parser in SPO, will result in non-accurate results due to presence of catch up blobs.
// 4. Ordering service used 250ms timeout to coalesce non-immediate noops. It was changed to 2000 ms to allow more
//    aggressive noop sending from client side.
// 5. Number of ops sent by all clients is proportional to number of "write" clients (every client sends noops),
//    but number of sequenced noops is a function of time (one op per 2 seconds at most).
//    We should consider impact to both outbound traffic (might be huge, depends on number of clients) and file size.
// Please also see Issue #5629 for more discussions.
//
// With that, the current algorithm is as follows:
// 1. Sent noop 2000 ms of receiving an op if no ops were sent by this client within this timeframe.
//    This will ensure that MSN moves forward with reasonable speed. If that results in too many sequenced noops,
//    server timeout of 2000ms should be reconsidered to be increased.
// 2. If there are more than 50 ops received without sending any ops, send noop to keep collab window small.
//    Note that system ops (including noops themselves) are excluded, so it's 1 noop per 50 real ops.
class CollabWindowTracker {
    constructor(submit, NoopTimeFrequency = defaultNoopTimeFrequency, NoopCountFrequency = defaultNoopCountFrequency) {
        this.submit = submit;
        this.NoopCountFrequency = NoopCountFrequency;
        this.opsCountSinceNoop = 0;
        if (NoopTimeFrequency !== Infinity) {
            this.timer = new common_utils_1.Timer(NoopTimeFrequency, () => {
                // Can get here due to this.stopSequenceNumberUpdate() not resetting timer.
                // Also timer callback can fire even after timer cancellation if it was queued before cancellation.
                if (this.opsCountSinceNoop !== 0) {
                    this.submitNoop(false /* immediate */);
                }
            });
        }
    }
    /**
     * Schedules as ack to the server to update the reference sequence number
     */
    scheduleSequenceNumberUpdate(message, immediateNoOp) {
        // While processing a message, an immediate no-op can be requested.
        // i.e. to expedite approve or commit phase of quorum.
        if (immediateNoOp) {
            this.submitNoop(true /* immediate */);
            return;
        }
        // We don't acknowledge no-ops to avoid acknowledgement cycles (i.e. ack the MSN
        // update, which updates the MSN, then ack the update, etc...).
        // Intent here is for runtime (and DDSes) not to keep too much tracking state / memory
        // due to runtime ops from other clients.
        if (!(0, driver_utils_1.isRuntimeMessage)(message)) {
            return;
        }
        this.opsCountSinceNoop++;
        if (this.opsCountSinceNoop >= this.NoopCountFrequency) {
            this.submitNoop(false /* immediate */);
            return;
        }
        if (this.timer !== undefined) {
            if (this.opsCountSinceNoop === 1) {
                this.timer.restart();
            }
            (0, common_utils_1.assert)(this.timer.hasTimer, 0x242 /* "has timer" */);
        }
    }
    submitNoop(immediate) {
        // Anything other than null is immediate noop
        this.submit(protocol_definitions_1.MessageType.NoOp, immediate ? "" : null);
        (0, common_utils_1.assert)(this.opsCountSinceNoop === 0, 0x243 /* "stopSequenceNumberUpdate should be called as result of sending any op!" */);
    }
    stopSequenceNumberUpdate() {
        this.opsCountSinceNoop = 0;
        // Ideally, we cancel timer here. But that will result in too often set/reset cycle if this client
        // keeps sending ops. In most cases it's actually better to let it expire (at most - 4 times per second)
        // for nothing, then have a ton of set/reset cycles.
        // Note that Timer.restart() is smart and will not change timer expiration if we keep extending timer
        // expiration - it will restart the timer instead when it fires with adjusted expiration.
        // this.timer.clear();
    }
}
exports.CollabWindowTracker = CollabWindowTracker;

},{"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174}],291:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionManager = void 0;
const abort_controller_1 = __importDefault(require("abort-controller"));
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const contracts_1 = require("./contracts");
const deltaQueue_1 = require("./deltaQueue");
const MaxReconnectDelayInMs = 8000;
const InitialReconnectDelayInMs = 1000;
const DefaultChunkSize = 16 * 1024;
const fatalConnectErrorProp = { fatalConnectError: true };
function getNackReconnectInfo(nackContent) {
    const message = `Nack (${nackContent.type}): ${nackContent.message}`;
    const canRetry = nackContent.code !== 403;
    const retryAfterMs = nackContent.retryAfter !== undefined ? nackContent.retryAfter * 1000 : undefined;
    return (0, driver_utils_1.createGenericNetworkError)(message, { canRetry, retryAfterMs }, { statusCode: nackContent.code, driverVersion: undefined });
}
/**
 * Implementation of IDocumentDeltaConnection that does not support submitting
 * or receiving ops. Used in storage-only mode.
 */
class NoDeltaStream extends common_utils_1.TypedEventEmitter {
    constructor() {
        super(...arguments);
        this.clientId = "storage-only client";
        this.claims = {
            scopes: [protocol_definitions_1.ScopeType.DocRead],
        };
        this.mode = "read";
        this.existing = true;
        this.maxMessageSize = 0;
        this.version = "";
        this.initialMessages = [];
        this.initialSignals = [];
        this.initialClients = [];
        this.serviceConfiguration = {
            maxMessageSize: 0,
            blockSize: 0,
            summary: undefined,
        };
        this.checkpointSequenceNumber = undefined;
        this._disposed = false;
    }
    submit(messages) {
        this.emit("nack", this.clientId, messages.map((operation) => {
            return {
                operation,
                content: { message: "Cannot submit with storage-only connection", code: 403 },
            };
        }));
    }
    submitSignal(message) {
        this.emit("nack", this.clientId, {
            operation: message,
            content: { message: "Cannot submit signal with storage-only connection", code: 403 },
        });
    }
    get disposed() { return this._disposed; }
    dispose() { this._disposed = true; }
}
/**
 * Implementation of IConnectionManager, used by Container class
 * Implements constant connectivity to relay service, by reconnecting in case of loast connection or error.
 * Exposes various controls to influecen this process, including manual reconnects, forced read-only mode, etc.
 */
class ConnectionManager {
    constructor(serviceProvider, client, reconnectAllowed, logger, props) {
        this.serviceProvider = serviceProvider;
        this.client = client;
        this.logger = logger;
        this.props = props;
        /** tracks host requiring read-only mode. */
        this._forceReadonly = false;
        /** True if there is pending (async) reconnection from "read" to "write" */
        this.pendingReconnect = false;
        this.clientSequenceNumber = 0;
        this.clientSequenceNumberObserved = 0;
        /** Counts the number of noops sent by the client which may not be acked. */
        this.trailingNoopCount = 0;
        this.connectFirstConnection = true;
        this._connectionVerboseProps = {};
        this._connectionProps = {};
        this.closed = false;
        this.opHandler = (documentId, messagesArg) => {
            const messages = Array.isArray(messagesArg) ? messagesArg : [messagesArg];
            this.props.incomingOpHandler(messages, "opHandler");
        };
        // Always connect in write mode after getting nacked.
        this.nackHandler = (documentId, messages) => {
            const message = messages[0];
            if (this._readonlyPermissions === true) {
                this.props.closeHandler((0, driver_utils_1.createWriteError)("writeOnReadOnlyDocument", { driverVersion: undefined }));
                return;
            }
            const reconnectInfo = getNackReconnectInfo(message.content);
            // If the nack indicates we cannot retry, then close the container outright
            if (!reconnectInfo.canRetry) {
                this.props.closeHandler(reconnectInfo);
                return;
            }
            this.reconnectOnError("write", reconnectInfo);
        };
        // Connection mode is always read on disconnect/error unless the system mode was write.
        this.disconnectHandlerInternal = (disconnectReason) => {
            // Note: we might get multiple disconnect calls on same socket, as early disconnect notification
            // ("server_disconnect", ODSP-specific) is mapped to "disconnect"
            this.reconnectOnError(this.defaultReconnectionMode, disconnectReason);
        };
        this.errorHandler = (error) => {
            this.reconnectOnError(this.defaultReconnectionMode, error);
        };
        this.clientDetails = this.client.details;
        this.defaultReconnectionMode = this.client.mode;
        this._reconnectMode = reconnectAllowed ? contracts_1.ReconnectMode.Enabled : contracts_1.ReconnectMode.Never;
        // Outbound message queue. The outbound queue is represented as a queue of an array of ops. Ops contained
        // within an array *must* fit within the maxMessageSize and are guaranteed to be ordered sequentially.
        this._outbound = new deltaQueue_1.DeltaQueue((messages) => {
            if (this.connection === undefined) {
                throw new Error("Attempted to submit an outbound message without connection");
            }
            this.connection.submit(messages);
        });
        this._outbound.on("error", (error) => {
            this.props.closeHandler((0, telemetry_utils_1.normalizeError)(error));
        });
    }
    get connectionVerboseProps() { return this._connectionVerboseProps; }
    /**
     * The current connection mode, initially read.
     */
    get connectionMode() {
        var _a, _b;
        return (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : "read";
    }
    get connected() { return this.connection !== undefined; }
    get clientId() { var _a; return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId; }
    /**
     * Automatic reconnecting enabled or disabled.
     * If set to Never, then reconnecting will never be allowed.
     */
    get reconnectMode() {
        return this._reconnectMode;
    }
    get maxMessageSize() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration) === null || _b === void 0 ? void 0 : _b.maxMessageSize) !== null && _c !== void 0 ? _c : DefaultChunkSize;
    }
    get version() {
        if (this.connection === undefined) {
            throw new Error("Cannot check version without a connection");
        }
        return this.connection.version;
    }
    get serviceConfiguration() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.serviceConfiguration;
    }
    get scopes() {
        var _a;
        return (_a = this.connection) === null || _a === void 0 ? void 0 : _a.claims.scopes;
    }
    get outbound() {
        return this._outbound;
    }
    /**
     * Returns set of props that can be logged in telemetry that provide some insights / statistics
     * about current or last connection (if there is no connection at the moment)
    */
    get connectionProps() {
        if (this.connection !== undefined) {
            return this._connectionProps;
        }
        else {
            return Object.assign(Object.assign({}, this._connectionProps), { 
                // Report how many ops this client sent in last disconnected session
                sentOps: this.clientSequenceNumber });
        }
    }
    shouldJoinWrite() {
        // We don't have to wait for ack for topmost NoOps. So subtract those.
        return this.clientSequenceNumberObserved < (this.clientSequenceNumber - this.trailingNoopCount);
    }
    /**
     * Tells if container is in read-only mode.
     * Data stores should listen for "readonly" notifications and disallow user
     * making changes to data stores.
     * Readonly state can be because of no storage write permission,
     * or due to host forcing readonly mode for container.
     * It is undefined if we have not yet established websocket connection
     * and do not know if user has write access to a file.
     */
    get readonly() {
        if (this._forceReadonly) {
            return true;
        }
        return this._readonlyPermissions;
    }
    get readOnlyInfo() {
        const storageOnly = this.connection !== undefined && this.connection instanceof NoDeltaStream;
        if (storageOnly || this._forceReadonly || this._readonlyPermissions === true) {
            return {
                readonly: true,
                forced: this._forceReadonly,
                permissions: this._readonlyPermissions,
                storageOnly,
            };
        }
        return { readonly: this._readonlyPermissions };
    }
    static detailsFromConnection(connection) {
        return {
            claims: connection.claims,
            clientId: connection.clientId,
            existing: connection.existing,
            checkpointSequenceNumber: connection.checkpointSequenceNumber,
            get initialClients() { return connection.initialClients; },
            mode: connection.mode,
            serviceConfiguration: connection.serviceConfiguration,
            version: connection.version,
        };
    }
    dispose(error) {
        if (this.closed) {
            return;
        }
        this.closed = true;
        this.pendingConnection = undefined;
        // Ensure that things like triggerConnect() will short circuit
        this._reconnectMode = contracts_1.ReconnectMode.Never;
        this._outbound.clear();
        const disconnectReason = error !== undefined
            ? `Closing DeltaManager (${error.message})`
            : "Closing DeltaManager";
        // This raises "disconnect" event if we have active connection.
        this.disconnectFromDeltaStream(disconnectReason);
        // Notify everyone we are in read-only state.
        // Useful for data stores in case we hit some critical error,
        // to switch to a mode where user edits are not accepted
        this.set_readonlyPermissions(true);
    }
    /**
     * Enables or disables automatic reconnecting.
     * Will throw an error if reconnectMode set to Never.
    */
    setAutoReconnect(mode) {
        (0, common_utils_1.assert)(mode !== contracts_1.ReconnectMode.Never && this._reconnectMode !== contracts_1.ReconnectMode.Never, 0x278 /* "API is not supported for non-connecting or closed container" */);
        this._reconnectMode = mode;
        if (mode !== contracts_1.ReconnectMode.Enabled) {
            // immediately disconnect - do not rely on service eventually dropping connection.
            this.disconnectFromDeltaStream("setAutoReconnect");
        }
    }
    /**
     * Sends signal to runtime (and data stores) to be read-only.
     * Hosts may have read only views, indicating to data stores that no edits are allowed.
     * This is independent from this._readonlyPermissions (permissions) and this.connectionMode
     * (server can return "write" mode even when asked for "read")
     * Leveraging same "readonly" event as runtime & data stores should behave the same in such case
     * as in read-only permissions.
     * But this.active can be used by some DDSes to figure out if ops can be sent
     * (for example, read-only view still participates in code proposals / upgrades decisions)
     *
     * Forcing Readonly does not prevent DDS from generating ops. It is up to user code to honour
     * the readonly flag. If ops are generated, they will accumulate locally and not be sent. If
     * there are pending in the outbound queue, it will stop sending until force readonly is
     * cleared.
     *
     * @param readonly - set or clear force readonly.
     */
    forceReadonly(readonly) {
        if (readonly !== this._forceReadonly) {
            this.logger.sendTelemetryEvent({
                eventName: "ForceReadOnly",
                value: readonly,
            });
        }
        const oldValue = this.readonly;
        this._forceReadonly = readonly;
        if (oldValue !== this.readonly) {
            if (this._reconnectMode === contracts_1.ReconnectMode.Never) {
                throw new container_utils_1.UsageError("API is not supported for non-connecting or closed container");
            }
            let reconnect = false;
            if (this.readonly === true) {
                // If we switch to readonly while connected, we should disconnect first
                // See comment in the "readonly" event handler to deltaManager set up by
                // the ContainerRuntime constructor
                if (this.shouldJoinWrite()) {
                    // If we have pending changes, then we will never send them - it smells like
                    // host logic error.
                    this.logger.sendErrorEvent({ eventName: "ForceReadonlyPendingChanged" });
                }
                reconnect = this.disconnectFromDeltaStream("Force readonly");
            }
            this.props.readonlyChangeHandler(this.readonly);
            if (reconnect) {
                // reconnect if we disconnected from before.
                this.triggerConnect("read");
            }
        }
    }
    set_readonlyPermissions(readonly) {
        const oldValue = this.readonly;
        this._readonlyPermissions = readonly;
        if (oldValue !== this.readonly) {
            this.props.readonlyChangeHandler(this.readonly);
        }
    }
    connect(connectionMode) {
        this.connectCore(connectionMode).catch((error) => {
            const normalizedError = (0, telemetry_utils_1.normalizeError)(error, { props: fatalConnectErrorProp });
            this.props.closeHandler(normalizedError);
        });
    }
    async connectCore(connectionMode) {
        var _a, _b;
        (0, common_utils_1.assert)(!this.closed, 0x26a /* "not closed" */);
        if (this.connection !== undefined) {
            return; // Connection attempt already completed successfully
        }
        let pendingConnectionMode;
        if (this.pendingConnection !== undefined) {
            pendingConnectionMode = this.pendingConnection.connectionMode;
            this.cancelConnection(); // Throw out in-progress connection attempt in favor of new attempt
            (0, common_utils_1.assert)(this.pendingConnection === undefined, 0x344 /* this.pendingConnection should be undefined */);
        }
        // If there is no specified ConnectionMode, try the previous mode, if there is no previous mode use default
        let requestedMode = (_a = connectionMode !== null && connectionMode !== void 0 ? connectionMode : pendingConnectionMode) !== null && _a !== void 0 ? _a : this.defaultReconnectionMode;
        // if we have any non-acked ops from last connection, reconnect as "write".
        // without that we would connect in view-only mode, which will result in immediate
        // firing of "connected" event from Container and switch of current clientId (as tracked
        // by all DDSes). This will make it impossible to figure out if ops actually made it through,
        // so DDSes will immediately resubmit all pending ops, and some of them will be duplicates, corrupting document
        if (this.shouldJoinWrite()) {
            requestedMode = "write";
        }
        const docService = this.serviceProvider();
        (0, common_utils_1.assert)(docService !== undefined, 0x2a7 /* "Container is not attached" */);
        let connection;
        if (((_b = docService.policies) === null || _b === void 0 ? void 0 : _b.storageOnly) === true) {
            connection = new NoDeltaStream();
            this.setupNewSuccessfulConnection(connection, "read");
            (0, common_utils_1.assert)(this.pendingConnection === undefined, 0x2b3 /* "logic error" */);
            return;
        }
        let delayMs = InitialReconnectDelayInMs;
        let connectRepeatCount = 0;
        const connectStartTime = common_utils_1.performance.now();
        let lastError;
        const abortController = new abort_controller_1.default();
        const abortSignal = abortController.signal;
        this.pendingConnection = { abort: () => { abortController.abort(); }, connectionMode: requestedMode };
        // This loop will keep trying to connect until successful, with a delay between each iteration.
        while (connection === undefined) {
            if (this.closed) {
                throw new Error("Attempting to connect a closed DeltaManager");
            }
            if (abortSignal.aborted === true) {
                this.logger.sendTelemetryEvent({
                    eventName: "ConnectionAttemptCancelled",
                    attempts: connectRepeatCount,
                    duration: telemetry_utils_1.TelemetryLogger.formatTick(common_utils_1.performance.now() - connectStartTime),
                    connectionEstablished: false,
                });
                return;
            }
            connectRepeatCount++;
            try {
                this.client.mode = requestedMode;
                connection = await docService.connectToDeltaStream(Object.assign(Object.assign({}, this.client), { mode: requestedMode }));
                if (connection.disposed) {
                    // Nobody observed this connection, so drop it on the floor and retry.
                    this.logger.sendTelemetryEvent({ eventName: "ReceivedClosedConnection" });
                    connection = undefined;
                }
            }
            catch (origError) {
                if (typeof origError === "object" && origError !== null &&
                    (origError === null || origError === void 0 ? void 0 : origError.errorType) === driver_utils_1.DeltaStreamConnectionForbiddenError.errorType) {
                    connection = new NoDeltaStream();
                    requestedMode = "read";
                    break;
                }
                // Socket.io error when we connect to wrong socket, or hit some multiplexing bug
                if (!(0, driver_utils_1.canRetryOnError)(origError)) {
                    const error = (0, telemetry_utils_1.normalizeError)(origError, { props: fatalConnectErrorProp });
                    this.props.closeHandler(error);
                    throw error;
                }
                // Since the error is retryable this will not log to the error table
                (0, driver_utils_1.logNetworkFailure)(this.logger, {
                    attempts: connectRepeatCount,
                    delay: delayMs,
                    eventName: "DeltaConnectionFailureToConnect",
                    duration: telemetry_utils_1.TelemetryLogger.formatTick(common_utils_1.performance.now() - connectStartTime),
                }, origError);
                lastError = origError;
                const retryDelayFromError = (0, driver_utils_1.getRetryDelayFromError)(origError);
                delayMs = retryDelayFromError !== null && retryDelayFromError !== void 0 ? retryDelayFromError : Math.min(delayMs * 2, MaxReconnectDelayInMs);
                if (retryDelayFromError !== undefined) {
                    this.props.reconnectionDelayHandler(retryDelayFromError, origError);
                }
                await (0, driver_utils_1.waitForConnectedState)(delayMs);
            }
        }
        // If we retried more than once, log an event about how long it took (this will not log to error table)
        if (connectRepeatCount > 1) {
            (0, driver_utils_1.logNetworkFailure)(this.logger, {
                eventName: "MultipleDeltaConnectionFailures",
                attempts: connectRepeatCount,
                duration: telemetry_utils_1.TelemetryLogger.formatTick(common_utils_1.performance.now() - connectStartTime),
            }, lastError);
        }
        // Check for abort signal after while loop as well
        if (abortSignal.aborted === true) {
            connection.dispose();
            this.logger.sendTelemetryEvent({
                eventName: "ConnectionAttemptCancelled",
                attempts: connectRepeatCount,
                duration: telemetry_utils_1.TelemetryLogger.formatTick(common_utils_1.performance.now() - connectStartTime),
                connectionEstablished: true,
            });
            return;
        }
        this.setupNewSuccessfulConnection(connection, requestedMode);
    }
    /**
     * Start the connection. Any error should result in container being close.
     * And report the error if it excape for any reason.
     * @param args - The connection arguments
     */
    triggerConnect(connectionMode) {
        (0, common_utils_1.assert)(this.connection === undefined, 0x239 /* "called only in disconnected state" */);
        if (this.reconnectMode !== contracts_1.ReconnectMode.Enabled) {
            return;
        }
        this.connect(connectionMode);
    }
    /**
     * Disconnect the current connection.
     * @param reason - Text description of disconnect reason to emit with disconnect event
     * @returns A boolean that indicates if there was an existing connection (or pending connection) to disconnect
     */
    disconnectFromDeltaStream(reason) {
        this.pendingReconnect = false;
        if (this.connection === undefined) {
            if (this.pendingConnection !== undefined) {
                this.cancelConnection();
                return true;
            }
            return false;
        }
        (0, common_utils_1.assert)(this.pendingConnection === undefined, 0x27b /* "reentrancy may result in incorrect behavior" */);
        const connection = this.connection;
        // Avoid any re-entrancy - clear object reference
        this.connection = undefined;
        // Remove listeners first so we don't try to retrigger this flow accidentally through reconnectOnError
        connection.off("op", this.opHandler);
        connection.off("signal", this.props.signalHandler);
        connection.off("nack", this.nackHandler);
        connection.off("disconnect", this.disconnectHandlerInternal);
        connection.off("error", this.errorHandler);
        connection.off("pong", this.props.pongHandler);
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._outbound.pause();
        this._outbound.clear();
        this.props.disconnectHandler(reason);
        connection.dispose();
        this._connectionVerboseProps = {};
        return true;
    }
    /**
     * Cancel in-progress connection attempt.
     */
    cancelConnection() {
        (0, common_utils_1.assert)(this.pendingConnection !== undefined, 0x345 /* this.pendingConnection is undefined when trying to cancel */);
        this.pendingConnection.abort();
        this.pendingConnection = undefined;
        this.logger.sendTelemetryEvent({ eventName: "ConnectionCancelReceived" });
    }
    /**
     * Once we've successfully gotten a connection, we need to set up state, attach event listeners, and process
     * initial messages.
     * @param connection - The newly established connection
     */
    setupNewSuccessfulConnection(connection, requestedMode) {
        // Old connection should have been cleaned up before establishing a new one
        (0, common_utils_1.assert)(this.connection === undefined, 0x0e6 /* "old connection exists on new connection setup" */);
        (0, common_utils_1.assert)(!connection.disposed, 0x28a /* "can't be disposed - Callers need to ensure that!" */);
        this.pendingConnection = undefined;
        this.connection = connection;
        // Does information in scopes & mode matches?
        // If we asked for "write" and got "read", then file is read-only
        // But if we ask read, server can still give us write.
        const readonly = !connection.claims.scopes.includes(protocol_definitions_1.ScopeType.DocWrite);
        // This connection mode validation logic is moving to the driver layer in 0.44.  These two asserts can be
        // removed after those packages have released and become ubiquitous.
        (0, common_utils_1.assert)(requestedMode === "read" || readonly === (this.connectionMode === "read"), 0x0e7 /* "claims/connectionMode mismatch" */);
        (0, common_utils_1.assert)(!readonly || this.connectionMode === "read", 0x0e8 /* "readonly perf with write connection" */);
        this.set_readonlyPermissions(readonly);
        if (this.closed) {
            // Raise proper events, Log telemetry event and close connection.
            this.disconnectFromDeltaStream("ConnectionManager already closed");
            return;
        }
        this._outbound.resume();
        connection.on("op", this.opHandler);
        connection.on("signal", this.props.signalHandler);
        connection.on("nack", this.nackHandler);
        connection.on("disconnect", this.disconnectHandlerInternal);
        connection.on("error", this.errorHandler);
        connection.on("pong", this.props.pongHandler);
        // Initial messages are always sorted. However, due to early op handler installed by drivers and appending those
        // ops to initialMessages, resulting set is no longer sorted, which would result in client hitting storage to
        // fill in gap. We will recover by cancelling this request once we process remaining ops, but it's a waste that
        // we could avoid
        const initialMessages = connection.initialMessages.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        // Some storages may provide checkpointSequenceNumber to identify how far client is behind.
        let checkpointSequenceNumber = connection.checkpointSequenceNumber;
        this._connectionVerboseProps = {
            clientId: connection.clientId,
            mode: connection.mode,
        };
        // reset connection props
        this._connectionProps = {};
        if (connection.relayServiceAgent !== undefined) {
            this._connectionVerboseProps.relayServiceAgent = connection.relayServiceAgent;
            this._connectionProps.relayServiceAgent = connection.relayServiceAgent;
        }
        this._connectionProps.socketDocumentId = connection.claims.documentId;
        this._connectionProps.connectionMode = connection.mode;
        let last = -1;
        if (initialMessages.length !== 0) {
            this._connectionVerboseProps.connectionInitialOpsFrom = initialMessages[0].sequenceNumber;
            last = initialMessages[initialMessages.length - 1].sequenceNumber;
            this._connectionVerboseProps.connectionInitialOpsTo = last + 1;
            // Update knowledge of how far we are behind, before raising "connect" event
            // This is duplication of what incomingOpHandler() does, but we have to raise event before we get there,
            // so duplicating update logic here as well.
            if (checkpointSequenceNumber === undefined || checkpointSequenceNumber < last) {
                checkpointSequenceNumber = last;
            }
        }
        this.props.incomingOpHandler(initialMessages, this.connectFirstConnection ? "InitialOps" : "ReconnectOps");
        if (connection.initialSignals !== undefined) {
            for (const signal of connection.initialSignals) {
                this.props.signalHandler(signal);
            }
        }
        const details = ConnectionManager.detailsFromConnection(connection);
        details.checkpointSequenceNumber = checkpointSequenceNumber;
        this.props.connectHandler(details);
        this.connectFirstConnection = false;
    }
    /**
     * Disconnect the current connection and reconnect. Closes the container if it fails.
     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection
     * @param requestedMode - Read or write
     * @param error - Error reconnect information including whether or not to reconnect
     * @returns A promise that resolves when the connection is reestablished or we stop trying
     */
    reconnectOnError(requestedMode, error) {
        this.reconnect(requestedMode, error.message, error)
            .catch(this.props.closeHandler);
    }
    /**
     * Disconnect the current connection and reconnect.
     * @param connection - The connection that wants to reconnect - no-op if it's different from this.connection
     * @param requestedMode - Read or write
     * @param error - Error reconnect information including whether or not to reconnect
     * @returns A promise that resolves when the connection is reestablished or we stop trying
     */
    async reconnect(requestedMode, disconnectMessage, error) {
        // We quite often get protocol errors before / after observing nack/disconnect
        // we do not want to run through same sequence twice.
        // If we're already disconnected/disconnecting it's not appropriate to call this again.
        (0, common_utils_1.assert)(this.connection !== undefined, 0x0eb /* "Missing connection for reconnect" */);
        this.disconnectFromDeltaStream(disconnectMessage);
        // We will always trigger reconnect, even if canRetry is false.
        // Any truly fatal error state will result in container close upon attempted reconnect,
        // which is a preferable to closing abruptly when a live connection fails.
        if (error !== undefined && !error.canRetry) {
            this.logger.sendTelemetryEvent({
                eventName: "reconnectingDespiteFatalError",
                reconnectMode: this.reconnectMode,
            }, error);
        }
        if (this.reconnectMode === contracts_1.ReconnectMode.Never) {
            // Do not raise container error if we are closing just because we lost connection.
            // Those errors (like IdleDisconnect) would show up in telemetry dashboards and
            // are very misleading, as first initial reaction - some logic is broken.
            this.props.closeHandler();
        }
        // If closed then we can't reconnect
        if (this.closed || this.reconnectMode !== contracts_1.ReconnectMode.Enabled) {
            return;
        }
        const delayMs = (0, driver_utils_1.getRetryDelayFromError)(error);
        if (error !== undefined && delayMs !== undefined) {
            this.props.reconnectionDelayHandler(delayMs, error);
            await (0, driver_utils_1.waitForConnectedState)(delayMs);
        }
        this.triggerConnect(requestedMode);
    }
    prepareMessageToSend(message) {
        var _a, _b;
        if (this.readonly === true) {
            (0, common_utils_1.assert)(this.readOnlyInfo.readonly === true, 0x1f0 /* "Unexpected mismatch in readonly" */);
            const error = new container_utils_1.GenericError("deltaManagerReadonlySubmit", undefined /* error */, {
                readonly: this.readOnlyInfo.readonly,
                forcedReadonly: this.readOnlyInfo.forced,
                readonlyPermissions: this.readOnlyInfo.permissions,
                storageOnly: this.readOnlyInfo.storageOnly,
            });
            this.props.closeHandler(error);
            return undefined;
        }
        // reset clientSequenceNumber if we are using new clientId.
        // we keep info about old connection as long as possible to be able to account for all non-acked ops
        // that we pick up on next connection.
        (0, common_utils_1.assert)(!!this.connection, 0x0e4 /* "Lost old connection!" */);
        if (this.lastSubmittedClientId !== ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.clientId)) {
            this.lastSubmittedClientId = (_b = this.connection) === null || _b === void 0 ? void 0 : _b.clientId;
            this.clientSequenceNumber = 0;
            this.clientSequenceNumberObserved = 0;
        }
        if (message.type === protocol_definitions_1.MessageType.NoOp) {
            this.trailingNoopCount++;
        }
        else {
            this.trailingNoopCount = 0;
        }
        return Object.assign(Object.assign({}, message), { clientSequenceNumber: ++this.clientSequenceNumber });
    }
    submitSignal(content) {
        if (this.connection !== undefined) {
            this.connection.submitSignal(content);
        }
        else {
            this.logger.sendErrorEvent({ eventName: "submitSignalDisconnected" });
        }
    }
    sendMessages(messages) {
        (0, common_utils_1.assert)(this.connected, 0x2b4 /* "not connected on sending ops!" */);
        // If connection is "read" or implicit "read" (got leave op for "write" connection),
        // then op can't make it through - we will get a nack if op is sent.
        // We can short-circuit this process.
        // Note that we also want nacks to be rare and be treated as catastrophic failures.
        // Be careful with reentrancy though - disconnected event should not be be raised in the
        // middle of the current workflow, but rather on clean stack!
        if (this.connectionMode === "read") {
            if (!this.pendingReconnect) {
                this.pendingReconnect = true;
                Promise.resolve().then(async () => {
                    if (this.pendingReconnect) { // still valid?
                        await this.reconnect("write", // connectionMode
                        "Switch to write");
                    }
                })
                    .catch(() => { });
            }
            return;
        }
        (0, common_utils_1.assert)(!this.pendingReconnect, 0x2b5 /* "logic error" */);
        this._outbound.push(messages);
    }
    beforeProcessingIncomingOp(message) {
        // if we have connection, and message is local, then we better treat is as local!
        (0, common_utils_1.assert)(this.clientId !== message.clientId || this.lastSubmittedClientId === message.clientId, 0x0ee /* "Not accounting local messages correctly" */);
        if (this.lastSubmittedClientId !== undefined && this.lastSubmittedClientId === message.clientId) {
            const clientSequenceNumber = message.clientSequenceNumber;
            (0, common_utils_1.assert)(this.clientSequenceNumberObserved < clientSequenceNumber, 0x0ef /* "client seq# not growing" */);
            (0, common_utils_1.assert)(clientSequenceNumber <= this.clientSequenceNumber, 0x0f0 /* "Incoming local client seq# > generated by this client" */);
            this.clientSequenceNumberObserved = clientSequenceNumber;
        }
        if (message.type === protocol_definitions_1.MessageType.ClientLeave) {
            const systemLeaveMessage = message;
            const clientId = JSON.parse(systemLeaveMessage.data);
            if (clientId === this.clientId) {
                // We have been kicked out from quorum
                this.logger.sendPerformanceEvent({ eventName: "ReadConnectionTransition" });
                // Please see #8483 for more details on why maintaining connection further as is would not work.
                // Short story - connection properties are immutable, and many processes (consensus DDSes, summarizer)
                // assume that connection stays "write" connection until disconnect, and act accordingly, which may
                // not work well with de-facto "read" connection we are in after receiving own leave op on timeout.
                // Clients need to be able to transition to "read" state after some time of inactivity!
                // Note - this may close container!
                this.reconnect("read", // connectionMode
                "Switch to read").catch((error) => {
                    this.logger.sendErrorEvent({ eventName: "SwitchToReadConnection" }, error);
                });
            }
        }
    }
}
exports.ConnectionManager = ConnectionManager;

},{"./contracts":297,"./deltaQueue":300,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"abort-controller":312}],292:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionState = void 0;
var ConnectionState;
(function (ConnectionState) {
    /**
     * The container is not connected to the ordering service
     * Note - When in this state the container may be about to reconnect,
     * or may remain disconnected until explicitly told to connect.
     */
    ConnectionState[ConnectionState["Disconnected"] = 0] = "Disconnected";
    /**
     * The container is disconnected but actively trying to establish a new connection
     * PLEASE NOTE that this numerical value falls out of the order you may expect for this state
     */
    ConnectionState[ConnectionState["EstablishingConnection"] = 3] = "EstablishingConnection";
    /**
     * See {@link ConnectionState.CatchingUp}, which is the new name for this state.
     * @deprecated - This state itself is not gone, just being renamed. Please use {@link ConnectionState.CatchingUp}.
     */
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    /**
     * The container has an inbound connection only, and is catching up to the latest known state from the service.
     */
    ConnectionState[ConnectionState["CatchingUp"] = 1] = "CatchingUp";
    /**
     * The container is fully connected and syncing
     */
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));

},{}],293:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionStateHandler = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const connectionState_1 = require("./connectionState");
const JoinOpTimeoutMs = 45000;
/**
 * In the lifetime of a container, the connection will likely disconnect and reconnect periodically.
 * This class ensures that any ops sent by this container instance on previous connection are either
 * sequenced or blocked by the server before emitting the new "connected" event and allowing runtime to resubmit ops.
 *
 * Each connection is assigned a clientId by the service, and the connection is book-ended by a Join and a Leave op
 * generated by the service. Due to the distributed nature of the ordering service, in the case of reconnect we cannot
 * make any assumptions about ordering of operations between the old and new connections - i.e. new Join op could
 * be sequenced before old Leave op (and some acks from pending ops that were in flight when we disconnected).
 *
 * The job of this class is to encapsulate the transition period during reconnect, which is identified by
 * ConnectionState.CatchingUp. Specifically, before moving to Connected state with the new clientId, it ensures that:
 * (A) We process the Leave op for the previous clientId. This allows us to properly handle any acks from in-flight ops
 *     that got sequenced with the old clientId (we'll recognize them as local ops). After the Leave op, any other
 *     pending ops can safely be submitted with the new clientId without fear of duplication in the sequenced op stream.
 * (B) We process the Join op for the new clientId (identified when the underlying connection was first established),
 *     indicating the service is ready to sequence ops sent with the new clientId.
 *
 * For (A) we give up waiting after some time (same timeout as server uses), and go ahead and transition to Connected.
 * For (B) we log telemetry if it takes too long, but still only transition to Connected when the Join op is processed
 * and we are added to the Quorum.
 */
class ConnectionStateHandler {
    constructor(handler, logger, _clientId) {
        var _a;
        this.handler = handler;
        this.logger = logger;
        this._clientId = _clientId;
        this._connectionState = connectionState_1.ConnectionState.Disconnected;
        this.prevClientLeftTimer = new common_utils_1.Timer(
        // Default is 5 min for which we are going to wait for its own "leave" message. This is same as
        // the max time on server after which leave op is sent.
        (_a = this.handler.maxClientLeaveWaitTime) !== null && _a !== void 0 ? _a : 300000, () => {
            (0, common_utils_1.assert)(!this.connected, 0x2ac /* "Connected when timeout waiting for leave from previous session fired!" */);
            this.applyForConnectedState("timeout");
        });
        // Based on recent data, it looks like majority of cases where we get stuck are due to really slow or
        // timing out ops fetches. So attempt recovery infrequently. Also fetch uses 30 second timeout, so
        // if retrying fixes the problem, we should not see these events.
        this.joinOpTimer = new common_utils_1.Timer(JoinOpTimeoutMs, () => {
            var _a;
            // I've observed timer firing within couple ms from disconnect event, looks like
            // queued timer callback is not cancelled if timer is cancelled while callback sits in the queue.
            if (this.connectionState !== connectionState_1.ConnectionState.CatchingUp) {
                return;
            }
            const quorumClients = this.handler.quorumClients();
            const details = {
                quorumInitialized: quorumClients !== undefined,
                hasPendingClientId: this.pendingClientId !== undefined,
                inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_a = this.pendingClientId) !== null && _a !== void 0 ? _a : "")) !== undefined,
                waitingForLeaveOp: this.waitingForLeaveOp,
            };
            this.handler.logConnectionIssue("NoJoinOp", details);
        });
    }
    get connectionState() {
        return this._connectionState;
    }
    get connected() {
        return this.connectionState === connectionState_1.ConnectionState.Connected;
    }
    get clientId() {
        return this._clientId;
    }
    get pendingClientId() {
        return this._pendingClientId;
    }
    startJoinOpTimer() {
        (0, common_utils_1.assert)(!this.joinOpTimer.hasTimer, 0x234 /* "has joinOpTimer" */);
        this.joinOpTimer.start();
    }
    stopJoinOpTimer() {
        (0, common_utils_1.assert)(this.joinOpTimer.hasTimer, 0x235 /* "no joinOpTimer" */);
        this.joinOpTimer.clear();
    }
    get waitingForLeaveOp() {
        return this.prevClientLeftTimer.hasTimer;
    }
    dispose() {
        (0, common_utils_1.assert)(!this.joinOpTimer.hasTimer, 0x2a5 /* "join timer" */);
        this.prevClientLeftTimer.clear();
    }
    containerSaved() {
        // If we were waiting for moving to Connected state, then only apply for state change. Since the container
        // is now saved and we don't have any ops to roundtrip, we can clear the timer and apply for connected state.
        if (this.waitingForLeaveOp) {
            this.prevClientLeftTimer.clear();
            this.applyForConnectedState("containerSaved");
        }
    }
    receivedAddMemberEvent(clientId) {
        // This is the only one that requires the pending client ID
        if (clientId === this.pendingClientId) {
            if (this.joinOpTimer.hasTimer) {
                this.stopJoinOpTimer();
            }
            else {
                // timer has already fired, meaning it took too long to get join on.
                // Record how long it actually took to recover.
                this.handler.logConnectionIssue("ReceivedJoinOp");
            }
            // Start the event in case we are waiting for leave or timeout.
            if (this.waitingForLeaveOp) {
                this.waitEvent = telemetry_utils_1.PerformanceEvent.start(this.logger, {
                    eventName: "WaitBeforeClientLeave",
                    details: JSON.stringify({
                        waitOnClientId: this._clientId,
                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),
                    }),
                });
            }
            this.applyForConnectedState("addMemberEvent");
        }
    }
    applyForConnectedState(source) {
        var _a, _b;
        const quorumClients = this.handler.quorumClients();
        (0, common_utils_1.assert)(quorumClients !== undefined, 0x236 /* "In all cases it should be already installed" */);
        (0, common_utils_1.assert)(this.waitingForLeaveOp === false ||
            (this.clientId !== undefined && quorumClients.getMember(this.clientId) !== undefined), 0x2e2 /* "Must only wait for leave message when clientId in quorum" */);
        // Move to connected state only if we are in Connecting state, we have seen our join op
        // and there is no timer running which means we are not waiting for previous client to leave
        // or timeout has occurred while doing so.
        if (this.pendingClientId !== this.clientId
            && this.pendingClientId !== undefined
            && quorumClients.getMember(this.pendingClientId) !== undefined
            && !this.waitingForLeaveOp) {
            (_a = this.waitEvent) === null || _a === void 0 ? void 0 : _a.end({ source });
            this.setConnectionState(connectionState_1.ConnectionState.Connected);
        }
        else {
            // Adding this event temporarily so that we can get help debugging if something goes wrong.
            this.logger.sendTelemetryEvent({
                eventName: "connectedStateRejected",
                category: source === "timeout" ? "error" : "generic",
                details: JSON.stringify({
                    source,
                    pendingClientId: this.pendingClientId,
                    clientId: this.clientId,
                    waitingForLeaveOp: this.waitingForLeaveOp,
                    inQuorum: (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember((_b = this.pendingClientId) !== null && _b !== void 0 ? _b : "")) !== undefined,
                }),
            });
        }
    }
    receivedRemoveMemberEvent(clientId) {
        // If the client which has left was us, then finish the timer.
        if (this.clientId === clientId) {
            this.prevClientLeftTimer.clear();
            this.applyForConnectedState("removeMemberEvent");
        }
    }
    receivedDisconnectEvent(reason) {
        if (this.joinOpTimer.hasTimer) {
            this.stopJoinOpTimer();
        }
        this.setConnectionState(connectionState_1.ConnectionState.Disconnected, reason);
    }
    /**
     * The "connect" event indicates the connection to the Relay Service is live.
     * However, some additional conditions must be met before we can fully transition to
     * "Connected" state. This function handles that interim period, known as "Connecting" state.
     * @param connectionMode - Read or Write connection
     * @param details - Connection details returned from the ordering service
     */
    receivedConnectEvent(connectionMode, details) {
        const oldState = this._connectionState;
        this._connectionState = connectionState_1.ConnectionState.CatchingUp;
        const writeConnection = connectionMode === "write";
        (0, common_utils_1.assert)(writeConnection || !this.handler.shouldClientJoinWrite(), 0x30a /* shouldClientJoinWrite should imply this is a writeConnection */);
        (0, common_utils_1.assert)(writeConnection || !this.waitingForLeaveOp, 0x2a6 /* "waitingForLeaveOp should imply writeConnection (we need to be ready to flush pending ops)" */);
        // Note that this may be undefined since the connection is established proactively on load
        // and the quorum may still be under initialization.
        const quorumClients = this.handler.quorumClients();
        // Stash the clientID to detect when transitioning from connecting (socket.io channel open) to connected
        // (have received the join message for the client ID)
        // This is especially important in the reconnect case. It's possible there could be outstanding
        // ops sent by this client, so we should keep the old client id until we see our own client's
        // join message. after we see the join message for our new connection with our new client id,
        // we know there can no longer be outstanding ops that we sent with the previous client id.
        this._pendingClientId = details.clientId;
        // IMPORTANT: Report telemetry after we set _pendingClientId, but before transitioning to Connected state
        this.handler.logConnectionStateChangeTelemetry(connectionState_1.ConnectionState.CatchingUp, oldState);
        // For write connections, this pending clientId could be in the quorum already (i.e. join op already processed).
        // We are fetching ops from storage in parallel to connecting to Relay Service,
        // and given async processes, it's possible that we have already processed our own join message before
        // connection was fully established.
        // If quorumClients itself is undefined, we expect it will process the join op after it's initialized.
        const waitingForJoinOp = writeConnection && (quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._pendingClientId)) === undefined;
        if (waitingForJoinOp) {
            // Previous client left, and we are waiting for our own join op. When it is processed we'll join the quorum
            // and attempt to transition to Connected state via receivedAddMemberEvent.
            this.startJoinOpTimer();
        }
        else if (!this.waitingForLeaveOp) {
            // We're not waiting for Join or Leave op (if read-only connection those don't even apply),
            // go ahead and declare the state to be Connected!
            // If we are waiting for Leave op still, do nothing for now, we will transition to Connected later.
            this.setConnectionState(connectionState_1.ConnectionState.Connected);
        }
    }
    setConnectionState(value, reason) {
        if (this.connectionState === value) {
            // Already in the desired state - exit early
            this.logger.sendErrorEvent({ eventName: "setConnectionStateSame", value });
            return;
        }
        const oldState = this._connectionState;
        this._connectionState = value;
        const quorumClients = this.handler.quorumClients();
        let client;
        if (this._clientId !== undefined) {
            client = quorumClients === null || quorumClients === void 0 ? void 0 : quorumClients.getMember(this._clientId);
        }
        if (value === connectionState_1.ConnectionState.Connected) {
            (0, common_utils_1.assert)(oldState === connectionState_1.ConnectionState.CatchingUp, 0x1d8 /* "Should only transition from Connecting state" */);
            // Mark our old client should have left in the quorum if it's still there
            if (client !== undefined) {
                client.shouldHaveLeft = true;
            }
            this._clientId = this.pendingClientId;
        }
        else if (value === connectionState_1.ConnectionState.Disconnected) {
            // Important as we process our own joinSession message through delta request
            this._pendingClientId = undefined;
            // Only wait for "leave" message if the connected client exists in the quorum because only the write
            // client will exist in the quorum and only for those clients we will receive "removeMember" event and
            // the client has some unacked ops.
            // Also server would not accept ops from read client. Also check if the timer is not already running as
            // we could receive "Disconnected" event multiple times without getting connected and in that case we
            // don't want to reset the timer as we still want to wait on original client which started this timer.
            if (client !== undefined
                && this.handler.shouldClientJoinWrite()
                && this.prevClientLeftTimer.hasTimer === false) {
                this.prevClientLeftTimer.restart();
            }
            else {
                // Adding this event temporarily so that we can get help debugging if something goes wrong.
                this.logger.sendTelemetryEvent({
                    eventName: "noWaitOnDisconnected",
                    details: JSON.stringify({
                        inQuorum: client !== undefined,
                        waitingForLeaveOp: this.waitingForLeaveOp,
                        hadOutstandingOps: this.handler.shouldClientJoinWrite(),
                    }),
                });
            }
        }
        // Report transition before we propagate event across layers
        this.handler.logConnectionStateChangeTelemetry(this._connectionState, oldState, reason);
        // Propagate event across layers
        this.handler.connectionStateChanged();
    }
    initProtocol(protocol) {
        protocol.quorum.on("addMember", (clientId, _details) => {
            this.receivedAddMemberEvent(clientId);
        });
        protocol.quorum.on("removeMember", (clientId) => {
            this.receivedRemoveMemberEvent(clientId);
        });
        // if we have a clientId from a previous container we need to wait for its leave message
        if (this.clientId !== undefined && protocol.quorum.getMember(this.clientId) !== undefined) {
            this.prevClientLeftTimer.restart();
        }
    }
}
exports.ConnectionStateHandler = ConnectionStateHandler;

},{"./connectionState":292,"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279}],294:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = exports.waitContainerToCatchUp = void 0;
// eslint-disable-next-line import/no-internal-modules
const merge_1 = __importDefault(require("lodash/merge"));
const uuid_1 = require("uuid");
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const protocol_base_1 = require("@fluidframework/protocol-base");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const audience_1 = require("./audience");
const containerContext_1 = require("./containerContext");
const contracts_1 = require("./contracts");
const deltaManager_1 = require("./deltaManager");
const deltaManagerProxy_1 = require("./deltaManagerProxy");
const loader_1 = require("./loader");
const packageVersion_1 = require("./packageVersion");
const connectionStateHandler_1 = require("./connectionStateHandler");
const retriableDocumentStorageService_1 = require("./retriableDocumentStorageService");
const protocolTreeDocumentStorageService_1 = require("./protocolTreeDocumentStorageService");
const containerStorageAdapter_1 = require("./containerStorageAdapter");
const utils_1 = require("./utils");
const quorum_1 = require("./quorum");
const collabWindowTracker_1 = require("./collabWindowTracker");
const connectionManager_1 = require("./connectionManager");
const connectionState_1 = require("./connectionState");
const detachedContainerRefSeqNumber = 0;
const dirtyContainerEvent = "dirty";
const savedContainerEvent = "saved";
/**
 * Waits until container connects to delta storage and gets up-to-date
 * Useful when resolving URIs and hitting 404, due to container being loaded from (stale) snapshot and not being
 * up to date. Host may chose to wait in such case and retry resolving URI.
 * Warning: Will wait infinitely for connection to establish if there is no connection.
 * May result in deadlock if Container.disconnect() is called and never followed by a call to Container.connect().
 * @returns true: container is up to date, it processed all the ops that were know at the time of first connection
 *          false: storage does not provide indication of how far the client is. Container processed
 *          all the ops known to it, but it maybe still behind.
 * @throws an error beginning with `"Container closed"` if the container is closed before it catches up.
 */
async function waitContainerToCatchUp(container) {
    // Make sure we stop waiting if container is closed.
    if (container.closed) {
        throw new container_utils_1.UsageError("waitContainerToCatchUp: Container closed");
    }
    return new Promise((resolve, reject) => {
        const deltaManager = container.deltaManager;
        const closedCallback = (err) => {
            container.off("closed", closedCallback);
            const baseMessage = "Container closed while waiting to catch up";
            reject(err !== undefined
                ? (0, telemetry_utils_1.wrapError)(err, (innerMessage) => new container_utils_1.GenericError(`${baseMessage}: ${innerMessage}`))
                : new container_utils_1.GenericError(baseMessage));
        };
        container.on("closed", closedCallback);
        const waitForOps = () => {
            (0, common_utils_1.assert)(container.connectionState === connectionState_1.ConnectionState.CatchingUp
                || container.connectionState === connectionState_1.ConnectionState.Connected, 0x0cd /* "Container disconnected while waiting for ops!" */);
            const hasCheckpointSequenceNumber = deltaManager.hasCheckpointSequenceNumber;
            const connectionOpSeqNumber = deltaManager.lastKnownSeqNumber;
            (0, common_utils_1.assert)(deltaManager.lastSequenceNumber <= connectionOpSeqNumber, 0x266 /* "lastKnownSeqNumber should never be below last processed sequence number" */);
            if (deltaManager.lastSequenceNumber === connectionOpSeqNumber) {
                container.off("closed", closedCallback);
                resolve(hasCheckpointSequenceNumber);
                return;
            }
            const callbackOps = (message) => {
                if (connectionOpSeqNumber <= message.sequenceNumber) {
                    container.off("closed", closedCallback);
                    resolve(hasCheckpointSequenceNumber);
                    deltaManager.off("op", callbackOps);
                }
            };
            deltaManager.on("op", callbackOps);
        };
        // We can leverage DeltaManager's "connect" event here and test for ConnectionState.Disconnected
        // But that works only if service provides us checkPointSequenceNumber
        // Our internal testing is based on R11S that does not, but almost all tests connect as "write" and
        // use this function to catch up, so leveraging our own join op as a fence/barrier
        if (container.connectionState === connectionState_1.ConnectionState.Connected) {
            waitForOps();
            return;
        }
        const callback = () => {
            container.off(telemetry_utils_1.connectedEventName, callback);
            waitForOps();
        };
        container.on(telemetry_utils_1.connectedEventName, callback);
        if (container.connectionState === connectionState_1.ConnectionState.Disconnected) {
            container.connect();
        }
    });
}
exports.waitContainerToCatchUp = waitContainerToCatchUp;
const getCodeProposal = 
// eslint-disable-next-line @typescript-eslint/no-unsafe-return
(quorum) => { var _a; return (_a = quorum.get("code")) !== null && _a !== void 0 ? _a : quorum.get("code2"); };
/**
 * Helper function to report to telemetry cases where operation takes longer than expected (1s)
 * @param logger - logger to use
 * @param eventName - event name
 * @param action - functor to call and measure
 */
async function ReportIfTooLong(logger, eventName, action) {
    const event = telemetry_utils_1.PerformanceEvent.start(logger, { eventName });
    const props = await action();
    if (event.duration > 1000) {
        event.end(props);
    }
}
const summarizerClientType = "summarizer";
class Container extends telemetry_utils_1.EventEmitterWithErrorHandling {
    constructor(loader, config) {
        var _a, _b;
        super((name, error) => {
            this.mc.logger.sendErrorEvent({
                eventName: "ContainerEventHandlerException",
                name: typeof name === "string" ? name : undefined,
            }, error);
        });
        this.loader = loader;
        // Tells if container can reconnect on losing fist connection
        // If false, container gets closed on loss of connection.
        this._canReconnect = true;
        this._lifecycleState = "loading";
        this._attachState = container_definitions_1.AttachState.Detached;
        /** During initialization we pause the inbound queues. We track this state to ensure we only call resume once */
        this.inboundQueuePausedFromInit = true;
        this.firstConnection = true;
        this.connectionTransitionTimes = [];
        this.messageCountAfterDisconnection = 0;
        this.attachStarted = false;
        this._dirtyContainer = false;
        this.setAutoReconnectTime = common_utils_1.performance.now();
        this._audience = new audience_1.Audience();
        this.clientDetailsOverride = config.clientDetailsOverride;
        this._resolvedUrl = config.resolvedUrl;
        if (config.canReconnect !== undefined) {
            this._canReconnect = config.canReconnect;
        }
        // Create logger for data stores to use
        const type = this.client.details.type;
        const interactive = this.client.details.capabilities.interactive;
        const clientType = `${interactive ? "interactive" : "noninteractive"}${type !== undefined && type !== "" ? `/${type}` : ""}`;
        // Need to use the property getter for docId because for detached flow we don't have the docId initially.
        // We assign the id later so property getter is used.
        this.subLogger = telemetry_utils_1.ChildLogger.create(loader.services.subLogger, undefined, {
            all: {
                clientType,
                containerId: (0, uuid_1.v4)(),
                docId: () => { var _a, _b; return (_b = (_a = this._resolvedUrl) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : undefined; },
                containerAttachState: () => this._attachState,
                containerLifecycleState: () => this._lifecycleState,
                containerConnectionState: () => connectionState_1.ConnectionState[this.connectionState],
                serializedContainer: config.serializedContainerState !== undefined,
            },
            // we need to be judicious with our logging here to avoid generating too much data
            // all data logged here should be broadly applicable, and not specific to a
            // specific error or class of errors
            error: {
                // load information to associate errors with the specific load point
                dmInitialSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.initialSequenceNumber; },
                dmLastProcessedSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastSequenceNumber; },
                dmLastKnownSeqNumber: () => { var _a; return (_a = this._deltaManager) === null || _a === void 0 ? void 0 : _a.lastKnownSeqNumber; },
                containerLoadedFromVersionId: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.id; },
                containerLoadedFromVersionDate: () => { var _a; return (_a = this.loadedFromVersion) === null || _a === void 0 ? void 0 : _a.date; },
                // message information to associate errors with the specific execution state
                // dmLastMsqSeqNumber: if present, same as dmLastProcessedSeqNumber
                dmLastMsqSeqNumber: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber; },
                dmLastMsqSeqTimestamp: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.timestamp; },
                dmLastMsqSeqClientId: () => { var _a, _b; return (_b = (_a = this.deltaManager) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.clientId; },
                connectionStateDuration: () => common_utils_1.performance.now() - this.connectionTransitionTimes[this.connectionState],
            },
        });
        // Prefix all events in this file with container-loader
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(telemetry_utils_1.ChildLogger.create(this.subLogger, "Container"));
        const summarizeProtocolTree = (_a = this.mc.config.getBoolean("Fluid.Container.summarizeProtocolTree")) !== null && _a !== void 0 ? _a : this.loader.services.options.summarizeProtocolTree;
        this.options = Object.assign(Object.assign({}, this.loader.services.options), { summarizeProtocolTree });
        this.connectionStateHandler = new connectionStateHandler_1.ConnectionStateHandler({
            quorumClients: () => { var _a; return (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum; },
            logConnectionStateChangeTelemetry: (value, oldState, reason) => this.logConnectionStateChangeTelemetry(value, oldState, reason),
            shouldClientJoinWrite: () => this._deltaManager.connectionManager.shouldJoinWrite(),
            maxClientLeaveWaitTime: this.loader.services.options.maxClientLeaveWaitTime,
            logConnectionIssue: (eventName, details) => {
                // We get here when socket does not receive any ops on "write" connection, including
                // its own join op. Attempt recovery option.
                this._deltaManager.logConnectionIssue(Object.assign({ eventName, duration: common_utils_1.performance.now() - this.connectionTransitionTimes[connectionState_1.ConnectionState.CatchingUp] }, (details === undefined ? {} : { details: JSON.stringify(details) })));
            },
            connectionStateChanged: () => {
                // Fire events only if container is fully loaded and not closed
                if (this._lifecycleState === "loaded") {
                    this.propagateConnectionState();
                }
            },
        }, this.mc.logger, (_b = config.serializedContainerState) === null || _b === void 0 ? void 0 : _b.clientId);
        this.on(savedContainerEvent, () => {
            this.connectionStateHandler.containerSaved();
        });
        this._deltaManager = this.createDeltaManager();
        this._storage = new containerStorageAdapter_1.ContainerStorageAdapter(() => {
            if (this.attachState !== container_definitions_1.AttachState.Attached) {
                if (this.loader.services.detachedBlobStorage !== undefined) {
                    return new containerStorageAdapter_1.BlobOnlyStorage(this.loader.services.detachedBlobStorage, this.mc.logger);
                }
                this.mc.logger.sendErrorEvent({
                    eventName: "NoRealStorageInDetachedContainer",
                });
                throw new Error("Real storage calls not allowed in Unattached container");
            }
            return this.storageService;
        });
        const isDomAvailable = typeof document === "object" &&
            document !== null &&
            typeof document.addEventListener === "function" &&
            document.addEventListener !== null;
        // keep track of last time page was visible for telemetry
        if (isDomAvailable) {
            this.lastVisible = document.hidden ? common_utils_1.performance.now() : undefined;
            this.visibilityEventHandler = () => {
                if (document.hidden) {
                    this.lastVisible = common_utils_1.performance.now();
                }
                else {
                    // settimeout so this will hopefully fire after disconnect event if being hidden caused it
                    setTimeout(() => { this.lastVisible = undefined; }, 0);
                }
            };
            document.addEventListener("visibilitychange", this.visibilityEventHandler);
        }
        // We observed that most users of platform do not check Container.connected event on load, causing bugs.
        // As such, we are raising events when new listener pops up.
        // Note that we can raise both "disconnected" & "connect" events at the same time,
        // if we are in connecting stage.
        this.on("newListener", (event, listener) => {
            // Fire events on the end of JS turn, giving a chance for caller to be in consistent state.
            Promise.resolve().then(() => {
                switch (event) {
                    case dirtyContainerEvent:
                        if (this._dirtyContainer) {
                            listener();
                        }
                        break;
                    case savedContainerEvent:
                        if (!this._dirtyContainer) {
                            listener();
                        }
                        break;
                    case telemetry_utils_1.connectedEventName:
                        if (this.connected) {
                            listener(this.clientId);
                        }
                        break;
                    case telemetry_utils_1.disconnectedEventName:
                        if (!this.connected) {
                            listener();
                        }
                        break;
                    default:
                }
            }).catch((error) => {
                this.mc.logger.sendErrorEvent({ eventName: "RaiseConnectedEventError" }, error);
            });
        });
    }
    /**
     * Load an existing container.
     */
    static async load(loader, loadOptions, pendingLocalState) {
        const container = new Container(loader, {
            clientDetailsOverride: loadOptions.clientDetailsOverride,
            resolvedUrl: loadOptions.resolvedUrl,
            canReconnect: loadOptions.canReconnect,
            serializedContainerState: pendingLocalState,
        });
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "Load" }, async (event) => new Promise((resolve, reject) => {
            var _a, _b;
            const version = loadOptions.version;
            const defaultMode = { opsBeforeReturn: "cached" };
            // if we have pendingLocalState, anything we cached is not useful and we shouldn't wait for connection
            // to return container, so ignore this value and use undefined for opsBeforeReturn
            const mode = pendingLocalState
                ? Object.assign(Object.assign({}, ((_a = loadOptions.loadMode) !== null && _a !== void 0 ? _a : defaultMode)), { opsBeforeReturn: undefined }) : (_b = loadOptions.loadMode) !== null && _b !== void 0 ? _b : defaultMode;
            const onClosed = (err) => {
                // pre-0.58 error message: containerClosedWithoutErrorDuringLoad
                reject(err !== null && err !== void 0 ? err : new container_utils_1.GenericError("Container closed without error during load"));
            };
            container.on("closed", onClosed);
            container.load(version, mode, pendingLocalState)
                .finally(() => {
                container.removeListener("closed", onClosed);
            })
                .then((props) => {
                event.end(Object.assign(Object.assign({}, props), loadOptions.loadMode));
                resolve(container);
            }, (error) => {
                const err = (0, telemetry_utils_1.normalizeError)(error);
                // Depending where error happens, we can be attempting to connect to web socket
                // and continuously retrying (consider offline mode)
                // Host has no container to close, so it's prudent to do it here
                container.close(err);
                onClosed(err);
            });
        }), { start: true, end: true, cancel: "generic" });
    }
    /**
     * Create a new container in a detached state.
     */
    static async createDetached(loader, codeDetails) {
        const container = new Container(loader, {});
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "CreateDetached" }, async (_event) => {
            await container.createDetached(codeDetails);
            return container;
        }, { start: true, end: true, cancel: "generic" });
    }
    /**
     * Create a new container in a detached state that is initialized with a
     * snapshot from a previous detached container.
     */
    static async rehydrateDetachedFromSnapshot(loader, snapshot) {
        const container = new Container(loader, {});
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(container.mc.logger, { eventName: "RehydrateDetachedFromSnapshot" }, async (_event) => {
            const deserializedSummary = JSON.parse(snapshot);
            await container.rehydrateDetachedFromSnapshot(deserializedSummary);
            return container;
        }, { start: true, end: true, cancel: "generic" });
    }
    setLoaded() {
        // It's conceivable the container could be closed when this is called
        // Only transition states if currently loading
        if (this._lifecycleState === "loading") {
            // Propagate current connection state through the system.
            this.propagateConnectionState();
            this._lifecycleState = "loaded";
        }
    }
    get closed() {
        return (this._lifecycleState === "closing" || this._lifecycleState === "closed");
    }
    get storage() {
        return this._storage;
    }
    get storageService() {
        if (this._storageService === undefined) {
            throw new Error("Attempted to access storageService before it was defined");
        }
        return this._storageService;
    }
    get context() {
        if (this._context === undefined) {
            throw new container_utils_1.GenericError("Attempted to access context before it was defined");
        }
        return this._context;
    }
    get protocolHandler() {
        if (this._protocolHandler === undefined) {
            throw new Error("Attempted to access protocolHandler before it was defined");
        }
        return this._protocolHandler;
    }
    get connectionMode() { return this._deltaManager.connectionManager.connectionMode; }
    get IFluidRouter() { return this; }
    get resolvedUrl() {
        return this._resolvedUrl;
    }
    get loadedFromVersion() {
        return this._loadedFromVersion;
    }
    get readOnlyInfo() {
        return this._deltaManager.readOnlyInfo;
    }
    get closeSignal() {
        return this._deltaManager.closeAbortController.signal;
    }
    /**
     * Tracks host requiring read-only mode.
     */
    forceReadonly(readonly) {
        this._deltaManager.connectionManager.forceReadonly(readonly);
    }
    get deltaManager() {
        return this._deltaManager;
    }
    get connectionState() {
        return this.connectionStateHandler.connectionState;
    }
    get connected() {
        return this.connectionStateHandler.connected;
    }
    /**
     * Service configuration details. If running in offline mode will be undefined otherwise will contain service
     * configuration details returned as part of the initial connection.
     */
    get serviceConfiguration() {
        return this._deltaManager.serviceConfiguration;
    }
    /**
     * The server provided id of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get clientId() {
        return this.connectionStateHandler.clientId;
    }
    /**
     * The server provided claims of the client.
     * Set once this.connected is true, otherwise undefined
     */
    get scopes() {
        return this._deltaManager.connectionManager.scopes;
    }
    get clientDetails() {
        return this._deltaManager.clientDetails;
    }
    /**
     * Get the code details that are currently specified for the container.
     * @returns The current code details if any are specified, undefined if none are specified.
     */
    getSpecifiedCodeDetails() {
        return this.getCodeDetailsFromQuorum();
    }
    /**
     * Get the code details that were used to load the container.
     * @returns The code details that were used to load the container if it is loaded, undefined if it is not yet
     * loaded.
     */
    getLoadedCodeDetails() {
        var _a;
        return (_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails;
    }
    /**
     * Retrieves the audience associated with the document
     */
    get audience() {
        return this._audience;
    }
    /**
     * Returns true if container is dirty.
     * Which means data loss if container is closed at that same moment
     * Most likely that happens when there is no network connection to ordering service
     */
    get isDirty() {
        return this._dirtyContainer;
    }
    get serviceFactory() { return this.loader.services.documentServiceFactory; }
    get urlResolver() { return this.loader.services.urlResolver; }
    get scope() { return this.loader.services.scope; }
    get codeLoader() { return this.loader.services.codeLoader; }
    /**
     * Retrieves the quorum associated with the document
     */
    getQuorum() {
        return this.protocolHandler.quorum;
    }
    close(error) {
        // 1. Ensure that close sequence is exactly the same no matter if it's initiated by host or by DeltaManager
        // 2. We need to ensure that we deliver disconnect event to runtime properly. See connectionStateChanged
        //    handler. We only deliver events if container fully loaded. Transitioning from "loading" ->
        //    "closing" will lose that info (can also solve by tracking extra state).
        this._deltaManager.close(error);
        (0, common_utils_1.assert)(this.connectionState === connectionState_1.ConnectionState.Disconnected, 0x0cf /* "disconnect event was not raised!" */);
        (0, common_utils_1.assert)(this._lifecycleState === "closed", 0x314 /* Container properly closed */);
    }
    closeCore(error) {
        var _a, _b, _c, _d;
        (0, common_utils_1.assert)(!this.closed, 0x315 /* re-entrancy */);
        try {
            // Ensure that we raise all key events even if one of these throws
            try {
                // Raise event first, to ensure we capture _lifecycleState before transition.
                // This gives us a chance to know what errors happened on open vs. on fully loaded container.
                this.mc.logger.sendTelemetryEvent({
                    eventName: "ContainerClose",
                    category: error === undefined ? "generic" : "error",
                }, error);
                this._lifecycleState = "closing";
                (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.close();
                this.connectionStateHandler.dispose();
                (_b = this._context) === null || _b === void 0 ? void 0 : _b.dispose(error !== undefined ? new Error(error.message) : undefined);
                (_c = this._storageService) === null || _c === void 0 ? void 0 : _c.dispose();
                // Notify storage about critical errors. They may be due to disconnect between client & server knowledge
                // about file, like file being overwritten in storage, but client having stale local cache.
                // Driver need to ensure all caches are cleared on critical errors
                (_d = this.service) === null || _d === void 0 ? void 0 : _d.dispose(error);
            }
            catch (exception) {
                this.mc.logger.sendErrorEvent({ eventName: "ContainerCloseException" }, exception);
            }
            this.emit("closed", error);
            this.removeAllListeners();
            if (this.visibilityEventHandler !== undefined) {
                document.removeEventListener("visibilitychange", this.visibilityEventHandler);
            }
        }
        finally {
            this._lifecycleState = "closed";
        }
    }
    closeAndGetPendingLocalState() {
        // runtime matches pending ops to successful ones by clientId and client seq num, so we need to close the
        // container at the same time we get pending state, otherwise this container could reconnect and resubmit with
        // a new clientId and a future container using stale pending state without the new clientId would resubmit them
        (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Attached, 0x0d1 /* "Container should be attached before close" */);
        (0, common_utils_1.assert)(this.resolvedUrl !== undefined && this.resolvedUrl.type === "fluid", 0x0d2 /* "resolved url should be valid Fluid url" */);
        (0, common_utils_1.assert)(!!this._protocolHandler, 0x2e3 /* "Must have a valid protocol handler instance" */);
        (0, common_utils_1.assert)(this._protocolHandler.attributes.term !== undefined, 0x30b /* Must have a valid protocol handler instance */);
        const pendingState = {
            pendingRuntimeState: this.context.getPendingLocalState(),
            url: this.resolvedUrl.url,
            protocol: this.protocolHandler.getProtocolState(),
            term: this._protocolHandler.attributes.term,
            clientId: this.clientId,
        };
        this.close();
        return JSON.stringify(pendingState);
    }
    get attachState() {
        return this._attachState;
    }
    serialize() {
        (0, common_utils_1.assert)(this.attachState === container_definitions_1.AttachState.Detached, 0x0d3 /* "Should only be called in detached container" */);
        const appSummary = this.context.createSummary();
        const protocolSummary = this.captureProtocolSummary();
        const combinedSummary = (0, driver_utils_1.combineAppAndProtocolSummary)(appSummary, protocolSummary);
        if (this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0) {
            combinedSummary.tree[".hasAttachmentBlobs"] = { type: protocol_definitions_1.SummaryType.Blob, content: "true" };
        }
        return JSON.stringify(combinedSummary);
    }
    async attach(request) {
        await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Attach" }, async () => {
            if (this._lifecycleState !== "loaded") {
                // pre-0.58 error message: containerNotValidForAttach
                throw new container_utils_1.UsageError(`The Container is not in a valid state for attach [${this._lifecycleState}]`);
            }
            // If container is already attached or attach is in progress, throw an error.
            (0, common_utils_1.assert)(this._attachState === container_definitions_1.AttachState.Detached && !this.attachStarted, 0x205 /* "attach() called more than once" */);
            this.attachStarted = true;
            // If attachment blobs were uploaded in detached state we will go through a different attach flow
            const hasAttachmentBlobs = this.loader.services.detachedBlobStorage !== undefined
                && this.loader.services.detachedBlobStorage.size > 0;
            try {
                (0, common_utils_1.assert)(this.deltaManager.inbound.length === 0, 0x0d6 /* "Inbound queue should be empty when attaching" */);
                let summary;
                if (!hasAttachmentBlobs) {
                    // Get the document state post attach - possibly can just call attach but we need to change the
                    // semantics around what the attach means as far as async code goes.
                    const appSummary = this.context.createSummary();
                    const protocolSummary = this.captureProtocolSummary();
                    summary = (0, driver_utils_1.combineAppAndProtocolSummary)(appSummary, protocolSummary);
                    // Set the state as attaching as we are starting the process of attaching container.
                    // This should be fired after taking the summary because it is the place where we are
                    // starting to attach the container to storage.
                    // Also, this should only be fired in detached container.
                    this._attachState = container_definitions_1.AttachState.Attaching;
                    this.context.notifyAttaching((0, utils_1.getSnapshotTreeFromSerializedContainer)(summary));
                }
                // Actually go and create the resolved document
                const createNewResolvedUrl = await this.urlResolver.resolve(request);
                (0, driver_utils_1.ensureFluidResolvedUrl)(createNewResolvedUrl);
                if (this.service === undefined) {
                    (0, common_utils_1.assert)(this.client.details.type !== summarizerClientType, 0x2c4 /* "client should not be summarizer before container is created" */);
                    this.service = await (0, driver_utils_1.runWithRetry)(async () => this.serviceFactory.createContainer(summary, createNewResolvedUrl, this.subLogger, false), "containerAttach", this.mc.logger, {
                        cancel: this.closeSignal,
                    });
                }
                const resolvedUrl = this.service.resolvedUrl;
                (0, driver_utils_1.ensureFluidResolvedUrl)(resolvedUrl);
                this._resolvedUrl = resolvedUrl;
                await this.connectStorageService();
                if (hasAttachmentBlobs) {
                    // upload blobs to storage
                    (0, common_utils_1.assert)(!!this.loader.services.detachedBlobStorage, 0x24e /* "assertion for type narrowing" */);
                    // build a table mapping IDs assigned locally to IDs assigned by storage and pass it to runtime to
                    // support blob handles that only know about the local IDs
                    const redirectTable = new Map();
                    // if new blobs are added while uploading, upload them too
                    while (redirectTable.size < this.loader.services.detachedBlobStorage.size) {
                        const newIds = this.loader.services.detachedBlobStorage.getBlobIds().filter((id) => !redirectTable.has(id));
                        for (const id of newIds) {
                            const blob = await this.loader.services.detachedBlobStorage.readBlob(id);
                            const response = await this.storageService.createBlob(blob);
                            redirectTable.set(id, response.id);
                        }
                    }
                    // take summary and upload
                    const appSummary = this.context.createSummary(redirectTable);
                    const protocolSummary = this.captureProtocolSummary();
                    summary = (0, driver_utils_1.combineAppAndProtocolSummary)(appSummary, protocolSummary);
                    this._attachState = container_definitions_1.AttachState.Attaching;
                    this.context.notifyAttaching((0, utils_1.getSnapshotTreeFromSerializedContainer)(summary));
                    await this.storageService.uploadSummaryWithContext(summary, {
                        referenceSequenceNumber: 0,
                        ackHandle: undefined,
                        proposalHandle: undefined,
                    });
                }
                this._attachState = container_definitions_1.AttachState.Attached;
                this.emit("attached");
                // Propagate current connection state through the system.
                this.propagateConnectionState();
                if (!this.closed) {
                    this.resumeInternal({ fetchOpsFromStorage: false, reason: "createDetached" });
                }
            }
            catch (error) {
                // add resolved URL on error object so that host has the ability to find this document and delete it
                const newError = (0, telemetry_utils_1.normalizeError)(error);
                const resolvedUrl = this.resolvedUrl;
                if ((0, driver_utils_1.isFluidResolvedUrl)(resolvedUrl)) {
                    newError.addTelemetryProperties({ resolvedUrl: resolvedUrl.url });
                }
                this.close(newError);
                throw newError;
            }
        }, { start: true, end: true, cancel: "generic" });
    }
    async request(path) {
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Request" }, async () => this.context.request(path), { end: true, cancel: "error" });
    }
    setAutoReconnectInternal(mode) {
        const currentMode = this._deltaManager.connectionManager.reconnectMode;
        if (currentMode === mode) {
            return;
        }
        const now = common_utils_1.performance.now();
        const duration = now - this.setAutoReconnectTime;
        this.setAutoReconnectTime = now;
        this.mc.logger.sendTelemetryEvent({
            eventName: mode === contracts_1.ReconnectMode.Enabled ? "AutoReconnectEnabled" : "AutoReconnectDisabled",
            connectionMode: this.connectionMode,
            connectionState: connectionState_1.ConnectionState[this.connectionState],
            duration,
        });
        this._deltaManager.connectionManager.setAutoReconnect(mode);
    }
    connect() {
        if (this.closed) {
            throw new container_utils_1.UsageError(`The Container is closed and cannot be connected`);
        }
        else if (this._attachState !== container_definitions_1.AttachState.Attached) {
            throw new container_utils_1.UsageError(`The Container is not attached and cannot be connected`);
        }
        else if (!this.connected) {
            // Note: no need to fetch ops as we do it preemptively as part of DeltaManager.attachOpHandler().
            // If there is gap, we will learn about it once connected, but the gap should be small (if any),
            // assuming that connect() is called quickly after initial container boot.
            this.connectInternal({ reason: "DocumentConnect", fetchOpsFromStorage: false });
        }
    }
    connectInternal(args) {
        (0, common_utils_1.assert)(!this.closed, 0x2c5 /* "Attempting to connect() a closed Container" */);
        (0, common_utils_1.assert)(this._attachState === container_definitions_1.AttachState.Attached, 0x2c6 /* "Attempting to connect() a container that is not attached" */);
        // Resume processing ops and connect to delta stream
        this.resumeInternal(args);
        // Set Auto Reconnect Mode
        const mode = contracts_1.ReconnectMode.Enabled;
        this.setAutoReconnectInternal(mode);
    }
    disconnect() {
        if (this.closed) {
            throw new container_utils_1.UsageError(`The Container is closed and cannot be disconnected`);
        }
        else {
            this.disconnectInternal();
        }
    }
    disconnectInternal() {
        (0, common_utils_1.assert)(!this.closed, 0x2c7 /* "Attempting to disconnect() a closed Container" */);
        // Set Auto Reconnect Mode
        const mode = contracts_1.ReconnectMode.Disabled;
        this.setAutoReconnectInternal(mode);
    }
    resumeInternal(args) {
        (0, common_utils_1.assert)(!this.closed, 0x0d9 /* "Attempting to connect() a closed DeltaManager" */);
        // Resume processing ops
        if (this.inboundQueuePausedFromInit) {
            this.inboundQueuePausedFromInit = false;
            this._deltaManager.inbound.resume();
            this._deltaManager.inboundSignal.resume();
        }
        // Ensure connection to web socket
        this.connectToDeltaStream(args);
    }
    async getAbsoluteUrl(relativeUrl) {
        var _a;
        if (this.resolvedUrl === undefined) {
            return undefined;
        }
        return this.urlResolver.getAbsoluteUrl(this.resolvedUrl, relativeUrl, (0, contracts_1.getPackageName)((_a = this._context) === null || _a === void 0 ? void 0 : _a.codeDetails));
    }
    async proposeCodeDetails(codeDetails) {
        if (!(0, container_definitions_1.isFluidCodeDetails)(codeDetails)) {
            throw new Error("Provided codeDetails are not IFluidCodeDetails");
        }
        if (this.codeLoader.IFluidCodeDetailsComparer) {
            const comparison = await this.codeLoader.IFluidCodeDetailsComparer.compare(codeDetails, this.getCodeDetailsFromQuorum());
            if (comparison !== undefined && comparison <= 0) {
                throw new Error("Proposed code details should be greater than the current");
            }
        }
        return this.protocolHandler.quorum.propose("code", codeDetails)
            .then(() => true)
            .catch(() => false);
    }
    async processCodeProposal() {
        const codeDetails = this.getCodeDetailsFromQuorum();
        await Promise.all([
            this.deltaManager.inbound.pause(),
            this.deltaManager.inboundSignal.pause()
        ]);
        if ((await this.context.satisfies(codeDetails) === true)) {
            this.deltaManager.inbound.resume();
            this.deltaManager.inboundSignal.resume();
            return;
        }
        // pre-0.58 error message: existingContextDoesNotSatisfyIncomingProposal
        this.close(new container_utils_1.GenericError("Existing context does not satisfy incoming proposal"));
    }
    async getVersion(version) {
        const versions = await this.storageService.getVersions(version, 1);
        return versions[0];
    }
    recordConnectStartTime() {
        if (this.connectionTransitionTimes[connectionState_1.ConnectionState.Disconnected] === undefined) {
            this.connectionTransitionTimes[connectionState_1.ConnectionState.Disconnected] = common_utils_1.performance.now();
        }
    }
    connectToDeltaStream(args) {
        this.recordConnectStartTime();
        // All agents need "write" access, including summarizer.
        if (!this._canReconnect || !this.client.details.capabilities.interactive) {
            args.mode = "write";
        }
        this._deltaManager.connect(args);
    }
    /**
     * Load container.
     *
     * @param specifiedVersion - one of the following
     *   - undefined - fetch latest snapshot
     *   - otherwise, version sha to load snapshot
     */
    async load(specifiedVersion, loadMode, pendingLocalState) {
        if (this._resolvedUrl === undefined) {
            throw new Error("Attempting to load without a resolved url");
        }
        this.service = await this.serviceFactory.createDocumentService(this._resolvedUrl, this.subLogger, this.client.details.type === summarizerClientType);
        // Ideally we always connect as "read" by default.
        // Currently that works with SPO & r11s, because we get "write" connection when connecting to non-existing file.
        // We should not rely on it by (one of them will address the issue, but we need to address both)
        // 1) switching create new flow to one where we create file by posting snapshot
        // 2) Fixing quorum workflows (have retry logic)
        // That all said, "read" does not work with memorylicious workflows (that opens two simultaneous
        // connections to same file) in two ways:
        // A) creation flow breaks (as one of the clients "sees" file as existing, and hits #2 above)
        // B) Once file is created, transition from view-only connection to write does not work - some bugs to be fixed.
        const connectionArgs = { reason: "DocumentOpen", mode: "write", fetchOpsFromStorage: false };
        // Start websocket connection as soon as possible. Note that there is no op handler attached yet, but the
        // DeltaManager is resilient to this and will wait to start processing ops until after it is attached.
        if (loadMode.deltaConnection === undefined) {
            this.connectToDeltaStream(connectionArgs);
        }
        if (!pendingLocalState) {
            await this.connectStorageService();
        }
        else {
            // if we have pendingLocalState we can load without storage; don't wait for connection
            this.connectStorageService().catch((error) => this.close(error));
        }
        this._attachState = container_definitions_1.AttachState.Attached;
        // Fetch specified snapshot.
        const { snapshot, versionId } = pendingLocalState === undefined
            ? await this.fetchSnapshotTree(specifiedVersion)
            : { snapshot: undefined, versionId: undefined };
        (0, common_utils_1.assert)(snapshot !== undefined || pendingLocalState !== undefined, 0x237 /* "Snapshot should exist" */);
        const attributes = pendingLocalState === undefined
            ? await this.getDocumentAttributes(this.storageService, snapshot)
            : {
                sequenceNumber: pendingLocalState.protocol.sequenceNumber,
                minimumSequenceNumber: pendingLocalState.protocol.minimumSequenceNumber,
                term: pendingLocalState.term,
            };
        let opsBeforeReturnP;
        // Attach op handlers to finish initialization and be able to start processing ops
        // Kick off any ops fetching if required.
        switch (loadMode.opsBeforeReturn) {
            case undefined:
                // Start prefetch, but not set opsBeforeReturnP - boot is not blocked by it!
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this.attachDeltaManagerOpHandler(attributes, loadMode.deltaConnection !== "none" ? "all" : "none");
                break;
            case "cached":
                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, "cached");
                break;
            case "all":
                opsBeforeReturnP = this.attachDeltaManagerOpHandler(attributes, "all");
                break;
            default:
                (0, common_utils_1.unreachableCase)(loadMode.opsBeforeReturn);
        }
        // ...load in the existing quorum
        // Initialize the protocol handler
        this._protocolHandler = pendingLocalState === undefined
            ? await this.initializeProtocolStateFromSnapshot(attributes, this.storageService, snapshot)
            : await this.initializeProtocolState(attributes, pendingLocalState.protocol.members, pendingLocalState.protocol.proposals, pendingLocalState.protocol.values);
        const codeDetails = this.getCodeDetailsFromQuorum();
        await this.instantiateContext(true, // existing
        codeDetails, snapshot, pendingLocalState === null || pendingLocalState === void 0 ? void 0 : pendingLocalState.pendingRuntimeState);
        // We might have hit some failure that did not manifest itself in exception in this flow,
        // do not start op processing in such case - static version of Container.load() will handle it correctly.
        if (!this.closed) {
            if (opsBeforeReturnP !== undefined) {
                this._deltaManager.inbound.resume();
                await ReportIfTooLong(this.mc.logger, "WaitOps", async () => { await opsBeforeReturnP; return {}; });
                await ReportIfTooLong(this.mc.logger, "WaitOpProcessing", async () => this._deltaManager.inbound.waitTillProcessingDone());
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                this._deltaManager.inbound.pause();
            }
            switch (loadMode.deltaConnection) {
                case undefined:
                case "delayed":
                    (0, common_utils_1.assert)(this.inboundQueuePausedFromInit, 0x346 /* inboundQueuePausedFromInit should be true */);
                    this.inboundQueuePausedFromInit = false;
                    this._deltaManager.inbound.resume();
                    this._deltaManager.inboundSignal.resume();
                    break;
                case "none":
                    break;
                default:
                    (0, common_utils_1.unreachableCase)(loadMode.deltaConnection);
            }
        }
        // Safety net: static version of Container.load() should have learned about it through "closed" handler.
        // But if that did not happen for some reason, fail load for sure.
        // Otherwise we can get into situations where container is closed and does not try to connect to ordering
        // service, but caller does not know that (callers do expect container to be not closed on successful path
        // and listen only on "closed" event)
        if (this.closed) {
            throw new Error("Container was closed while load()");
        }
        // Internal context is fully loaded at this point
        this.setLoaded();
        return {
            sequenceNumber: attributes.sequenceNumber,
            version: versionId,
            dmLastProcessedSeqNumber: this._deltaManager.lastSequenceNumber,
            dmLastKnownSeqNumber: this._deltaManager.lastKnownSeqNumber,
        };
    }
    async createDetached(source) {
        const attributes = {
            sequenceNumber: detachedContainerRefSeqNumber,
            term: 1,
            minimumSequenceNumber: 0,
        };
        await this.attachDeltaManagerOpHandler(attributes);
        // Need to just seed the source data in the code quorum. Quorum itself is empty
        const qValues = (0, quorum_1.initQuorumValuesFromCodeDetails)(source);
        this._protocolHandler = await this.initializeProtocolState(attributes, [], // members
        [], // proposals
        qValues);
        // The load context - given we seeded the quorum - will be great
        await this.instantiateContextDetached(false);
        this.setLoaded();
    }
    async rehydrateDetachedFromSnapshot(detachedContainerSnapshot) {
        if (detachedContainerSnapshot.tree[".hasAttachmentBlobs"] !== undefined) {
            (0, common_utils_1.assert)(!!this.loader.services.detachedBlobStorage && this.loader.services.detachedBlobStorage.size > 0, 0x250 /* "serialized container with attachment blobs must be rehydrated with detached blob storage" */);
            delete detachedContainerSnapshot.tree[".hasAttachmentBlobs"];
        }
        const snapshotTree = (0, utils_1.getSnapshotTreeFromSerializedContainer)(detachedContainerSnapshot);
        this._storage.loadSnapshotForRehydratingContainer(snapshotTree);
        const attributes = await this.getDocumentAttributes(this._storage, snapshotTree);
        await this.attachDeltaManagerOpHandler(attributes);
        // Initialize the protocol handler
        const baseTree = (0, utils_1.getProtocolSnapshotTree)(snapshotTree);
        const qValues = await (0, driver_utils_1.readAndParse)(this._storage, baseTree.blobs.quorumValues);
        const codeDetails = (0, quorum_1.getCodeDetailsFromQuorumValues)(qValues);
        this._protocolHandler =
            await this.initializeProtocolState(attributes, [], // members
            [], // proposals
            codeDetails !== undefined ? (0, quorum_1.initQuorumValuesFromCodeDetails)(codeDetails) : []);
        await this.instantiateContextDetached(true, // existing
        snapshotTree);
        this.setLoaded();
    }
    async connectStorageService() {
        var _a, _b;
        if (this._storageService !== undefined) {
            return;
        }
        (0, common_utils_1.assert)(this.service !== undefined, 0x1ef /* "services must be defined" */);
        const storageService = await this.service.connectToStorage();
        this._storageService =
            new retriableDocumentStorageService_1.RetriableDocumentStorageService(storageService, this.mc.logger);
        if (this.options.summarizeProtocolTree === true) {
            this.mc.logger.sendTelemetryEvent({ eventName: "summarizeProtocolTreeEnabled" });
            this._storageService =
                new protocolTreeDocumentStorageService_1.ProtocolTreeStorageService(this._storageService, () => this.captureProtocolSummary());
        }
        // ensure we did not lose that policy in the process of wrapping
        (0, common_utils_1.assert)(((_a = storageService.policies) === null || _a === void 0 ? void 0 : _a.minBlobSize) === ((_b = this.storageService.policies) === null || _b === void 0 ? void 0 : _b.minBlobSize), 0x0e0 /* "lost minBlobSize policy" */);
    }
    async getDocumentAttributes(storage, tree) {
        if (tree === undefined) {
            return {
                minimumSequenceNumber: 0,
                sequenceNumber: 0,
                term: 1,
            };
        }
        // Backward compatibility: old docs would have ".attributes" instead of "attributes"
        const attributesHash = ".protocol" in tree.trees
            ? tree.trees[".protocol"].blobs.attributes
            : tree.blobs[".attributes"];
        const attributes = await (0, driver_utils_1.readAndParse)(storage, attributesHash);
        // Backward compatibility for older summaries with no term
        if (attributes.term === undefined) {
            attributes.term = 1;
        }
        return attributes;
    }
    async initializeProtocolStateFromSnapshot(attributes, storage, snapshot) {
        let members = [];
        let proposals = [];
        let values = [];
        if (snapshot !== undefined) {
            const baseTree = (0, utils_1.getProtocolSnapshotTree)(snapshot);
            [members, proposals, values] = await Promise.all([
                (0, driver_utils_1.readAndParse)(storage, baseTree.blobs.quorumMembers),
                (0, driver_utils_1.readAndParse)(storage, baseTree.blobs.quorumProposals),
                (0, driver_utils_1.readAndParse)(storage, baseTree.blobs.quorumValues),
            ]);
        }
        const protocolHandler = await this.initializeProtocolState(attributes, members, proposals, values);
        return protocolHandler;
    }
    async initializeProtocolState(attributes, members, proposals, values) {
        const protocol = new protocol_base_1.ProtocolOpHandlerWithClientValidation(attributes.minimumSequenceNumber, attributes.sequenceNumber, attributes.term, members, proposals, values, (key, value) => this.submitMessage(protocol_definitions_1.MessageType.Propose, { key, value }));
        const protocolLogger = telemetry_utils_1.ChildLogger.create(this.subLogger, "ProtocolHandler");
        protocol.quorum.on("error", (error) => {
            protocolLogger.sendErrorEvent(error);
        });
        // Track membership changes and update connection state accordingly
        this.connectionStateHandler.initProtocol(protocol);
        protocol.quorum.on("addProposal", (proposal) => {
            if (proposal.key === "code" || proposal.key === "code2") {
                this.emit("codeDetailsProposed", proposal.value, proposal);
            }
        });
        protocol.quorum.on("approveProposal", (sequenceNumber, key, value) => {
            if (key === "code" || key === "code2") {
                if (!(0, container_definitions_1.isFluidCodeDetails)(value)) {
                    this.mc.logger.sendErrorEvent({
                        eventName: "CodeProposalNotIFluidCodeDetails",
                    });
                }
                this.processCodeProposal().catch((error) => {
                    this.close((0, telemetry_utils_1.normalizeError)(error));
                    throw error;
                });
            }
        });
        return protocol;
    }
    captureProtocolSummary() {
        const quorumSnapshot = this.protocolHandler.snapshot();
        const summary = {
            tree: {
                attributes: {
                    content: JSON.stringify(this.protocolHandler.attributes),
                    type: protocol_definitions_1.SummaryType.Blob,
                },
                quorumMembers: {
                    content: JSON.stringify(quorumSnapshot.members),
                    type: protocol_definitions_1.SummaryType.Blob,
                },
                quorumProposals: {
                    content: JSON.stringify(quorumSnapshot.proposals),
                    type: protocol_definitions_1.SummaryType.Blob,
                },
                quorumValues: {
                    content: JSON.stringify(quorumSnapshot.values),
                    type: protocol_definitions_1.SummaryType.Blob,
                },
            },
            type: protocol_definitions_1.SummaryType.Tree,
        };
        return summary;
    }
    getCodeDetailsFromQuorum() {
        const quorum = this.protocolHandler.quorum;
        const pkg = getCodeProposal(quorum);
        return pkg;
    }
    get client() {
        var _a;
        const client = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.client) !== undefined
            ? this.options.client
            : {
                details: {
                    capabilities: { interactive: true },
                },
                mode: "read",
                permission: [],
                scopes: [],
                user: { id: "" },
            };
        if (this.clientDetailsOverride !== undefined) {
            (0, merge_1.default)(client.details, this.clientDetailsOverride);
        }
        client.details.environment = [client.details.environment, ` loaderVersion:${packageVersion_1.pkgVersion}`].join(";");
        return client;
    }
    /**
     * Returns true if connection is active, i.e. it's "write" connection and
     * container runtime was notified about this connection (i.e. we are up-to-date and could send ops).
     * This happens after client received its own joinOp and thus is in the quorum.
     * If it's not true, runtime is not in position to send ops.
     */
    activeConnection() {
        return this.connectionState === connectionState_1.ConnectionState.Connected &&
            this.connectionMode === "write";
    }
    createDeltaManager() {
        const serviceProvider = () => this.service;
        const deltaManager = new deltaManager_1.DeltaManager(serviceProvider, telemetry_utils_1.ChildLogger.create(this.subLogger, "DeltaManager"), () => this.activeConnection(), (props) => new connectionManager_1.ConnectionManager(serviceProvider, this.client, this._canReconnect, telemetry_utils_1.ChildLogger.create(this.subLogger, "ConnectionManager"), props));
        // Disable inbound queues as Container is not ready to accept any ops until we are fully loaded!
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        deltaManager.inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        deltaManager.inboundSignal.pause();
        deltaManager.on("connect", (details, opsBehind) => {
            var _a;
            // Back-compat for new client and old server.
            this._audience.clear();
            for (const priorClient of (_a = details.initialClients) !== null && _a !== void 0 ? _a : []) {
                this._audience.addMember(priorClient.clientId, priorClient.client);
            }
            this.connectionStateHandler.receivedConnectEvent(this.connectionMode, details);
        });
        deltaManager.on("disconnect", (reason) => {
            var _a;
            (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();
            this.connectionStateHandler.receivedDisconnectEvent(reason);
        });
        deltaManager.on("throttled", (warning) => {
            const warn = warning;
            // Some "warning" events come from outside the container and are logged
            // elsewhere (e.g. summarizing container). We shouldn't log these here.
            if (warn.logged !== true) {
                this.logContainerError(warn);
            }
            this.emit("warning", warn);
        });
        deltaManager.on("readonly", (readonly) => {
            this.emit("readonly", readonly);
        });
        deltaManager.on("closed", (error) => {
            this.closeCore(error);
        });
        return deltaManager;
    }
    async attachDeltaManagerOpHandler(attributes, prefetchType) {
        var _a;
        return this._deltaManager.attachOpHandler(attributes.minimumSequenceNumber, attributes.sequenceNumber, (_a = attributes.term) !== null && _a !== void 0 ? _a : 1, {
            process: (message) => this.processRemoteMessage(message),
            processSignal: (message) => {
                this.processSignal(message);
            },
        }, prefetchType);
    }
    logConnectionStateChangeTelemetry(value, oldState, reason) {
        var _a;
        // Log actual event
        const time = common_utils_1.performance.now();
        this.connectionTransitionTimes[value] = time;
        const duration = time - this.connectionTransitionTimes[oldState];
        let durationFromDisconnected;
        let connectionInitiationReason;
        let autoReconnect;
        let checkpointSequenceNumber;
        let opsBehind;
        if (value === connectionState_1.ConnectionState.Disconnected) {
            autoReconnect = this._deltaManager.connectionManager.reconnectMode;
        }
        else {
            if (value === connectionState_1.ConnectionState.Connected) {
                durationFromDisconnected = time - this.connectionTransitionTimes[connectionState_1.ConnectionState.Disconnected];
                durationFromDisconnected = telemetry_utils_1.TelemetryLogger.formatTick(durationFromDisconnected);
            }
            else {
                // This info is of most interest on establishing connection only.
                checkpointSequenceNumber = this.deltaManager.lastKnownSeqNumber;
                if (this.deltaManager.hasCheckpointSequenceNumber) {
                    opsBehind = checkpointSequenceNumber - this.deltaManager.lastSequenceNumber;
                }
            }
            if (this.firstConnection) {
                connectionInitiationReason = "InitialConnect";
            }
            else {
                connectionInitiationReason = "AutoReconnect";
            }
        }
        this.mc.logger.sendPerformanceEvent(Object.assign({ eventName: `ConnectionStateChange_${connectionState_1.ConnectionState[value]}`, from: connectionState_1.ConnectionState[oldState], duration,
            durationFromDisconnected,
            reason,
            connectionInitiationReason, pendingClientId: this.connectionStateHandler.pendingClientId, clientId: this.clientId, autoReconnect,
            opsBehind, online: driver_utils_1.OnlineStatus[(0, driver_utils_1.isOnline)()], lastVisible: this.lastVisible !== undefined ? common_utils_1.performance.now() - this.lastVisible : undefined, checkpointSequenceNumber, quorumSize: (_a = this._protocolHandler) === null || _a === void 0 ? void 0 : _a.quorum.getMembers().size }, this._deltaManager.connectionProps));
        if (value === connectionState_1.ConnectionState.Connected) {
            this.firstConnection = false;
        }
    }
    propagateConnectionState() {
        var _a;
        const logOpsOnReconnect = this.connectionState === connectionState_1.ConnectionState.Connected &&
            !this.firstConnection &&
            this.connectionMode === "write";
        if (logOpsOnReconnect) {
            this.messageCountAfterDisconnection = 0;
        }
        const state = this.connectionState === connectionState_1.ConnectionState.Connected;
        // Both protocol and context should not be undefined if we got so far.
        if (((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) === false) {
            this.context.setConnectionState(state, this.clientId);
        }
        this.protocolHandler.setConnectionState(state, this.clientId);
        (0, telemetry_utils_1.raiseConnectedEvent)(this.mc.logger, this, state, this.clientId);
        if (logOpsOnReconnect) {
            this.mc.logger.sendTelemetryEvent({ eventName: "OpsSentOnReconnect", count: this.messageCountAfterDisconnection });
        }
    }
    submitContainerMessage(type, contents, batch, metadata) {
        const outboundMessageType = type;
        switch (outboundMessageType) {
            case protocol_definitions_1.MessageType.Operation:
            case protocol_definitions_1.MessageType.RemoteHelp:
                break;
            case protocol_definitions_1.MessageType.Summarize: {
                // github #6451: this is only needed for staging so the server
                // know when the protocol tree is included
                // this can be removed once all clients send
                // protocol tree by default
                const summary = contents;
                if (summary.details === undefined) {
                    summary.details = {};
                }
                summary.details.includesProtocolTree =
                    this.options.summarizeProtocolTree === true;
                break;
            }
            default:
                this.close(new container_utils_1.GenericError("invalidContainerSubmitOpType", undefined /* error */, { messageType: type }));
                return -1;
        }
        return this.submitMessage(type, contents, batch, metadata);
    }
    submitMessage(type, contents, batch, metadata) {
        var _a;
        if (this.connectionState !== connectionState_1.ConnectionState.Connected) {
            this.mc.logger.sendErrorEvent({ eventName: "SubmitMessageWithNoConnection", type });
            return -1;
        }
        this.messageCountAfterDisconnection += 1;
        (_a = this.collabWindowTracker) === null || _a === void 0 ? void 0 : _a.stopSequenceNumberUpdate();
        return this._deltaManager.submit(type, contents, batch, metadata);
    }
    processRemoteMessage(message) {
        const local = this.clientId === message.clientId;
        // Allow the protocol handler to process the message
        let result = { immediateNoOp: false };
        try {
            result = this.protocolHandler.processMessage(message, local);
        }
        catch (error) {
            this.close((0, telemetry_utils_1.wrapError)(error, (errorMessage) => new container_utils_1.DataCorruptionError(errorMessage, (0, container_utils_1.extractSafePropertiesFromMessage)(message))));
        }
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if ((0, driver_utils_1.isUnpackedRuntimeMessage)(message) && !(0, driver_utils_1.isRuntimeMessage)(message)) {
            this.mc.logger.sendTelemetryEvent({ eventName: "UnpackedRuntimeMessage", type: message.type });
        }
        // Forward non system messages to the loaded runtime for processing
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        if ((0, driver_utils_1.isRuntimeMessage)(message) || (0, driver_utils_1.isUnpackedRuntimeMessage)(message)) {
            this.context.process(message, local, undefined);
        }
        // Inactive (not in quorum or not writers) clients don't take part in the minimum sequence number calculation.
        if (this.activeConnection()) {
            if (this.collabWindowTracker === undefined) {
                // Note that config from first connection will be used for this container's lifetime.
                // That means that if relay service changes settings, such changes will impact only newly booted
                // clients.
                // All existing will continue to use settings they got earlier.
                (0, common_utils_1.assert)(this.serviceConfiguration !== undefined, 0x2e4 /* "there should be service config for active connection" */);
                this.collabWindowTracker = new collabWindowTracker_1.CollabWindowTracker((type, contents) => {
                    (0, common_utils_1.assert)(this.activeConnection(), 0x241 /* "disconnect should result in stopSequenceNumberUpdate() call" */);
                    this.submitMessage(type, contents);
                }, this.serviceConfiguration.noopTimeFrequency, this.serviceConfiguration.noopCountFrequency);
            }
            this.collabWindowTracker.scheduleSequenceNumberUpdate(message, result.immediateNoOp === true);
        }
        this.emit("op", message);
        return result;
    }
    submitSignal(message) {
        this._deltaManager.submitSignal(JSON.stringify(message));
    }
    processSignal(message) {
        // No clientId indicates a system signal message.
        if (message.clientId === null) {
            const innerContent = message.content;
            if (innerContent.type === protocol_definitions_1.MessageType.ClientJoin) {
                const newClient = innerContent.content;
                this._audience.addMember(newClient.clientId, newClient.client);
            }
            else if (innerContent.type === protocol_definitions_1.MessageType.ClientLeave) {
                const leftClientId = innerContent.content;
                this._audience.removeMember(leftClientId);
            }
        }
        else {
            const local = this.clientId === message.clientId;
            this.context.processSignal(message, local);
        }
    }
    /**
     * Get the most recent snapshot, or a specific version.
     * @param specifiedVersion - The specific version of the snapshot to retrieve
     * @returns The snapshot requested, or the latest snapshot if no version was specified, plus version ID
     */
    async fetchSnapshotTree(specifiedVersion) {
        var _a;
        const version = await this.getVersion(specifiedVersion !== null && specifiedVersion !== void 0 ? specifiedVersion : null);
        if (version === undefined && specifiedVersion !== undefined) {
            // We should have a defined version to load from if specified version requested
            this.mc.logger.sendErrorEvent({ eventName: "NoVersionFoundWhenSpecified", id: specifiedVersion });
        }
        this._loadedFromVersion = version;
        const snapshot = (_a = await this.storageService.getSnapshotTree(version)) !== null && _a !== void 0 ? _a : undefined;
        if (snapshot === undefined && version !== undefined) {
            this.mc.logger.sendErrorEvent({ eventName: "getSnapshotTreeFailed", id: version.id });
        }
        return { snapshot, versionId: version === null || version === void 0 ? void 0 : version.id };
    }
    async instantiateContextDetached(existing, snapshot) {
        const codeDetails = this.getCodeDetailsFromQuorum();
        if (codeDetails === undefined) {
            throw new Error("pkg should be provided in create flow!!");
        }
        await this.instantiateContext(existing, codeDetails, snapshot);
    }
    async instantiateContext(existing, codeDetails, snapshot, pendingLocalState) {
        var _a;
        (0, common_utils_1.assert)(((_a = this._context) === null || _a === void 0 ? void 0 : _a.disposed) !== false, 0x0dd /* "Existing context not disposed" */);
        // The relative loader will proxy requests to '/' to the loader itself assuming no non-cache flags
        // are set. Global requests will still go directly to the loader
        const loader = new loader_1.RelativeLoader(this, this.loader);
        this._context = await containerContext_1.ContainerContext.createOrLoad(this, this.scope, this.codeLoader, codeDetails, snapshot, new deltaManagerProxy_1.DeltaManagerProxy(this._deltaManager), new quorum_1.QuorumProxy(this.protocolHandler.quorum), loader, (type, contents, batch, metadata) => this.submitContainerMessage(type, contents, batch, metadata), (message) => this.submitSignal(message), (error) => this.close(error), Container.version, (dirty) => this.updateDirtyContainerState(dirty), existing, pendingLocalState);
        this.emit("contextChanged", codeDetails);
    }
    updateDirtyContainerState(dirty) {
        if (this._dirtyContainer === dirty) {
            return;
        }
        this._dirtyContainer = dirty;
        this.emit(dirty ? dirtyContainerEvent : savedContainerEvent);
    }
    logContainerError(warning) {
        this.mc.logger.sendErrorEvent({ eventName: "ContainerWarning" }, warning);
    }
}
exports.Container = Container;
Container.version = "^0.1.0";

},{"./audience":289,"./collabWindowTracker":290,"./connectionManager":291,"./connectionState":292,"./connectionStateHandler":293,"./containerContext":295,"./containerStorageAdapter":296,"./contracts":297,"./deltaManager":298,"./deltaManagerProxy":299,"./loader":302,"./packageVersion":303,"./protocolTreeDocumentStorageService":304,"./quorum":305,"./retriableDocumentStorageService":306,"./utils":307,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"lodash/merge":521,"uuid":544}],295:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerContext = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_definitions_1 = require("@fluidframework/container-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const PackageNotFactoryError = "Code package does not implement IRuntimeFactory";
class ContainerContext {
    constructor(container, scope, codeLoader, _codeDetails, _baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {
        this.container = container;
        this.scope = scope;
        this.codeLoader = codeLoader;
        this._codeDetails = _codeDetails;
        this._baseSnapshot = _baseSnapshot;
        this.deltaManager = deltaManager;
        this.loader = loader;
        this.submitFn = submitFn;
        this.submitSignalFn = submitSignalFn;
        this.closeFn = closeFn;
        this.version = version;
        this.updateDirtyContainerState = updateDirtyContainerState;
        this.existing = existing;
        this.pendingLocalState = pendingLocalState;
        this._disposed = false;
        this._quorum = quorum;
        this.taggedLogger = container.subLogger;
        this._fluidModuleP = new common_utils_1.LazyPromise(async () => this.loadCodeModule(_codeDetails));
        this.attachListener();
    }
    static async createOrLoad(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState) {
        const context = new ContainerContext(container, scope, codeLoader, codeDetails, baseSnapshot, deltaManager, quorum, loader, submitFn, submitSignalFn, closeFn, version, updateDirtyContainerState, existing, pendingLocalState);
        await context.instantiateRuntime(existing);
        return context;
    }
    get clientId() {
        return this.container.clientId;
    }
    /**
     * DISCLAIMER: this id is only for telemetry purposes. Not suitable for any other usages.
     */
    get id() {
        const resolvedUrl = this.container.resolvedUrl;
        if ((0, driver_utils_1.isFluidResolvedUrl)(resolvedUrl)) {
            return resolvedUrl.id;
        }
        return "";
    }
    get clientDetails() {
        return this.container.clientDetails;
    }
    get connected() {
        return this.container.connected;
    }
    get canSummarize() {
        return "summarize" in this.runtime;
    }
    get serviceConfiguration() {
        return this.container.serviceConfiguration;
    }
    get audience() {
        return this.container.audience;
    }
    get options() {
        return this.container.options;
    }
    get baseSnapshot() {
        return this._baseSnapshot;
    }
    get storage() {
        return this.container.storage;
    }
    get runtime() {
        if (this._runtime === undefined) {
            throw new Error("Attempted to access runtime before it was defined");
        }
        return this._runtime;
    }
    get disposed() {
        return this._disposed;
    }
    get codeDetails() { return this._codeDetails; }
    get quorum() { return this._quorum; }
    /**
     * @deprecated - Temporary migratory API, to be removed when customers no longer need it.  When removed,
     * ContainerContext should only take an IQuorumClients rather than an IQuorum.  See IContainerContext for more
     * details.
     */
    getSpecifiedCodeDetails() {
        var _a;
        return ((_a = this._quorum.get("code")) !== null && _a !== void 0 ? _a : this._quorum.get("code2"));
    }
    dispose(error) {
        if (this._disposed) {
            return;
        }
        this._disposed = true;
        this.runtime.dispose(error);
        this._quorum.dispose();
        this.deltaManager.dispose();
    }
    getLoadedFromVersion() {
        return this.container.loadedFromVersion;
    }
    get attachState() {
        return this.container.attachState;
    }
    /**
     * Create a summary. Used when attaching or serializing a detached container.
     *
     * @param blobRedirectTable - A table passed during the attach process. While detached, blob upload is supported
     * using IDs generated locally. After attach, these IDs cannot be used, so this table maps the old local IDs to the
     * new storage IDs so requests can be redirected.
     */
    createSummary(blobRedirectTable) {
        return this.runtime.createSummary(blobRedirectTable);
    }
    setConnectionState(connected, clientId) {
        const runtime = this.runtime;
        (0, common_utils_1.assert)(connected === this.connected, 0x0de /* "Mismatch in connection state while setting" */);
        runtime.setConnectionState(connected, clientId);
    }
    process(message, local, context) {
        this.runtime.process(message, local, context);
    }
    processSignal(message, local) {
        this.runtime.processSignal(message, local);
    }
    async request(path) {
        return this.runtime.request(path);
    }
    async getAbsoluteUrl(relativeUrl) {
        return this.container.getAbsoluteUrl(relativeUrl);
    }
    getPendingLocalState() {
        return this.runtime.getPendingLocalState();
    }
    /**
     * Determines if the current code details of the context
     * satisfy the incoming constraint code details
     */
    async satisfies(constraintCodeDetails) {
        var _a;
        const comparers = [];
        const maybeCompareCodeLoader = this.codeLoader;
        if (maybeCompareCodeLoader.IFluidCodeDetailsComparer !== undefined) {
            comparers.push(maybeCompareCodeLoader.IFluidCodeDetailsComparer);
        }
        const moduleWithDetails = await this._fluidModuleP;
        const maybeCompareExport = (_a = moduleWithDetails.module) === null || _a === void 0 ? void 0 : _a.fluidExport;
        if ((maybeCompareExport === null || maybeCompareExport === void 0 ? void 0 : maybeCompareExport.IFluidCodeDetailsComparer) !== undefined) {
            comparers.push(maybeCompareExport.IFluidCodeDetailsComparer);
        }
        // if there are not comparers it is not possible to know
        // if the current satisfy the incoming, so return false,
        // as assuming they do not satisfy is safer .e.g we will
        // reload, rather than potentially running with
        // incompatible code
        if (comparers.length === 0) {
            return false;
        }
        for (const comparer of comparers) {
            const satisfies = await comparer.satisfies(moduleWithDetails.details, constraintCodeDetails);
            if (satisfies === false) {
                return false;
            }
        }
        return true;
    }
    notifyAttaching(snapshot) {
        var _a, _b;
        this._baseSnapshot = snapshot;
        (_b = (_a = this.runtime).notifyAttaching) === null || _b === void 0 ? void 0 : _b.call(_a, snapshot);
        this.runtime.setAttachState(container_definitions_1.AttachState.Attaching);
    }
    // #region private
    async getRuntimeFactory() {
        var _a;
        const fluidExport = (_a = (await this._fluidModuleP).module) === null || _a === void 0 ? void 0 : _a.fluidExport;
        const runtimeFactory = fluidExport === null || fluidExport === void 0 ? void 0 : fluidExport.IRuntimeFactory;
        if (runtimeFactory === undefined) {
            throw new Error(PackageNotFactoryError);
        }
        return runtimeFactory;
    }
    async instantiateRuntime(existing) {
        const runtimeFactory = await this.getRuntimeFactory();
        this._runtime = await runtimeFactory.instantiateRuntime(this, existing);
    }
    attachListener() {
        this.container.once("attached", () => {
            this.runtime.setAttachState(container_definitions_1.AttachState.Attached);
        });
    }
    async loadCodeModule(codeDetails) {
        const loadCodeResult = await telemetry_utils_1.PerformanceEvent.timedExecAsync(this.taggedLogger, { eventName: "CodeLoad" }, async () => this.codeLoader.load(codeDetails));
        if ("module" in loadCodeResult) {
            const { module, details } = loadCodeResult;
            return {
                module,
                details: details !== null && details !== void 0 ? details : codeDetails,
            };
        }
        else {
            // If "module" is not in the result, we are using a legacy ICodeLoader.  Fix the result up with details.
            // Once usage drops to 0 we can remove this compat path.
            this.taggedLogger.sendTelemetryEvent({ eventName: "LegacyCodeLoader" });
            return loadCodeResult;
        }
    }
}
exports.ContainerContext = ContainerContext;

},{"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279}],296:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobOnlyStorage = exports.ContainerStorageAdapter = void 0;
/**
 * This class wraps the actual storage and make sure no wrong apis are called according to
 * container attach state.
 */
class ContainerStorageAdapter {
    constructor(storageGetter) {
        this.storageGetter = storageGetter;
        this.blobContents = {};
    }
    loadSnapshotForRehydratingContainer(snapshotTree) {
        this.getBlobContents(snapshotTree);
    }
    getBlobContents(snapshotTree) {
        for (const [id, value] of Object.entries(snapshotTree.blobsContents)) {
            this.blobContents[id] = value;
        }
        for (const [_, tree] of Object.entries(snapshotTree.trees)) {
            this.getBlobContents(tree);
        }
    }
    get policies() {
        // back-compat 0.40 containerRuntime requests policies even in detached container if storage is present
        // and storage is always present in >=0.41.
        try {
            return this.storageGetter().policies;
        }
        catch (e) { }
        return undefined;
    }
    get repositoryUrl() {
        return this.storageGetter().repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.storageGetter().getSnapshotTree(version, scenarioName);
    }
    async readBlob(id) {
        const blob = this.blobContents[id];
        if (blob !== undefined) {
            return blob;
        }
        return this.storageGetter().readBlob(id);
    }
    async getVersions(versionId, count, scenarioName) {
        return this.storageGetter().getVersions(versionId, count, scenarioName);
    }
    async uploadSummaryWithContext(summary, context) {
        return this.storageGetter().uploadSummaryWithContext(summary, context);
    }
    async downloadSummary(handle) {
        return this.storageGetter().downloadSummary(handle);
    }
    async createBlob(file) {
        return this.storageGetter().createBlob(file);
    }
}
exports.ContainerStorageAdapter = ContainerStorageAdapter;
/**
 * Storage which only supports createBlob() and readBlob(). This is used with IDetachedBlobStorage to support
 * blobs in detached containers.
 */
class BlobOnlyStorage {
    constructor(blobStorage, logger) {
        this.blobStorage = blobStorage;
        this.logger = logger;
        /* eslint-disable @typescript-eslint/unbound-method */
        this.getSnapshotTree = this.notCalled;
        this.getVersions = this.notCalled;
        this.write = this.notCalled;
        this.uploadSummaryWithContext = this.notCalled;
        this.downloadSummary = this.notCalled;
    }
    async createBlob(content) {
        return this.blobStorage.createBlob(content);
    }
    async readBlob(blobId) {
        return this.blobStorage.readBlob(blobId);
    }
    get policies() {
        return this.notCalled();
    }
    get repositoryUrl() {
        return this.notCalled();
    }
    /* eslint-enable @typescript-eslint/unbound-method */
    notCalled() {
        try {
            // some browsers may not populate stack unless exception is thrown
            throw new Error("BlobOnlyStorage not implemented method used");
        }
        catch (err) {
            this.logger.sendErrorEvent({ eventName: "BlobOnlyStorageWrongCall" }, err);
            throw err;
        }
    }
}
exports.BlobOnlyStorage = BlobOnlyStorage;

},{}],297:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPackageName = exports.ReconnectMode = void 0;
const container_definitions_1 = require("@fluidframework/container-definitions");
var ReconnectMode;
(function (ReconnectMode) {
    ReconnectMode["Never"] = "Never";
    ReconnectMode["Disabled"] = "Disabled";
    ReconnectMode["Enabled"] = "Enabled";
})(ReconnectMode = exports.ReconnectMode || (exports.ReconnectMode = {}));
/**
 *
 * @param codeDetails- - Data structure used to describe the code to load on the Fluid document
 * @returns The name of the Fluid package
 */
const getPackageName = (codeDetails) => {
    let containerPackageName;
    if (codeDetails && "name" in codeDetails) {
        containerPackageName = codeDetails;
    }
    else if ((0, container_definitions_1.isFluidPackage)(codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package)) {
        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package.name;
    }
    else {
        containerPackageName = codeDetails === null || codeDetails === void 0 ? void 0 : codeDetails.package;
    }
    return { name: containerPackageName };
};
exports.getPackageName = getPackageName;

},{"@fluidframework/container-definitions":50}],298:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaManager = void 0;
const abort_controller_1 = __importDefault(require("abort-controller"));
const uuid_1 = require("uuid");
const common_utils_1 = require("@fluidframework/common-utils");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_definitions_1 = require("@fluidframework/driver-definitions");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const driver_utils_1 = require("@fluidframework/driver-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const deltaQueue_1 = require("./deltaQueue");
/**
 * Manages the flow of both inbound and outbound messages. This class ensures that shared objects receive delta
 * messages in order regardless of possible network conditions or timings causing out of order delivery.
 */
class DeltaManager extends common_utils_1.TypedEventEmitter {
    constructor(serviceProvider, logger, _active, createConnectionManager) {
        super();
        this.serviceProvider = serviceProvider;
        this.logger = logger;
        this._active = _active;
        this.pending = [];
        // The minimum sequence number and last sequence number received from the server
        this.minSequenceNumber = 0;
        // There are three numbers we track
        // * lastQueuedSequenceNumber is the last queued sequence number. If there are gaps in seq numbers, then this number
        //   is not updated until we cover that gap, so it increases each time by 1.
        // * lastObservedSeqNumber is  an estimation of last known sequence number for container in storage. It's initially
        //   populated at web socket connection time (if storage provides that info) and is  updated once ops shows up.
        //   It's never less than lastQueuedSequenceNumber
        // * lastProcessedSequenceNumber - last processed sequence number
        this.lastQueuedSequenceNumber = 0;
        this.lastObservedSeqNumber = 0;
        this.lastProcessedSequenceNumber = 0;
        this.baseTerm = 0;
        /**
         * Track down the ops size.
        */
        this.opsSize = 0;
        // The sequence number we initially loaded from
        this.initSequenceNumber = 0;
        this.closed = false;
        this.throttlingIdSet = new Set();
        this.timeTillThrottling = 0;
        this.closeAbortController = new abort_controller_1.default();
        this.deltaStorageDelayId = (0, uuid_1.v4)();
        this.deltaStreamDelayId = (0, uuid_1.v4)();
        this.messageBuffer = [];
        const props = {
            incomingOpHandler: (messages, reason) => {
                try {
                    this.enqueueMessages(messages, reason);
                }
                catch (error) {
                    this.logger.sendErrorEvent({ eventName: "EnqueueMessages_Exception" }, error);
                    this.close((0, telemetry_utils_1.normalizeError)(error));
                }
            },
            signalHandler: (message) => this._inboundSignal.push(message),
            reconnectionDelayHandler: (delayMs, error) => this.emitDelayInfo(this.deltaStreamDelayId, delayMs, error),
            closeHandler: (error) => this.close(error),
            disconnectHandler: (reason) => this.disconnectHandler(reason),
            connectHandler: (connection) => this.connectHandler(connection),
            pongHandler: (latency) => this.emit("pong", latency),
            readonlyChangeHandler: (readonly) => (0, telemetry_utils_1.safeRaiseEvent)(this, this.logger, "readonly", readonly),
        };
        this.connectionManager = createConnectionManager(props);
        this._inbound = new deltaQueue_1.DeltaQueue((op) => {
            this.processInboundMessage(op);
        });
        this._inbound.on("error", (error) => {
            this.close(container_utils_1.DataProcessingError.wrapIfUnrecognized(error, "deltaManagerInboundErrorHandler", this.lastMessage));
        });
        // Inbound signal queue
        this._inboundSignal = new deltaQueue_1.DeltaQueue((message) => {
            if (this.handler === undefined) {
                throw new Error("Attempted to process an inbound signal without a handler attached");
            }
            this.handler.processSignal({
                clientId: message.clientId,
                content: JSON.parse(message.content),
            });
        });
        this._inboundSignal.on("error", (error) => {
            this.close((0, telemetry_utils_1.normalizeError)(error));
        });
        // Initially, all queues are created paused.
        // - outbound is flipped back and forth in setupNewSuccessfulConnection / disconnectFromDeltaStream
        // - inbound & inboundSignal are resumed in attachOpHandler() when we have handler setup
    }
    get active() { return this._active(); }
    get disposed() { return this.closed; }
    get IDeltaSender() { return this; }
    get inbound() {
        return this._inbound;
    }
    get inboundSignal() {
        return this._inboundSignal;
    }
    get initialSequenceNumber() {
        return this.initSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.lastProcessedSequenceNumber;
    }
    get lastMessage() {
        return this.lastProcessedMessage;
    }
    get lastKnownSeqNumber() {
        return this.lastObservedSeqNumber;
    }
    get referenceTerm() {
        return this.baseTerm;
    }
    get minimumSequenceNumber() {
        return this.minSequenceNumber;
    }
    /**
     * Tells if  current connection has checkpoint information.
     * I.e. we know how far behind the client was at the time of establishing connection
     */
    get hasCheckpointSequenceNumber() {
        // Valid to be called only if we have active connection.
        (0, common_utils_1.assert)(this.connectionManager.connected, 0x0df /* "Missing active connection" */);
        return this._checkpointSequenceNumber !== undefined;
    }
    // Forwarding connection manager properties / IDeltaManager implementation
    get maxMessageSize() { return this.connectionManager.maxMessageSize; }
    get version() { return this.connectionManager.version; }
    get serviceConfiguration() { return this.connectionManager.serviceConfiguration; }
    get outbound() { return this.connectionManager.outbound; }
    get readOnlyInfo() { return this.connectionManager.readOnlyInfo; }
    get clientDetails() { return this.connectionManager.clientDetails; }
    submit(type, contents, batch = false, metadata) {
        const messagePartial = {
            contents: JSON.stringify(contents),
            metadata,
            referenceSequenceNumber: this.lastProcessedSequenceNumber,
            type,
        };
        if (!batch) {
            this.flush();
        }
        const message = this.connectionManager.prepareMessageToSend(messagePartial);
        if (message === undefined) {
            return -1;
        }
        this.opsSize += message.contents.length;
        this.messageBuffer.push(message);
        this.emit("submitOp", message);
        if (!batch) {
            this.flush();
        }
        return message.clientSequenceNumber;
    }
    submitSignal(content) { return this.connectionManager.submitSignal(content); }
    flush() {
        if (this.messageBuffer.length === 0) {
            return;
        }
        // The prepareFlush event allows listeners to append metadata to the batch prior to submission.
        this.emit("prepareSend", this.messageBuffer);
        this.connectionManager.sendMessages(this.messageBuffer);
        this.messageBuffer = [];
    }
    get connectionProps() {
        return Object.assign({ sequenceNumber: this.lastSequenceNumber, opsSize: this.opsSize > 0 ? this.opsSize : undefined }, this.connectionManager.connectionProps);
    }
    /**
     * Log error event with a bunch of internal to DeltaManager information about state of op processing
     * Used to diagnose connectivity issues related to op processing (i.e. cases where for some reason
     * we stop processing ops that results in no processing join op and thus moving to connected state)
     * @param event - Event to log.
     */
    logConnectionIssue(event) {
        var _a;
        (0, common_utils_1.assert)(this.connectionManager.connected, 0x238 /* "called only in connected state" */);
        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        this.logger.sendErrorEvent(Object.assign(Object.assign(Object.assign(Object.assign({}, event), { 
            // This directly tells us if fetching ops is in flight, and thus likely the reason of
            // stalled op processing
            fetchReason: this.fetchReason, 
            // A bunch of useful sequence numbers to understand if we are holding some ops from processing
            lastQueuedSequenceNumber: this.lastQueuedSequenceNumber, lastProcessedSequenceNumber: this.lastProcessedSequenceNumber, lastObserved: this.lastObservedSeqNumber }), this.connectionManager.connectionVerboseProps), { pendingOps: this.pending.length, pendingFirst: (_a = pendingSorted[0]) === null || _a === void 0 ? void 0 : _a.sequenceNumber, haveHandler: this.handler !== undefined, inboundLength: this.inbound.length, inboundPaused: this.inbound.paused }));
    }
    connectHandler(connection) {
        this.refreshDelayInfo(this.deltaStreamDelayId);
        const props = this.connectionManager.connectionVerboseProps;
        props.connectionLastQueuedSequenceNumber = this.lastQueuedSequenceNumber;
        props.connectionLastObservedSeqNumber = this.lastObservedSeqNumber;
        const checkpointSequenceNumber = connection.checkpointSequenceNumber;
        this._checkpointSequenceNumber = checkpointSequenceNumber;
        if (checkpointSequenceNumber !== undefined) {
            this.updateLatestKnownOpSeqNumber(checkpointSequenceNumber);
        }
        // We cancel all ops on lost of connectivity, and rely on DDSes to resubmit them.
        // Semantics are not well defined for batches (and they are broken right now on disconnects anyway),
        // but it's safe to assume (until better design is put into place) that batches should not exist
        // across multiple connections. Right now we assume runtime will not submit any ops in disconnected
        // state. As requirements change, so should these checks.
        (0, common_utils_1.assert)(this.messageBuffer.length === 0, 0x0e9 /* "messageBuffer is not empty on new connection" */);
        this.opsSize = 0;
        this.emit("connect", connection, checkpointSequenceNumber !== undefined ?
            this.lastObservedSeqNumber - this.lastSequenceNumber : undefined);
        // If we got some initial ops, then we know the gap and call above fetched ops to fill it.
        // Same is true for "write" mode even if we have no ops - we will get "join" own op very very soon.
        // However if we are connecting as view-only, then there is no good signal to realize if client is behind.
        // Thus we have to hit storage to see if any ops are there.
        if (checkpointSequenceNumber !== undefined) {
            // We know how far we are behind (roughly). If it's non-zero gap, fetch ops right away.
            if (checkpointSequenceNumber > this.lastQueuedSequenceNumber) {
                this.fetchMissingDeltas("AfterConnection");
            }
            // we do not know the gap, and we will not learn about it if socket is quite - have to ask.
        }
        else if (connection.mode === "read") {
            this.fetchMissingDeltas("AfterReadConnection");
        }
    }
    dispose() {
        throw new Error("Not implemented.");
    }
    /**
     * Sets the sequence number from which inbound messages should be returned
     */
    async attachOpHandler(minSequenceNumber, sequenceNumber, term, handler, prefetchType = "none") {
        this.initSequenceNumber = sequenceNumber;
        this.lastProcessedSequenceNumber = sequenceNumber;
        this.baseTerm = term;
        this.minSequenceNumber = minSequenceNumber;
        this.lastQueuedSequenceNumber = sequenceNumber;
        this.lastObservedSeqNumber = sequenceNumber;
        // We will use same check in other places to make sure all the seq number above are set properly.
        (0, common_utils_1.assert)(this.handler === undefined, 0x0e2 /* "DeltaManager already has attached op handler!" */);
        this.handler = handler;
        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
        (0, common_utils_1.assert)(!!this.handler, 0x0e3 /* "Newly set op handler is null/undefined!" */);
        // There should be no pending fetch!
        // This API is called right after attachOpHandler by Container.load().
        // We might have connection already and it might have called fetchMissingDeltas() from
        // setupNewSuccessfulConnection. But it should do nothing, because there is no way to fetch ops before
        // we know snapshot sequence number that is set in attachOpHandler. So all such calls should be noop.
        (0, common_utils_1.assert)(this.fetchReason === undefined, 0x268 /* "There can't be pending fetch that early in boot sequence!" */);
        if (this.closed) {
            return;
        }
        this._inbound.resume();
        this._inboundSignal.resume();
        if (prefetchType !== "none") {
            const cacheOnly = prefetchType === "cached";
            await this.fetchMissingDeltasCore(`DocumentOpen_${prefetchType}`, cacheOnly);
            // Keep going with fetching ops from storage once we have all cached ops in.
            // But do not block load and make this request async / not blocking this api.
            // Ops processing will start once cached ops are in and and will stop when queue is empty
            // (which in most cases will happen when we are done processing cached ops)
            if (cacheOnly) {
                // fire and forget
                this.fetchMissingDeltas("PostDocumentOpen");
            }
        }
        // Ensure there is no need to call this.processPendingOps() at the end of boot sequence
        (0, common_utils_1.assert)(this.fetchReason !== undefined || this.pending.length === 0, 0x269 /* "pending ops are not dropped" */);
    }
    connect(args) {
        var _a;
        const fetchOpsFromStorage = (_a = args.fetchOpsFromStorage) !== null && _a !== void 0 ? _a : true;
        (0, telemetry_utils_1.logIfFalse)(this.handler !== undefined || !fetchOpsFromStorage, this.logger, "CantFetchWithoutBaseline"); // can't fetch if no baseline
        // Note: There is race condition here.
        // We want to issue request to storage as soon as possible, to
        // reduce latency of becoming current, thus this code here.
        // But there is no ordering between fetching OPs and connection to delta stream
        // As result, we might be behind by the time we connect to delta stream
        // In case of r/w connection, that's not an issue, because we will hear our
        // own "join" message and realize any gap client has in ops.
        // But for view-only connection, we have no such signal, and with no traffic
        // on the wire, we might be always behind.
        // See comment at the end of "connect" handler
        if (fetchOpsFromStorage) {
            this.fetchMissingDeltas(args.reason);
        }
        this.connectionManager.connect(args.mode);
    }
    async getDeltas(from, // inclusive
    to, // exclusive
    fetchReason, callback, cacheOnly) {
        const docService = this.serviceProvider();
        if (docService === undefined) {
            throw new Error("Delta manager is not attached");
        }
        if (this.deltaStorage === undefined) {
            this.deltaStorage = await docService.connectToDeltaStorage();
        }
        let cancelFetch;
        if (to !== undefined) {
            const lastExpectedOp = to - 1; // make it inclusive!
            // It is possible that due to asynchrony (including await above), required ops were already
            // received through delta stream. Validate that before moving forward.
            if (this.lastQueuedSequenceNumber >= lastExpectedOp) {
                this.logger.sendPerformanceEvent(Object.assign({ reason: fetchReason, eventName: "ExtraStorageCall", early: true, from,
                    to }, this.connectionManager.connectionVerboseProps));
                return;
            }
            // Be prepared for the case where webSocket would receive the ops that we are trying to fill through
            // storage. Ideally it should never happen (i.e. ops on socket are always ordered, and thus once we
            // detected gap, this gap can't be filled in later on through websocket).
            // And in practice that does look like the case. The place where this code gets hit is if we lost
            // connection and reconnected (likely to another box), and new socket's initial ops contains these ops.
            cancelFetch = (op) => op.sequenceNumber >= lastExpectedOp;
        }
        else {
            // Unbound requests are made to proactively fetch ops, but also get up to date in cases where socket
            // is silent (and connection is "read", thus we might not have any data on how far client is behind).
            // Once we have any op coming in from socket, we can cancel it as it's not needed any more.
            // That said, if we have socket connection, make sure we got ops up to checkpointSequenceNumber!
            cancelFetch = (op) => op.sequenceNumber >= this.lastObservedSeqNumber;
        }
        const controller = new abort_controller_1.default();
        let opsFromFetch = false;
        const opListener = (op) => {
            (0, common_utils_1.assert)(op.sequenceNumber === this.lastQueuedSequenceNumber, 0x23a /* "seq#'s" */);
            // Ops that are coming from this request should not cancel itself.
            // This is useless for known ranges (to is defined) as it means request is over either way.
            // And it will cancel unbound request too early, not allowing us to learn where the end of the file is.
            if (!opsFromFetch && cancelFetch(op)) {
                controller.abort();
                this._inbound.off("push", opListener);
            }
        };
        try {
            this._inbound.on("push", opListener);
            (0, common_utils_1.assert)(this.closeAbortController.signal.onabort === null, 0x1e8 /* "reentrancy" */);
            this.closeAbortController.signal.onabort = () => controller.abort();
            const stream = this.deltaStorage.fetchMessages(from, // inclusive
            to, // exclusive
            controller.signal, cacheOnly, fetchReason);
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const result = await stream.read();
                if (result.done) {
                    break;
                }
                try {
                    opsFromFetch = true;
                    callback(result.value);
                }
                finally {
                    opsFromFetch = false;
                }
            }
        }
        finally {
            this.closeAbortController.signal.onabort = null;
            this._inbound.off("push", opListener);
            (0, common_utils_1.assert)(!opsFromFetch, 0x289 /* "logic error" */);
        }
    }
    /**
     * Closes the connection and clears inbound & outbound queues.
     */
    close(error) {
        if (this.closed) {
            return;
        }
        this.closed = true;
        this.connectionManager.dispose(error);
        this.closeAbortController.abort();
        this._inbound.clear();
        this._inboundSignal.clear();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inbound.pause();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this._inboundSignal.pause();
        // Drop pending messages - this will ensure catchUp() does not go into infinite loop
        this.pending = [];
        // This needs to be the last thing we do (before removing listeners), as it causes
        // Container to dispose context and break ability of data stores / runtime to "hear"
        // from delta manager, including notification (above) about readonly state.
        this.emit("closed", error);
        this.removeAllListeners();
    }
    refreshDelayInfo(id) {
        this.throttlingIdSet.delete(id);
        if (this.throttlingIdSet.size === 0) {
            this.timeTillThrottling = 0;
        }
    }
    disconnectHandler(reason) {
        this.messageBuffer.length = 0;
        this.emit("disconnect", reason);
    }
    /**
     * Emit info about a delay in service communication on account of throttling.
     * @param id - Id of the connection that is delayed
     * @param delayMs - Duration of the delay
     * @param error - error object indicating the throttling
     */
    emitDelayInfo(id, delayMs, error) {
        const timeNow = Date.now();
        this.throttlingIdSet.add(id);
        if (delayMs > 0 && (timeNow + delayMs > this.timeTillThrottling)) {
            this.timeTillThrottling = timeNow + delayMs;
            const throttlingWarning = container_utils_1.ThrottlingWarning.wrap(error, delayMs / 1000 /* retryAfterSeconds */, this.logger);
            this.emit("throttled", throttlingWarning);
        }
    }
    // returns parts of message (in string format) that should never change for a given message.
    // Used for message comparison. It attempts to avoid comparing fields that potentially may differ.
    // for example, it's not clear if serverMetadata or timestamp property is a property of message or server state.
    // We only extract the most obvious fields that are sufficient (with high probability) to detect sequence number
    // reuse.
    // Also payload goes to telemetry, so no PII, including content!!
    // Note: It's possible for a duplicate op to be broadcasted and have everything the same except the timestamp.
    comparableMessagePayload(m) {
        return `${m.clientId}-${m.type}-${m.minimumSequenceNumber}-${m.referenceSequenceNumber}-${m.timestamp}`;
    }
    enqueueMessages(messages, reason, allowGaps = false) {
        var _a, _b;
        if (this.handler === undefined) {
            // We did not setup handler yet.
            // This happens when we connect to web socket faster than we get attributes for container
            // and thus faster than attachOpHandler() is called
            // this.lastProcessedSequenceNumber is still zero, so we can't rely on this.fetchMissingDeltas()
            // to do the right thing.
            this.pending = this.pending.concat(messages);
            return;
        }
        // Pending ops should never just hang around for nothing.
        // This invariant will stay true through this function execution,
        // so there is no need to process pending ops here.
        // It's responsibility of
        // - attachOpHandler()
        // - fetchMissingDeltas() after it's done with querying storage
        (0, common_utils_1.assert)(this.pending.length === 0 || this.fetchReason !== undefined, 0x1e9 /* "Pending ops" */);
        if (messages.length === 0) {
            return;
        }
        const from = messages[0].sequenceNumber;
        const last = messages[messages.length - 1].sequenceNumber;
        // Report stats about missing and duplicate ops
        // This helps better understand why we fetch ops from storage, and thus may delay
        // getting current / sending ops
        // It's possible that this batch is already too late - do not bother
        if (last > this.lastQueuedSequenceNumber) {
            let prev = from - 1;
            const initialGap = prev - this.lastQueuedSequenceNumber;
            let firstMissing;
            let duplicate = 0;
            let gap = 0;
            // Count all gaps and duplicates
            for (const message of messages) {
                if (message.sequenceNumber === prev) {
                    duplicate++;
                }
                else if (message.sequenceNumber !== prev + 1) {
                    gap++;
                    if (firstMissing === undefined) {
                        firstMissing = prev + 1;
                    }
                }
                prev = message.sequenceNumber;
            }
            let eventName;
            // Report if we found some issues
            if (duplicate !== 0 || gap !== 0 && !allowGaps || initialGap > 0 && this.fetchReason === undefined) {
                eventName = "enqueueMessages";
                // Also report if we are fetching ops, and same range comes in, thus making this fetch obsolete.
            }
            else if (this.fetchReason !== undefined && this.fetchReason !== reason &&
                (from <= this.lastQueuedSequenceNumber + 1 && last > this.lastQueuedSequenceNumber)) {
                eventName = "enqueueMessagesExtraFetch";
            }
            // Report if there is something to report
            // Do not report when pending fetch is in progress, as such reporting will not
            // correctly take into account pending ops.
            if (eventName !== undefined) {
                this.logger.sendPerformanceEvent(Object.assign({ eventName,
                    reason, previousReason: this.prevEnqueueMessagesReason, from, to: last + 1, length: messages.length, fetchReason: this.fetchReason, duplicate: duplicate > 0 ? duplicate : undefined, initialGap: initialGap !== 0 ? initialGap : undefined, gap: gap > 0 ? gap : undefined, firstMissing, dmInitialSeqNumber: this.initialSequenceNumber }, this.connectionManager.connectionVerboseProps));
            }
        }
        this.updateLatestKnownOpSeqNumber(messages[messages.length - 1].sequenceNumber);
        const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
        (0, common_utils_1.assert)(n === undefined || n === this.lastQueuedSequenceNumber, 0x0ec /* "Unexpected value for previously processed message's sequence number" */);
        for (const message of messages) {
            // Check that the messages are arriving in the expected order
            if (message.sequenceNumber <= this.lastQueuedSequenceNumber) {
                // Validate that we do not have data loss, i.e. sequencing is reset and started again
                // with numbers that this client already observed before.
                if (((_b = this.previouslyProcessedMessage) === null || _b === void 0 ? void 0 : _b.sequenceNumber) === message.sequenceNumber) {
                    const message1 = this.comparableMessagePayload(this.previouslyProcessedMessage);
                    const message2 = this.comparableMessagePayload(message);
                    if (message1 !== message2) {
                        const error = new driver_utils_1.NonRetryableError(
                        // This looks like a data corruption but the culprit was that the file was overwritten
                        // in storage.  See PR #5882.
                        // Likely to be an issue with Fluid Services. Content does not match previous client
                        // knowledge about this file. If the file is overwritten for any reason, this error can be
                        // hit. One example is that some clients could be submitting ops to two different service
                        // instances such that the same sequence number is reused for two different ops.
                        // pre-0.58 error message: twoMessagesWithSameSeqNumAndDifferentPayload
                        "Found two messages with the same sequenceNumber but different payloads. Likely to be a "
                            + "service issue", driver_definitions_1.DriverErrorType.fileOverwrittenInStorage, {
                            clientId: this.connectionManager.clientId,
                            sequenceNumber: message.sequenceNumber,
                            message1,
                            message2,
                            driverVersion: undefined,
                        });
                        this.close(error);
                    }
                }
            }
            else if (message.sequenceNumber !== this.lastQueuedSequenceNumber + 1) {
                this.pending.push(message);
                this.fetchMissingDeltas(reason, message.sequenceNumber);
            }
            else {
                this.lastQueuedSequenceNumber = message.sequenceNumber;
                this.previouslyProcessedMessage = message;
                this._inbound.push(message);
            }
        }
        // When / if we report a gap in ops in the future, we want telemetry to correctly reflect source
        // of prior ops. But if we have some out of order ops (this.pending), then reporting current reason
        // becomes not accurate, as the gap existed before current batch, so we should just report "unknown".
        this.prevEnqueueMessagesReason = this.pending.length > 0 ? "unknown" : reason;
    }
    processInboundMessage(message) {
        const startTime = Date.now();
        this.lastProcessedMessage = message;
        // All non-system messages are coming from some client, and should have clientId
        // System messages may have no clientId (but some do, like propose, noop, summarize)
        (0, common_utils_1.assert)(message.clientId !== undefined
            || !((0, driver_utils_1.isClientMessage)(message)), 0x0ed /* "non-system message have to have clientId" */);
        // TODO Remove after SPO picks up the latest build.
        if (typeof message.contents === "string"
            && message.contents !== ""
            && message.type !== protocol_definitions_1.MessageType.ClientLeave) {
            message.contents = JSON.parse(message.contents);
        }
        this.connectionManager.beforeProcessingIncomingOp(message);
        // Watch the minimum sequence number and be ready to update as needed
        if (this.minSequenceNumber > message.minimumSequenceNumber) {
            // pre-0.58 error message: msnMovesBackwards
            throw new container_utils_1.DataCorruptionError("Found a lower minimumSequenceNumber (msn) than previously recorded", Object.assign(Object.assign({}, (0, container_utils_1.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));
        }
        this.minSequenceNumber = message.minimumSequenceNumber;
        if (message.sequenceNumber !== this.lastProcessedSequenceNumber + 1) {
            // pre-0.58 error message: nonSequentialSequenceNumber
            throw new container_utils_1.DataCorruptionError("Found a non-Sequential sequenceNumber", Object.assign(Object.assign({}, (0, container_utils_1.extractSafePropertiesFromMessage)(message)), { clientId: this.connectionManager.clientId }));
        }
        this.lastProcessedSequenceNumber = message.sequenceNumber;
        // a bunch of code assumes that this is true
        (0, common_utils_1.assert)(this.lastProcessedSequenceNumber <= this.lastObservedSeqNumber, 0x267 /* "lastObservedSeqNumber should be updated first" */);
        // Back-compat for older server with no term
        if (message.term === undefined) {
            message.term = 1;
        }
        this.baseTerm = message.term;
        if (this.handler === undefined) {
            throw new Error("Attempted to process an inbound message without a handler attached");
        }
        this.handler.process(message);
        const endTime = Date.now();
        // Should be last, after changing this.lastProcessedSequenceNumber above, as many callers
        // test this.lastProcessedSequenceNumber instead of using op.sequenceNumber itself.
        this.emit("op", message, endTime - startTime);
    }
    /**
     * Retrieves the missing deltas between the given sequence numbers
     */
    fetchMissingDeltas(reasonArg, to) {
        this.fetchMissingDeltasCore(reasonArg, false /* cacheOnly */, to).catch((error) => {
            this.logger.sendErrorEvent({ eventName: "fetchMissingDeltasException" }, error);
        });
    }
    /**
    * Retrieves the missing deltas between the given sequence numbers
    */
    async fetchMissingDeltasCore(reason, cacheOnly, to) {
        var _a;
        // Exit out early if we're already fetching deltas
        if (this.fetchReason !== undefined) {
            return;
        }
        if (this.closed) {
            this.logger.sendTelemetryEvent({ eventName: "fetchMissingDeltasClosedConnection", reason });
            return;
        }
        if (this.handler === undefined) {
            // We do not poses yet any information
            (0, common_utils_1.assert)(this.lastQueuedSequenceNumber === 0, 0x26b /* "initial state" */);
            return;
        }
        try {
            let from = this.lastQueuedSequenceNumber + 1;
            const n = (_a = this.previouslyProcessedMessage) === null || _a === void 0 ? void 0 : _a.sequenceNumber;
            if (n !== undefined) {
                // If we already processed at least one op, then we have this.previouslyProcessedMessage populated
                // and can use it to validate that we are operating on same file, i.e. it was not overwritten.
                // Knowing about this mechanism, we could ask for op we already observed to increase validation.
                // This is especially useful when coming out of offline mode or loading from
                // very old cached (by client / driver) snapshot.
                (0, common_utils_1.assert)(n === this.lastQueuedSequenceNumber, 0x0f2 /* "previouslyProcessedMessage" */);
                (0, common_utils_1.assert)(from > 1, 0x0f3 /* "not positive" */);
                from--;
            }
            const fetchReason = `${reason}_fetch`;
            this.fetchReason = fetchReason;
            await this.getDeltas(from, to, fetchReason, (messages) => {
                this.refreshDelayInfo(this.deltaStorageDelayId);
                this.enqueueMessages(messages, fetchReason);
            }, cacheOnly);
        }
        catch (error) {
            this.logger.sendErrorEvent({ eventName: "GetDeltas_Exception" }, error);
            this.close((0, telemetry_utils_1.normalizeError)(error));
        }
        finally {
            this.refreshDelayInfo(this.deltaStorageDelayId);
            this.fetchReason = undefined;
            this.processPendingOps(reason);
        }
    }
    /**
     * Sorts pending ops and attempts to apply them
     */
    processPendingOps(reason) {
        if (this.closed) {
            return;
        }
        (0, common_utils_1.assert)(this.handler !== undefined, 0x26c /* "handler should be installed" */);
        const pendingSorted = this.pending.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
        this.pending = [];
        // Given that we do not track where these ops came from any more, it's not very
        // actionably to report gaps in this range.
        this.enqueueMessages(pendingSorted, `${reason}_pending`, true /* allowGaps */);
        // Re-entrancy is ignored by fetchMissingDeltas, execution will come here when it's over
        if (this.fetchReason === undefined) {
            // See issue #7312 for more details
            // We observe cases where client gets into situation where it is not aware of missing ops
            // (i.e. client being behind), and as such, does not attempt to fetch them.
            // In some cases client may not have enough signal (example - "read" connection that is silent -
            // there is no easy way for client to realize it's behind, see a bit of commentary / logic at the
            // end of setupNewSuccessfulConnection). In other cases it should be able to learn that info ("write"
            // connection, learn by receiving its own join op), but data suggest it does not happen.
            // In 50% of these cases we do know we are behind through checkpointSequenceNumber on connection object
            // and thus can leverage that to trigger recovery. But this is not going to solve all the problems
            // (the other 50%), and thus these errors below should be looked at even if code below results in
            // recovery.
            if (this.lastQueuedSequenceNumber < this.lastObservedSeqNumber) {
                this.fetchMissingDeltas("OpsBehind");
            }
        }
    }
    updateLatestKnownOpSeqNumber(seq) {
        if (this.lastObservedSeqNumber < seq) {
            this.lastObservedSeqNumber = seq;
        }
    }
}
exports.DeltaManager = DeltaManager;

},{"./deltaQueue":300,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"abort-controller":312,"uuid":544}],299:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaManagerProxy = exports.DeltaQueueProxy = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Proxy to the real IDeltaQueue - used to restrict access
 */
class DeltaQueueProxy extends common_utils_1.EventForwarder {
    constructor(queue) {
        super(queue);
        this.queue = queue;
    }
    get paused() {
        return this.queue.paused;
    }
    get length() {
        return this.queue.length;
    }
    get idle() {
        return this.queue.idle;
    }
    peek() {
        return this.queue.peek();
    }
    toArray() {
        return this.queue.toArray();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemPause() {
        return this.pause();
    }
    async pause() {
        return this.queue.pause();
    }
    // back-compat: usage removed in 0.33, remove in future versions
    async systemResume() {
        return this.resume();
    }
    async resume() {
        this.queue.resume();
    }
    async waitTillProcessingDone() {
        return this.queue.waitTillProcessingDone();
    }
}
exports.DeltaQueueProxy = DeltaQueueProxy;
/**
 * Proxy to the real IDeltaManager - used to restrict access
 */
class DeltaManagerProxy extends common_utils_1.EventForwarder {
    constructor(deltaManager) {
        super(deltaManager);
        this.deltaManager = deltaManager;
        this.inbound = new DeltaQueueProxy(deltaManager.inbound);
        this.outbound = new DeltaQueueProxy(deltaManager.outbound);
        this.inboundSignal = new DeltaQueueProxy(deltaManager.inboundSignal);
    }
    get IDeltaSender() {
        return this;
    }
    get minimumSequenceNumber() {
        return this.deltaManager.minimumSequenceNumber;
    }
    get lastSequenceNumber() {
        return this.deltaManager.lastSequenceNumber;
    }
    get lastMessage() {
        return this.deltaManager.lastMessage;
    }
    get lastKnownSeqNumber() {
        return this.deltaManager.lastKnownSeqNumber;
    }
    get initialSequenceNumber() {
        return this.deltaManager.initialSequenceNumber;
    }
    get hasCheckpointSequenceNumber() {
        return this.deltaManager.hasCheckpointSequenceNumber;
    }
    get clientDetails() {
        return this.deltaManager.clientDetails;
    }
    get version() {
        return this.deltaManager.version;
    }
    get maxMessageSize() {
        return this.deltaManager.maxMessageSize;
    }
    get serviceConfiguration() {
        return this.deltaManager.serviceConfiguration;
    }
    get active() {
        return this.deltaManager.active;
    }
    get readOnlyInfo() {
        return this.deltaManager.readOnlyInfo;
    }
    dispose() {
        this.inbound.dispose();
        this.outbound.dispose();
        this.inboundSignal.dispose();
        super.dispose();
    }
    submitSignal(content) {
        return this.deltaManager.submitSignal(content);
    }
    flush() {
        return this.deltaManager.flush();
    }
}
exports.DeltaManagerProxy = DeltaManagerProxy;

},{"@fluidframework/common-utils":29}],300:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeltaQueue = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const double_ended_queue_1 = __importDefault(require("double-ended-queue"));
class DeltaQueue extends common_utils_1.TypedEventEmitter {
    /**
     * @param worker - A callback to process a delta.
     * @param logger - For logging telemetry.
     */
    constructor(worker) {
        super();
        this.worker = worker;
        this.isDisposed = false;
        this.q = new double_ended_queue_1.default();
        /**
         * Tracks the number of pause requests for the queue
         * The DeltaQueue is create initially paused.
         */
        this.pauseCount = 1;
    }
    get disposed() {
        return this.isDisposed;
    }
    /**
     * @returns True if the queue is paused, false if not.
     */
    get paused() {
        return this.pauseCount !== 0;
    }
    get length() {
        return this.q.length;
    }
    get idle() {
        return this.processingPromise === undefined && this.q.length === 0;
    }
    async waitTillProcessingDone() {
        var _a;
        return (_a = this.processingPromise) !== null && _a !== void 0 ? _a : { count: 0, duration: 0 };
    }
    dispose() {
        throw new Error("Not implemented.");
        this.isDisposed = true;
    }
    clear() {
        this.q.clear();
    }
    peek() {
        return this.q.peekFront();
    }
    toArray() {
        return this.q.toArray();
    }
    push(task) {
        try {
            this.q.push(task);
            this.emit("push", task);
            this.ensureProcessing();
        }
        catch (error) {
            this.emit("error", error);
        }
    }
    async pause() {
        this.pauseCount++;
        // If called from within the processing loop, we are in the middle of processing an op. Return a promise
        // that will resolve when processing has actually stopped.
        await this.waitTillProcessingDone();
    }
    resume() {
        (0, common_utils_1.assert)(this.pauseCount > 0, 0x0f4 /* "Nonzero pause-count on resume()" */);
        this.pauseCount--;
        this.ensureProcessing();
    }
    /**
     * There are several actions that may need to kick off delta processing, so we want to guard against
     * accidental reentrancy. ensureProcessing can be called safely to start the processing loop if it is
     * not already started.
     */
    ensureProcessing() {
        if (this.anythingToProcess() && this.processingPromise === undefined) {
            // Use a resolved promise to start the processing on a separate stack.
            this.processingPromise = Promise.resolve().then(() => {
                (0, common_utils_1.assert)(this.processingPromise !== undefined, "reentrancy?");
                const result = this.processDeltas();
                (0, common_utils_1.assert)(this.processingPromise !== undefined, "reentrancy?");
                // WARNING: Do not move next line to .finally() clause!
                // It runs async and creates a race condition where incoming ensureProcessing() call observes
                // from previous run while previous run is over (but finally clause was not scheduled yet)
                this.processingPromise = undefined;
                return result;
            }).catch((error) => {
                this.error = error;
                this.processingPromise = undefined;
                this.emit("error", error);
                return { count: 0, duration: 0 };
            });
            (0, common_utils_1.assert)(this.processingPromise !== undefined, "processDeltas() should run async");
        }
    }
    anythingToProcess() {
        return this.q.length !== 0 && !this.paused && this.error === undefined;
    }
    /**
     * Executes the delta processing loop until a stop condition is reached.
     */
    processDeltas() {
        const start = common_utils_1.performance.now();
        let count = 0;
        // For grouping to work we must process all local messages immediately and in the single turn.
        // So loop over them until no messages to process, we have become paused, or hit an error.
        while (this.anythingToProcess()) {
            // Get the next message in the queue
            const next = this.q.shift();
            count++;
            // Process the message.
            // We know next is defined since we did a length check just prior to shifting.
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.worker(next);
            this.emit("op", next);
        }
        const duration = common_utils_1.performance.now() - start;
        if (this.q.length === 0) {
            this.emit("idle", count, duration);
        }
        return { count, duration };
    }
}
exports.DeltaQueue = DeltaQueue;

},{"@fluidframework/common-utils":29,"double-ended-queue":348}],301:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelativeLoader = exports.Loader = exports.waitContainerToCatchUp = exports.Container = exports.ConnectionState = void 0;
var connectionState_1 = require("./connectionState");
Object.defineProperty(exports, "ConnectionState", { enumerable: true, get: function () { return connectionState_1.ConnectionState; } });
var container_1 = require("./container");
Object.defineProperty(exports, "Container", { enumerable: true, get: function () { return container_1.Container; } });
Object.defineProperty(exports, "waitContainerToCatchUp", { enumerable: true, get: function () { return container_1.waitContainerToCatchUp; } });
var loader_1 = require("./loader");
Object.defineProperty(exports, "Loader", { enumerable: true, get: function () { return loader_1.Loader; } });
Object.defineProperty(exports, "RelativeLoader", { enumerable: true, get: function () { return loader_1.RelativeLoader; } });

},{"./connectionState":292,"./container":294,"./loader":302}],302:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = exports.RelativeLoader = void 0;
const uuid_1 = require("uuid");
const container_definitions_1 = require("@fluidframework/container-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
const container_1 = require("./container");
const utils_1 = require("./utils");
const packageVersion_1 = require("./packageVersion");
function canUseCache(request) {
    if (request.headers === undefined) {
        return true;
    }
    return request.headers[container_definitions_1.LoaderHeader.cache] !== false;
}
class RelativeLoader {
    constructor(container, loader) {
        this.container = container;
        this.loader = loader;
    }
    get IFluidRouter() { return this; }
    async resolve(request) {
        var _a, _b, _c, _d, _e;
        if (request.url.startsWith("/")) {
            if (canUseCache(request)) {
                return this.container;
            }
            else {
                const resolvedUrl = this.container.resolvedUrl;
                (0, driver_utils_1.ensureFluidResolvedUrl)(resolvedUrl);
                const container = await container_1.Container.load(this.loader, {
                    canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[container_definitions_1.LoaderHeader.reconnect],
                    clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[container_definitions_1.LoaderHeader.clientDetails],
                    resolvedUrl: Object.assign({}, resolvedUrl),
                    version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[container_definitions_1.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,
                    loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[container_definitions_1.LoaderHeader.loadMode],
                });
                return container;
            }
        }
        if (this.loader === undefined) {
            throw new Error("Cannot resolve external containers");
        }
        return this.loader.resolve(request);
    }
    async request(request) {
        if (request.url.startsWith("/")) {
            const container = await this.resolve(request);
            return container.request(request);
        }
        if (this.loader === undefined) {
            return {
                status: 404,
                value: "Cannot request external containers",
                mimeType: "plain/text",
            };
        }
        return this.loader.request(request);
    }
}
exports.RelativeLoader = RelativeLoader;
function createCachedResolver(resolver) {
    const cacheResolver = Object.create(resolver);
    const resolveCache = new Map();
    cacheResolver.resolve = async (request) => {
        if (!canUseCache(request)) {
            return resolver.resolve(request);
        }
        if (!resolveCache.has(request.url)) {
            resolveCache.set(request.url, resolver.resolve(request));
        }
        return resolveCache.get(request.url);
    };
    return cacheResolver;
}
/**
 * Manages Fluid resource loading
 */
class Loader {
    constructor(loaderProps) {
        var _a, _b;
        this.containers = new Map();
        const scope = Object.assign({}, loaderProps.scope);
        if (((_a = loaderProps.options) === null || _a === void 0 ? void 0 : _a.provideScopeLoader) !== false) {
            scope.ILoader = this;
        }
        const telemetryProps = {
            loaderId: (0, uuid_1.v4)(),
            loaderVersion: packageVersion_1.pkgVersion,
        };
        const subMc = (0, telemetry_utils_1.mixinMonitoringContext)(telemetry_utils_1.DebugLogger.mixinDebugLogger("fluid:telemetry", loaderProps.logger, { all: telemetryProps }), telemetry_utils_1.sessionStorageConfigProvider.value, loaderProps.configProvider);
        this.services = {
            urlResolver: createCachedResolver(driver_utils_1.MultiUrlResolver.create(loaderProps.urlResolver)),
            documentServiceFactory: driver_utils_1.MultiDocumentServiceFactory.create(loaderProps.documentServiceFactory),
            codeLoader: loaderProps.codeLoader,
            options: (_b = loaderProps.options) !== null && _b !== void 0 ? _b : {},
            scope,
            subLogger: subMc.logger,
            detachedBlobStorage: loaderProps.detachedBlobStorage,
        };
        this.mc = (0, telemetry_utils_1.loggerToMonitoringContext)(telemetry_utils_1.ChildLogger.create(this.services.subLogger, "Loader"));
    }
    get IFluidRouter() { return this; }
    async createDetachedContainer(codeDetails) {
        const container = await container_1.Container.createDetached(this, codeDetails);
        if (this.cachingEnabled) {
            container.once("attached", () => {
                (0, driver_utils_1.ensureFluidResolvedUrl)(container.resolvedUrl);
                const parsedUrl = (0, utils_1.parseUrl)(container.resolvedUrl.url);
                if (parsedUrl !== undefined) {
                    this.addToContainerCache(parsedUrl.id, Promise.resolve(container));
                }
            });
        }
        return container;
    }
    async rehydrateDetachedContainerFromSnapshot(snapshot) {
        return container_1.Container.rehydrateDetachedFromSnapshot(this, snapshot);
    }
    async resolve(request, pendingLocalState) {
        const eventName = pendingLocalState === undefined ? "Resolve" : "ResolveWithPendingState";
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName }, async () => {
            const resolved = await this.resolveCore(request, pendingLocalState !== undefined ? JSON.parse(pendingLocalState) : undefined);
            return resolved.container;
        });
    }
    async request(request) {
        return telemetry_utils_1.PerformanceEvent.timedExecAsync(this.mc.logger, { eventName: "Request" }, async () => {
            const resolved = await this.resolveCore(request);
            return resolved.container.request(Object.assign(Object.assign({}, request), { url: `${resolved.parsed.path}${resolved.parsed.query}` }));
        });
    }
    getKeyForContainerCache(request, parsedUrl) {
        var _a;
        const key = ((_a = request.headers) === null || _a === void 0 ? void 0 : _a[container_definitions_1.LoaderHeader.version]) !== undefined
            ? `${parsedUrl.id}@${request.headers[container_definitions_1.LoaderHeader.version]}`
            : parsedUrl.id;
        return key;
    }
    addToContainerCache(key, containerP) {
        this.containers.set(key, containerP);
        containerP.then((container) => {
            // If the container is closed or becomes closed after we resolve it, remove it from the cache.
            if (container.closed) {
                this.containers.delete(key);
            }
            else {
                container.once("closed", () => {
                    this.containers.delete(key);
                });
            }
        }).catch((error) => { });
    }
    async resolveCore(request, pendingLocalState) {
        const resolvedAsFluid = await this.services.urlResolver.resolve(request);
        (0, driver_utils_1.ensureFluidResolvedUrl)(resolvedAsFluid);
        // Parse URL into data stores
        const parsed = (0, utils_1.parseUrl)(resolvedAsFluid.url);
        if (parsed === undefined) {
            throw new Error(`Invalid URL ${resolvedAsFluid.url}`);
        }
        if (pendingLocalState !== undefined) {
            const parsedPendingUrl = (0, utils_1.parseUrl)(pendingLocalState.url);
            if ((parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.id) !== parsed.id ||
                (parsedPendingUrl === null || parsedPendingUrl === void 0 ? void 0 : parsedPendingUrl.path.replace(/\/$/, "")) !== parsed.path.replace(/\/$/, "")) {
                const message = `URL ${resolvedAsFluid.url} does not match pending state URL ${pendingLocalState.url}`;
                throw new Error(message);
            }
        }
        const { canCache, fromSequenceNumber } = this.parseHeader(parsed, request);
        const shouldCache = pendingLocalState !== undefined ? false : canCache;
        let container;
        if (shouldCache) {
            const key = this.getKeyForContainerCache(request, parsed);
            const maybeContainer = await this.containers.get(key);
            if (maybeContainer !== undefined) {
                container = maybeContainer;
            }
            else {
                const containerP = this.loadContainer(request, resolvedAsFluid);
                this.addToContainerCache(key, containerP);
                container = await containerP;
            }
        }
        else {
            container =
                await this.loadContainer(request, resolvedAsFluid, pendingLocalState);
        }
        if (container.deltaManager.lastSequenceNumber <= fromSequenceNumber) {
            await new Promise((resolve, reject) => {
                function opHandler(message) {
                    if (message.sequenceNumber > fromSequenceNumber) {
                        resolve();
                        container.removeListener("op", opHandler);
                    }
                }
                container.on("op", opHandler);
            });
        }
        return { container, parsed };
    }
    get cachingEnabled() {
        return this.services.options.cache !== false;
    }
    canCacheForRequest(headers) {
        return this.cachingEnabled && headers[container_definitions_1.LoaderHeader.cache] !== false;
    }
    parseHeader(parsed, request) {
        var _a, _b;
        let fromSequenceNumber = -1;
        request.headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
        const headerSeqNum = request.headers[container_definitions_1.LoaderHeader.sequenceNumber];
        if (headerSeqNum !== undefined) {
            fromSequenceNumber = headerSeqNum;
        }
        // If set in both query string and headers, use query string
        request.headers[container_definitions_1.LoaderHeader.version] = (_b = parsed.version) !== null && _b !== void 0 ? _b : request.headers[container_definitions_1.LoaderHeader.version];
        const canCache = this.canCacheForRequest(request.headers);
        return {
            canCache,
            fromSequenceNumber,
        };
    }
    async loadContainer(request, resolved, pendingLocalState) {
        var _a, _b, _c, _d, _e;
        return container_1.Container.load(this, {
            canReconnect: (_a = request.headers) === null || _a === void 0 ? void 0 : _a[container_definitions_1.LoaderHeader.reconnect],
            clientDetailsOverride: (_b = request.headers) === null || _b === void 0 ? void 0 : _b[container_definitions_1.LoaderHeader.clientDetails],
            resolvedUrl: resolved,
            version: (_d = (_c = request.headers) === null || _c === void 0 ? void 0 : _c[container_definitions_1.LoaderHeader.version]) !== null && _d !== void 0 ? _d : undefined,
            loadMode: (_e = request.headers) === null || _e === void 0 ? void 0 : _e[container_definitions_1.LoaderHeader.loadMode],
        }, pendingLocalState);
    }
}
exports.Loader = Loader;

},{"./container":294,"./packageVersion":303,"./utils":307,"@fluidframework/container-definitions":50,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279,"uuid":544}],303:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 *
 * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.pkgVersion = exports.pkgName = void 0;
exports.pkgName = "@fluidframework/container-loader";
exports.pkgVersion = "1.3.6";

},{}],304:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtocolTreeStorageService = void 0;
const driver_utils_1 = require("@fluidframework/driver-utils");
class ProtocolTreeStorageService {
    constructor(internalStorageService, generateProtocolTree) {
        this.internalStorageService = internalStorageService;
        this.generateProtocolTree = generateProtocolTree;
        this.getSnapshotTree = this.internalStorageService.getSnapshotTree.bind(this.internalStorageService);
        this.getVersions = this.internalStorageService.getVersions.bind(this.internalStorageService);
        this.createBlob = this.internalStorageService.createBlob.bind(this.internalStorageService);
        this.readBlob = this.internalStorageService.readBlob.bind(this.internalStorageService);
        this.downloadSummary = this.internalStorageService.downloadSummary.bind(this.internalStorageService);
        this.dispose = this.internalStorageService.dispose.bind(this.internalStorageService);
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    get disposed() {
        return this.internalStorageService.disposed;
    }
    async uploadSummaryWithContext(summary, context) {
        return this.internalStorageService.uploadSummaryWithContext((0, driver_utils_1.combineAppAndProtocolSummary)(summary, this.generateProtocolTree()), context);
    }
}
exports.ProtocolTreeStorageService = ProtocolTreeStorageService;

},{"@fluidframework/driver-utils":110}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initQuorumValuesFromCodeDetails = exports.getCodeDetailsFromQuorumValues = exports.QuorumProxy = void 0;
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
const common_utils_1 = require("@fluidframework/common-utils");
/**
 * Proxies Quorum events.
 */
class QuorumProxy extends common_utils_1.EventForwarder {
    constructor(quorum) {
        super(quorum);
        // This is heavily used object, increase limit at which Node prints warnings.
        super.setMaxListeners(50);
        this.propose = (0, common_utils_1.doIfNotDisposed)(this, quorum.propose.bind(quorum));
        this.has = (0, common_utils_1.doIfNotDisposed)(this, quorum.has.bind(quorum));
        this.get = (0, common_utils_1.doIfNotDisposed)(this, quorum.get.bind(quorum));
        this.getMembers = (0, common_utils_1.doIfNotDisposed)(this, quorum.getMembers.bind(quorum));
        this.getMember = (0, common_utils_1.doIfNotDisposed)(this, quorum.getMember.bind(quorum));
    }
}
exports.QuorumProxy = QuorumProxy;
function getCodeDetailsFromQuorumValues(quorumValues) {
    const qValuesMap = new Map(quorumValues);
    const proposal = qValuesMap.get("code");
    (0, common_utils_1.assert)(proposal !== undefined, 0x2dc /* "Cannot find code proposal" */);
    return proposal === null || proposal === void 0 ? void 0 : proposal.value;
}
exports.getCodeDetailsFromQuorumValues = getCodeDetailsFromQuorumValues;
function initQuorumValuesFromCodeDetails(source) {
    // Seed the base quorum to be an empty list with a code quorum set
    const committedCodeProposal = {
        key: "code",
        value: source,
        approvalSequenceNumber: 0,
        commitSequenceNumber: 0,
        sequenceNumber: 0,
    };
    return [["code", committedCodeProposal]];
}
exports.initQuorumValuesFromCodeDetails = initQuorumValuesFromCodeDetails;

},{"@fluidframework/common-utils":29}],306:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetriableDocumentStorageService = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const container_utils_1 = require("@fluidframework/container-utils");
const driver_utils_1 = require("@fluidframework/driver-utils");
class RetriableDocumentStorageService {
    constructor(internalStorageService, logger) {
        this.internalStorageService = internalStorageService;
        this.logger = logger;
        this._disposed = false;
    }
    get policies() {
        return this.internalStorageService.policies;
    }
    get disposed() { return this._disposed; }
    dispose() {
        this._disposed = true;
    }
    get repositoryUrl() {
        return this.internalStorageService.repositoryUrl;
    }
    async getSnapshotTree(version, scenarioName) {
        return this.runWithRetry(async () => this.internalStorageService.getSnapshotTree(version, scenarioName), "storage_getSnapshotTree");
    }
    async readBlob(id) {
        return this.runWithRetry(async () => this.internalStorageService.readBlob(id), "storage_readBlob");
    }
    async getVersions(versionId, count, scenarioName) {
        return this.runWithRetry(async () => this.internalStorageService.getVersions(versionId, count, scenarioName), "storage_getVersions");
    }
    async uploadSummaryWithContext(summary, context) {
        // Not using retry loop here. Couple reasons:
        // 1. If client lost connectivity, then retry loop will result in uploading stale summary
        //    by stale summarizer after connectivity comes back. It will cause failures for this client and for
        //    real (new) summarizer. This problem in particular should be solved in future by supplying abort handle
        //    on all APIs and caller (ContainerRuntime.submitSummary) aborting call on loss of connectivity
        // 2. Similar, if we get 429 with retryAfter = 10 minutes, it's likely not the right call to retry summary
        //    upload in 10 minutes - it's better to keep processing ops and retry later. Though caller needs to take
        //    retryAfter into account!
        // But retry loop is required for creation flow (Container.attach)
        (0, common_utils_1.assert)((context.referenceSequenceNumber === 0) === (context.ackHandle === undefined), 0x251 /* "creation summary has to have seq=0 && handle === undefined" */);
        if (context.referenceSequenceNumber !== 0) {
            return this.internalStorageService.uploadSummaryWithContext(summary, context);
        }
        // Creation flow with attachment blobs - need to do retries!
        return this.runWithRetry(async () => this.internalStorageService.uploadSummaryWithContext(summary, context), "storage_uploadSummaryWithContext");
    }
    async downloadSummary(handle) {
        return this.runWithRetry(async () => this.internalStorageService.downloadSummary(handle), "storage_downloadSummary");
    }
    async createBlob(file) {
        return this.runWithRetry(async () => this.internalStorageService.createBlob(file), "storage_createBlob");
    }
    checkStorageDisposed() {
        if (this._disposed) {
            // pre-0.58 error message: storageServiceDisposedCannotRetry
            throw new container_utils_1.GenericError("Storage Service is disposed. Cannot retry", { canRetry: false });
        }
        return undefined;
    }
    async runWithRetry(api, callName) {
        return (0, driver_utils_1.runWithRetry)(api, callName, this.logger, {
            onRetry: () => this.checkStorageDisposed(),
        });
    }
}
exports.RetriableDocumentStorageService = RetriableDocumentStorageService;

},{"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110}],307:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProtocolSnapshotTree = exports.getSnapshotTreeFromSerializedContainer = exports.convertProtocolAndAppSummaryToSnapshotTree = exports.parseUrl = void 0;
const url_1 = require("url");
const uuid_1 = require("uuid");
const common_utils_1 = require("@fluidframework/common-utils");
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const telemetry_utils_1 = require("@fluidframework/telemetry-utils");
function parseUrl(url) {
    var _a;
    const parsed = (0, url_1.parse)(url, true);
    if (typeof parsed.pathname !== "string") {
        throw new telemetry_utils_1.LoggingError("Failed to parse pathname");
    }
    const query = (_a = parsed.search) !== null && _a !== void 0 ? _a : "";
    const regex = /^\/([^/]*\/[^/]*)(\/?.*)$/;
    const match = regex.exec(parsed.pathname);
    return ((match === null || match === void 0 ? void 0 : match.length) === 3)
        ? { id: match[1], path: match[2], query, version: parsed.query.version }
        : undefined;
}
exports.parseUrl = parseUrl;
/**
 * Converts summary tree (for upload) to snapshot tree (for download).
 * Summary tree blobs contain contents, but snapshot tree blobs normally
 * contain IDs pointing to storage. This will create 2 blob entries in the
 * snapshot tree for each blob in the summary tree. One will be the regular
 * path pointing to a uniquely generated ID. Then there will be another
 * entry with the path as that uniquely generated ID, and value as the
 * blob contents as a base-64 string.
 * @param summary - summary to convert
 */
function convertSummaryToSnapshotWithEmbeddedBlobContents(summary) {
    const treeNode = {
        blobs: {},
        blobsContents: {},
        trees: {},
        id: (0, uuid_1.v4)(),
        unreferenced: summary.unreferenced,
    };
    const keys = Object.keys(summary.tree);
    for (const key of keys) {
        const summaryObject = summary.tree[key];
        switch (summaryObject.type) {
            case protocol_definitions_1.SummaryType.Tree: {
                treeNode.trees[key] = convertSummaryToSnapshotWithEmbeddedBlobContents(summaryObject);
                break;
            }
            case protocol_definitions_1.SummaryType.Attachment:
                treeNode.blobs[key] = summaryObject.id;
                break;
            case protocol_definitions_1.SummaryType.Blob: {
                const blobId = (0, uuid_1.v4)();
                treeNode.blobs[key] = blobId;
                const contentBuffer = typeof summaryObject.content === "string" ?
                    (0, common_utils_1.stringToBuffer)(summaryObject.content, "utf8") : (0, common_utils_1.Uint8ArrayToArrayBuffer)(summaryObject.content);
                treeNode.blobsContents[blobId] = contentBuffer;
                break;
            }
            case protocol_definitions_1.SummaryType.Handle:
                throw new telemetry_utils_1.LoggingError("No handles should be there in summary in detached container!!");
                break;
            default: {
                (0, common_utils_1.unreachableCase)(summaryObject, `Unknown tree type ${summaryObject.type}`);
            }
        }
    }
    return treeNode;
}
/**
 * Combine and convert protocol and app summary tree to format which is readable by container while rehydrating.
 * @param protocolSummaryTree - Protocol Summary Tree
 * @param appSummaryTree - App Summary Tree
 */
function convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree) {
    // Shallow copy is fine, since we are doing a deep clone below.
    const combinedSummary = {
        type: protocol_definitions_1.SummaryType.Tree,
        tree: Object.assign({}, appSummaryTree.tree),
    };
    combinedSummary.tree[".protocol"] = protocolSummaryTree;
    const snapshotTreeWithBlobContents = convertSummaryToSnapshotWithEmbeddedBlobContents(combinedSummary);
    return snapshotTreeWithBlobContents;
}
exports.convertProtocolAndAppSummaryToSnapshotTree = convertProtocolAndAppSummaryToSnapshotTree;
// This function converts the snapshot taken in detached container(by serialize api) to snapshotTree with which
// a detached container can be rehydrated.
const getSnapshotTreeFromSerializedContainer = (detachedContainerSnapshot) => {
    const protocolSummaryTree = detachedContainerSnapshot.tree[".protocol"];
    const appSummaryTree = detachedContainerSnapshot.tree[".app"];
    (0, common_utils_1.assert)(protocolSummaryTree !== undefined && appSummaryTree !== undefined, 0x1e0 /* "Protocol and App summary trees should be present" */);
    const snapshotTreeWithBlobContents = convertProtocolAndAppSummaryToSnapshotTree(protocolSummaryTree, appSummaryTree);
    return snapshotTreeWithBlobContents;
};
exports.getSnapshotTreeFromSerializedContainer = getSnapshotTreeFromSerializedContainer;
function getProtocolSnapshotTree(snapshot) {
    return ".protocol" in snapshot.trees ? snapshot.trees[".protocol"] : snapshot;
}
exports.getProtocolSnapshotTree = getProtocolSnapshotTree;

},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"url":569,"uuid":544}],308:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./insecureTinyliciousUrlResolver"), exports);
__exportStar(require("./insecureTinyliciousTokenProvider"), exports);

},{"./insecureTinyliciousTokenProvider":309,"./insecureTinyliciousUrlResolver":310}],309:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsecureTinyliciousTokenProvider = void 0;
const protocol_definitions_1 = require("@fluidframework/protocol-definitions");
const server_services_client_1 = require("@fluidframework/server-services-client");
const jsrsasign_1 = require("jsrsasign");
const uuid_1 = require("uuid");
/**
 * As the name implies this is not secure and should not be used in production. It simply makes the example easier
 * to get up and running.
 */
class InsecureTinyliciousTokenProvider {
    async fetchOrdererToken(tenantId, documentId) {
        return {
            fromCache: true,
            jwt: this.getSignedToken(tenantId, documentId),
        };
    }
    async fetchStorageToken(tenantId, documentId) {
        return {
            fromCache: true,
            jwt: this.getSignedToken(tenantId, documentId),
        };
    }
    getSignedToken(tenantId, documentId, lifetime = 60 * 60, ver = "1.0") {
        // Current time in seconds
        const now = Math.round((new Date()).getTime() / 1000);
        const user = { id: (0, uuid_1.v4)(), name: (0, server_services_client_1.getRandomName)() };
        const claims = {
            documentId: documentId !== null && documentId !== void 0 ? documentId : "",
            scopes: [protocol_definitions_1.ScopeType.DocRead, protocol_definitions_1.ScopeType.DocWrite, protocol_definitions_1.ScopeType.SummaryWrite],
            tenantId,
            user,
            iat: now,
            exp: now + lifetime,
            ver,
        };
        const utf8Key = { utf8: "12345" };
        return jsrsasign_1.KJUR.jws.JWS.sign(null, JSON.stringify({ alg: "HS256", typ: "JWT" }), claims, utf8Key);
    }
}
exports.InsecureTinyliciousTokenProvider = InsecureTinyliciousTokenProvider;

},{"@fluidframework/protocol-definitions":174,"@fluidframework/server-services-client":245,"jsrsasign":396,"uuid":544}],310:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTinyliciousCreateNewRequest = exports.InsecureTinyliciousUrlResolver = exports.defaultTinyliciousEndpoint = exports.defaultTinyliciousPort = void 0;
const driver_definitions_1 = require("@fluidframework/driver-definitions");
/**
 * Default endpoint port. Will be used by the service if the consumer does not specify a port.
 */
exports.defaultTinyliciousPort = 7070;
/**
 * Default endpoint URL base. Will be used by the service if the consumer does not specify an endpoint.
 */
exports.defaultTinyliciousEndpoint = "http://localhost";
/**
 * InsecureTinyliciousUrlResolver knows how to get the URLs to the service (in this case Tinylicious) to use
 * for a given request.  This particular implementation has a goal to avoid imposing requirements on the app's
 * URL shape, so it expects the request url to have this format (as opposed to a more traditional URL):
 * documentId/containerRelativePathing
 */
class InsecureTinyliciousUrlResolver {
    constructor(port = exports.defaultTinyliciousPort, endpoint = exports.defaultTinyliciousEndpoint) {
        this.tinyliciousEndpoint = `${endpoint}:${port}`;
        this.fluidProtocolEndpoint = this.tinyliciousEndpoint.replace(/(^\w+:|^)\/\//, "fluid://");
    }
    async resolve(request) {
        var _a;
        // determine whether the request is for creating of a new container.
        // such request has the `createNew` header set to true and doesn't have a container ID.
        if (request.headers && request.headers[driver_definitions_1.DriverHeader.createNew] === true) {
            // honor the document ID passed by the application via the create request
            // otherwise use the reserved keyword to let the driver generate the ID.
            // TODO: deprecate this capability for tinylicious as the r11s driver will stop using the document ID
            // in create requests.
            const newDocumentId = (_a = request.url) !== null && _a !== void 0 ? _a : "new";
            return {
                endpoints: {
                    deltaStorageUrl: `${this.tinyliciousEndpoint}/deltas/tinylicious/${newDocumentId}`,
                    ordererUrl: this.tinyliciousEndpoint,
                    storageUrl: `${this.tinyliciousEndpoint}/repos/tinylicious`,
                },
                // id is a mandatory attribute, but it's ignored by the driver for new container requests.
                id: request.url,
                // tokens attribute is redundant as all tokens are generated via ITokenProvider
                tokens: {},
                type: "fluid",
                url: `${this.fluidProtocolEndpoint}/tinylicious/${newDocumentId}`,
            };
        }
        // for an existing container we'll parse the request URL to determine the document ID.
        const url = request.url.replace(`${this.tinyliciousEndpoint}/`, "");
        const documentId = url.split("/")[0];
        const encodedDocId = encodeURIComponent(documentId);
        const documentRelativePath = url.slice(documentId.length);
        const documentUrl = `${this.fluidProtocolEndpoint}/tinylicious/${encodedDocId}${documentRelativePath}`;
        const deltaStorageUrl = `${this.tinyliciousEndpoint}/deltas/tinylicious/${encodedDocId}`;
        const storageUrl = `${this.tinyliciousEndpoint}/repos/tinylicious`;
        const response = {
            endpoints: {
                deltaStorageUrl,
                ordererUrl: this.tinyliciousEndpoint,
                storageUrl,
            },
            id: documentId,
            tokens: {},
            type: "fluid",
            url: documentUrl,
        };
        return response;
    }
    async getAbsoluteUrl(resolvedUrl, relativeUrl) {
        const documentId = decodeURIComponent(resolvedUrl.url.replace(`${this.fluidProtocolEndpoint}/tinylicious/`, ""));
        /*
         * The detached container flow will ultimately call getAbsoluteUrl() with the resolved.url produced by
         * resolve().  The container expects getAbsoluteUrl's return value to be a URL that can then be roundtripped
         * back through resolve() again, and get the same result again.  So we'll return a "URL" with the same format
         * described above.
         */
        return `${documentId}/${relativeUrl}`;
    }
}
exports.InsecureTinyliciousUrlResolver = InsecureTinyliciousUrlResolver;
const createTinyliciousCreateNewRequest = (documentId) => ({
    url: documentId !== null && documentId !== void 0 ? documentId : "",
    headers: {
        [driver_definitions_1.DriverHeader.createNew]: true,
    },
});
exports.createTinyliciousCreateNewRequest = createTinyliciousCreateNewRequest;

},{"@fluidframework/driver-definitions":100}],311:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

exports.Emitter = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

// alias used for reserved events (protected method)
Emitter.prototype.emitReserved = Emitter.prototype.emit;

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],312:[function(require,module,exports){
/*globals self, window */
"use strict"

/*eslint-disable @mysticatea/prettier */
const { AbortController, AbortSignal } =
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    /* otherwise */ undefined
/*eslint-enable @mysticatea/prettier */

module.exports = AbortController
module.exports.AbortSignal = AbortSignal
module.exports.default = AbortController

},{}],313:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":315}],314:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');
var transitionalDefaults = require('../defaults/transitional');
var Cancel = require('../cancel/Cancel');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../cancel/Cancel":316,"../core/buildFullPath":321,"../core/createError":322,"../defaults/transitional":329,"./../core/settle":326,"./../helpers/buildURL":332,"./../helpers/cookies":334,"./../helpers/isURLSameOrigin":337,"./../helpers/parseHeaders":339,"./../utils":342}],315:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":316,"./cancel/CancelToken":317,"./cancel/isCancel":318,"./core/Axios":319,"./core/mergeConfig":325,"./defaults":328,"./env/data":330,"./helpers/bind":331,"./helpers/isAxiosError":336,"./helpers/spread":340,"./utils":342}],316:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],317:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":316}],318:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],319:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":332,"../helpers/validator":341,"./../utils":342,"./InterceptorManager":320,"./dispatchRequest":323,"./mergeConfig":325}],320:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":342}],321:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":333,"../helpers/isAbsoluteURL":335}],322:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":324}],323:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var Cancel = require('../cancel/Cancel');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/Cancel":316,"../cancel/isCancel":318,"../defaults":328,"./../utils":342,"./transformData":327}],324:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};

},{}],325:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

},{"../utils":342}],326:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":322}],327:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"../defaults":328,"./../utils":342}],328:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('../utils');
var normalizeHeaderName = require('../helpers/normalizeHeaderName');
var enhanceError = require('../core/enhanceError');
var transitionalDefaults = require('./transitional');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('../adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('../adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))
},{"../adapters/http":314,"../adapters/xhr":314,"../core/enhanceError":324,"../helpers/normalizeHeaderName":338,"../utils":342,"./transitional":329,"_process":564}],329:[function(require,module,exports){
'use strict';

module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],330:[function(require,module,exports){
module.exports = {
  "version": "0.26.1"
};
},{}],331:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],332:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":342}],333:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],334:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":342}],335:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],336:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

},{"./../utils":342}],337:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":342}],338:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":342}],339:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":342}],340:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],341:[function(require,module,exports){
'use strict';

var VERSION = require('../env/data').version;

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../env/data":330}],342:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return toString.call(val) === '[object FormData]';
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return toString.call(val) === '[object URLSearchParams]';
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":331}],343:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],344:[function(require,module,exports){
/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if('object' === typeof exports) {
			factory(exports);
		} else if ('function' === typeof define && define.amd) {
			define(function () {
				var module = {};
				factory(module);
				return module;
			});
		} else {
			factory(CRC32 = {});
		}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.0';
/* see perf/crc32table.js */
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T = signed_crc_table();
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1, L = bstr.length - 1;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
	}
	if(i === L) C = (C>>>8) ^ T[(C ^ bstr.charCodeAt(i))&0xFF];
	return C ^ -1;
}

function crc32_buf(buf, seed) {
	if(buf.length > 10000) return crc32_buf_8(buf, seed);
	var C = seed ^ -1, L = buf.length - 3;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+3) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_buf_8(buf, seed) {
	var C = seed ^ -1, L = buf.length - 7;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+7) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L=str.length, c, d; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T[(C ^ c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return C ^ -1;
}
CRC32.table = T;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));

},{}],345:[function(require,module,exports){
var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports

},{}],346:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":347,"_process":564}],347:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":525}],348:[function(require,module,exports){
/**
 * Copyright (c) 2013 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
"use strict";
function Deque(capacity) {
    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    if (isArray(capacity)) {
        var len = capacity.length;
        for (var i = 0; i < len; ++i) {
            this[i] = capacity[i];
        }
        this._length = len;
    }
}

Deque.prototype.toArray = function Deque$toArray() {
    var len = this._length;
    var ret = new Array(len);
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        ret[j] = this[(front + j) & (capacity - 1)];
    }
    return ret;
};

Deque.prototype.push = function Deque$push(item) {
    var argsLength = arguments.length;
    var length = this._length;
    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = (this._front + length) & (this._capacity - 1);
                this[j] = arguments[i];
                length++;
                this._length = length;
            }
            return length;
        }
        else {
            var j = this._front;
            for (var i = 0; i < argsLength; ++i) {
                this[(j + length) & (capacity - 1)] = arguments[i];
                j++;
            }
            this._length = length + argsLength;
            return length + argsLength;
        }

    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = item;
    this._length = length + 1;
    return length + 1;
};

Deque.prototype.pop = function Deque$pop() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var i = (this._front + length - 1) & (this._capacity - 1);
    var ret = this[i];
    this[i] = void 0;
    this._length = length - 1;
    return ret;
};

Deque.prototype.shift = function Deque$shift() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var front = this._front;
    var ret = this[front];
    this[front] = void 0;
    this._front = (front + 1) & (this._capacity - 1);
    this._length = length - 1;
    return ret;
};

Deque.prototype.unshift = function Deque$unshift(item) {
    var length = this._length;
    var argsLength = arguments.length;


    if (argsLength > 1) {
        var capacity = this._capacity;
        if (length + argsLength > capacity) {
            for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (((( this._front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
            }
            return length;
        }
        else {
            var front = this._front;
            for (var i = argsLength - 1; i >= 0; i--) {
                var j = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
                this[j] = arguments[i];
                front = j;
            }
            this._front = front;
            this._length = length + argsLength;
            return length + argsLength;
        }
    }

    if (argsLength === 0) return length;

    this._checkCapacity(length + 1);
    var capacity = this._capacity;
    var i = (((( this._front - 1 ) &
        ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = item;
    this._length = length + 1;
    this._front = i;
    return length + 1;
};

Deque.prototype.peekBack = function Deque$peekBack() {
    var length = this._length;
    if (length === 0) {
        return void 0;
    }
    var index = (this._front + length - 1) & (this._capacity - 1);
    return this[index];
};

Deque.prototype.peekFront = function Deque$peekFront() {
    if (this._length === 0) {
        return void 0;
    }
    return this[this._front];
};

Deque.prototype.get = function Deque$get(index) {
    var i = index;
    if ((i !== (i | 0))) {
        return void 0;
    }
    var len = this._length;
    if (i < 0) {
        i = i + len;
    }
    if (i < 0 || i >= len) {
        return void 0;
    }
    return this[(this._front + i) & (this._capacity - 1)];
};

Deque.prototype.isEmpty = function Deque$isEmpty() {
    return this._length === 0;
};

Deque.prototype.clear = function Deque$clear() {
    var len = this._length;
    var front = this._front;
    var capacity = this._capacity;
    for (var j = 0; j < len; ++j) {
        this[(front + j) & (capacity - 1)] = void 0;
    }
    this._length = 0;
    this._front = 0;
};

Deque.prototype.toString = function Deque$toString() {
    return this.toArray().toString();
};

Deque.prototype.valueOf = Deque.prototype.toString;
Deque.prototype.removeFront = Deque.prototype.shift;
Deque.prototype.removeBack = Deque.prototype.pop;
Deque.prototype.insertFront = Deque.prototype.unshift;
Deque.prototype.insertBack = Deque.prototype.push;
Deque.prototype.enqueue = Deque.prototype.push;
Deque.prototype.dequeue = Deque.prototype.shift;
Deque.prototype.toJSON = Deque.prototype.toArray;

Object.defineProperty(Deque.prototype, "length", {
    get: function() {
        return this._length;
    },
    set: function() {
        throw new RangeError("");
    }
});

Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
    if (this._capacity < size) {
        this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
    }
};

Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    if (front + length > oldCapacity) {
        var moveItemsCount = (front + length) & (oldCapacity - 1);
        arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    }
};


var isArray = Array.isArray;

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function pow2AtLeast(n) {
    n = n >>> 0;
    n = n - 1;
    n = n | (n >> 1);
    n = n | (n >> 2);
    n = n | (n >> 4);
    n = n | (n >> 8);
    n = n | (n >> 16);
    return n + 1;
}

function getCapacity(capacity) {
    if (typeof capacity !== "number") {
        if (isArray(capacity)) {
            capacity = capacity.length;
        }
        else {
            return 16;
        }
    }
    return pow2AtLeast(
        Math.min(
            Math.max(16, capacity), 1073741824)
    );
}

module.exports = Deque;

},{}],349:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasCORS = void 0;
// imported from https://github.com/component/has-cors
let value = false;
try {
    value = typeof XMLHttpRequest !== 'undefined' &&
        'withCredentials' in new XMLHttpRequest();
}
catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
}
exports.hasCORS = value;

},{}],350:[function(require,module,exports){
"use strict";
// imported from https://github.com/galkn/querystring
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
function encode(obj) {
    let str = '';
    for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
            if (str.length)
                str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
    }
    return str;
}
exports.encode = encode;
/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */
function decode(qs) {
    let qry = {};
    let pairs = qs.split('&');
    for (let i = 0, l = pairs.length; i < l; i++) {
        let pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
}
exports.decode = decode;

},{}],351:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = void 0;
// imported from https://github.com/galkn/parseuri
/**
 * Parses a URI
 *
 * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.
 *
 * See:
 * - https://developer.mozilla.org/en-US/docs/Web/API/URL
 * - https://caniuse.com/url
 * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B
 *
 * History of the parse() method:
 * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c
 * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3
 * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];
function parse(str) {
    const src = str, b = str.indexOf('['), e = str.indexOf(']');
    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }
    let m = re.exec(str || ''), uri = {}, i = 14;
    while (i--) {
        uri[parts[i]] = m[i] || '';
    }
    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri['path']);
    uri.queryKey = queryKey(uri, uri['query']);
    return uri;
}
exports.parse = parse;
function pathNames(obj, path) {
    const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.slice(0, 1) == '/' || path.length === 0) {
        names.splice(0, 1);
    }
    if (path.slice(-1) == '/') {
        names.splice(names.length - 1, 1);
    }
    return names;
}
function queryKey(uri, query) {
    const data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
        if ($1) {
            data[$1] = $2;
        }
    });
    return data;
}

},{}],352:[function(require,module,exports){
// imported from https://github.com/unshiftio/yeast
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.yeast = exports.decode = exports.encode = void 0;
const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};
let seed = 0, i = 0, prev;
/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
    let encoded = '';
    do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
}
exports.encode = encode;
/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
    let decoded = 0;
    for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
    }
    return decoded;
}
exports.decode = decode;
/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
    const now = encode(+new Date());
    if (now !== prev)
        return seed = 0, prev = now;
    return now + '.' + encode(seed++);
}
exports.yeast = yeast;
//
// Map each character to its index.
//
for (; i < length; i++)
    map[alphabet[i]] = i;

},{}],353:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.globalThisShim = void 0;
exports.globalThisShim = (() => {
    if (typeof self !== "undefined") {
        return self;
    }
    else if (typeof window !== "undefined") {
        return window;
    }
    else {
        return Function("return this")();
    }
})();

},{}],354:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextTick = exports.parse = exports.installTimerFunctions = exports.transports = exports.Transport = exports.protocol = exports.Socket = void 0;
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
exports.protocol = socket_js_1.Socket.protocol;
var transport_js_1 = require("./transport.js");
Object.defineProperty(exports, "Transport", { enumerable: true, get: function () { return transport_js_1.Transport; } });
var index_js_1 = require("./transports/index.js");
Object.defineProperty(exports, "transports", { enumerable: true, get: function () { return index_js_1.transports; } });
var util_js_1 = require("./util.js");
Object.defineProperty(exports, "installTimerFunctions", { enumerable: true, get: function () { return util_js_1.installTimerFunctions; } });
var parseuri_js_1 = require("./contrib/parseuri.js");
Object.defineProperty(exports, "parse", { enumerable: true, get: function () { return parseuri_js_1.parse; } });
var websocket_constructor_js_1 = require("./transports/websocket-constructor.js");
Object.defineProperty(exports, "nextTick", { enumerable: true, get: function () { return websocket_constructor_js_1.nextTick; } });

},{"./contrib/parseuri.js":351,"./socket.js":355,"./transport.js":356,"./transports/index.js":357,"./transports/websocket-constructor.js":359,"./util.js":362}],355:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const index_js_1 = require("./transports/index.js");
const util_js_1 = require("./util.js");
const parseqs_js_1 = require("./contrib/parseqs.js");
const parseuri_js_1 = require("./contrib/parseuri.js");
const debug_1 = __importDefault(require("debug")); // debug()
const component_emitter_1 = require("@socket.io/component-emitter");
const engine_io_parser_1 = require("engine.io-parser");
const debug = (0, debug_1.default)("engine.io-client:socket"); // debug()
class Socket extends component_emitter_1.Emitter {
    /**
     * Socket constructor.
     *
     * @param {String|Object} uri - uri or options
     * @param {Object} opts - options
     */
    constructor(uri, opts = {}) {
        super();
        this.writeBuffer = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = null;
        }
        if (uri) {
            uri = (0, parseuri_js_1.parse)(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
                opts.query = uri.query;
        }
        else if (opts.host) {
            opts.hostname = (0, parseuri_js_1.parse)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure =
            null != opts.secure
                ? opts.secure
                : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
            // if no port is specified manually, use the protocol default
            opts.port = this.secure ? "443" : "80";
        }
        this.hostname =
            opts.hostname ||
                (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port =
            opts.port ||
                (typeof location !== "undefined" && location.port
                    ? location.port
                    : this.secure
                        ? "443"
                        : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
                threshold: 1024,
            },
            transportOptions: {},
            closeOnBeforeunload: true,
        }, opts);
        this.opts.path =
            this.opts.path.replace(/\/$/, "") +
                (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
            this.opts.query = (0, parseqs_js_1.decode)(this.opts.query);
        }
        // set on handshake
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        // set on heartbeat
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
                // Firefox closes the connection when the "beforeunload" event is emitted but not Chrome. This event listener
                // ensures every browser behaves the same (no "disconnect" event at the Socket.IO level when the page is
                // closed/reloaded)
                this.beforeunloadEventListener = () => {
                    if (this.transport) {
                        // silently close the transport
                        this.transport.removeAllListeners();
                        this.transport.close();
                    }
                };
                addEventListener("beforeunload", this.beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
                this.offlineEventListener = () => {
                    this.onClose("transport close", {
                        description: "network connection lost",
                    });
                };
                addEventListener("offline", this.offlineEventListener, false);
            }
        }
        this.open();
    }
    /**
     * Creates transport of the given type.
     *
     * @param {String} name - transport name
     * @return {Transport}
     * @private
     */
    createTransport(name) {
        debug('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        // append engine.io protocol identifier
        query.EIO = engine_io_parser_1.protocol;
        // transport name
        query.transport = name;
        // session id if we already have one
        if (this.id)
            query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port,
        });
        debug("options: %j", opts);
        return new index_js_1.transports[name](opts);
    }
    /**
     * Initializes transport to use and starts probe.
     *
     * @private
     */
    open() {
        let transport;
        if (this.opts.rememberUpgrade &&
            Socket.priorWebsocketSuccess &&
            this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
        }
        else if (0 === this.transports.length) {
            // Emit error on next tick so it can be listened to
            this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
            }, 0);
            return;
        }
        else {
            transport = this.transports[0];
        }
        this.readyState = "opening";
        // Retry with the next transport if the transport is disabled (jsonp: false)
        try {
            transport = this.createTransport(transport);
        }
        catch (e) {
            debug("error while creating transport: %s", e);
            this.transports.shift();
            this.open();
            return;
        }
        transport.open();
        this.setTransport(transport);
    }
    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @private
     */
    setTransport(transport) {
        debug("setting transport %s", transport.name);
        if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);
            this.transport.removeAllListeners();
        }
        // set up transport
        this.transport = transport;
        // set up transport listeners
        transport
            .on("drain", this.onDrain.bind(this))
            .on("packet", this.onPacket.bind(this))
            .on("error", this.onError.bind(this))
            .on("close", (reason) => this.onClose("transport close", reason));
    }
    /**
     * Probes a transport.
     *
     * @param {String} name - transport name
     * @private
     */
    probe(name) {
        debug('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
            if (failed)
                return;
            debug('probe transport "%s" opened', name);
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
                if (failed)
                    return;
                if ("pong" === msg.type && "probe" === msg.data) {
                    debug('probe transport "%s" pong', name);
                    this.upgrading = true;
                    this.emitReserved("upgrading", transport);
                    if (!transport)
                        return;
                    Socket.priorWebsocketSuccess = "websocket" === transport.name;
                    debug('pausing current transport "%s"', this.transport.name);
                    this.transport.pause(() => {
                        if (failed)
                            return;
                        if ("closed" === this.readyState)
                            return;
                        debug("changing transport and sending upgrade packet");
                        cleanup();
                        this.setTransport(transport);
                        transport.send([{ type: "upgrade" }]);
                        this.emitReserved("upgrade", transport);
                        transport = null;
                        this.upgrading = false;
                        this.flush();
                    });
                }
                else {
                    debug('probe transport "%s" failed', name);
                    const err = new Error("probe error");
                    // @ts-ignore
                    err.transport = transport.name;
                    this.emitReserved("upgradeError", err);
                }
            });
        };
        function freezeTransport() {
            if (failed)
                return;
            // Any callback called by transport should be ignored since now
            failed = true;
            cleanup();
            transport.close();
            transport = null;
        }
        // Handle any error that happens while probing
        const onerror = (err) => {
            const error = new Error("probe error: " + err);
            // @ts-ignore
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
            onerror("transport closed");
        }
        // When the socket is closed while we're probing
        function onclose() {
            onerror("socket closed");
        }
        // When the socket is upgraded while we're probing
        function onupgrade(to) {
            if (transport && to.name !== transport.name) {
                debug('"%s" works - aborting "%s"', to.name, transport.name);
                freezeTransport();
            }
        }
        // Remove all listeners on the transport and on self
        const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.off("close", onclose);
            this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
    }
    /**
     * Called when connection is deemed open.
     *
     * @private
     */
    onOpen() {
        debug("socket open");
        this.readyState = "open";
        Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
        // we check for `readyState` in case an `open`
        // listener already closed the socket
        if ("open" === this.readyState && this.opts.upgrade) {
            debug("starting upgrade probes");
            let i = 0;
            const l = this.upgrades.length;
            for (; i < l; i++) {
                this.probe(this.upgrades[i]);
            }
        }
    }
    /**
     * Handles a packet.
     *
     * @private
     */
    onPacket(packet) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emitReserved("packet", packet);
            // Socket is live - any packet counts
            this.emitReserved("heartbeat");
            switch (packet.type) {
                case "open":
                    this.onHandshake(JSON.parse(packet.data));
                    break;
                case "ping":
                    this.resetPingTimeout();
                    this.sendPacket("pong");
                    this.emitReserved("ping");
                    this.emitReserved("pong");
                    break;
                case "error":
                    const err = new Error("server error");
                    // @ts-ignore
                    err.code = packet.data;
                    this.onError(err);
                    break;
                case "message":
                    this.emitReserved("data", packet.data);
                    this.emitReserved("message", packet.data);
                    break;
            }
        }
        else {
            debug('packet received with socket readyState "%s"', this.readyState);
        }
    }
    /**
     * Called upon handshake completion.
     *
     * @param {Object} data - handshake obj
     * @private
     */
    onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.maxPayload = data.maxPayload;
        this.onOpen();
        // In case open handler closes socket
        if ("closed" === this.readyState)
            return;
        this.resetPingTimeout();
    }
    /**
     * Sets and resets ping timeout timer based on server pings.
     *
     * @private
     */
    resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
        }
    }
    /**
     * Called on `drain` event
     *
     * @private
     */
    onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        // setting prevBufferLen = 0 is very important
        // for example, when upgrading, upgrade packet is sent over,
        // and a nonzero prevBufferLen could cause problems on `drain`
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
            this.emitReserved("drain");
        }
        else {
            this.flush();
        }
    }
    /**
     * Flush write buffers.
     *
     * @private
     */
    flush() {
        if ("closed" !== this.readyState &&
            this.transport.writable &&
            !this.upgrading &&
            this.writeBuffer.length) {
            const packets = this.getWritablePackets();
            debug("flushing %d packets in socket", packets.length);
            this.transport.send(packets);
            // keep track of current length of writeBuffer
            // splice writeBuffer and callbackBuffer on `drain`
            this.prevBufferLen = packets.length;
            this.emitReserved("flush");
        }
    }
    /**
     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
     * long-polling)
     *
     * @private
     */
    getWritablePackets() {
        const shouldCheckPayloadSize = this.maxPayload &&
            this.transport.name === "polling" &&
            this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
            return this.writeBuffer;
        }
        let payloadSize = 1; // first packet type
        for (let i = 0; i < this.writeBuffer.length; i++) {
            const data = this.writeBuffer[i].data;
            if (data) {
                payloadSize += (0, util_js_1.byteLength)(data);
            }
            if (i > 0 && payloadSize > this.maxPayload) {
                debug("only send %d out of %d packets", i, this.writeBuffer.length);
                return this.writeBuffer.slice(0, i);
            }
            payloadSize += 2; // separator + packet type
        }
        debug("payload size is %d (max: %d)", payloadSize, this.maxPayload);
        return this.writeBuffer;
    }
    /**
     * Sends a message.
     *
     * @param {String} msg - message.
     * @param {Object} options.
     * @param {Function} callback function.
     * @return {Socket} for chaining.
     */
    write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type: packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} fn - callback function.
     * @private
     */
    sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
            fn = data;
            data = undefined;
        }
        if ("function" === typeof options) {
            fn = options;
            options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
            return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
            type: type,
            data: data,
            options: options,
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
            this.once("flush", fn);
        this.flush();
    }
    /**
     * Closes the connection.
     */
    close() {
        const close = () => {
            this.onClose("forced close");
            debug("socket closing - telling transport to close");
            this.transport.close();
        };
        const cleanupAndClose = () => {
            this.off("upgrade", cleanupAndClose);
            this.off("upgradeError", cleanupAndClose);
            close();
        };
        const waitForUpgrade = () => {
            // wait for upgrade to finish since we can't send packets while pausing a transport
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
        };
        if ("opening" === this.readyState || "open" === this.readyState) {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
                this.once("drain", () => {
                    if (this.upgrading) {
                        waitForUpgrade();
                    }
                    else {
                        close();
                    }
                });
            }
            else if (this.upgrading) {
                waitForUpgrade();
            }
            else {
                close();
            }
        }
        return this;
    }
    /**
     * Called upon transport error
     *
     * @private
     */
    onError(err) {
        debug("socket error %j", err);
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
    }
    /**
     * Called upon transport close.
     *
     * @private
     */
    onClose(reason, description) {
        if ("opening" === this.readyState ||
            "open" === this.readyState ||
            "closing" === this.readyState) {
            debug('socket close with reason: "%s"', reason);
            // clear timers
            this.clearTimeoutFn(this.pingTimeoutTimer);
            // stop event from firing again for transport
            this.transport.removeAllListeners("close");
            // ensure transport won't stay open
            this.transport.close();
            // ignore further transport communication
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
                removeEventListener("beforeunload", this.beforeunloadEventListener, false);
                removeEventListener("offline", this.offlineEventListener, false);
            }
            // set ready state
            this.readyState = "closed";
            // clear session id
            this.id = null;
            // emit close event
            this.emitReserved("close", reason, description);
            // clean buffers after, so users can still
            // grab the buffers on `close` event
            this.writeBuffer = [];
            this.prevBufferLen = 0;
        }
    }
    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} upgrades - server upgrades
     * @private
     */
    filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
            if (~this.transports.indexOf(upgrades[i]))
                filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
    }
}
exports.Socket = Socket;
Socket.protocol = engine_io_parser_1.protocol;

},{"./contrib/parseqs.js":350,"./contrib/parseuri.js":351,"./transports/index.js":357,"./util.js":362,"@socket.io/component-emitter":311,"debug":346,"engine.io-parser":367}],356:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
const engine_io_parser_1 = require("engine.io-parser");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("./util.js");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = (0, debug_1.default)("engine.io-client:transport"); // debug()
class TransportError extends Error {
    constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
    }
}
class Transport extends component_emitter_1.Emitter {
    /**
     * Transport abstract constructor.
     *
     * @param {Object} opts - options
     * @protected
     */
    constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
    }
    /**
     * Emits an error.
     *
     * @param {String} reason
     * @param description
     * @param context - the error context
     * @return {Transport} for chaining
     * @protected
     */
    onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
    }
    /**
     * Opens the transport.
     */
    open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
    }
    /**
     * Closes the transport.
     */
    close() {
        if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
        }
        return this;
    }
    /**
     * Sends multiple packets.
     *
     * @param {Array} packets
     */
    send(packets) {
        if (this.readyState === "open") {
            this.write(packets);
        }
        else {
            // this might happen if the transport was silently closed in the beforeunload event handler
            debug("transport is not open, discarding packets");
        }
    }
    /**
     * Called upon open
     *
     * @protected
     */
    onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
    }
    /**
     * Called with data.
     *
     * @param {String} data
     * @protected
     */
    onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
    }
    /**
     * Called with a decoded packet.
     *
     * @protected
     */
    onPacket(packet) {
        super.emitReserved("packet", packet);
    }
    /**
     * Called upon close.
     *
     * @protected
     */
    onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
    }
    /**
     * Pauses the transport, in order not to lose packets during an upgrade.
     *
     * @param onPause
     */
    pause(onPause) { }
}
exports.Transport = Transport;

},{"./util.js":362,"@socket.io/component-emitter":311,"debug":346,"engine.io-parser":367}],357:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transports = void 0;
const polling_js_1 = require("./polling.js");
const websocket_js_1 = require("./websocket.js");
exports.transports = {
    websocket: websocket_js_1.WS,
    polling: polling_js_1.Polling,
};

},{"./polling.js":358,"./websocket.js":360}],358:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Request = exports.Polling = void 0;
const transport_js_1 = require("../transport.js");
const debug_1 = __importDefault(require("debug")); // debug()
const yeast_js_1 = require("../contrib/yeast.js");
const parseqs_js_1 = require("../contrib/parseqs.js");
const engine_io_parser_1 = require("engine.io-parser");
const xmlhttprequest_js_1 = require("./xmlhttprequest.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const util_js_1 = require("../util.js");
const globalThis_js_1 = require("../globalThis.js");
const debug = (0, debug_1.default)("engine.io-client:polling"); // debug()
function empty() { }
const hasXHR2 = (function () {
    const xhr = new xmlhttprequest_js_1.XHR({
        xdomain: false,
    });
    return null != xhr.responseType;
})();
class Polling extends transport_js_1.Transport {
    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @package
     */
    constructor(opts) {
        super(opts);
        this.polling = false;
        if (typeof location !== "undefined") {
            const isSSL = "https:" === location.protocol;
            let port = location.port;
            // some user agents have empty `location.port`
            if (!port) {
                port = isSSL ? "443" : "80";
            }
            this.xd =
                (typeof location !== "undefined" &&
                    opts.hostname !== location.hostname) ||
                    port !== opts.port;
            this.xs = opts.secure !== isSSL;
        }
        /**
         * XHR supports binary
         */
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
    }
    get name() {
        return "polling";
    }
    /**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @protected
     */
    doOpen() {
        this.poll();
    }
    /**
     * Pauses polling.
     *
     * @param {Function} onPause - callback upon buffers are flushed and transport is paused
     * @package
     */
    pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
        };
        if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
                debug("we are currently polling - waiting to pause");
                total++;
                this.once("pollComplete", function () {
                    debug("pre-pause polling complete");
                    --total || pause();
                });
            }
            if (!this.writable) {
                debug("we are currently writing - waiting to pause");
                total++;
                this.once("drain", function () {
                    debug("pre-pause writing complete");
                    --total || pause();
                });
            }
        }
        else {
            pause();
        }
    }
    /**
     * Starts polling cycle.
     *
     * @private
     */
    poll() {
        debug("polling");
        this.polling = true;
        this.doPoll();
        this.emitReserved("poll");
    }
    /**
     * Overloads onData to detect payloads.
     *
     * @protected
     */
    onData(data) {
        debug("polling got data %s", data);
        const callback = (packet) => {
            // if its the first message we consider the transport open
            if ("opening" === this.readyState && packet.type === "open") {
                this.onOpen();
            }
            // if its a close packet, we close the ongoing requests
            if ("close" === packet.type) {
                this.onClose({ description: "transport closed by the server" });
                return false;
            }
            // otherwise bypass onData and handle the message
            this.onPacket(packet);
        };
        // decode payload
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        // if an event did not trigger closing
        if ("closed" !== this.readyState) {
            // if we got data we're not polling
            this.polling = false;
            this.emitReserved("pollComplete");
            if ("open" === this.readyState) {
                this.poll();
            }
            else {
                debug('ignoring poll - transport state "%s"', this.readyState);
            }
        }
    }
    /**
     * For polling, send a close packet.
     *
     * @protected
     */
    doClose() {
        const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
        };
        if ("open" === this.readyState) {
            debug("transport open - closing");
            close();
        }
        else {
            // in case we're trying to close while
            // handshaking is in progress (GH-164)
            debug("transport not open - deferring close");
            this.once("open", close);
        }
    }
    /**
     * Writes a packets payload.
     *
     * @param {Array} packets - data packets
     * @protected
     */
    write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
            this.doWrite(data, () => {
                this.writable = true;
                this.emitReserved("drain");
            });
        });
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        // cache busting is forced
        if (false !== this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
        }
        // avoid port if default for schema
        if (this.opts.port &&
            (("https" === schema && Number(this.opts.port) !== 443) ||
                ("http" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
    /**
     * Creates a request.
     *
     * @param {String} method
     * @private
     */
    request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
    }
    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @private
     */
    doWrite(data, fn) {
        const req = this.request({
            method: "POST",
            data: data,
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr post error", xhrStatus, context);
        });
    }
    /**
     * Starts a poll cycle.
     *
     * @private
     */
    doPoll() {
        debug("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
            this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
    }
}
exports.Polling = Polling;
class Request extends component_emitter_1.Emitter {
    /**
     * Request constructor
     *
     * @param {Object} options
     * @package
     */
    constructor(uri, opts) {
        super();
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.create();
    }
    /**
     * Creates the XHR object and sends the request.
     *
     * @private
     */
    create() {
        const opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = (this.xhr = new xmlhttprequest_js_1.XHR(opts));
        try {
            debug("xhr open %s: %s", this.method, this.uri);
            xhr.open(this.method, this.uri, this.async);
            try {
                if (this.opts.extraHeaders) {
                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
                    for (let i in this.opts.extraHeaders) {
                        if (this.opts.extraHeaders.hasOwnProperty(i)) {
                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                        }
                    }
                }
            }
            catch (e) { }
            if ("POST" === this.method) {
                try {
                    xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                }
                catch (e) { }
            }
            try {
                xhr.setRequestHeader("Accept", "*/*");
            }
            catch (e) { }
            // ie6 check
            if ("withCredentials" in xhr) {
                xhr.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
                xhr.timeout = this.opts.requestTimeout;
            }
            xhr.onreadystatechange = () => {
                if (4 !== xhr.readyState)
                    return;
                if (200 === xhr.status || 1223 === xhr.status) {
                    this.onLoad();
                }
                else {
                    // make sure the `error` event handler that's user-set
                    // does not throw in the same tick and gets caught here
                    this.setTimeoutFn(() => {
                        this.onError(typeof xhr.status === "number" ? xhr.status : 0);
                    }, 0);
                }
            };
            debug("xhr data %s", this.data);
            xhr.send(this.data);
        }
        catch (e) {
            // Need to defer since .create() is called directly from the constructor
            // and thus the 'error' event can only be only bound *after* this exception
            // occurs.  Therefore, also, we cannot throw here at all.
            this.setTimeoutFn(() => {
                this.onError(e);
            }, 0);
            return;
        }
        if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
        }
    }
    /**
     * Called upon error.
     *
     * @private
     */
    onError(err) {
        this.emitReserved("error", err, this.xhr);
        this.cleanup(true);
    }
    /**
     * Cleans up house.
     *
     * @private
     */
    cleanup(fromError) {
        if ("undefined" === typeof this.xhr || null === this.xhr) {
            return;
        }
        this.xhr.onreadystatechange = empty;
        if (fromError) {
            try {
                this.xhr.abort();
            }
            catch (e) { }
        }
        if (typeof document !== "undefined") {
            delete Request.requests[this.index];
        }
        this.xhr = null;
    }
    /**
     * Called upon load.
     *
     * @private
     */
    onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
            this.emitReserved("data", data);
            this.emitReserved("success");
            this.cleanup();
        }
    }
    /**
     * Aborts the request.
     *
     * @package
     */
    abort() {
        this.cleanup();
    }
}
exports.Request = Request;
Request.requestsCount = 0;
Request.requests = {};
/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */
if (typeof document !== "undefined") {
    // @ts-ignore
    if (typeof attachEvent === "function") {
        // @ts-ignore
        attachEvent("onunload", unloadHandler);
    }
    else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis_js_1.globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
    }
}
function unloadHandler() {
    for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
        }
    }
}

},{"../contrib/parseqs.js":350,"../contrib/yeast.js":352,"../globalThis.js":353,"../transport.js":356,"../util.js":362,"./xmlhttprequest.js":361,"@socket.io/component-emitter":311,"debug":346,"engine.io-parser":367}],359:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultBinaryType = exports.usingBrowserWebSocket = exports.WebSocket = exports.nextTick = void 0;
const globalThis_js_1 = require("../globalThis.js");
exports.nextTick = (() => {
    const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
    if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
    }
    else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
    }
})();
exports.WebSocket = globalThis_js_1.globalThisShim.WebSocket || globalThis_js_1.globalThisShim.MozWebSocket;
exports.usingBrowserWebSocket = true;
exports.defaultBinaryType = "arraybuffer";

},{"../globalThis.js":353}],360:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WS = void 0;
const transport_js_1 = require("../transport.js");
const parseqs_js_1 = require("../contrib/parseqs.js");
const yeast_js_1 = require("../contrib/yeast.js");
const util_js_1 = require("../util.js");
const websocket_constructor_js_1 = require("./websocket-constructor.js");
const debug_1 = __importDefault(require("debug")); // debug()
const engine_io_parser_1 = require("engine.io-parser");
const debug = (0, debug_1.default)("engine.io-client:websocket"); // debug()
// detect ReactNative environment
const isReactNative = typeof navigator !== "undefined" &&
    typeof navigator.product === "string" &&
    navigator.product.toLowerCase() === "reactnative";
class WS extends transport_js_1.Transport {
    /**
     * WebSocket transport constructor.
     *
     * @param {Object} opts - connection options
     * @protected
     */
    constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
    }
    get name() {
        return "websocket";
    }
    doOpen() {
        if (!this.check()) {
            // let probe timeout
            return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        // React Native only supports the 'headers' option, and will print a warning if anything else is passed
        const opts = isReactNative
            ? {}
            : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
        }
        try {
            this.ws =
                websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative
                    ? protocols
                        ? new websocket_constructor_js_1.WebSocket(uri, protocols)
                        : new websocket_constructor_js_1.WebSocket(uri)
                    : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
        }
        catch (err) {
            return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;
        this.addEventListeners();
    }
    /**
     * Adds event listeners to the socket
     *
     * @private
     */
    addEventListeners() {
        this.ws.onopen = () => {
            if (this.opts.autoUnref) {
                this.ws._socket.unref();
            }
            this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
            description: "websocket connection closed",
            context: closeEvent,
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
    }
    write(packets) {
        this.writable = false;
        // encodePacket efficient as it uses WS framing
        // no need for encodePayload
        for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
                // always create a new object (GH-437)
                const opts = {};
                if (!websocket_constructor_js_1.usingBrowserWebSocket) {
                    if (packet.options) {
                        opts.compress = packet.options.compress;
                    }
                    if (this.opts.perMessageDeflate) {
                        const len = 
                        // @ts-ignore
                        "string" === typeof data ? Buffer.byteLength(data) : data.length;
                        if (len < this.opts.perMessageDeflate.threshold) {
                            opts.compress = false;
                        }
                    }
                }
                // Sometimes the websocket has already been closed but the browser didn't
                // have a chance of informing us about it yet, in that case send will
                // throw an error
                try {
                    if (websocket_constructor_js_1.usingBrowserWebSocket) {
                        // TypeError is thrown when passing the second argument on Safari
                        this.ws.send(data);
                    }
                    else {
                        this.ws.send(data, opts);
                    }
                }
                catch (e) {
                    debug("websocket closed before onclose event");
                }
                if (lastPacket) {
                    // fake drain
                    // defer to next tick to allow Socket to clear writeBuffer
                    (0, websocket_constructor_js_1.nextTick)(() => {
                        this.writable = true;
                        this.emitReserved("drain");
                    }, this.setTimeoutFn);
                }
            });
        }
    }
    doClose() {
        if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
        }
    }
    /**
     * Generates uri for connection.
     *
     * @private
     */
    uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        // avoid port if default for schema
        if (this.opts.port &&
            (("wss" === schema && Number(this.opts.port) !== 443) ||
                ("ws" === schema && Number(this.opts.port) !== 80))) {
            port = ":" + this.opts.port;
        }
        // append timestamp to URI
        if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = (0, yeast_js_1.yeast)();
        }
        // communicate binary support capabilities
        if (!this.supportsBinary) {
            query.b64 = 1;
        }
        const encodedQuery = (0, parseqs_js_1.encode)(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return (schema +
            "://" +
            (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
            port +
            this.opts.path +
            (encodedQuery.length ? "?" + encodedQuery : ""));
    }
    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @private
     */
    check() {
        return !!websocket_constructor_js_1.WebSocket;
    }
}
exports.WS = WS;

}).call(this)}).call(this,require("buffer").Buffer)
},{"../contrib/parseqs.js":350,"../contrib/yeast.js":352,"../transport.js":356,"../util.js":362,"./websocket-constructor.js":359,"buffer":561,"debug":346,"engine.io-parser":367}],361:[function(require,module,exports){
"use strict";
// browser shim for xmlhttprequest module
Object.defineProperty(exports, "__esModule", { value: true });
exports.XHR = void 0;
const has_cors_js_1 = require("../contrib/has-cors.js");
const globalThis_js_1 = require("../globalThis.js");
function XHR(opts) {
    const xdomain = opts.xdomain;
    // XMLHttpRequest can be disabled on IE
    try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || has_cors_js_1.hasCORS)) {
            return new XMLHttpRequest();
        }
    }
    catch (e) { }
    if (!xdomain) {
        try {
            return new globalThis_js_1.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        }
        catch (e) { }
    }
}
exports.XHR = XHR;

},{"../contrib/has-cors.js":349,"../globalThis.js":353}],362:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.byteLength = exports.installTimerFunctions = exports.pick = void 0;
const globalThis_js_1 = require("./globalThis.js");
function pick(obj, ...attr) {
    return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
            acc[k] = obj[k];
        }
        return acc;
    }, {});
}
exports.pick = pick;
// Keep a reference to the real timeout functions so they can be used when overridden
const NATIVE_SET_TIMEOUT = globalThis_js_1.globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThis_js_1.globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
    if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.globalThisShim);
    }
    else {
        obj.setTimeoutFn = globalThis_js_1.globalThisShim.setTimeout.bind(globalThis_js_1.globalThisShim);
        obj.clearTimeoutFn = globalThis_js_1.globalThisShim.clearTimeout.bind(globalThis_js_1.globalThisShim);
    }
}
exports.installTimerFunctions = installTimerFunctions;
// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)
const BASE64_OVERHEAD = 1.33;
// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9
function byteLength(obj) {
    if (typeof obj === "string") {
        return utf8Length(obj);
    }
    // arraybuffer or blob
    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
exports.byteLength = byteLength;
function utf8Length(str) {
    let c = 0, length = 0;
    for (let i = 0, l = str.length; i < l; i++) {
        c = str.charCodeAt(i);
        if (c < 0x80) {
            length += 1;
        }
        else if (c < 0x800) {
            length += 2;
        }
        else if (c < 0xd800 || c >= 0xe000) {
            length += 3;
        }
        else {
            i++;
            length += 4;
        }
    }
    return length;
}

},{"./globalThis.js":353}],363:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
const PACKET_TYPES = Object.create(null); // no Map = no polyfill
exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(key => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
exports.ERROR_PACKET = ERROR_PACKET;

},{}],364:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
// imported from https://github.com/socketio/base64-arraybuffer
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
// Use a lookup table to find the index.
const lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}
const encode = (arraybuffer) => {
    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
    for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
        base64 += chars[bytes[i + 2] & 63];
    }
    if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + '=';
    }
    else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + '==';
    }
    return base64;
};
exports.encode = encode;
const decode = (base64) => {
    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }
    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];
        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }
    return arraybuffer;
};
exports.decode = decode;

},{}],365:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commons_js_1 = require("./commons.js");
const base64_arraybuffer_js_1 = require("./contrib/base64-arraybuffer.js");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
        return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
        };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
        return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
    }
    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
    if (!packetType) {
        return commons_js_1.ERROR_PACKET;
    }
    return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1)
        }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type]
        };
};
const decodeBase64Packet = (data, binaryType) => {
    if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_js_1.decode)(data);
        return mapBinary(decoded, binaryType);
    }
    else {
        return { base64: true, data }; // fallback for old browsers
    }
};
const mapBinary = (data, binaryType) => {
    switch (binaryType) {
        case "blob":
            return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
            return data; // assuming the data is already an ArrayBuffer
    }
};
exports.default = decodePacket;

},{"./commons.js":363,"./contrib/base64-arraybuffer.js":364}],366:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commons_js_1 = require("./commons.js");
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
// ArrayBuffer.isView method is not defined in IE10
const isView = obj => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(data, callback);
        }
    }
    else if (withNativeArrayBuffer &&
        (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
            return callback(data);
        }
        else {
            return encodeBlobAsBase64(new Blob([data]), callback);
        }
    }
    // plain string
    return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function () {
        const content = fileReader.result.split(",")[1];
        callback("b" + (content || ""));
    };
    return fileReader.readAsDataURL(data);
};
exports.default = encodePacket;

},{"./commons.js":363}],367:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;
const encodePacket_js_1 = require("./encodePacket.js");
exports.encodePacket = encodePacket_js_1.default;
const decodePacket_js_1 = require("./decodePacket.js");
exports.decodePacket = decodePacket_js_1.default;
const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
const encodePayload = (packets, callback) => {
    // some packets may be added to the array while encoding, so the initial length must be saved
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.default)(packet, false, encodedPacket => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
                callback(encodedPackets.join(SEPARATOR));
            }
        });
    });
};
exports.encodePayload = encodePayload;
const decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
            break;
        }
    }
    return packets;
};
exports.decodePayload = decodePayload;
exports.protocol = 4;

},{"./decodePacket.js":365,"./encodePacket.js":366}],368:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerErrorType = exports.AttachState = void 0;
var container_definitions_1 = require("@fluidframework/container-definitions");
Object.defineProperty(exports, "AttachState", { enumerable: true, get: function () { return container_definitions_1.AttachState; } });
Object.defineProperty(exports, "ContainerErrorType", { enumerable: true, get: function () { return container_definitions_1.ContainerErrorType; } });

},{"@fluidframework/container-definitions":50}],369:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionState = void 0;
var container_loader_1 = require("@fluidframework/container-loader");
Object.defineProperty(exports, "ConnectionState", { enumerable: true, get: function () { return container_loader_1.ConnectionState; } });

},{"@fluidframework/container-loader":387}],370:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DriverErrorType = void 0;
var driver_definitions_1 = require("@fluidframework/driver-definitions");
Object.defineProperty(exports, "DriverErrorType", { enumerable: true, get: function () { return driver_definitions_1.DriverErrorType; } });

},{"@fluidframework/driver-definitions":100}],371:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("@fluidframework/fluid-static"), exports);

},{"@fluidframework/fluid-static":127}],372:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The **fluid-framework** package bundles a collection of Fluid Framework client packages for easy use when paired with
 * a corresponding service client package (for example, `\@fluidframework/azure-client` or
 * `\@fluidframework/tinylicious-client`).
 *
 * @packageDocumentation
 */
__exportStar(require("./containerDefinitions"), exports);
__exportStar(require("./containerLoader"), exports);
__exportStar(require("./driverDefinitions"), exports);
__exportStar(require("./fluidStatic"), exports);
__exportStar(require("./map"), exports);
__exportStar(require("./sequence"), exports);

},{"./containerDefinitions":368,"./containerLoader":369,"./driverDefinitions":370,"./fluidStatic":371,"./map":373,"./sequence":374}],373:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("@fluidframework/map"), exports);

},{"@fluidframework/map":137}],374:[function(require,module,exports){
"use strict";
/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("@fluidframework/sequence"), exports);

},{"@fluidframework/sequence":225}],375:[function(require,module,exports){
arguments[4][289][0].apply(exports,arguments)
},{"dup":289,"events":562}],376:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"dup":290}],377:[function(require,module,exports){
arguments[4][291][0].apply(exports,arguments)
},{"./contracts":383,"./deltaQueue":386,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"abort-controller":312,"dup":291}],378:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"dup":292}],379:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"./connectionState":378,"@fluidframework/common-utils":29,"@fluidframework/telemetry-utils":279,"dup":293}],380:[function(require,module,exports){
arguments[4][294][0].apply(exports,arguments)
},{"./audience":375,"./collabWindowTracker":376,"./connectionManager":377,"./connectionState":378,"./connectionStateHandler":379,"./containerContext":381,"./containerStorageAdapter":382,"./contracts":383,"./deltaManager":384,"./deltaManagerProxy":385,"./loader":388,"./packageVersion":389,"./protocolTreeDocumentStorageService":390,"./quorum":391,"./retriableDocumentStorageService":392,"./utils":393,"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"@fluidframework/protocol-base":166,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"dup":294,"lodash/merge":521,"uuid":544}],381:[function(require,module,exports){
arguments[4][295][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"@fluidframework/container-definitions":50,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279,"dup":295}],382:[function(require,module,exports){
arguments[4][296][0].apply(exports,arguments)
},{"dup":296}],383:[function(require,module,exports){
arguments[4][297][0].apply(exports,arguments)
},{"@fluidframework/container-definitions":50,"dup":297}],384:[function(require,module,exports){
arguments[4][298][0].apply(exports,arguments)
},{"./deltaQueue":386,"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-definitions":100,"@fluidframework/driver-utils":110,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"abort-controller":312,"dup":298,"uuid":544}],385:[function(require,module,exports){
arguments[4][299][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"dup":299}],386:[function(require,module,exports){
arguments[4][300][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"double-ended-queue":348,"dup":300}],387:[function(require,module,exports){
arguments[4][301][0].apply(exports,arguments)
},{"./connectionState":378,"./container":380,"./loader":388,"dup":301}],388:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./container":380,"./packageVersion":389,"./utils":393,"@fluidframework/container-definitions":50,"@fluidframework/driver-utils":110,"@fluidframework/telemetry-utils":279,"dup":302,"uuid":544}],389:[function(require,module,exports){
arguments[4][303][0].apply(exports,arguments)
},{"dup":303}],390:[function(require,module,exports){
arguments[4][304][0].apply(exports,arguments)
},{"@fluidframework/driver-utils":110,"dup":304}],391:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"dup":305}],392:[function(require,module,exports){
arguments[4][306][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"@fluidframework/container-utils":87,"@fluidframework/driver-utils":110,"dup":306}],393:[function(require,module,exports){
arguments[4][307][0].apply(exports,arguments)
},{"@fluidframework/common-utils":29,"@fluidframework/protocol-definitions":174,"@fluidframework/telemetry-utils":279,"dup":307,"url":569,"uuid":544}],394:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],395:[function(require,module,exports){
exports = module.exports = stringify
exports.getSerialize = serializer

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = []

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return "[Circular ~]"
    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this)
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)
    }
    else stack.push(value)

    return replacer == null ? value : replacer.call(this, key, value)
  }
}

},{}],396:[function(require,module,exports){
(function (Buffer){(function (){

var navigator = {};
navigator.userAgent = false;

var window = {};
/*
 * jsrsasign(all) 10.8.1 (2023-04-09) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license
 */
var VERSION = "10.8.1";
var VERSION_FULL = "jsrsasign(all) 10.8.1 (2023-04-09) (c) 2010-2023 Kenji Urushima | kjur.github.io/jsrsasign/license";

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var CryptoJS=CryptoJS||(function(e,g){var a={};var b=a.lib={};var j=b.Base=(function(){function n(){}return{extend:function(p){n.prototype=this;var o=new n();if(p){o.mixIn(p)}if(!o.hasOwnProperty("init")){o.init=function(){o.$super.init.apply(this,arguments)}}o.init.prototype=o;o.$super=this;return o},create:function(){var o=this.extend();o.init.apply(o,arguments);return o},init:function(){},mixIn:function(p){for(var o in p){if(p.hasOwnProperty(o)){this[o]=p[o]}}if(p.hasOwnProperty("toString")){this.toString=p.toString}},clone:function(){return this.init.prototype.extend(this)}}}());var l=b.WordArray=j.extend({init:function(o,n){o=this.words=o||[];if(n!=g){this.sigBytes=n}else{this.sigBytes=o.length*4}},toString:function(n){return(n||h).stringify(this)},concat:function(t){var q=this.words;var p=t.words;var n=this.sigBytes;var s=t.sigBytes;this.clamp();if(n%4){for(var r=0;r<s;r++){var o=(p[r>>>2]>>>(24-(r%4)*8))&255;q[(n+r)>>>2]|=o<<(24-((n+r)%4)*8)}}else{for(var r=0;r<s;r+=4){q[(n+r)>>>2]=p[r>>>2]}}this.sigBytes+=s;return this},clamp:function(){var o=this.words;var n=this.sigBytes;o[n>>>2]&=4294967295<<(32-(n%4)*8);o.length=e.ceil(n/4)},clone:function(){var n=j.clone.call(this);n.words=this.words.slice(0);return n},random:function(p){var o=[];for(var n=0;n<p;n+=4){o.push((e.random()*4294967296)|0)}return new l.init(o,p)}});var m=a.enc={};var h=m.Hex={stringify:function(p){var r=p.words;var o=p.sigBytes;var q=[];for(var n=0;n<o;n++){var s=(r[n>>>2]>>>(24-(n%4)*8))&255;q.push((s>>>4).toString(16));q.push((s&15).toString(16))}return q.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o+=2){q[o>>>3]|=parseInt(p.substr(o,2),16)<<(24-(o%8)*4)}return new l.init(q,n/2)}};var d=m.Latin1={stringify:function(q){var r=q.words;var p=q.sigBytes;var n=[];for(var o=0;o<p;o++){var s=(r[o>>>2]>>>(24-(o%4)*8))&255;n.push(String.fromCharCode(s))}return n.join("")},parse:function(p){var n=p.length;var q=[];for(var o=0;o<n;o++){q[o>>>2]|=(p.charCodeAt(o)&255)<<(24-(o%4)*8)}return new l.init(q,n)}};var c=m.Utf8={stringify:function(n){try{return decodeURIComponent(escape(d.stringify(n)))}catch(o){throw new Error("Malformed UTF-8 data")}},parse:function(n){return d.parse(unescape(encodeURIComponent(n)))}};var i=b.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new l.init();this._nDataBytes=0},_append:function(n){if(typeof n=="string"){n=c.parse(n)}this._data.concat(n);this._nDataBytes+=n.sigBytes},_process:function(w){var q=this._data;var x=q.words;var n=q.sigBytes;var t=this.blockSize;var v=t*4;var u=n/v;if(w){u=e.ceil(u)}else{u=e.max((u|0)-this._minBufferSize,0)}var s=u*t;var r=e.min(s*4,n);if(s){for(var p=0;p<s;p+=t){this._doProcessBlock(x,p)}var o=x.splice(0,s);q.sigBytes-=r}return new l.init(o,r)},clone:function(){var n=j.clone.call(this);n._data=this._data.clone();return n},_minBufferSize:0});var f=b.Hasher=i.extend({cfg:j.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset()},reset:function(){i.reset.call(this);this._doReset()},update:function(n){this._append(n);this._process();return this},finalize:function(n){if(n){this._append(n)}var o=this._doFinalize();return o},blockSize:512/32,_createHelper:function(n){return function(p,o){return new n.init(o).finalize(p)}},_createHmacHelper:function(n){return function(p,o){return new k.HMAC.init(n,o).finalize(p)}}});var k=a.algo={};return a}(Math));
/*
CryptoJS v3.1.2 x64-core-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(g){var a=CryptoJS,f=a.lib,e=f.Base,h=f.WordArray,a=a.x64={};a.Word=e.extend({init:function(b,c){this.high=b;this.low=c}});a.WordArray=e.extend({init:function(b,c){b=this.words=b||[];this.sigBytes=c!=g?c:8*b.length},toX32:function(){for(var b=this.words,c=b.length,a=[],d=0;d<c;d++){var e=b[d];a.push(e.high);a.push(e.low)}return h.create(a,this.sigBytes)},clone:function(){for(var b=e.clone.call(this),c=b.words=this.words.slice(0),a=c.length,d=0;d<a;d++)c[d]=c[d].clone();return b}})})();

/*
CryptoJS v3.1.2 cipher-core.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
CryptoJS.lib.Cipher||function(u){var g=CryptoJS,f=g.lib,k=f.Base,l=f.WordArray,q=f.BufferedBlockAlgorithm,r=g.enc.Base64,v=g.algo.EvpKDF,n=f.Cipher=q.extend({cfg:k.extend(),createEncryptor:function(a,b){return this.create(this._ENC_XFORM_MODE,a,b)},createDecryptor:function(a,b){return this.create(this._DEC_XFORM_MODE,a,b)},init:function(a,b,c){this.cfg=this.cfg.extend(c);this._xformMode=a;this._key=b;this.reset()},reset:function(){q.reset.call(this);this._doReset()},process:function(a){this._append(a);
return this._process()},finalize:function(a){a&&this._append(a);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(a){return{encrypt:function(b,c,d){return("string"==typeof c?s:j).encrypt(a,b,c,d)},decrypt:function(b,c,d){return("string"==typeof c?s:j).decrypt(a,b,c,d)}}}});f.StreamCipher=n.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var m=g.mode={},t=function(a,b,c){var d=this._iv;d?this._iv=u:d=this._prevBlock;for(var e=
0;e<c;e++)a[b+e]^=d[e]},h=(f.BlockCipherMode=k.extend({createEncryptor:function(a,b){return this.Encryptor.create(a,b)},createDecryptor:function(a,b){return this.Decryptor.create(a,b)},init:function(a,b){this._cipher=a;this._iv=b}})).extend();h.Encryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize;t.call(this,a,b,d);c.encryptBlock(a,b);this._prevBlock=a.slice(b,b+d)}});h.Decryptor=h.extend({processBlock:function(a,b){var c=this._cipher,d=c.blockSize,e=a.slice(b,b+d);c.decryptBlock(a,
b);t.call(this,a,b,d);this._prevBlock=e}});m=m.CBC=h;h=(g.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,e=[],f=0;f<c;f+=4)e.push(d);c=l.create(e,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};f.BlockCipher=n.extend({cfg:n.cfg.extend({mode:m,padding:h}),reset:function(){n.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;
this._mode=c.call(a,this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var p=f.CipherParams=k.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),m=(g.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;
return(a?l.create([1398893684,1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=l.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return p.create({ciphertext:a,salt:c})}},j=f.SerializableCipher=k.extend({cfg:k.extend({format:m}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var e=a.createEncryptor(c,d);b=e.finalize(b);e=e.cfg;return p.create({ciphertext:b,key:c,iv:e.iv,algorithm:a,mode:e.mode,padding:e.padding,
blockSize:a.blockSize,formatter:d.format})},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),g=(g.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=l.random(8));a=v.create({keySize:b+c}).compute(a,d);c=l.create(a.words.slice(b),4*c);a.sigBytes=4*b;return p.create({key:a,iv:c,salt:d})}},s=f.PasswordBasedCipher=j.extend({cfg:j.cfg.extend({kdf:g}),encrypt:function(a,
b,c,d){d=this.cfg.extend(d);c=d.kdf.execute(c,a.keySize,a.ivSize);d.iv=c.iv;a=j.encrypt.call(this,a,b,c.key,d);a.mixIn(c);return a},decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);c=d.kdf.execute(c,a.keySize,a.ivSize,b.salt);d.iv=c.iv;return j.decrypt.call(this,a,b,c.key,d)}})}();

/*
CryptoJS v3.1.2 aes.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){for(var q=CryptoJS,x=q.lib.BlockCipher,r=q.algo,j=[],y=[],z=[],A=[],B=[],C=[],s=[],u=[],v=[],w=[],g=[],k=0;256>k;k++)g[k]=128>k?k<<1:k<<1^283;for(var n=0,l=0,k=0;256>k;k++){var f=l^l<<1^l<<2^l<<3^l<<4,f=f>>>8^f&255^99;j[n]=f;y[f]=n;var t=g[n],D=g[t],E=g[D],b=257*g[f]^16843008*f;z[n]=b<<24|b>>>8;A[n]=b<<16|b>>>16;B[n]=b<<8|b>>>24;C[n]=b;b=16843009*E^65537*D^257*t^16843008*n;s[f]=b<<24|b>>>8;u[f]=b<<16|b>>>16;v[f]=b<<8|b>>>24;w[f]=b;n?(n=t^g[g[g[E^t]]],l^=g[g[l]]):n=l=1}var F=[0,1,2,4,8,
16,32,64,128,27,54],r=r.AES=x.extend({_doReset:function(){for(var c=this._key,e=c.words,a=c.sigBytes/4,c=4*((this._nRounds=a+6)+1),b=this._keySchedule=[],h=0;h<c;h++)if(h<a)b[h]=e[h];else{var d=b[h-1];h%a?6<a&&4==h%a&&(d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255]):(d=d<<8|d>>>24,d=j[d>>>24]<<24|j[d>>>16&255]<<16|j[d>>>8&255]<<8|j[d&255],d^=F[h/a|0]<<24);b[h]=b[h-a]^d}e=this._invKeySchedule=[];for(a=0;a<c;a++)h=c-a,d=a%4?b[h]:b[h-4],e[a]=4>a||4>=h?d:s[j[d>>>24]]^u[j[d>>>16&255]]^v[j[d>>>
8&255]]^w[j[d&255]]},encryptBlock:function(c,e){this._doCryptBlock(c,e,this._keySchedule,z,A,B,C,j)},decryptBlock:function(c,e){var a=c[e+1];c[e+1]=c[e+3];c[e+3]=a;this._doCryptBlock(c,e,this._invKeySchedule,s,u,v,w,y);a=c[e+1];c[e+1]=c[e+3];c[e+3]=a},_doCryptBlock:function(c,e,a,b,h,d,j,m){for(var n=this._nRounds,f=c[e]^a[0],g=c[e+1]^a[1],k=c[e+2]^a[2],p=c[e+3]^a[3],l=4,t=1;t<n;t++)var q=b[f>>>24]^h[g>>>16&255]^d[k>>>8&255]^j[p&255]^a[l++],r=b[g>>>24]^h[k>>>16&255]^d[p>>>8&255]^j[f&255]^a[l++],s=
b[k>>>24]^h[p>>>16&255]^d[f>>>8&255]^j[g&255]^a[l++],p=b[p>>>24]^h[f>>>16&255]^d[g>>>8&255]^j[k&255]^a[l++],f=q,g=r,k=s;q=(m[f>>>24]<<24|m[g>>>16&255]<<16|m[k>>>8&255]<<8|m[p&255])^a[l++];r=(m[g>>>24]<<24|m[k>>>16&255]<<16|m[p>>>8&255]<<8|m[f&255])^a[l++];s=(m[k>>>24]<<24|m[p>>>16&255]<<16|m[f>>>8&255]<<8|m[g&255])^a[l++];p=(m[p>>>24]<<24|m[f>>>16&255]<<16|m[g>>>8&255]<<8|m[k&255])^a[l++];c[e]=q;c[e+1]=r;c[e+2]=s;c[e+3]=p},keySize:8});q.AES=x._createHelper(r)})();

/*
CryptoJS v3.1.2 tripledes-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){function j(b,c){var a=(this._lBlock>>>b^this._rBlock)&c;this._rBlock^=a;this._lBlock^=a<<b}function l(b,c){var a=(this._rBlock>>>b^this._lBlock)&c;this._lBlock^=a;this._rBlock^=a<<b}var h=CryptoJS,e=h.lib,n=e.WordArray,e=e.BlockCipher,g=h.algo,q=[57,49,41,33,25,17,9,1,58,50,42,34,26,18,10,2,59,51,43,35,27,19,11,3,60,52,44,36,63,55,47,39,31,23,15,7,62,54,46,38,30,22,14,6,61,53,45,37,29,21,13,5,28,20,12,4],p=[14,17,11,24,1,5,3,28,15,6,21,10,23,19,12,4,26,8,16,7,27,20,13,2,41,52,31,37,47,
55,30,40,51,45,33,48,44,49,39,56,34,53,46,42,50,36,29,32],r=[1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28],s=[{"0":8421888,268435456:32768,536870912:8421378,805306368:2,1073741824:512,1342177280:8421890,1610612736:8389122,1879048192:8388608,2147483648:514,2415919104:8389120,2684354560:33280,2952790016:8421376,3221225472:32770,3489660928:8388610,3758096384:0,4026531840:33282,134217728:0,402653184:8421890,671088640:33282,939524096:32768,1207959552:8421888,1476395008:512,1744830464:8421378,2013265920:2,
2281701376:8389120,2550136832:33280,2818572288:8421376,3087007744:8389122,3355443200:8388610,3623878656:32770,3892314112:514,4160749568:8388608,1:32768,268435457:2,536870913:8421888,805306369:8388608,1073741825:8421378,1342177281:33280,1610612737:512,1879048193:8389122,2147483649:8421890,2415919105:8421376,2684354561:8388610,2952790017:33282,3221225473:514,3489660929:8389120,3758096385:32770,4026531841:0,134217729:8421890,402653185:8421376,671088641:8388608,939524097:512,1207959553:32768,1476395009:8388610,
1744830465:2,2013265921:33282,2281701377:32770,2550136833:8389122,2818572289:514,3087007745:8421888,3355443201:8389120,3623878657:0,3892314113:33280,4160749569:8421378},{"0":1074282512,16777216:16384,33554432:524288,50331648:1074266128,67108864:1073741840,83886080:1074282496,100663296:1073758208,117440512:16,134217728:540672,150994944:1073758224,167772160:1073741824,184549376:540688,201326592:524304,218103808:0,234881024:16400,251658240:1074266112,8388608:1073758208,25165824:540688,41943040:16,58720256:1073758224,
75497472:1074282512,92274688:1073741824,109051904:524288,125829120:1074266128,142606336:524304,159383552:0,176160768:16384,192937984:1074266112,209715200:1073741840,226492416:540672,243269632:1074282496,260046848:16400,268435456:0,285212672:1074266128,301989888:1073758224,318767104:1074282496,335544320:1074266112,352321536:16,369098752:540688,385875968:16384,402653184:16400,419430400:524288,436207616:524304,452984832:1073741840,469762048:540672,486539264:1073758208,503316480:1073741824,520093696:1074282512,
276824064:540688,293601280:524288,310378496:1074266112,327155712:16384,343932928:1073758208,360710144:1074282512,377487360:16,394264576:1073741824,411041792:1074282496,427819008:1073741840,444596224:1073758224,461373440:524304,478150656:0,494927872:16400,511705088:1074266128,528482304:540672},{"0":260,1048576:0,2097152:67109120,3145728:65796,4194304:65540,5242880:67108868,6291456:67174660,7340032:67174400,8388608:67108864,9437184:67174656,10485760:65792,11534336:67174404,12582912:67109124,13631488:65536,
14680064:4,15728640:256,524288:67174656,1572864:67174404,2621440:0,3670016:67109120,4718592:67108868,5767168:65536,6815744:65540,7864320:260,8912896:4,9961472:256,11010048:67174400,12058624:65796,13107200:65792,14155776:67109124,15204352:67174660,16252928:67108864,16777216:67174656,17825792:65540,18874368:65536,19922944:67109120,20971520:256,22020096:67174660,23068672:67108868,24117248:0,25165824:67109124,26214400:67108864,27262976:4,28311552:65792,29360128:67174400,30408704:260,31457280:65796,32505856:67174404,
17301504:67108864,18350080:260,19398656:67174656,20447232:0,21495808:65540,22544384:67109120,23592960:256,24641536:67174404,25690112:65536,26738688:67174660,27787264:65796,28835840:67108868,29884416:67109124,30932992:67174400,31981568:4,33030144:65792},{"0":2151682048,65536:2147487808,131072:4198464,196608:2151677952,262144:0,327680:4198400,393216:2147483712,458752:4194368,524288:2147483648,589824:4194304,655360:64,720896:2147487744,786432:2151678016,851968:4160,917504:4096,983040:2151682112,32768:2147487808,
98304:64,163840:2151678016,229376:2147487744,294912:4198400,360448:2151682112,425984:0,491520:2151677952,557056:4096,622592:2151682048,688128:4194304,753664:4160,819200:2147483648,884736:4194368,950272:4198464,1015808:2147483712,1048576:4194368,1114112:4198400,1179648:2147483712,1245184:0,1310720:4160,1376256:2151678016,1441792:2151682048,1507328:2147487808,1572864:2151682112,1638400:2147483648,1703936:2151677952,1769472:4198464,1835008:2147487744,1900544:4194304,1966080:64,2031616:4096,1081344:2151677952,
1146880:2151682112,1212416:0,1277952:4198400,1343488:4194368,1409024:2147483648,1474560:2147487808,1540096:64,1605632:2147483712,1671168:4096,1736704:2147487744,1802240:2151678016,1867776:4160,1933312:2151682048,1998848:4194304,2064384:4198464},{"0":128,4096:17039360,8192:262144,12288:536870912,16384:537133184,20480:16777344,24576:553648256,28672:262272,32768:16777216,36864:537133056,40960:536871040,45056:553910400,49152:553910272,53248:0,57344:17039488,61440:553648128,2048:17039488,6144:553648256,
10240:128,14336:17039360,18432:262144,22528:537133184,26624:553910272,30720:536870912,34816:537133056,38912:0,43008:553910400,47104:16777344,51200:536871040,55296:553648128,59392:16777216,63488:262272,65536:262144,69632:128,73728:536870912,77824:553648256,81920:16777344,86016:553910272,90112:537133184,94208:16777216,98304:553910400,102400:553648128,106496:17039360,110592:537133056,114688:262272,118784:536871040,122880:0,126976:17039488,67584:553648256,71680:16777216,75776:17039360,79872:537133184,
83968:536870912,88064:17039488,92160:128,96256:553910272,100352:262272,104448:553910400,108544:0,112640:553648128,116736:16777344,120832:262144,124928:537133056,129024:536871040},{"0":268435464,256:8192,512:270532608,768:270540808,1024:268443648,1280:2097152,1536:2097160,1792:268435456,2048:0,2304:268443656,2560:2105344,2816:8,3072:270532616,3328:2105352,3584:8200,3840:270540800,128:270532608,384:270540808,640:8,896:2097152,1152:2105352,1408:268435464,1664:268443648,1920:8200,2176:2097160,2432:8192,
2688:268443656,2944:270532616,3200:0,3456:270540800,3712:2105344,3968:268435456,4096:268443648,4352:270532616,4608:270540808,4864:8200,5120:2097152,5376:268435456,5632:268435464,5888:2105344,6144:2105352,6400:0,6656:8,6912:270532608,7168:8192,7424:268443656,7680:270540800,7936:2097160,4224:8,4480:2105344,4736:2097152,4992:268435464,5248:268443648,5504:8200,5760:270540808,6016:270532608,6272:270540800,6528:270532616,6784:8192,7040:2105352,7296:2097160,7552:0,7808:268435456,8064:268443656},{"0":1048576,
16:33555457,32:1024,48:1049601,64:34604033,80:0,96:1,112:34603009,128:33555456,144:1048577,160:33554433,176:34604032,192:34603008,208:1025,224:1049600,240:33554432,8:34603009,24:0,40:33555457,56:34604032,72:1048576,88:33554433,104:33554432,120:1025,136:1049601,152:33555456,168:34603008,184:1048577,200:1024,216:34604033,232:1,248:1049600,256:33554432,272:1048576,288:33555457,304:34603009,320:1048577,336:33555456,352:34604032,368:1049601,384:1025,400:34604033,416:1049600,432:1,448:0,464:34603008,480:33554433,
496:1024,264:1049600,280:33555457,296:34603009,312:1,328:33554432,344:1048576,360:1025,376:34604032,392:33554433,408:34603008,424:0,440:34604033,456:1049601,472:1024,488:33555456,504:1048577},{"0":134219808,1:131072,2:134217728,3:32,4:131104,5:134350880,6:134350848,7:2048,8:134348800,9:134219776,10:133120,11:134348832,12:2080,13:0,14:134217760,15:133152,2147483648:2048,2147483649:134350880,2147483650:134219808,2147483651:134217728,2147483652:134348800,2147483653:133120,2147483654:133152,2147483655:32,
2147483656:134217760,2147483657:2080,2147483658:131104,2147483659:134350848,2147483660:0,2147483661:134348832,2147483662:134219776,2147483663:131072,16:133152,17:134350848,18:32,19:2048,20:134219776,21:134217760,22:134348832,23:131072,24:0,25:131104,26:134348800,27:134219808,28:134350880,29:133120,30:2080,31:134217728,2147483664:131072,2147483665:2048,2147483666:134348832,2147483667:133152,2147483668:32,2147483669:134348800,2147483670:134217728,2147483671:134219808,2147483672:134350880,2147483673:134217760,
2147483674:134219776,2147483675:0,2147483676:133120,2147483677:2080,2147483678:131104,2147483679:134350848}],t=[4160749569,528482304,33030144,2064384,129024,8064,504,2147483679],m=g.DES=e.extend({_doReset:function(){for(var b=this._key.words,c=[],a=0;56>a;a++){var f=q[a]-1;c[a]=b[f>>>5]>>>31-f%32&1}b=this._subKeys=[];for(f=0;16>f;f++){for(var d=b[f]=[],e=r[f],a=0;24>a;a++)d[a/6|0]|=c[(p[a]-1+e)%28]<<31-a%6,d[4+(a/6|0)]|=c[28+(p[a+24]-1+e)%28]<<31-a%6;d[0]=d[0]<<1|d[0]>>>31;for(a=1;7>a;a++)d[a]>>>=
4*(a-1)+3;d[7]=d[7]<<5|d[7]>>>27}c=this._invSubKeys=[];for(a=0;16>a;a++)c[a]=b[15-a]},encryptBlock:function(b,c){this._doCryptBlock(b,c,this._subKeys)},decryptBlock:function(b,c){this._doCryptBlock(b,c,this._invSubKeys)},_doCryptBlock:function(b,c,a){this._lBlock=b[c];this._rBlock=b[c+1];j.call(this,4,252645135);j.call(this,16,65535);l.call(this,2,858993459);l.call(this,8,16711935);j.call(this,1,1431655765);for(var f=0;16>f;f++){for(var d=a[f],e=this._lBlock,h=this._rBlock,g=0,k=0;8>k;k++)g|=s[k][((h^
d[k])&t[k])>>>0];this._lBlock=h;this._rBlock=e^g}a=this._lBlock;this._lBlock=this._rBlock;this._rBlock=a;j.call(this,1,1431655765);l.call(this,8,16711935);l.call(this,2,858993459);j.call(this,16,65535);j.call(this,4,252645135);b[c]=this._lBlock;b[c+1]=this._rBlock},keySize:2,ivSize:2,blockSize:2});h.DES=e._createHelper(m);g=g.TripleDES=e.extend({_doReset:function(){var b=this._key.words;this._des1=m.createEncryptor(n.create(b.slice(0,2)));this._des2=m.createEncryptor(n.create(b.slice(2,4)));this._des3=
m.createEncryptor(n.create(b.slice(4,6)))},encryptBlock:function(b,c){this._des1.encryptBlock(b,c);this._des2.decryptBlock(b,c);this._des3.encryptBlock(b,c)},decryptBlock:function(b,c){this._des3.decryptBlock(b,c);this._des2.encryptBlock(b,c);this._des1.decryptBlock(b,c)},keySize:6,ivSize:2,blockSize:2});h.TripleDES=e._createHelper(g)})();

/*
CryptoJS v3.1.2 enc-base64.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a<f;a+=3)for(var d=(e[a>>>2]>>>24-8*(a%4)&255)<<16|(e[a+1>>>2]>>>24-8*((a+1)%4)&255)<<8|e[a+2>>>2]>>>24-8*((a+2)%4)&255,g=0;4>g&&a+0.75*g<f;g++)b.push(c.charAt(d>>>6*(3-g)&63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join("")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&&(c=b.indexOf(c),-1!=c&&(e=c));for(var c=[],a=0,d=0;d<
e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))<<2*(d%4),h=f.indexOf(b.charAt(d))>>>6-2*(d%4);c[a>>>2]|=(g|h)<<24-8*(a%4);a++}return j.create(c,a)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();

/*
CryptoJS v3.1.2 md5.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);

/*
CryptoJS v3.1.2 sha1-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var k=CryptoJS,b=k.lib,m=b.WordArray,l=b.Hasher,d=[],b=k.algo.SHA1=l.extend({_doReset:function(){this._hash=new m.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(n,p){for(var a=this._hash.words,e=a[0],f=a[1],h=a[2],j=a[3],b=a[4],c=0;80>c;c++){if(16>c)d[c]=n[p+c]|0;else{var g=d[c-3]^d[c-8]^d[c-14]^d[c-16];d[c]=g<<1|g>>>31}g=(e<<5|e>>>27)+b+d[c];g=20>c?g+((f&h|~f&j)+1518500249):40>c?g+((f^h^j)+1859775393):60>c?g+((f&h|f&j|h&j)-1894007588):g+((f^h^
j)-899497514);b=j;j=h;h=f<<30|f>>>2;f=e;e=g}a[0]=a[0]+e|0;a[1]=a[1]+f|0;a[2]=a[2]+h|0;a[3]=a[3]+j|0;a[4]=a[4]+b|0},_doFinalize:function(){var b=this._data,d=b.words,a=8*this._nDataBytes,e=8*b.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=Math.floor(a/4294967296);d[(e+64>>>9<<4)+15]=a;b.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var b=l.clone.call(this);b._hash=this._hash.clone();return b}});k.SHA1=l._createHelper(b);k.HmacSHA1=l._createHmacHelper(b)})();

/*
CryptoJS v3.1.2 sha256-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(k){for(var g=CryptoJS,h=g.lib,v=h.WordArray,j=h.Hasher,h=g.algo,s=[],t=[],u=function(q){return 4294967296*(q-(q|0))|0},l=2,b=0;64>b;){var d;a:{d=l;for(var w=k.sqrt(d),r=2;r<=w;r++)if(!(d%r)){d=!1;break a}d=!0}d&&(8>b&&(s[b]=u(k.pow(l,0.5))),t[b]=u(k.pow(l,1/3)),b++);l++}var n=[],h=h.SHA256=j.extend({_doReset:function(){this._hash=new v.init(s.slice(0))},_doProcessBlock:function(q,h){for(var a=this._hash.words,c=a[0],d=a[1],b=a[2],k=a[3],f=a[4],g=a[5],j=a[6],l=a[7],e=0;64>e;e++){if(16>e)n[e]=
q[h+e]|0;else{var m=n[e-15],p=n[e-2];n[e]=((m<<25|m>>>7)^(m<<14|m>>>18)^m>>>3)+n[e-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+n[e-16]}m=l+((f<<26|f>>>6)^(f<<21|f>>>11)^(f<<7|f>>>25))+(f&g^~f&j)+t[e]+n[e];p=((c<<30|c>>>2)^(c<<19|c>>>13)^(c<<10|c>>>22))+(c&d^c&b^d&b);l=j;j=g;g=f;f=k+m|0;k=b;b=d;d=c;c=m+p|0}a[0]=a[0]+c|0;a[1]=a[1]+d|0;a[2]=a[2]+b|0;a[3]=a[3]+k|0;a[4]=a[4]+f|0;a[5]=a[5]+g|0;a[6]=a[6]+j|0;a[7]=a[7]+l|0},_doFinalize:function(){var d=this._data,b=d.words,a=8*this._nDataBytes,c=8*d.sigBytes;
b[c>>>5]|=128<<24-c%32;b[(c+64>>>9<<4)+14]=k.floor(a/4294967296);b[(c+64>>>9<<4)+15]=a;d.sigBytes=4*b.length;this._process();return this._hash},clone:function(){var b=j.clone.call(this);b._hash=this._hash.clone();return b}});g.SHA256=j._createHelper(h);g.HmacSHA256=j._createHmacHelper(h)})(Math);

/*
CryptoJS v3.1.2 sha224-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var b=CryptoJS,d=b.lib.WordArray,a=b.algo,c=a.SHA256,a=a.SHA224=c.extend({_doReset:function(){this._hash=new d.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var a=c._doFinalize.call(this);a.sigBytes-=4;return a}});b.SHA224=c._createHelper(a);b.HmacSHA224=c._createHmacHelper(a)})();

/*
CryptoJS v3.1.2 sha512-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){function a(){return d.create.apply(d,arguments)}for(var n=CryptoJS,r=n.lib.Hasher,e=n.x64,d=e.Word,T=e.WordArray,e=n.algo,ea=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),
a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,
2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),
a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,
3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],w=0;80>w;w++)v[w]=a();e=e.SHA512=r.extend({_doReset:function(){this._hash=new T.init([new d.init(1779033703,4089235720),new d.init(3144134277,2227873595),new d.init(1013904242,4271175723),new d.init(2773480762,1595750129),new d.init(1359893119,2917565137),new d.init(2600822924,725511199),new d.init(528734635,4215389547),new d.init(1541459225,327033209)])},_doProcessBlock:function(a,d){for(var f=this._hash.words,
F=f[0],e=f[1],n=f[2],r=f[3],G=f[4],H=f[5],I=f[6],f=f[7],w=F.high,J=F.low,X=e.high,K=e.low,Y=n.high,L=n.low,Z=r.high,M=r.low,$=G.high,N=G.low,aa=H.high,O=H.low,ba=I.high,P=I.low,ca=f.high,Q=f.low,k=w,g=J,z=X,x=K,A=Y,y=L,U=Z,B=M,l=$,h=N,R=aa,C=O,S=ba,D=P,V=ca,E=Q,m=0;80>m;m++){var s=v[m];if(16>m)var j=s.high=a[d+2*m]|0,b=s.low=a[d+2*m+1]|0;else{var j=v[m-15],b=j.high,p=j.low,j=(b>>>1|p<<31)^(b>>>8|p<<24)^b>>>7,p=(p>>>1|b<<31)^(p>>>8|b<<24)^(p>>>7|b<<25),u=v[m-2],b=u.high,c=u.low,u=(b>>>19|c<<13)^(b<<
3|c>>>29)^b>>>6,c=(c>>>19|b<<13)^(c<<3|b>>>29)^(c>>>6|b<<26),b=v[m-7],W=b.high,t=v[m-16],q=t.high,t=t.low,b=p+b.low,j=j+W+(b>>>0<p>>>0?1:0),b=b+c,j=j+u+(b>>>0<c>>>0?1:0),b=b+t,j=j+q+(b>>>0<t>>>0?1:0);s.high=j;s.low=b}var W=l&R^~l&S,t=h&C^~h&D,s=k&z^k&A^z&A,T=g&x^g&y^x&y,p=(k>>>28|g<<4)^(k<<30|g>>>2)^(k<<25|g>>>7),u=(g>>>28|k<<4)^(g<<30|k>>>2)^(g<<25|k>>>7),c=ea[m],fa=c.high,da=c.low,c=E+((h>>>14|l<<18)^(h>>>18|l<<14)^(h<<23|l>>>9)),q=V+((l>>>14|h<<18)^(l>>>18|h<<14)^(l<<23|h>>>9))+(c>>>0<E>>>0?1:
0),c=c+t,q=q+W+(c>>>0<t>>>0?1:0),c=c+da,q=q+fa+(c>>>0<da>>>0?1:0),c=c+b,q=q+j+(c>>>0<b>>>0?1:0),b=u+T,s=p+s+(b>>>0<u>>>0?1:0),V=S,E=D,S=R,D=C,R=l,C=h,h=B+c|0,l=U+q+(h>>>0<B>>>0?1:0)|0,U=A,B=y,A=z,y=x,z=k,x=g,g=c+b|0,k=q+s+(g>>>0<c>>>0?1:0)|0}J=F.low=J+g;F.high=w+k+(J>>>0<g>>>0?1:0);K=e.low=K+x;e.high=X+z+(K>>>0<x>>>0?1:0);L=n.low=L+y;n.high=Y+A+(L>>>0<y>>>0?1:0);M=r.low=M+B;r.high=Z+U+(M>>>0<B>>>0?1:0);N=G.low=N+h;G.high=$+l+(N>>>0<h>>>0?1:0);O=H.low=O+C;H.high=aa+R+(O>>>0<C>>>0?1:0);P=I.low=P+D;
I.high=ba+S+(P>>>0<D>>>0?1:0);Q=f.low=Q+E;f.high=ca+V+(Q>>>0<E>>>0?1:0)},_doFinalize:function(){var a=this._data,d=a.words,f=8*this._nDataBytes,e=8*a.sigBytes;d[e>>>5]|=128<<24-e%32;d[(e+128>>>10<<5)+30]=Math.floor(f/4294967296);d[(e+128>>>10<<5)+31]=f;a.sigBytes=4*d.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});n.SHA512=r._createHelper(e);n.HmacSHA512=r._createHmacHelper(e)})();

/*
CryptoJS v3.1.2 sha384-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var c=CryptoJS,a=c.x64,b=a.Word,e=a.WordArray,a=c.algo,d=a.SHA512,a=a.SHA384=d.extend({_doReset:function(){this._hash=new e.init([new b.init(3418070365,3238371032),new b.init(1654270250,914150663),new b.init(2438529370,812702999),new b.init(355462360,4144912697),new b.init(1731405415,4290775857),new b.init(2394180231,1750603025),new b.init(3675008525,1694076839),new b.init(1203062813,3204075428)])},_doFinalize:function(){var a=d._doFinalize.call(this);a.sigBytes-=16;return a}});c.SHA384=
d._createHelper(a);c.HmacSHA384=d._createHmacHelper(a)})();

/*
CryptoJS v3.1.2 ripemd160-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/*

(c) 2012 by Cedric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function(){var q=CryptoJS,d=q.lib,n=d.WordArray,p=d.Hasher,d=q.algo,x=n.create([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13]),y=n.create([5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11]),z=n.create([11,14,15,12,
5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6]),A=n.create([8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]),B=n.create([0,1518500249,1859775393,2400959708,2840853838]),C=n.create([1352829926,1548603684,1836072691,
2053994217,0]),d=d.RIPEMD160=p.extend({_doReset:function(){this._hash=n.create([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(e,v){for(var b=0;16>b;b++){var c=v+b,f=e[c];e[c]=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360}var c=this._hash.words,f=B.words,d=C.words,n=x.words,q=y.words,p=z.words,w=A.words,t,g,h,j,r,u,k,l,m,s;u=t=c[0];k=g=c[1];l=h=c[2];m=j=c[3];s=r=c[4];for(var a,b=0;80>b;b+=1)a=t+e[v+n[b]]|0,a=16>b?a+((g^h^j)+f[0]):32>b?a+((g&h|~g&j)+f[1]):48>b?
a+(((g|~h)^j)+f[2]):64>b?a+((g&j|h&~j)+f[3]):a+((g^(h|~j))+f[4]),a|=0,a=a<<p[b]|a>>>32-p[b],a=a+r|0,t=r,r=j,j=h<<10|h>>>22,h=g,g=a,a=u+e[v+q[b]]|0,a=16>b?a+((k^(l|~m))+d[0]):32>b?a+((k&m|l&~m)+d[1]):48>b?a+(((k|~l)^m)+d[2]):64>b?a+((k&l|~k&m)+d[3]):a+((k^l^m)+d[4]),a|=0,a=a<<w[b]|a>>>32-w[b],a=a+s|0,u=s,s=m,m=l<<10|l>>>22,l=k,k=a;a=c[1]+h+m|0;c[1]=c[2]+j+s|0;c[2]=c[3]+r+u|0;c[3]=c[4]+t+k|0;c[4]=c[0]+g+l|0;c[0]=a},_doFinalize:function(){var e=this._data,d=e.words,b=8*this._nDataBytes,c=8*e.sigBytes;
d[c>>>5]|=128<<24-c%32;d[(c+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;e.sigBytes=4*(d.length+1);this._process();e=this._hash;d=e.words;for(b=0;5>b;b++)c=d[b],d[b]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return e},clone:function(){var d=p.clone.call(this);d._hash=this._hash.clone();return d}});q.RIPEMD160=p._createHelper(d);q.HmacRIPEMD160=p._createHmacHelper(d)})(Math);

/*
CryptoJS v3.1.2 hmac.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var c=CryptoJS,k=c.enc.Utf8;c.algo.HMAC=c.lib.Base.extend({init:function(a,b){a=this._hasher=new a.init;"string"==typeof b&&(b=k.parse(b));var c=a.blockSize,e=4*c;b.sigBytes>e&&(b=a.finalize(b));b.clamp();for(var f=this._oKey=b.clone(),g=this._iKey=b.clone(),h=f.words,j=g.words,d=0;d<c;d++)h[d]^=1549556828,j[d]^=909522486;f.sigBytes=g.sigBytes=e;this.reset()},reset:function(){var a=this._hasher;a.reset();a.update(this._iKey)},update:function(a){this._hasher.update(a);return this},finalize:function(a){var b=
this._hasher;a=b.finalize(a);b.reset();return b.finalize(this._oKey.clone().concat(a))}})})();

/*
CryptoJS v3.1.2 pbkdf2-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var b=CryptoJS,a=b.lib,d=a.Base,m=a.WordArray,a=b.algo,q=a.HMAC,l=a.PBKDF2=d.extend({cfg:d.extend({keySize:4,hasher:a.SHA1,iterations:1}),init:function(a){this.cfg=this.cfg.extend(a)},compute:function(a,b){for(var c=this.cfg,f=q.create(c.hasher,a),g=m.create(),d=m.create([1]),l=g.words,r=d.words,n=c.keySize,c=c.iterations;l.length<n;){var h=f.update(b).finalize(d);f.reset();for(var j=h.words,s=j.length,k=h,p=1;p<c;p++){k=f.finalize(k);f.reset();for(var t=k.words,e=0;e<s;e++)j[e]^=t[e]}g.concat(h);
r[0]++}g.sigBytes=4*n;return g}});b.PBKDF2=function(a,b,c){return l.create(c).compute(a,b)}})();

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var b64pad="=";function hex2b64(d){var b;var e;var a="";for(b=0;b+3<=d.length;b+=3){e=parseInt(d.substring(b,b+3),16);a+=b64map.charAt(e>>6)+b64map.charAt(e&63)}if(b+1==d.length){e=parseInt(d.substring(b,b+1),16);a+=b64map.charAt(e<<2)}else{if(b+2==d.length){e=parseInt(d.substring(b,b+2),16);a+=b64map.charAt(e>>2)+b64map.charAt((e&3)<<4)}}if(b64pad){while((a.length&3)>0){a+=b64pad}}return a}function b64tohex(f){var d="";var e;var b=0;var c;var a;for(e=0;e<f.length;++e){if(f.charAt(e)==b64pad){break}a=b64map.indexOf(f.charAt(e));if(a<0){continue}if(b==0){d+=int2char(a>>2);c=a&3;b=1}else{if(b==1){d+=int2char((c<<2)|(a>>4));c=a&15;b=2}else{if(b==2){d+=int2char(c);d+=int2char(a>>2);c=a&3;b=3}else{d+=int2char((c<<2)|(a>>4));d+=int2char(a&15);b=0}}}}if(b==1){d+=int2char(c<<2)}return d}function b64toBA(e){var d=b64tohex(e);var c;var b=new Array();for(c=0;2*c<d.length;++c){b[c]=parseInt(d.substring(2*c,2*c+2),16)}return b};
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits;var canary=244837814094590;var j_lm=((canary&16777215)==15715070);function BigInteger(e,d,f){if(e!=null){if("number"==typeof e){this.fromNumber(e,d,f)}else{if(d==null&&"string"!=typeof e){this.fromString(e,256)}else{this.fromString(e,d)}}}}function nbi(){return new BigInteger(null)}function am1(f,a,b,e,h,g){while(--g>=0){var d=a*this[f++]+b[e]+h;h=Math.floor(d/67108864);b[e++]=d&67108863}return h}function am2(f,q,r,e,o,a){var k=q&32767,p=q>>15;while(--a>=0){var d=this[f]&32767;var g=this[f++]>>15;var b=p*d+g*k;d=k*d+((b&32767)<<15)+r[e]+(o&1073741823);o=(d>>>30)+(b>>>15)+p*g+(o>>>30);r[e++]=d&1073741823}return o}function am3(f,q,r,e,o,a){var k=q&16383,p=q>>14;while(--a>=0){var d=this[f]&16383;var g=this[f++]>>14;var b=p*d+g*k;d=k*d+((b&16383)<<14)+r[e]+o;o=(d>>28)+(b>>14)+p*g;r[e++]=d&268435455}return o}if(j_lm&&(navigator.appName=="Microsoft Internet Explorer")){BigInteger.prototype.am=am2;dbits=30}else{if(j_lm&&(navigator.appName!="Netscape")){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=((1<<dbits)-1);BigInteger.prototype.DV=(1<<dbits);var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array();var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv){BI_RC[rr++]=vv}rr="a".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}rr="A".charCodeAt(0);for(vv=10;vv<36;++vv){BI_RC[rr++]=vv}function int2char(a){return BI_RM.charAt(a)}function intAt(b,a){var d=BI_RC[b.charCodeAt(a)];return(d==null)?-1:d}function bnpCopyTo(b){for(var a=this.t-1;a>=0;--a){b[a]=this[a]}b.t=this.t;b.s=this.s}function bnpFromInt(a){this.t=1;this.s=(a<0)?-1:0;if(a>0){this[0]=a}else{if(a<-1){this[0]=a+this.DV}else{this.t=0}}}function nbv(a){var b=nbi();b.fromInt(a);return b}function bnpFromString(h,c){var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==256){e=8}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{this.fromRadix(h,c);return}}}}}}this.t=0;this.s=0;var g=h.length,d=false,f=0;while(--g>=0){var a=(e==8)?h[g]&255:intAt(h,g);if(a<0){if(h.charAt(g)=="-"){d=true}continue}d=false;if(f==0){this[this.t++]=a}else{if(f+e>this.DB){this[this.t-1]|=(a&((1<<(this.DB-f))-1))<<f;this[this.t++]=(a>>(this.DB-f))}else{this[this.t-1]|=a<<f}}f+=e;if(f>=this.DB){f-=this.DB}}if(e==8&&(h[0]&128)!=0){this.s=-1;if(f>0){this[this.t-1]|=((1<<(this.DB-f))-1)<<f}}this.clamp();if(d){BigInteger.ZERO.subTo(this,this)}}function bnpClamp(){var a=this.s&this.DM;while(this.t>0&&this[this.t-1]==a){--this.t}}function bnToString(c){if(this.s<0){return"-"+this.negate().toString(c)}var e;if(c==16){e=4}else{if(c==8){e=3}else{if(c==2){e=1}else{if(c==32){e=5}else{if(c==4){e=2}else{return this.toRadix(c)}}}}}var g=(1<<e)-1,l,a=false,h="",f=this.t;var j=this.DB-(f*this.DB)%e;if(f-->0){if(j<this.DB&&(l=this[f]>>j)>0){a=true;h=int2char(l)}while(f>=0){if(j<e){l=(this[f]&((1<<j)-1))<<(e-j);l|=this[--f]>>(j+=this.DB-e)}else{l=(this[f]>>(j-=e))&g;if(j<=0){j+=this.DB;--f}}if(l>0){a=true}if(a){h+=int2char(l)}}}return a?h:"0"}function bnNegate(){var a=nbi();BigInteger.ZERO.subTo(this,a);return a}function bnAbs(){return(this.s<0)?this.negate():this}function bnCompareTo(b){var d=this.s-b.s;if(d!=0){return d}var c=this.t;d=c-b.t;if(d!=0){return(this.s<0)?-d:d}while(--c>=0){if((d=this[c]-b[c])!=0){return d}}return 0}function nbits(a){var c=1,b;if((b=a>>>16)!=0){a=b;c+=16}if((b=a>>8)!=0){a=b;c+=8}if((b=a>>4)!=0){a=b;c+=4}if((b=a>>2)!=0){a=b;c+=2}if((b=a>>1)!=0){a=b;c+=1}return c}function bnBitLength(){if(this.t<=0){return 0}return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM))}function bnpDLShiftTo(c,b){var a;for(a=this.t-1;a>=0;--a){b[a+c]=this[a]}for(a=c-1;a>=0;--a){b[a]=0}b.t=this.t+c;b.s=this.s}function bnpDRShiftTo(c,b){for(var a=c;a<this.t;++a){b[a-c]=this[a]}b.t=Math.max(this.t-c,0);b.s=this.s}function bnpLShiftTo(j,e){var b=j%this.DB;var a=this.DB-b;var g=(1<<a)-1;var f=Math.floor(j/this.DB),h=(this.s<<b)&this.DM,d;for(d=this.t-1;d>=0;--d){e[d+f+1]=(this[d]>>a)|h;h=(this[d]&g)<<b}for(d=f-1;d>=0;--d){e[d]=0}e[f]=h;e.t=this.t+f+1;e.s=this.s;e.clamp()}function bnpRShiftTo(g,d){d.s=this.s;var e=Math.floor(g/this.DB);if(e>=this.t){d.t=0;return}var b=g%this.DB;var a=this.DB-b;var f=(1<<b)-1;d[0]=this[e]>>b;for(var c=e+1;c<this.t;++c){d[c-e-1]|=(this[c]&f)<<a;d[c-e]=this[c]>>b}if(b>0){d[this.t-e-1]|=(this.s&f)<<a}d.t=this.t-e;d.clamp()}function bnpSubTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]-d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g-=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g-=d[e];f[e++]=g&this.DM;g>>=this.DB}g-=d.s}f.s=(g<0)?-1:0;if(g<-1){f[e++]=this.DV+g}else{if(g>0){f[e++]=g}}f.t=e;f.clamp()}function bnpMultiplyTo(c,e){var b=this.abs(),f=c.abs();var d=b.t;e.t=d+f.t;while(--d>=0){e[d]=0}for(d=0;d<f.t;++d){e[d+b.t]=b.am(0,f[d],e,d,0,b.t)}e.s=0;e.clamp();if(this.s!=c.s){BigInteger.ZERO.subTo(e,e)}}function bnpSquareTo(d){var a=this.abs();var b=d.t=2*a.t;while(--b>=0){d[b]=0}for(b=0;b<a.t-1;++b){var e=a.am(b,a[b],d,2*b,0,1);if((d[b+a.t]+=a.am(b+1,2*a[b],d,2*b+1,e,a.t-b-1))>=a.DV){d[b+a.t]-=a.DV;d[b+a.t+1]=1}}if(d.t>0){d[d.t-1]+=a.am(b,a[b],d,2*b,0,1)}d.s=0;d.clamp()}function bnpDivRemTo(n,h,g){var w=n.abs();if(w.t<=0){return}var k=this.abs();if(k.t<w.t){if(h!=null){h.fromInt(0)}if(g!=null){this.copyTo(g)}return}if(g==null){g=nbi()}var d=nbi(),a=this.s,l=n.s;var v=this.DB-nbits(w[w.t-1]);if(v>0){w.lShiftTo(v,d);k.lShiftTo(v,g)}else{w.copyTo(d);k.copyTo(g)}var p=d.t;var b=d[p-1];if(b==0){return}var o=b*(1<<this.F1)+((p>1)?d[p-2]>>this.F2:0);var A=this.FV/o,z=(1<<this.F1)/o,x=1<<this.F2;var u=g.t,s=u-p,f=(h==null)?nbi():h;d.dlShiftTo(s,f);if(g.compareTo(f)>=0){g[g.t++]=1;g.subTo(f,g)}BigInteger.ONE.dlShiftTo(p,f);f.subTo(d,d);while(d.t<p){d[d.t++]=0}while(--s>=0){var c=(g[--u]==b)?this.DM:Math.floor(g[u]*A+(g[u-1]+x)*z);if((g[u]+=d.am(0,c,g,s,0,p))<c){d.dlShiftTo(s,f);g.subTo(f,g);while(g[u]<--c){g.subTo(f,g)}}}if(h!=null){g.drShiftTo(p,h);if(a!=l){BigInteger.ZERO.subTo(h,h)}}g.t=p;g.clamp();if(v>0){g.rShiftTo(v,g)}if(a<0){BigInteger.ZERO.subTo(g,g)}}function bnMod(b){var c=nbi();this.abs().divRemTo(b,null,c);if(this.s<0&&c.compareTo(BigInteger.ZERO)>0){b.subTo(c,c)}return c}function Classic(a){this.m=a}function cConvert(a){if(a.s<0||a.compareTo(this.m)>=0){return a.mod(this.m)}else{return a}}function cRevert(a){return a}function cReduce(a){a.divRemTo(this.m,null,a)}function cMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}function cSqrTo(a,b){a.squareTo(b);this.reduce(b)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1){return 0}var a=this[0];if((a&1)==0){return 0}var b=a&3;b=(b*(2-(a&15)*b))&15;b=(b*(2-(a&255)*b))&255;b=(b*(2-(((a&65535)*b)&65535)))&65535;b=(b*(2-a*b%this.DV))%this.DV;return(b>0)?this.DV-b:-b}function Montgomery(a){this.m=a;this.mp=a.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<(a.DB-15))-1;this.mt2=2*a.t}function montConvert(a){var b=nbi();a.abs().dlShiftTo(this.m.t,b);b.divRemTo(this.m,null,b);if(a.s<0&&b.compareTo(BigInteger.ZERO)>0){this.m.subTo(b,b)}return b}function montRevert(a){var b=nbi();a.copyTo(b);this.reduce(b);return b}function montReduce(a){while(a.t<=this.mt2){a[a.t++]=0}for(var c=0;c<this.m.t;++c){var b=a[c]&32767;var d=(b*this.mpl+(((b*this.mph+(a[c]>>15)*this.mpl)&this.um)<<15))&a.DM;b=c+this.m.t;a[b]+=this.m.am(0,d,a,c,0,this.m.t);while(a[b]>=a.DV){a[b]-=a.DV;a[++b]++}}a.clamp();a.drShiftTo(this.m.t,a);if(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function montSqrTo(a,b){a.squareTo(b);this.reduce(b)}function montMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return((this.t>0)?(this[0]&1):this.s)==0}function bnpExp(h,j){if(h>4294967295||h<1){return BigInteger.ONE}var f=nbi(),a=nbi(),d=j.convert(this),c=nbits(h)-1;d.copyTo(f);while(--c>=0){j.sqrTo(f,a);if((h&(1<<c))>0){j.mulTo(a,d,f)}else{var b=f;f=a;a=b}}return j.revert(f)}function bnModPowInt(b,a){var c;if(b<256||a.isEven()){c=new Classic(a)}else{c=new Montgomery(a)}return this.exp(b,c)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function bnClone(){var a=nbi();this.copyTo(a);return a}function bnIntValue(){if(this.s<0){if(this.t==1){return this[0]-this.DV}else{if(this.t==0){return -1}}}else{if(this.t==1){return this[0]}else{if(this.t==0){return 0}}}return((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0]}function bnByteValue(){return(this.t==0)?this.s:(this[0]<<24)>>24}function bnShortValue(){return(this.t==0)?this.s:(this[0]<<16)>>16}function bnpChunkSize(a){return Math.floor(Math.LN2*this.DB/Math.log(a))}function bnSigNum(){if(this.s<0){return -1}else{if(this.t<=0||(this.t==1&&this[0]<=0)){return 0}else{return 1}}}function bnpToRadix(c){if(c==null){c=10}if(this.signum()==0||c<2||c>36){return"0"}var f=this.chunkSize(c);var e=Math.pow(c,f);var i=nbv(e),j=nbi(),h=nbi(),g="";this.divRemTo(i,j,h);while(j.signum()>0){g=(e+h.intValue()).toString(c).substr(1)+g;j.divRemTo(i,j,h)}return h.intValue().toString(c)+g}function bnpFromRadix(m,h){this.fromInt(0);if(h==null){h=10}var f=this.chunkSize(h);var g=Math.pow(h,f),e=false,a=0,l=0;for(var c=0;c<m.length;++c){var k=intAt(m,c);if(k<0){if(m.charAt(c)=="-"&&this.signum()==0){e=true}continue}l=h*l+k;if(++a>=f){this.dMultiply(g);this.dAddOffset(l,0);a=0;l=0}}if(a>0){this.dMultiply(Math.pow(h,a));this.dAddOffset(l,0)}if(e){BigInteger.ZERO.subTo(this,this)}}function bnpFromNumber(f,e,h){if("number"==typeof e){if(f<2){this.fromInt(1)}else{this.fromNumber(f,h);if(!this.testBit(f-1)){this.bitwiseTo(BigInteger.ONE.shiftLeft(f-1),op_or,this)}if(this.isEven()){this.dAddOffset(1,0)}while(!this.isProbablePrime(e)){this.dAddOffset(2,0);if(this.bitLength()>f){this.subTo(BigInteger.ONE.shiftLeft(f-1),this)}}}}else{var d=new Array(),g=f&7;d.length=(f>>3)+1;e.nextBytes(d);if(g>0){d[0]&=((1<<g)-1)}else{d[0]=0}this.fromString(d,256)}}function bnToByteArray(){var b=this.t,c=new Array();c[0]=this.s;var e=this.DB-(b*this.DB)%8,f,a=0;if(b-->0){if(e<this.DB&&(f=this[b]>>e)!=(this.s&this.DM)>>e){c[a++]=f|(this.s<<(this.DB-e))}while(b>=0){if(e<8){f=(this[b]&((1<<e)-1))<<(8-e);f|=this[--b]>>(e+=this.DB-8)}else{f=(this[b]>>(e-=8))&255;if(e<=0){e+=this.DB;--b}}if((f&128)!=0){f|=-256}if(a==0&&(this.s&128)!=(f&128)){++a}if(a>0||f!=this.s){c[a++]=f}}}return c}function bnEquals(b){return(this.compareTo(b)==0)}function bnMin(b){return(this.compareTo(b)<0)?this:b}function bnMax(b){return(this.compareTo(b)>0)?this:b}function bnpBitwiseTo(c,h,e){var d,g,b=Math.min(c.t,this.t);for(d=0;d<b;++d){e[d]=h(this[d],c[d])}if(c.t<this.t){g=c.s&this.DM;for(d=b;d<this.t;++d){e[d]=h(this[d],g)}e.t=this.t}else{g=this.s&this.DM;for(d=b;d<c.t;++d){e[d]=h(g,c[d])}e.t=c.t}e.s=h(this.s,c.s);e.clamp()}function op_and(a,b){return a&b}function bnAnd(b){var c=nbi();this.bitwiseTo(b,op_and,c);return c}function op_or(a,b){return a|b}function bnOr(b){var c=nbi();this.bitwiseTo(b,op_or,c);return c}function op_xor(a,b){return a^b}function bnXor(b){var c=nbi();this.bitwiseTo(b,op_xor,c);return c}function op_andnot(a,b){return a&~b}function bnAndNot(b){var c=nbi();this.bitwiseTo(b,op_andnot,c);return c}function bnNot(){var b=nbi();for(var a=0;a<this.t;++a){b[a]=this.DM&~this[a]}b.t=this.t;b.s=~this.s;return b}function bnShiftLeft(b){var a=nbi();if(b<0){this.rShiftTo(-b,a)}else{this.lShiftTo(b,a)}return a}function bnShiftRight(b){var a=nbi();if(b<0){this.lShiftTo(-b,a)}else{this.rShiftTo(b,a)}return a}function lbit(a){if(a==0){return -1}var b=0;if((a&65535)==0){a>>=16;b+=16}if((a&255)==0){a>>=8;b+=8}if((a&15)==0){a>>=4;b+=4}if((a&3)==0){a>>=2;b+=2}if((a&1)==0){++b}return b}function bnGetLowestSetBit(){for(var a=0;a<this.t;++a){if(this[a]!=0){return a*this.DB+lbit(this[a])}}if(this.s<0){return this.t*this.DB}return -1}function cbit(a){var b=0;while(a!=0){a&=a-1;++b}return b}function bnBitCount(){var c=0,a=this.s&this.DM;for(var b=0;b<this.t;++b){c+=cbit(this[b]^a)}return c}function bnTestBit(b){var a=Math.floor(b/this.DB);if(a>=this.t){return(this.s!=0)}return((this[a]&(1<<(b%this.DB)))!=0)}function bnpChangeBit(c,b){var a=BigInteger.ONE.shiftLeft(c);this.bitwiseTo(a,b,a);return a}function bnSetBit(a){return this.changeBit(a,op_or)}function bnClearBit(a){return this.changeBit(a,op_andnot)}function bnFlipBit(a){return this.changeBit(a,op_xor)}function bnpAddTo(d,f){var e=0,g=0,b=Math.min(d.t,this.t);while(e<b){g+=this[e]+d[e];f[e++]=g&this.DM;g>>=this.DB}if(d.t<this.t){g+=d.s;while(e<this.t){g+=this[e];f[e++]=g&this.DM;g>>=this.DB}g+=this.s}else{g+=this.s;while(e<d.t){g+=d[e];f[e++]=g&this.DM;g>>=this.DB}g+=d.s}f.s=(g<0)?-1:0;if(g>0){f[e++]=g}else{if(g<-1){f[e++]=this.DV+g}}f.t=e;f.clamp()}function bnAdd(b){var c=nbi();this.addTo(b,c);return c}function bnSubtract(b){var c=nbi();this.subTo(b,c);return c}function bnMultiply(b){var c=nbi();this.multiplyTo(b,c);return c}function bnSquare(){var a=nbi();this.squareTo(a);return a}function bnDivide(b){var c=nbi();this.divRemTo(b,c,null);return c}function bnRemainder(b){var c=nbi();this.divRemTo(b,null,c);return c}function bnDivideAndRemainder(b){var d=nbi(),c=nbi();this.divRemTo(b,d,c);return new Array(d,c)}function bnpDMultiply(a){this[this.t]=this.am(0,a-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(b,a){if(b==0){return}while(this.t<=a){this[this.t++]=0}this[a]+=b;while(this[a]>=this.DV){this[a]-=this.DV;if(++a>=this.t){this[this.t++]=0}++this[a]}}function NullExp(){}function nNop(a){return a}function nMulTo(a,c,b){a.multiplyTo(c,b)}function nSqrTo(a,b){a.squareTo(b)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(a){return this.exp(a,new NullExp())}function bnpMultiplyLowerTo(b,f,e){var d=Math.min(this.t+b.t,f);e.s=0;e.t=d;while(d>0){e[--d]=0}var c;for(c=e.t-this.t;d<c;++d){e[d+this.t]=this.am(0,b[d],e,d,0,this.t)}for(c=Math.min(b.t,f);d<c;++d){this.am(0,b[d],e,d,0,f-d)}e.clamp()}function bnpMultiplyUpperTo(b,e,d){--e;var c=d.t=this.t+b.t-e;d.s=0;while(--c>=0){d[c]=0}for(c=Math.max(e-this.t,0);c<b.t;++c){d[this.t+c-e]=this.am(e-c,b[c],d,0,0,this.t+c-e)}d.clamp();d.drShiftTo(1,d)}function Barrett(a){this.r2=nbi();this.q3=nbi();BigInteger.ONE.dlShiftTo(2*a.t,this.r2);this.mu=this.r2.divide(a);this.m=a}function barrettConvert(a){if(a.s<0||a.t>2*this.m.t){return a.mod(this.m)}else{if(a.compareTo(this.m)<0){return a}else{var b=nbi();a.copyTo(b);this.reduce(b);return b}}}function barrettRevert(a){return a}function barrettReduce(a){a.drShiftTo(this.m.t-1,this.r2);if(a.t>this.m.t+1){a.t=this.m.t+1;a.clamp()}this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);while(a.compareTo(this.r2)<0){a.dAddOffset(1,this.m.t+1)}a.subTo(this.r2,a);while(a.compareTo(this.m)>=0){a.subTo(this.m,a)}}function barrettSqrTo(a,b){a.squareTo(b);this.reduce(b)}function barrettMulTo(a,c,b){a.multiplyTo(c,b);this.reduce(b)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(q,f){var o=q.bitLength(),h,b=nbv(1),v;if(o<=0){return b}else{if(o<18){h=1}else{if(o<48){h=3}else{if(o<144){h=4}else{if(o<768){h=5}else{h=6}}}}}if(o<8){v=new Classic(f)}else{if(f.isEven()){v=new Barrett(f)}else{v=new Montgomery(f)}}var p=new Array(),d=3,s=h-1,a=(1<<h)-1;p[1]=v.convert(this);if(h>1){var A=nbi();v.sqrTo(p[1],A);while(d<=a){p[d]=nbi();v.mulTo(A,p[d-2],p[d]);d+=2}}var l=q.t-1,x,u=true,c=nbi(),y;o=nbits(q[l])-1;while(l>=0){if(o>=s){x=(q[l]>>(o-s))&a}else{x=(q[l]&((1<<(o+1))-1))<<(s-o);if(l>0){x|=q[l-1]>>(this.DB+o-s)}}d=h;while((x&1)==0){x>>=1;--d}if((o-=d)<0){o+=this.DB;--l}if(u){p[x].copyTo(b);u=false}else{while(d>1){v.sqrTo(b,c);v.sqrTo(c,b);d-=2}if(d>0){v.sqrTo(b,c)}else{y=b;b=c;c=y}v.mulTo(c,p[x],b)}while(l>=0&&(q[l]&(1<<o))==0){v.sqrTo(b,c);y=b;b=c;c=y;if(--o<0){o=this.DB-1;--l}}}return v.revert(b)}function bnGCD(c){var b=(this.s<0)?this.negate():this.clone();var h=(c.s<0)?c.negate():c.clone();if(b.compareTo(h)<0){var e=b;b=h;h=e}var d=b.getLowestSetBit(),f=h.getLowestSetBit();if(f<0){return b}if(d<f){f=d}if(f>0){b.rShiftTo(f,b);h.rShiftTo(f,h)}while(b.signum()>0){if((d=b.getLowestSetBit())>0){b.rShiftTo(d,b)}if((d=h.getLowestSetBit())>0){h.rShiftTo(d,h)}if(b.compareTo(h)>=0){b.subTo(h,b);b.rShiftTo(1,b)}else{h.subTo(b,h);h.rShiftTo(1,h)}}if(f>0){h.lShiftTo(f,h)}return h}function bnpModInt(e){if(e<=0){return 0}var c=this.DV%e,b=(this.s<0)?e-1:0;if(this.t>0){if(c==0){b=this[0]%e}else{for(var a=this.t-1;a>=0;--a){b=(c*b+this[a])%e}}}return b}function bnModInverse(f){var j=f.isEven();if((this.isEven()&&j)||f.signum()==0){return BigInteger.ZERO}var i=f.clone(),h=this.clone();var g=nbv(1),e=nbv(0),l=nbv(0),k=nbv(1);while(i.signum()!=0){while(i.isEven()){i.rShiftTo(1,i);if(j){if(!g.isEven()||!e.isEven()){g.addTo(this,g);e.subTo(f,e)}g.rShiftTo(1,g)}else{if(!e.isEven()){e.subTo(f,e)}}e.rShiftTo(1,e)}while(h.isEven()){h.rShiftTo(1,h);if(j){if(!l.isEven()||!k.isEven()){l.addTo(this,l);k.subTo(f,k)}l.rShiftTo(1,l)}else{if(!k.isEven()){k.subTo(f,k)}}k.rShiftTo(1,k)}if(i.compareTo(h)>=0){i.subTo(h,i);if(j){g.subTo(l,g)}e.subTo(k,e)}else{h.subTo(i,h);if(j){l.subTo(g,l)}k.subTo(e,k)}}if(h.compareTo(BigInteger.ONE)!=0){return BigInteger.ZERO}if(k.compareTo(f)>=0){return k.subtract(f)}if(k.signum()<0){k.addTo(f,k)}else{return k}if(k.signum()<0){return k.add(f)}else{return k}}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];var lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(e){var d,b=this.abs();if(b.t==1&&b[0]<=lowprimes[lowprimes.length-1]){for(d=0;d<lowprimes.length;++d){if(b[0]==lowprimes[d]){return true}}return false}if(b.isEven()){return false}d=1;while(d<lowprimes.length){var a=lowprimes[d],c=d+1;while(c<lowprimes.length&&a<lplim){a*=lowprimes[c++]}a=b.modInt(a);while(d<c){if(a%lowprimes[d++]==0){return false}}}return b.millerRabin(e)}function bnpMillerRabin(f){var g=this.subtract(BigInteger.ONE);var c=g.getLowestSetBit();if(c<=0){return false}var h=g.shiftRight(c);f=(f+1)>>1;if(f>lowprimes.length){f=lowprimes.length}var b=nbi();for(var e=0;e<f;++e){b.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);var l=b.modPow(h,this);if(l.compareTo(BigInteger.ONE)!=0&&l.compareTo(g)!=0){var d=1;while(d++<c&&l.compareTo(g)!=0){l=l.modPowInt(2,this);if(l.compareTo(BigInteger.ONE)==0){return false}}if(l.compareTo(g)!=0){return false}}}return true}BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.fromNumber=bnpFromNumber;BigInteger.prototype.bitwiseTo=bnpBitwiseTo;BigInteger.prototype.changeBit=bnpChangeBit;BigInteger.prototype.addTo=bnpAddTo;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger.prototype.modInt=bnpModInt;BigInteger.prototype.millerRabin=bnpMillerRabin;BigInteger.prototype.clone=bnClone;BigInteger.prototype.intValue=bnIntValue;BigInteger.prototype.byteValue=bnByteValue;BigInteger.prototype.shortValue=bnShortValue;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.toByteArray=bnToByteArray;BigInteger.prototype.equals=bnEquals;BigInteger.prototype.min=bnMin;BigInteger.prototype.max=bnMax;BigInteger.prototype.and=bnAnd;BigInteger.prototype.or=bnOr;BigInteger.prototype.xor=bnXor;BigInteger.prototype.andNot=bnAndNot;BigInteger.prototype.not=bnNot;BigInteger.prototype.shiftLeft=bnShiftLeft;BigInteger.prototype.shiftRight=bnShiftRight;BigInteger.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger.prototype.bitCount=bnBitCount;BigInteger.prototype.testBit=bnTestBit;BigInteger.prototype.setBit=bnSetBit;BigInteger.prototype.clearBit=bnClearBit;BigInteger.prototype.flipBit=bnFlipBit;BigInteger.prototype.add=bnAdd;BigInteger.prototype.subtract=bnSubtract;BigInteger.prototype.multiply=bnMultiply;BigInteger.prototype.divide=bnDivide;BigInteger.prototype.remainder=bnRemainder;BigInteger.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger.prototype.modPow=bnModPow;BigInteger.prototype.modInverse=bnModInverse;BigInteger.prototype.pow=bnPow;BigInteger.prototype.gcd=bnGCD;BigInteger.prototype.isProbablePrime=bnIsProbablePrime;BigInteger.prototype.square=bnSquare;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function Arcfour(){this.i=0;this.j=0;this.S=new Array()}function ARC4init(d){var c,a,b;for(c=0;c<256;++c){this.S[c]=c}a=0;for(c=0;c<256;++c){a=(a+this.S[c]+d[c%d.length])&255;b=this.S[c];this.S[c]=this.S[a];this.S[a]=b}this.i=0;this.j=0}function ARC4next(){var a;this.i=(this.i+1)&255;this.j=(this.j+this.S[this.i])&255;a=this.S[this.i];this.S[this.i]=this.S[this.j];this.S[this.j]=a;return this.S[(a+this.S[this.i])&255]}Arcfour.prototype.init=ARC4init;Arcfour.prototype.next=ARC4next;function prng_newstate(){return new Arcfour()}var rng_psize=256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var rng_state;var rng_pool;var rng_pptr;function rng_seed_int(a){rng_pool[rng_pptr++]^=a&255;rng_pool[rng_pptr++]^=(a>>8)&255;rng_pool[rng_pptr++]^=(a>>16)&255;rng_pool[rng_pptr++]^=(a>>24)&255;if(rng_pptr>=rng_psize){rng_pptr-=rng_psize}}function rng_seed_time(){rng_seed_int(new Date().getTime())}if(rng_pool==null){rng_pool=new Array();rng_pptr=0;var t;if(window!==undefined&&(window.crypto!==undefined||window.msCrypto!==undefined)){var crypto=window.crypto||window.msCrypto;if(crypto.getRandomValues){var ua=new Uint8Array(32);crypto.getRandomValues(ua);for(t=0;t<32;++t){rng_pool[rng_pptr++]=ua[t]}}else{if(navigator.appName=="Netscape"&&navigator.appVersion<"5"){var z=window.crypto.random(32);for(t=0;t<z.length;++t){rng_pool[rng_pptr++]=z.charCodeAt(t)&255}}}}while(rng_pptr<rng_psize){t=Math.floor(65536*Math.random());rng_pool[rng_pptr++]=t>>>8;rng_pool[rng_pptr++]=t&255}rng_pptr=0;rng_seed_time()}function rng_get_byte(){if(rng_state==null){rng_seed_time();rng_state=prng_newstate();rng_state.init(rng_pool);for(rng_pptr=0;rng_pptr<rng_pool.length;++rng_pptr){rng_pool[rng_pptr]=0}rng_pptr=0}return rng_state.next()}function rng_get_bytes(b){var a;for(a=0;a<b.length;++a){b[a]=rng_get_byte()}}function SecureRandom(){}SecureRandom.prototype.nextBytes=rng_get_bytes;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function parseBigInt(b,a){return new BigInteger(b,a)}function linebrk(c,d){var a="";var b=0;while(b+d<c.length){a+=c.substring(b,b+d)+"\n";b+=d}return a+c.substring(b,c.length)}function byte2Hex(a){if(a<16){return"0"+a.toString(16)}else{return a.toString(16)}}function pkcs1pad2(e,h){if(h<e.length+11){throw"Message too long for RSA";return null}var g=new Array();var d=e.length-1;while(d>=0&&h>0){var f=e.charCodeAt(d--);if(f<128){g[--h]=f}else{if((f>127)&&(f<2048)){g[--h]=(f&63)|128;g[--h]=(f>>6)|192}else{g[--h]=(f&63)|128;g[--h]=((f>>6)&63)|128;g[--h]=(f>>12)|224}}}g[--h]=0;var b=new SecureRandom();var a=new Array();while(h>2){a[0]=0;while(a[0]==0){b.nextBytes(a)}g[--h]=a[0]}g[--h]=2;g[--h]=0;return new BigInteger(g)}function oaep_mgf1_arr(c,a,e){var b="",d=0;while(b.length<a){b+=e(String.fromCharCode.apply(String,c.concat([(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255])));d+=1}return b}function oaep_pad(q,a,f,l){var c=KJUR.crypto.MessageDigest;var o=KJUR.crypto.Util;var b=null;if(!f){f="sha1"}if(typeof f==="string"){b=c.getCanonicalAlgName(f);l=c.getHashLength(b);f=function(i){return hextorstr(o.hashHex(rstrtohex(i),b))}}if(q.length+2*l+2>a){throw"Message too long for RSA"}var k="",e;for(e=0;e<a-q.length-2*l-2;e+=1){k+="\x00"}var h=f("")+k+"\x01"+q;var g=new Array(l);new SecureRandom().nextBytes(g);var j=oaep_mgf1_arr(g,h.length,f);var p=[];for(e=0;e<h.length;e+=1){p[e]=h.charCodeAt(e)^j.charCodeAt(e)}var m=oaep_mgf1_arr(p,g.length,f);var d=[0];for(e=0;e<g.length;e+=1){d[e+1]=g[e]^m.charCodeAt(e)}return new BigInteger(d.concat(p))}function RSAKey(){this.n=null;this.e=0;this.d=null;this.p=null;this.q=null;this.dmp1=null;this.dmq1=null;this.coeff=null}function RSASetPublic(b,a){this.isPublic=true;this.isPrivate=false;if(typeof b!=="string"){this.n=b;this.e=a}else{if(b!=null&&a!=null&&b.length>0&&a.length>0){this.n=parseBigInt(b,16);this.e=parseInt(a,16)}else{throw"Invalid RSA public key"}}}function RSADoPublic(a){return a.modPowInt(this.e,this.n)}function RSAEncrypt(d){var a=pkcs1pad2(d,(this.n.bitLength()+7)>>3);if(a==null){return null}var e=this.doPublic(a);if(e==null){return null}var b=e.toString(16);if((b.length&1)==0){return b}else{return"0"+b}}function RSAEncryptOAEP(f,e,b){var a=oaep_pad(f,(this.n.bitLength()+7)>>3,e,b);if(a==null){return null}var g=this.doPublic(a);if(g==null){return null}var d=g.toString(16);if((d.length&1)==0){return d}else{return"0"+d}}RSAKey.prototype.doPublic=RSADoPublic;RSAKey.prototype.setPublic=RSASetPublic;RSAKey.prototype.encrypt=RSAEncrypt;RSAKey.prototype.encryptOAEP=RSAEncryptOAEP;RSAKey.prototype.type="RSA";
/*! (c) Tom Wu, Kenji Urushima | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function pkcs1unpad2(g,j){var a=g.toByteArray();var f=0;while(f<a.length&&a[f]==0){++f}if(a.length-f!=j-1||a[f]!=2){return null}++f;while(a[f]!=0){if(++f>=a.length){return null}}var e="";while(++f<a.length){var h=a[f]&255;if(h<128){e+=String.fromCharCode(h)}else{if((h>191)&&(h<224)){e+=String.fromCharCode(((h&31)<<6)|(a[f+1]&63));++f}else{e+=String.fromCharCode(((h&15)<<12)|((a[f+1]&63)<<6)|(a[f+2]&63));f+=2}}}return e}function oaep_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=e(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]));d+=1}return b}function oaep_unpad(o,b,g,p){var e=KJUR.crypto.MessageDigest;var r=KJUR.crypto.Util;var c=null;if(!g){g="sha1"}if(typeof g==="string"){c=e.getCanonicalAlgName(g);p=e.getHashLength(c);g=function(d){return hextorstr(r.hashHex(rstrtohex(d),c))}}o=o.toByteArray();var h;for(h=0;h<o.length;h+=1){o[h]&=255}while(o.length<b){o.unshift(0)}o=String.fromCharCode.apply(String,o);if(o.length<2*p+2){throw"Cipher too short"}var f=o.substr(1,p);var s=o.substr(p+1);var q=oaep_mgf1_str(s,p,g);var k=[],h;for(h=0;h<f.length;h+=1){k[h]=f.charCodeAt(h)^q.charCodeAt(h)}var l=oaep_mgf1_str(String.fromCharCode.apply(String,k),o.length-p,g);var j=[];for(h=0;h<s.length;h+=1){j[h]=s.charCodeAt(h)^l.charCodeAt(h)}j=String.fromCharCode.apply(String,j);if(j.substr(0,p)!==g("")){throw"Hash mismatch"}j=j.substr(p);var a=j.indexOf("\x01");var m=(a!=-1)?j.substr(0,a).lastIndexOf("\x00"):-1;if(m+1!=a){throw"Malformed data"}return j.substr(a+1)}function RSASetPrivate(c,a,b){this.isPrivate=true;if(typeof c!=="string"){this.n=c;this.e=a;this.d=b}else{if(c!=null&&a!=null&&c.length>0&&a.length>0){this.n=parseBigInt(c,16);this.e=parseInt(a,16);this.d=parseBigInt(b,16)}else{throw"Invalid RSA private key"}}}function RSASetPrivateEx(g,d,e,c,b,a,h,f){this.isPrivate=true;this.isPublic=false;if(g==null){throw"RSASetPrivateEx N == null"}if(d==null){throw"RSASetPrivateEx E == null"}if(g.length==0){throw"RSASetPrivateEx N.length == 0"}if(d.length==0){throw"RSASetPrivateEx E.length == 0"}if(g!=null&&d!=null&&g.length>0&&d.length>0){this.n=parseBigInt(g,16);this.e=parseInt(d,16);this.d=parseBigInt(e,16);this.p=parseBigInt(c,16);this.q=parseBigInt(b,16);this.dmp1=parseBigInt(a,16);this.dmq1=parseBigInt(h,16);this.coeff=parseBigInt(f,16)}else{throw"Invalid RSA private key in RSASetPrivateEx"}}function RSAGenerate(b,l){var a=new SecureRandom();var g=b>>1;this.e=parseInt(l,16);var c=new BigInteger(l,16);var d=(b/2)-100;var k=BigInteger.ONE.shiftLeft(d);for(;;){for(;;){this.p=new BigInteger(b-g,1,a);if(this.p.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.p.isProbablePrime(10)){break}}for(;;){this.q=new BigInteger(g,1,a);if(this.q.subtract(BigInteger.ONE).gcd(c).compareTo(BigInteger.ONE)==0&&this.q.isProbablePrime(10)){break}}if(this.p.compareTo(this.q)<=0){var j=this.p;this.p=this.q;this.q=j}var h=this.q.subtract(this.p).abs();if(h.bitLength()<d||h.compareTo(k)<=0){continue}var i=this.p.subtract(BigInteger.ONE);var e=this.q.subtract(BigInteger.ONE);var f=i.multiply(e);if(f.gcd(c).compareTo(BigInteger.ONE)==0){this.n=this.p.multiply(this.q);if(this.n.bitLength()==b){this.d=c.modInverse(f);this.dmp1=this.d.mod(i);this.dmq1=this.d.mod(e);this.coeff=this.q.modInverse(this.p);break}}}this.isPrivate=true}function RSADoPrivate(a){if(this.p==null||this.q==null){return a.modPow(this.d,this.n)}var c=a.mod(this.p).modPow(this.dmp1,this.p);var b=a.mod(this.q).modPow(this.dmq1,this.q);while(c.compareTo(b)<0){c=c.add(this.p)}return c.subtract(b).multiply(this.coeff).mod(this.p).multiply(this.q).add(b)}function RSADecrypt(b){if(b.length!=Math.ceil(this.n.bitLength()/4)){throw new Error("wrong ctext length")}var d=parseBigInt(b,16);var a=this.doPrivate(d);if(a==null){return null}return pkcs1unpad2(a,(this.n.bitLength()+7)>>3)}function RSADecryptOAEP(e,d,b){if(e.length!=Math.ceil(this.n.bitLength()/4)){throw new Error("wrong ctext length")}var f=parseBigInt(e,16);var a=this.doPrivate(f);if(a==null){return null}return oaep_unpad(a,(this.n.bitLength()+7)>>3,d,b)}RSAKey.prototype.doPrivate=RSADoPrivate;RSAKey.prototype.setPrivate=RSASetPrivate;RSAKey.prototype.setPrivateEx=RSASetPrivateEx;RSAKey.prototype.generate=RSAGenerate;RSAKey.prototype.decrypt=RSADecrypt;RSAKey.prototype.decryptOAEP=RSADecryptOAEP;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function ECFieldElementFp(b,a){this.x=a;this.q=b}function feFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.x.equals(a.x))}function feFpToBigInteger(){return this.x}function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))}function feFpAdd(a){return new ECFieldElementFp(this.q,this.x.add(a.toBigInteger()).mod(this.q))}function feFpSubtract(a){return new ECFieldElementFp(this.q,this.x.subtract(a.toBigInteger()).mod(this.q))}function feFpMultiply(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger()).mod(this.q))}function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))}function feFpDivide(a){return new ECFieldElementFp(this.q,this.x.multiply(a.toBigInteger().modInverse(this.q)).mod(this.q))}ECFieldElementFp.prototype.equals=feFpEquals;ECFieldElementFp.prototype.toBigInteger=feFpToBigInteger;ECFieldElementFp.prototype.negate=feFpNegate;ECFieldElementFp.prototype.add=feFpAdd;ECFieldElementFp.prototype.subtract=feFpSubtract;ECFieldElementFp.prototype.multiply=feFpMultiply;ECFieldElementFp.prototype.square=feFpSquare;ECFieldElementFp.prototype.divide=feFpDivide;ECFieldElementFp.prototype.sqrt=function(){return new ECFieldElementFp(this.q,this.x.sqrt().mod(this.q))};function ECPointFp(c,a,d,b){this.curve=c;this.x=a;this.y=d;if(b==null){this.z=BigInteger.ONE}else{this.z=b}this.zinv=null}function pointFpGetX(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpGetY(){if(this.zinv==null){this.zinv=this.z.modInverse(this.curve.q)}return this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))}function pointFpEquals(a){if(a==this){return true}if(this.isInfinity()){return a.isInfinity()}if(a.isInfinity()){return this.isInfinity()}var c,b;c=a.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(a.z)).mod(this.curve.q);if(!c.equals(BigInteger.ZERO)){return false}b=a.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(a.z)).mod(this.curve.q);return b.equals(BigInteger.ZERO)}function pointFpIsInfinity(){if((this.x==null)&&(this.y==null)){return true}return this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)}function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)}function pointFpAdd(l){if(this.isInfinity()){return l}if(l.isInfinity()){return this}var p=l.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(l.z)).mod(this.curve.q);var o=l.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(l.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(o)){if(BigInteger.ZERO.equals(p)){return this.twice()}return this.curve.getInfinity()}var j=new BigInteger("3");var e=this.x.toBigInteger();var n=this.y.toBigInteger();var c=l.x.toBigInteger();var k=l.y.toBigInteger();var m=o.square();var i=m.multiply(o);var d=e.multiply(m);var g=p.square().multiply(this.z);var a=g.subtract(d.shiftLeft(1)).multiply(l.z).subtract(i).multiply(o).mod(this.curve.q);var h=d.multiply(j).multiply(p).subtract(n.multiply(i)).subtract(g.multiply(p)).multiply(l.z).add(p.multiply(i)).mod(this.curve.q);var f=i.multiply(this.z).multiply(l.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(h),f)}function pointFpTwice(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var g=new BigInteger("3");var c=this.x.toBigInteger();var h=this.y.toBigInteger();var e=h.multiply(this.z);var j=e.multiply(h).mod(this.curve.q);var i=this.curve.a.toBigInteger();var k=c.square().multiply(g);if(!BigInteger.ZERO.equals(i)){k=k.add(this.z.square().multiply(i))}k=k.mod(this.curve.q);var b=k.square().subtract(c.shiftLeft(3).multiply(j)).shiftLeft(1).multiply(e).mod(this.curve.q);var f=k.multiply(g).multiply(c).subtract(j.shiftLeft(1)).shiftLeft(2).multiply(j).subtract(k.square().multiply(k)).mod(this.curve.q);var d=e.square().multiply(e).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(b),this.curve.fromBigInteger(f),d)}function pointFpMultiply(d){if(this.isInfinity()){return this}if(d.signum()==0){return this.curve.getInfinity()}var m=d;var l=m.multiply(new BigInteger("3"));var b=this.negate();var j=this;var q=this.curve.q.subtract(d);var o=q.multiply(new BigInteger("3"));var c=new ECPointFp(this.curve,this.x,this.y);var a=c.negate();var g;for(g=l.bitLength()-2;g>0;--g){j=j.twice();var n=l.testBit(g);var f=m.testBit(g);if(n!=f){j=j.add(n?this:b)}}for(g=o.bitLength()-2;g>0;--g){c=c.twice();var p=o.testBit(g);var r=q.testBit(g);if(p!=r){c=c.add(p?c:a)}}return j}function pointFpMultiplyTwo(c,a,b){var d;if(c.bitLength()>b.bitLength()){d=c.bitLength()-1}else{d=b.bitLength()-1}var f=this.curve.getInfinity();var e=this.add(a);while(d>=0){f=f.twice();if(c.testBit(d)){if(b.testBit(d)){f=f.add(e)}else{f=f.add(this)}}else{if(b.testBit(d)){f=f.add(a)}}--d}return f}ECPointFp.prototype.getX=pointFpGetX;ECPointFp.prototype.getY=pointFpGetY;ECPointFp.prototype.equals=pointFpEquals;ECPointFp.prototype.isInfinity=pointFpIsInfinity;ECPointFp.prototype.negate=pointFpNegate;ECPointFp.prototype.add=pointFpAdd;ECPointFp.prototype.twice=pointFpTwice;ECPointFp.prototype.multiply=pointFpMultiply;ECPointFp.prototype.multiplyTwo=pointFpMultiplyTwo;function ECCurveFp(e,d,c){this.q=e;this.a=this.fromBigInteger(d);this.b=this.fromBigInteger(c);this.infinity=new ECPointFp(this,null,null)}function curveFpGetQ(){return this.q}function curveFpGetA(){return this.a}function curveFpGetB(){return this.b}function curveFpEquals(a){if(a==this){return true}return(this.q.equals(a.q)&&this.a.equals(a.a)&&this.b.equals(a.b))}function curveFpGetInfinity(){return this.infinity}function curveFpFromBigInteger(a){return new ECFieldElementFp(this.q,a)}function curveFpDecodePointHex(m){switch(parseInt(m.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:var c=m.substr(0,2);var l=m.substr(2);var j=this.fromBigInteger(new BigInteger(k,16));var i=this.getA();var h=this.getB();var e=j.square().add(i).multiply(j).add(h);var g=e.sqrt();if(c=="03"){g=g.negate()}return new ECPointFp(this,j,g);case 4:case 6:case 7:var d=(m.length-2)/2;var k=m.substr(2,d);var f=m.substr(d+2,d);return new ECPointFp(this,this.fromBigInteger(new BigInteger(k,16)),this.fromBigInteger(new BigInteger(f,16)));default:return null}}ECCurveFp.prototype.getQ=curveFpGetQ;ECCurveFp.prototype.getA=curveFpGetA;ECCurveFp.prototype.getB=curveFpGetB;ECCurveFp.prototype.equals=curveFpEquals;ECCurveFp.prototype.getInfinity=curveFpGetInfinity;ECCurveFp.prototype.fromBigInteger=curveFpFromBigInteger;ECCurveFp.prototype.decodePointHex=curveFpDecodePointHex;
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)};ECPointFp.prototype.getEncoded=function(c){var d=function(h,f){var g=h.toByteArrayUnsigned();if(f<g.length){g=g.slice(g.length-f)}else{while(f>g.length){g.unshift(0)}}return g};var a=this.getX().toBigInteger();var e=this.getY().toBigInteger();var b=d(a,32);if(c){if(e.isEven()){b.unshift(2)}else{b.unshift(3)}}else{b.unshift(4);b=b.concat(d(e,32))}return b};ECPointFp.decodeFrom=function(g,c){var f=c[0];var e=c.length-1;var d=c.slice(1,1+e/2);var b=c.slice(1+e/2,1+e);d.unshift(0);b.unshift(0);var a=new BigInteger(d);var h=new BigInteger(b);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.decodeFromHex=function(g,c){var f=c.substr(0,2);var e=c.length-2;var d=c.substr(2,e/2);var b=c.substr(2+e/2,e/2);var a=new BigInteger(d,16);var h=new BigInteger(b,16);return new ECPointFp(g,g.fromBigInteger(a),g.fromBigInteger(h))};ECPointFp.prototype.add2D=function(c){if(this.isInfinity()){return c}if(c.isInfinity()){return this}if(this.x.equals(c.x)){if(this.y.equals(c.y)){return this.twice()}return this.curve.getInfinity()}var g=c.x.subtract(this.x);var e=c.y.subtract(this.y);var a=e.divide(g);var d=a.square().subtract(this.x).subtract(c.x);var f=a.multiply(this.x.subtract(d)).subtract(this.y);return new ECPointFp(this.curve,d,f)};ECPointFp.prototype.twice2D=function(){if(this.isInfinity()){return this}if(this.y.toBigInteger().signum()==0){return this.curve.getInfinity()}var b=this.curve.fromBigInteger(BigInteger.valueOf(2));var e=this.curve.fromBigInteger(BigInteger.valueOf(3));var a=this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(b));var c=a.square().subtract(this.x.multiply(b));var d=a.multiply(this.x.subtract(c)).subtract(this.y);return new ECPointFp(this.curve,c,d)};ECPointFp.prototype.multiply2D=function(b){if(this.isInfinity()){return this}if(b.signum()==0){return this.curve.getInfinity()}var g=b;var f=g.multiply(new BigInteger("3"));var l=this.negate();var d=this;var c;for(c=f.bitLength()-2;c>0;--c){d=d.twice();var a=f.testBit(c);var j=g.testBit(c);if(a!=j){d=d.add2D(a?this:l)}}return d};ECPointFp.prototype.isOnCurve=function(){var d=this.getX().toBigInteger();var i=this.getY().toBigInteger();var f=this.curve.getA().toBigInteger();var c=this.curve.getB().toBigInteger();var h=this.curve.getQ();var e=i.multiply(i).mod(h);var g=d.multiply(d).multiply(d).add(f.multiply(d)).add(c).mod(h);return e.equals(g)};ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"};ECPointFp.prototype.validate=function(){var c=this.curve.getQ();if(this.isInfinity()){throw new Error("Point is at infinity.")}var a=this.getX().toBigInteger();var b=this.getY().toBigInteger();if(a.compareTo(BigInteger.ONE)<0||a.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("x coordinate out of bounds")}if(b.compareTo(BigInteger.ONE)<0||b.compareTo(c.subtract(BigInteger.ONE))>0){throw new Error("y coordinate out of bounds")}if(!this.isOnCurve()){throw new Error("Point is not on the curve.")}if(this.multiply(c).isInfinity()){throw new Error("Point is not a scalar multiple of G.")}return true};
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
var jsonParse=(function(){var e="(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)";var j='(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))';var i='(?:"'+j+'*")';var d=new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|"+e+"|"+i+")","g");var k=new RegExp("\\\\(?:([^u])|u(.{4}))","g");var g={'"':'"',"/":"/","\\":"\\",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function h(l,m,n){return m?g[m]:String.fromCharCode(parseInt(n,16))}var c=new String("");var a="\\";var f={"{":Object,"[":Array};var b=Object.hasOwnProperty;return function(u,q){var p=u.match(d);var x;var v=p[0];var l=false;if("{"===v){x={}}else{if("["===v){x=[]}else{x=[];l=true}}var t;var r=[x];for(var o=1-l,m=p.length;o<m;++o){v=p[o];var w;switch(v.charCodeAt(0)){default:w=r[0];w[t||w.length]=+(v);t=void 0;break;case 34:v=v.substring(1,v.length-1);if(v.indexOf(a)!==-1){v=v.replace(k,h)}w=r[0];if(!t){if(w instanceof Array){t=w.length}else{t=v||c;break}}w[t]=v;t=void 0;break;case 91:w=r[0];r.unshift(w[t||w.length]=[]);t=void 0;break;case 93:r.shift();break;case 102:w=r[0];w[t||w.length]=false;t=void 0;break;case 110:w=r[0];w[t||w.length]=null;t=void 0;break;case 116:w=r[0];w[t||w.length]=true;t=void 0;break;case 123:w=r[0];r.unshift(w[t||w.length]={});t=void 0;break;case 125:r.shift();break}}if(l){if(r.length!==1){throw new Error()}x=x[0]}else{if(r.length){throw new Error()}}if(q){var s=function(C,B){var D=C[B];if(D&&typeof D==="object"){var n=null;for(var z in D){if(b.call(D,z)&&D!==C){var y=s(D,z);if(y!==void 0){D[z]=y}else{if(!n){n=[]}n.push(z)}}}if(n){for(var A=n.length;--A>=0;){delete D[n[A]]}}}return q.call(C,B,D)};x=s({"":x},"")}return x}})();
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}KJUR.asn1.ASN1Util=new function(){this.integerToByteHex=function(a){var b=a.toString(16);if((b.length%2)==1){b="0"+b}return b};this.bigIntToMinTwosComplementsHex=function(j){var f=j.toString(16);if(f.substr(0,1)!="-"){if(f.length%2==1){f="0"+f}else{if(!f.match(/^[0-7]/)){f="00"+f}}}else{var a=f.substr(1);var e=a.length;if(e%2==1){e+=1}else{if(!f.match(/^[0-7]/)){e+=2}}var g="";for(var d=0;d<e;d++){g+="f"}var c=new BigInteger(g,16);var b=c.xor(j).add(BigInteger.ONE);f=b.toString(16).replace(/^-/,"")}return f};this.getPEMStringFromHex=function(a,b){return hextopem(a,b)};this.newObject=function(k){var F=KJUR,o=F.asn1,v=o.ASN1Object,B=o.DERBoolean,e=o.DERInteger,t=o.DERBitString,h=o.DEROctetString,x=o.DERNull,y=o.DERObjectIdentifier,m=o.DEREnumerated,g=o.DERUTF8String,f=o.DERNumericString,A=o.DERPrintableString,w=o.DERTeletexString,q=o.DERIA5String,E=o.DERUTCTime,j=o.DERGeneralizedTime,b=o.DERVisibleString,l=o.DERBMPString,n=o.DERSequence,c=o.DERSet,s=o.DERTaggedObject,p=o.ASN1Util.newObject;if(k instanceof o.ASN1Object){return k}var u=Object.keys(k);if(u.length!=1){throw new Error("key of param shall be only one.")}var H=u[0];if(":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":"+H+":")==-1){throw new Error("undefined key: "+H)}if(H=="bool"){return new B(k[H])}if(H=="int"){return new e(k[H])}if(H=="bitstr"){return new t(k[H])}if(H=="octstr"){return new h(k[H])}if(H=="null"){return new x(k[H])}if(H=="oid"){return new y(k[H])}if(H=="enum"){return new m(k[H])}if(H=="utf8str"){return new g(k[H])}if(H=="numstr"){return new f(k[H])}if(H=="prnstr"){return new A(k[H])}if(H=="telstr"){return new w(k[H])}if(H=="ia5str"){return new q(k[H])}if(H=="utctime"){return new E(k[H])}if(H=="gentime"){return new j(k[H])}if(H=="visstr"){return new b(k[H])}if(H=="bmpstr"){return new l(k[H])}if(H=="asn1"){return new v(k[H])}if(H=="seq"){var d=k[H];var G=[];for(var z=0;z<d.length;z++){var D=p(d[z]);G.push(D)}return new n({array:G})}if(H=="set"){var d=k[H];var G=[];for(var z=0;z<d.length;z++){var D=p(d[z]);G.push(D)}return new c({array:G})}if(H=="tag"){var C=k[H];if(Object.prototype.toString.call(C)==="[object Array]"&&C.length==3){var r=p(C[2]);return new s({tag:C[0],explicit:C[1],obj:r})}else{return new s(C)}}};this.jsonToASN1HEX=function(b){var a=this.newObject(b);return a.tohex()}};KJUR.asn1.ASN1Util.oidHexToInt=function(a){var j="";var k=parseInt(a.substr(0,2),16);var d=Math.floor(k/40);var c=k%40;var j=d+"."+c;var e="";for(var f=2;f<a.length;f+=2){var g=parseInt(a.substr(f,2),16);var h=("00000000"+g.toString(2)).slice(-8);e=e+h.substr(1,7);if(h.substr(0,1)=="0"){var b=new BigInteger(e,2);j=j+"."+b.toString(10);e=""}}return j};KJUR.asn1.ASN1Util.oidIntToHex=function(f){var e=function(a){var k=a.toString(16);if(k.length==1){k="0"+k}return k};var d=function(o){var n="";var k=new BigInteger(o,10);var a=k.toString(2);var l=7-a.length%7;if(l==7){l=0}var q="";for(var m=0;m<l;m++){q+="0"}a=q+a;for(var m=0;m<a.length-1;m+=7){var p=a.substr(m,7);if(m!=a.length-7){p="1"+p}n+=e(parseInt(p,2))}return n};if(!f.match(/^[0-9.]+$/)){throw"malformed oid string: "+f}var g="";var b=f.split(".");var j=parseInt(b[0])*40+parseInt(b[1]);g+=e(j);b.splice(0,2);for(var c=0;c<b.length;c++){g+=d(b[c])}return g};KJUR.asn1.ASN1Object=function(e){var c=true;var b=null;var d="00";var f="00";var a="";this.params=null;this.getLengthHexFromValue=function(){if(typeof this.hV=="undefined"||this.hV==null){throw new Error("this.hV is null or undefined")}if(this.hV.length%2==1){throw new Error("value hex must be even length: n="+a.length+",v="+this.hV)}var j=this.hV.length/2;var i=j.toString(16);if(i.length%2==1){i="0"+i}if(j<128){return i}else{var h=i.length/2;if(h>15){throw new Error("ASN.1 length too long to represent by 8x: n = "+j.toString(16))}var g=128+h;return g.toString(16)+i}};this.tohex=function(){if(this.hTLV==null||this.isModified){this.hV=this.getFreshValueHex();this.hL=this.getLengthHexFromValue();this.hTLV=this.hT+this.hL+this.hV;this.isModified=false}return this.hTLV};this.getEncodedHex=function(){return this.tohex()};this.getValueHex=function(){this.tohex();return this.hV};this.getFreshValueHex=function(){return""};this.setByParam=function(g){this.params=g};if(e!=undefined){if(e.tlv!=undefined){this.hTLV=e.tlv;this.isModified=false}}};KJUR.asn1.DERAbstractString=function(c){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var b=null;var a=null;this.getString=function(){return this.s};this.setString=function(d){this.hTLV=null;this.isModified=true;this.s=d;this.hV=utf8tohex(this.s).toLowerCase()};this.setStringHex=function(d){this.hTLV=null;this.isModified=true;this.s=null;this.hV=d};this.getFreshValueHex=function(){return this.hV};if(typeof c!="undefined"){if(typeof c=="string"){this.setString(c)}else{if(typeof c.str!="undefined"){this.setString(c.str)}else{if(typeof c.hex!="undefined"){this.setStringHex(c.hex)}}}}};extendClass(KJUR.asn1.DERAbstractString,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractTime=function(c){KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);var b=null;var a=null;this.localDateToUTC=function(g){var e=g.getTime()+(g.getTimezoneOffset()*60000);var f=new Date(e);return f};this.formatDate=function(m,o,e){var g=this.zeroPadding;var n=this.localDateToUTC(m);var p=String(n.getFullYear());if(o=="utc"){p=p.substr(2,2)}var l=g(String(n.getMonth()+1),2);var q=g(String(n.getDate()),2);var h=g(String(n.getHours()),2);var i=g(String(n.getMinutes()),2);var j=g(String(n.getSeconds()),2);var r=p+l+q+h+i+j;if(e===true){var f=n.getMilliseconds();if(f!=0){var k=g(String(f),3);k=k.replace(/[0]+$/,"");r=r+"."+k}}return r+"Z"};this.zeroPadding=function(e,d){if(e.length>=d){return e}return new Array(d-e.length+1).join("0")+e};this.setByParam=function(d){this.hV=null;this.hTLV=null;this.params=d};this.getString=function(){return undefined};this.setString=function(d){this.hTLV=null;this.isModified=true;if(this.params==undefined){this.params={}}this.params.str=d};this.setByDate=function(d){this.hTLV=null;this.isModified=true;if(this.params==undefined){this.params={}}this.params.date=d};this.setByDateValue=function(h,j,e,d,f,g){var i=new Date(Date.UTC(h,j-1,e,d,f,g,0));this.setByDate(i)};this.getFreshValueHex=function(){return this.hV}};extendClass(KJUR.asn1.DERAbstractTime,KJUR.asn1.ASN1Object);KJUR.asn1.DERAbstractStructured=function(b){KJUR.asn1.DERAbstractString.superclass.constructor.call(this);var a=null;this.setByASN1ObjectArray=function(c){this.hTLV=null;this.isModified=true;this.asn1Array=c};this.appendASN1Object=function(c){this.hTLV=null;this.isModified=true;this.asn1Array.push(c)};this.asn1Array=new Array();if(typeof b!="undefined"){if(typeof b.array!="undefined"){this.asn1Array=b.array}}};extendClass(KJUR.asn1.DERAbstractStructured,KJUR.asn1.ASN1Object);KJUR.asn1.DERBoolean=function(a){KJUR.asn1.DERBoolean.superclass.constructor.call(this);this.hT="01";if(a==false){this.hTLV="010100"}else{this.hTLV="0101ff"}};extendClass(KJUR.asn1.DERBoolean,KJUR.asn1.ASN1Object);KJUR.asn1.DERInteger=function(b){KJUR.asn1.DERInteger.superclass.constructor.call(this);this.hT="02";this.params=null;var a=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex;this.setByBigInteger=function(c){this.isModified=true;this.params={bigint:c}};this.setByInteger=function(c){this.isModified=true;this.params=c};this.setValueHex=function(c){this.isModified=true;this.params={hex:c}};this.getFreshValueHex=function(){var d=this.params;var c=null;if(d==null){throw new Error("value not set")}if(typeof d=="object"&&d.hex!=undefined){this.hV=d.hex;return this.hV}if(typeof d=="number"){c=new BigInteger(String(d),10)}else{if(d["int"]!=undefined){c=new BigInteger(String(d["int"]),10)}else{if(d.bigint!=undefined){c=d.bigint}else{throw new Error("wrong parameter")}}}this.hV=a(c);return this.hV};if(b!=undefined){this.params=b}};extendClass(KJUR.asn1.DERInteger,KJUR.asn1.ASN1Object);KJUR.asn1.DERBitString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex="00"+a.tohex()}KJUR.asn1.DERBitString.superclass.constructor.call(this);this.hT="03";this.setHexValueIncludingUnusedBits=function(c){this.hTLV=null;this.isModified=true;this.hV=c};this.setUnusedBitsAndHexValue=function(c,e){if(c<0||7<c){throw"unused bits shall be from 0 to 7: u = "+c}var d="0"+c;this.hTLV=null;this.isModified=true;this.hV=d+e};this.setByBinaryString=function(e){e=e.replace(/0+$/,"");var f=8-e.length%8;if(f==8){f=0}e+="0000000".substr(0,f);var j="";for(var g=0;g<e.length-1;g+=8){var d=e.substr(g,8);var c=parseInt(d,2).toString(16);if(c.length==1){c="0"+c}j+=c}this.hTLV=null;this.isModified=true;this.hV="0"+f+j};this.setByBooleanArray=function(e){var d="";for(var c=0;c<e.length;c++){if(e[c]==true){d+="1"}else{d+="0"}}this.setByBinaryString(d)};this.newFalseArray=function(e){var c=new Array(e);for(var d=0;d<e;d++){c[d]=false}return c};this.getFreshValueHex=function(){return this.hV};if(typeof b!="undefined"){if(typeof b=="string"&&b.toLowerCase().match(/^[0-9a-f]+$/)){this.setHexValueIncludingUnusedBits(b)}else{if(typeof b.hex!="undefined"){this.setHexValueIncludingUnusedBits(b.hex)}else{if(typeof b.bin!="undefined"){this.setByBinaryString(b.bin)}else{if(typeof b.array!="undefined"){this.setByBooleanArray(b.array)}}}}}};extendClass(KJUR.asn1.DERBitString,KJUR.asn1.ASN1Object);KJUR.asn1.DEROctetString=function(b){if(b!==undefined&&typeof b.obj!=="undefined"){var a=KJUR.asn1.ASN1Util.newObject(b.obj);b.hex=a.tohex()}KJUR.asn1.DEROctetString.superclass.constructor.call(this,b);this.hT="04"};extendClass(KJUR.asn1.DEROctetString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNull=function(){KJUR.asn1.DERNull.superclass.constructor.call(this);this.hT="05";this.hTLV="0500"};extendClass(KJUR.asn1.DERNull,KJUR.asn1.ASN1Object);KJUR.asn1.DERObjectIdentifier=function(a){KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);this.hT="06";this.setValueHex=function(b){this.hTLV=null;this.isModified=true;this.s=null;this.hV=b};this.setValueOidString=function(b){var c=oidtohex(b);if(c==null){throw new Error("malformed oid string: "+b)}this.hTLV=null;this.isModified=true;this.s=null;this.hV=c};this.setValueName=function(c){var b=KJUR.asn1.x509.OID.name2oid(c);if(b!==""){this.setValueOidString(b)}else{throw new Error("DERObjectIdentifier oidName undefined: "+c)}};this.setValueNameOrOid=function(b){if(b.match(/^[0-2].[0-9.]+$/)){this.setValueOidString(b)}else{this.setValueName(b)}};this.getFreshValueHex=function(){return this.hV};this.setByParam=function(b){if(typeof b==="string"){this.setValueNameOrOid(b)}else{if(b.oid!==undefined){this.setValueNameOrOid(b.oid)}else{if(b.name!==undefined){this.setValueNameOrOid(b.name)}else{if(b.hex!==undefined){this.setValueHex(b.hex)}}}}};if(a!==undefined){this.setByParam(a)}};extendClass(KJUR.asn1.DERObjectIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.DEREnumerated=function(a){KJUR.asn1.DEREnumerated.superclass.constructor.call(this);this.hT="0a";this.setByBigInteger=function(b){this.hTLV=null;this.isModified=true;this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(b)};this.setByInteger=function(c){var b=new BigInteger(String(c),10);this.setByBigInteger(b)};this.setValueHex=function(b){this.hV=b};this.getFreshValueHex=function(){return this.hV};if(typeof a!="undefined"){if(typeof a["int"]!="undefined"){this.setByInteger(a["int"])}else{if(typeof a=="number"){this.setByInteger(a)}else{if(typeof a.hex!="undefined"){this.setValueHex(a.hex)}}}}};extendClass(KJUR.asn1.DEREnumerated,KJUR.asn1.ASN1Object);KJUR.asn1.DERUTF8String=function(a){KJUR.asn1.DERUTF8String.superclass.constructor.call(this,a);this.hT="0c"};extendClass(KJUR.asn1.DERUTF8String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERNumericString=function(a){KJUR.asn1.DERNumericString.superclass.constructor.call(this,a);this.hT="12"};extendClass(KJUR.asn1.DERNumericString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERPrintableString=function(a){KJUR.asn1.DERPrintableString.superclass.constructor.call(this,a);this.hT="13"};extendClass(KJUR.asn1.DERPrintableString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERTeletexString=function(a){KJUR.asn1.DERTeletexString.superclass.constructor.call(this,a);this.hT="14"};extendClass(KJUR.asn1.DERTeletexString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERIA5String=function(a){KJUR.asn1.DERIA5String.superclass.constructor.call(this,a);this.hT="16"};extendClass(KJUR.asn1.DERIA5String,KJUR.asn1.DERAbstractString);KJUR.asn1.DERVisibleString=function(a){KJUR.asn1.DERIA5String.superclass.constructor.call(this,a);this.hT="1a"};extendClass(KJUR.asn1.DERVisibleString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERBMPString=function(a){KJUR.asn1.DERBMPString.superclass.constructor.call(this,a);this.hT="1e"};extendClass(KJUR.asn1.DERBMPString,KJUR.asn1.DERAbstractString);KJUR.asn1.DERUTCTime=function(a){KJUR.asn1.DERUTCTime.superclass.constructor.call(this,a);this.hT="17";this.params=undefined;this.getFreshValueHex=function(){var d=this.params;if(this.params==undefined){d={date:new Date()}}if(typeof d=="string"){if(d.match(/^[0-9]{12}Z$/)||d.match(/^[0-9]{12}\.[0-9]+Z$/)){this.hV=stohex(d)}else{throw new Error("malformed string for UTCTime: "+d)}}else{if(d.str!=undefined){this.hV=stohex(d.str)}else{if(d.date==undefined&&d.millis==true){var c=new Date();this.hV=stohex(this.formatDate(c,"utc",true))}else{if(d.date!=undefined&&d.date instanceof Date){var b=(d.millis===true);this.hV=stohex(this.formatDate(d.date,"utc",b))}else{if(d instanceof Date){this.hV=stohex(this.formatDate(d,"utc"))}}}}}if(this.hV==undefined){throw new Error("parameter not specified properly for UTCTime")}return this.hV};if(a!=undefined){this.setByParam(a)}};extendClass(KJUR.asn1.DERUTCTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERGeneralizedTime=function(a){KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this,a);this.hT="18";this.params=a;this.getFreshValueHex=function(){var d=this.params;if(this.params==undefined){d={date:new Date()}}if(typeof d=="string"){if(d.match(/^[0-9]{14}Z$/)||d.match(/^[0-9]{14}\.[0-9]+Z$/)){this.hV=stohex(d)}else{throw new Error("malformed string for GeneralizedTime: "+d)}}else{if(d.str!=undefined){this.hV=stohex(d.str)}else{if(d.date==undefined&&d.millis==true){var c=new Date();this.hV=stohex(this.formatDate(c,"gen",true))}else{if(d.date!=undefined&&d.date instanceof Date){var b=(d.millis===true);this.hV=stohex(this.formatDate(d.date,"gen",b))}else{if(d instanceof Date){this.hV=stohex(this.formatDate(d,"gen"))}}}}}if(this.hV==undefined){throw new Error("parameter not specified properly for GeneralizedTime")}return this.hV};if(a!=undefined){this.setByParam(a)}};extendClass(KJUR.asn1.DERGeneralizedTime,KJUR.asn1.DERAbstractTime);KJUR.asn1.DERSequence=function(a){KJUR.asn1.DERSequence.superclass.constructor.call(this,a);this.hT="30";this.getFreshValueHex=function(){var c="";for(var b=0;b<this.asn1Array.length;b++){var d=this.asn1Array[b];c+=d.tohex()}this.hV=c;return this.hV}};extendClass(KJUR.asn1.DERSequence,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERSet=function(a){KJUR.asn1.DERSet.superclass.constructor.call(this,a);this.hT="31";this.sortFlag=true;this.getFreshValueHex=function(){var b=new Array();for(var c=0;c<this.asn1Array.length;c++){var d=this.asn1Array[c];b.push(d.tohex())}if(this.sortFlag==true){b.sort()}this.hV=b.join("");return this.hV};if(typeof a!="undefined"){if(typeof a.sortflag!="undefined"&&a.sortflag==false){this.sortFlag=false}}};extendClass(KJUR.asn1.DERSet,KJUR.asn1.DERAbstractStructured);KJUR.asn1.DERTaggedObject=function(f){KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);var d=KJUR.asn1,e=ASN1HEX,a=e.getV,c=e.isASN1HEX,b=d.ASN1Util.newObject;this.hT="a0";this.hV="";this.isExplicit=true;this.asn1Object=null;this.params={tag:"a0",explicit:true};this.setASN1Object=function(g,h,i){this.params={tag:h,explicit:g,obj:i}};this.getFreshValueHex=function(){var h=this.params;if(h.explicit==undefined){h.explicit=true}if(h.tage!=undefined){h.tag=h.tage;h.explicit=true}if(h.tagi!=undefined){h.tag=h.tagi;h.explicit=false}if(h.str!=undefined){this.hV=utf8tohex(h.str)}else{if(h.hex!=undefined){this.hV=h.hex}else{if(h.obj!=undefined){var g;if(h.obj instanceof d.ASN1Object){g=h.obj.tohex()}else{if(typeof h.obj=="object"){g=b(h.obj).tohex()}}if(h.explicit){this.hV=g}else{this.hV=a(g,0)}}else{throw new Error("str, hex nor obj not specified")}}}if(h.tag==undefined){h.tag="a0"}this.hT=h.tag;this.hTLV=null;this.isModified=true;return this.hV};this.setByParam=function(g){this.params=g};if(f!==undefined){this.setByParam(f)}};extendClass(KJUR.asn1.DERTaggedObject,KJUR.asn1.ASN1Object);
var ASN1HEX=new function(){};ASN1HEX.getLblen=function(c,a){if(c.substr(a+2,1)!="8"){return 1}var b=parseInt(c.substr(a+3,1));if(b==0){return -1}if(0<b&&b<10){return b+1}return -2};ASN1HEX.getL=function(c,b){var a=ASN1HEX.getLblen(c,b);if(a<1){return""}return c.substr(b+2,a*2)};ASN1HEX.getVblen=function(d,a){var c,b;c=ASN1HEX.getL(d,a);if(c==""){return -1}if(c.substr(0,1)==="8"){b=new BigInteger(c.substr(2),16)}else{b=new BigInteger(c,16)}return b.intValue()};ASN1HEX.getVidx=function(c,b){var a=ASN1HEX.getLblen(c,b);if(a<0){return a}return b+(a+1)*2};ASN1HEX.getV=function(d,a){var c=ASN1HEX.getVidx(d,a);var b=ASN1HEX.getVblen(d,a);return d.substr(c,b*2)};ASN1HEX.getTLV=function(b,a){return b.substr(a,2)+ASN1HEX.getL(b,a)+ASN1HEX.getV(b,a)};ASN1HEX.getTLVblen=function(b,a){return 2+ASN1HEX.getLblen(b,a)*2+ASN1HEX.getVblen(b,a)*2};ASN1HEX.getNextSiblingIdx=function(d,a){var c=ASN1HEX.getVidx(d,a);var b=ASN1HEX.getVblen(d,a);return c+b*2};ASN1HEX.getChildIdx=function(e,k){var l=ASN1HEX;var j=[];var c,f,g;c=l.getVidx(e,k);f=l.getVblen(e,k)*2;if(e.substr(k,2)=="03"){c+=2;f-=2}g=0;var d=c;while(g<=f){var b=l.getTLVblen(e,d);g+=b;if(g<=f){j.push(d)}d+=b;if(g>=f){break}}return j};ASN1HEX.getNthChildIdx=function(d,b,e){var c=ASN1HEX.getChildIdx(d,b);return c[e]};ASN1HEX.getIdxbyList=function(e,d,c,i){var g=ASN1HEX;var f,b;if(c.length==0){if(i!==undefined){if(e.substr(d,2)!==i){return -1}}return d}f=c.shift();b=g.getChildIdx(e,d);if(f>=b.length){return -1}return g.getIdxbyList(e,b[f],c,i)};ASN1HEX.getIdxbyListEx=function(f,k,b,g){var m=ASN1HEX;var d,l;if(b.length==0){if(g!==undefined){if(f.substr(k,2)!==g){return -1}}return k}d=b.shift();l=m.getChildIdx(f,k);var j=0;for(var e=0;e<l.length;e++){var c=f.substr(l[e],2);if((typeof d=="number"&&(!m.isContextTag(c))&&j==d)||(typeof d=="string"&&m.isContextTag(c,d))){return m.getIdxbyListEx(f,l[e],b,g)}if(!m.isContextTag(c)){j++}}return -1};ASN1HEX.getTLVbyList=function(d,c,b,f){var e=ASN1HEX;var a=e.getIdxbyList(d,c,b,f);if(a==-1){return null}if(a>=d.length){return null}return e.getTLV(d,a)};ASN1HEX.getTLVbyListEx=function(d,c,b,f){var e=ASN1HEX;var a=e.getIdxbyListEx(d,c,b,f);if(a==-1){return null}return e.getTLV(d,a)};ASN1HEX.getVbyList=function(e,c,b,g,i){var f=ASN1HEX;var a,d;a=f.getIdxbyList(e,c,b,g);if(a==-1){return null}if(a>=e.length){return null}d=f.getV(e,a);if(i===true){d=d.substr(2)}return d};ASN1HEX.getVbyListEx=function(b,e,a,d,f){var j=ASN1HEX;var g,c,i;g=j.getIdxbyListEx(b,e,a,d);if(g==-1){return null}i=j.getV(b,g);if(b.substr(g,2)=="03"&&f!==false){i=i.substr(2)}return i};ASN1HEX.getInt=function(e,b,f){if(f==undefined){f=-1}try{var c=e.substr(b,2);if(c!="02"&&c!="03"){return f}var a=ASN1HEX.getV(e,b);if(c=="02"){return parseInt(a,16)}else{return bitstrtoint(a)}}catch(d){return f}};ASN1HEX.getOID=function(c,a,d){if(d==undefined){d=null}try{if(c.substr(a,2)!="06"){return d}var e=ASN1HEX.getV(c,a);return hextooid(e)}catch(b){return d}};ASN1HEX.getOIDName=function(d,a,f){if(f==undefined){f=null}try{var e=ASN1HEX.getOID(d,a,f);if(e==f){return f}var b=KJUR.asn1.x509.OID.oid2name(e);if(b==""){return e}return b}catch(c){return f}};ASN1HEX.getString=function(d,b,e){if(e==undefined){e=null}try{var a=ASN1HEX.getV(d,b);return hextorstr(a)}catch(c){return e}};ASN1HEX.hextooidstr=function(e){var h=function(b,a){if(b.length>=a){return b}return new Array(a-b.length+1).join("0")+b};var l=[];var o=e.substr(0,2);var f=parseInt(o,16);l[0]=new String(Math.floor(f/40));l[1]=new String(f%40);var m=e.substr(2);var k=[];for(var g=0;g<m.length/2;g++){k.push(parseInt(m.substr(g*2,2),16))}var j=[];var d="";for(var g=0;g<k.length;g++){if(k[g]&128){d=d+h((k[g]&127).toString(2),7)}else{d=d+h((k[g]&127).toString(2),7);j.push(new String(parseInt(d,2)));d=""}}var n=l.join(".");if(j.length>0){n=n+"."+j.join(".")}return n};ASN1HEX.dump=function(t,c,l,g){var p=ASN1HEX;var j=p.getV;var y=p.dump;var w=p.getChildIdx;var e=t;if(t instanceof KJUR.asn1.ASN1Object){e=t.tohex()}var q=function(A,i){if(A.length<=i*2){return A}else{var v=A.substr(0,i)+"..(total "+A.length/2+"bytes).."+A.substr(A.length-i,i);return v}};if(c===undefined){c={ommit_long_octet:32}}if(l===undefined){l=0}if(g===undefined){g=""}var x=c.ommit_long_octet;var z=e.substr(l,2);if(z=="01"){var h=j(e,l);if(h=="00"){return g+"BOOLEAN FALSE\n"}else{return g+"BOOLEAN TRUE\n"}}if(z=="02"){var h=j(e,l);return g+"INTEGER "+q(h,x)+"\n"}if(z=="03"){var h=j(e,l);if(p.isASN1HEX(h.substr(2))){var k=g+"BITSTRING, encapsulates\n";k=k+y(h.substr(2),c,0,g+"  ");return k}else{return g+"BITSTRING "+q(h,x)+"\n"}}if(z=="04"){var h=j(e,l);if(p.isASN1HEX(h)){var k=g+"OCTETSTRING, encapsulates\n";k=k+y(h,c,0,g+"  ");return k}else{return g+"OCTETSTRING "+q(h,x)+"\n"}}if(z=="05"){return g+"NULL\n"}if(z=="06"){var m=j(e,l);var b=KJUR.asn1.ASN1Util.oidHexToInt(m);var o=KJUR.asn1.x509.OID.oid2name(b);var a=b.replace(/\./g," ");if(o!=""){return g+"ObjectIdentifier "+o+" ("+a+")\n"}else{return g+"ObjectIdentifier ("+a+")\n"}}if(z=="0a"){return g+"ENUMERATED "+parseInt(j(e,l))+"\n"}if(z=="0c"){return g+"UTF8String '"+hextoutf8(j(e,l))+"'\n"}if(z=="13"){return g+"PrintableString '"+hextoutf8(j(e,l))+"'\n"}if(z=="14"){return g+"TeletexString '"+hextoutf8(j(e,l))+"'\n"}if(z=="16"){return g+"IA5String '"+hextoutf8(j(e,l))+"'\n"}if(z=="17"){return g+"UTCTime "+hextoutf8(j(e,l))+"\n"}if(z=="18"){return g+"GeneralizedTime "+hextoutf8(j(e,l))+"\n"}if(z=="1a"){return g+"VisualString '"+hextoutf8(j(e,l))+"'\n"}if(z=="1e"){return g+"BMPString '"+ucs2hextoutf8(j(e,l))+"'\n"}if(z=="30"){if(e.substr(l,4)=="3000"){return g+"SEQUENCE {}\n"}var k=g+"SEQUENCE\n";var d=w(e,l);var f=c;if((d.length==2||d.length==3)&&e.substr(d[0],2)=="06"&&e.substr(d[d.length-1],2)=="04"){var o=p.oidname(j(e,d[0]));var r=JSON.parse(JSON.stringify(c));r.x509ExtName=o;f=r}for(var u=0;u<d.length;u++){k=k+y(e,f,d[u],g+"  ")}return k}if(z=="31"){var k=g+"SET\n";var d=w(e,l);for(var u=0;u<d.length;u++){k=k+y(e,c,d[u],g+"  ")}return k}var z=parseInt(z,16);if((z&128)!=0){var n=z&31;if((z&32)!=0){var k=g+"["+n+"]\n";var d=w(e,l);for(var u=0;u<d.length;u++){k=k+y(e,c,d[u],g+"  ")}return k}else{var h=j(e,l);if(ASN1HEX.isASN1HEX(h)){var k=g+"["+n+"]\n";k=k+y(h,c,0,g+"  ");return k}else{if(h.substr(0,8)=="68747470"){h=hextoutf8(h)}else{if(c.x509ExtName==="subjectAltName"&&n==2){h=hextoutf8(h)}}}var k=g+"["+n+"] "+h+"\n";return k}}return g+"UNKNOWN("+z+") "+j(e,l)+"\n"};ASN1HEX.parse=function(x){var t=ASN1HEX,f=t.parse,a=t.isASN1HEX,l=t.getV,b=t.getTLV,y=t.getChildIdx,i=KJUR.asn1,e=i.ASN1Util.oidHexToInt,B=i.x509.OID.oid2name,k=hextoutf8,n=ucs2hextoutf8,q=iso88591hextoutf8;var c={"0c":"utf8str","12":"numstr","13":"prnstr","14":"telstr","16":"ia5str","17":"utctime","18":"gentime","1a":"visstr","1e":"bmpstr","30":"seq","31":"set"};var u=function(H){var D=[];var E=y(H,0);for(var G=0;G<E.length;G++){var s=E[G];var d=b(H,s);var F=f(d);D.push(F)}return D};var C=x.substr(0,2);var j={};var p=l(x,0);if(C=="01"){if(x=="0101ff"){return{bool:true}}return{bool:false}}else{if(C=="02"){return{"int":{hex:p}}}else{if(C=="03"){try{if(p.substr(0,2)!="00"){throw"not encap"}var v=p.substr(2);if(!a(v)){throw"not encap"}return{bitstr:{obj:f(v)}}}catch(z){var m=null;if(p.length<=10){m=bitstrtobinstr(p)}if(m==null){return{bitstr:{hex:p}}}else{return{bitstr:{bin:m}}}}}else{if(C=="04"){try{if(!a(p)){throw"not encap"}return{octstr:{obj:f(p)}}}catch(z){return{octstr:{hex:p}}}}else{if(C=="05"){return{"null":""}}else{if(C=="06"){var g=e(p);var r=B(g);if(r==""){return{oid:g}}else{return{oid:r}}}else{if(C=="0a"){if(p.length>4){return{"enum":{hex:p}}}else{return{"enum":parseInt(p,16)}}}else{if(C=="30"||C=="31"){j[c[C]]=u(x);return j}else{if(C=="14"){var o=q(p);j[c[C]]={str:o};return j}else{if(C=="1e"){var o=n(p);j[c[C]]={str:o};return j}else{if(":0c:12:13:16:17:18:1a:".indexOf(C)!=-1){var o=k(p);j[c[C]]={str:o};return j}else{if(C.match(/^8[0-9]$/)){var o=k(p);if(o==null|o==""){return{tag:{tag:C,explicit:false,hex:p}}}else{if(o.match(/[\x00-\x1F\x7F-\x9F]/)!=null||o.match(/[\u0000-\u001F\u0080–\u009F]/)!=null){return{tag:{tag:C,explicit:false,hex:p}}}else{return{tag:{tag:C,explicit:false,str:o}}}}}else{if(C.match(/^a[0-9]$/)){try{if(!a(p)){throw new Error("not encap")}return{tag:{tag:C,explicit:true,obj:f(p)}}}catch(z){return{tag:{tag:C,explicit:true,hex:p}}}}else{var A=new KJUR.asn1.ASN1Object();A.hV=p;var w=A.getLengthHexFromValue();return{asn1:{tlv:C+w+p}}}}}}}}}}}}}}}};ASN1HEX.isContextTag=function(c,b){c=c.toLowerCase();var f,e;try{f=parseInt(c,16)}catch(d){return -1}if(b===undefined){if((f&192)==128){return true}else{return false}}try{var a=b.match(/^\[[0-9]+\]$/);if(a==null){return false}e=parseInt(b.substr(1,b.length-1),10);if(e>31){return false}if(((f&192)==128)&&((f&31)==e)){return true}return false}catch(d){return false}};ASN1HEX.isASN1HEX=function(e){var d=ASN1HEX;if(e.length%2==1){return false}var c=d.getVblen(e,0);var b=e.substr(0,2);var f=d.getL(e,0);var a=e.length-b.length-f.length;if(a==c*2){return true}return false};ASN1HEX.checkStrictDER=function(g,o,d,c,r){var s=ASN1HEX;if(d===undefined){if(typeof g!="string"){throw new Error("not hex string")}g=g.toLowerCase();if(!KJUR.lang.String.isHex(g)){throw new Error("not hex string")}d=g.length;c=g.length/2;if(c<128){r=1}else{r=Math.ceil(c.toString(16))+1}}var k=s.getL(g,o);if(k.length>r*2){throw new Error("L of TLV too long: idx="+o)}var n=s.getVblen(g,o);if(n>c){throw new Error("value of L too long than hex: idx="+o)}var q=s.getTLV(g,o);var f=q.length-2-s.getL(g,o).length;if(f!==(n*2)){throw new Error("V string length and L's value not the same:"+f+"/"+(n*2))}if(o===0){if(g.length!=q.length){throw new Error("total length and TLV length unmatch:"+g.length+"!="+q.length)}}var b=g.substr(o,2);if(b==="02"){var a=s.getVidx(g,o);if(g.substr(a,2)=="00"&&g.charCodeAt(a+2)<56){throw new Error("not least zeros for DER INTEGER")}}if(parseInt(b,16)&32){var p=s.getVblen(g,o);var m=0;var l=s.getChildIdx(g,o);for(var e=0;e<l.length;e++){var j=s.getTLV(g,l[e]);m+=j.length;s.checkStrictDER(g,l[e],d,c,r)}if((p*2)!=m){throw new Error("sum of children's TLV length and L unmatch: "+(p*2)+"!="+m)}}};ASN1HEX.oidname=function(a){var c=KJUR.asn1;if(KJUR.lang.String.isHex(a)){a=c.ASN1Util.oidHexToInt(a)}var b=c.x509.OID.oid2name(a);if(b===""){b=a}return b};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.x509=="undefined"||!KJUR.asn1.x509){KJUR.asn1.x509={}}KJUR.asn1.x509.Certificate=function(h){KJUR.asn1.x509.Certificate.superclass.constructor.call(this);var d=KJUR,c=d.asn1,f=c.DERBitString,b=c.DERSequence,g=c.x509,a=g.TBSCertificate,e=g.AlgorithmIdentifier;this.params=undefined;this.setByParam=function(i){this.params=i};this.sign=function(){var l=this.params;var k=l.sigalg;if(l.sigalg.name!=undefined){k=l.sigalg.name}var i=l.tbsobj.tohex();var j=new KJUR.crypto.Signature({alg:k});j.init(l.cakey);j.updateHex(i);l.sighex=j.sign()};this.getPEM=function(){return hextopem(this.tohex(),"CERTIFICATE")};this.tohex=function(){var k=this.params;if(k.tbsobj==undefined||k.tbsobj==null){k.tbsobj=new a(k)}if(k.sighex==undefined&&k.cakey!=undefined){this.sign()}if(k.sighex==undefined){throw new Error("sighex or cakey parameter not defined")}var i=[];i.push(k.tbsobj);i.push(new e({name:k.sigalg}));i.push(new f({hex:"00"+k.sighex}));var j=new b({array:i});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};if(h!=undefined){this.params=h}};extendClass(KJUR.asn1.x509.Certificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertificate=function(f){KJUR.asn1.x509.TBSCertificate.superclass.constructor.call(this);var b=KJUR,i=b.asn1,d=i.x509,c=i.DERTaggedObject,h=i.DERInteger,g=i.DERSequence,l=d.AlgorithmIdentifier,e=d.Time,a=d.X500Name,j=d.Extensions,k=d.SubjectPublicKeyInfo;this.params=null;this.setByParam=function(m){this.params=m};this.tohex=function(){var n=[];var q=this.params;if(q.version!=undefined||q.version!=1){var m=2;if(q.version!=undefined){m=q.version-1}var p=new c({obj:new h({"int":m})});n.push(p)}n.push(new h(q.serial));n.push(new l({name:q.sigalg}));n.push(new a(q.issuer));n.push(new g({array:[new e(q.notbefore),new e(q.notafter)]}));n.push(new a(q.subject));n.push(new k(KEYUTIL.getKey(q.sbjpubkey)));if(q.ext!==undefined&&q.ext.length>0){n.push(new c({tag:"a3",obj:new j(q.ext)}))}var o=new KJUR.asn1.DERSequence({array:n});return o.tohex()};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){this.setByParam(f)}};extendClass(KJUR.asn1.x509.TBSCertificate,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extensions=function(d){KJUR.asn1.x509.Extensions.superclass.constructor.call(this);var c=KJUR,b=c.asn1,a=b.DERSequence,e=b.x509;this.aParam=[];this.setByParam=function(f){this.aParam=f};this.tohex=function(){var f=[];for(var h=0;h<this.aParam.length;h++){var l=this.aParam[h];var k=l.extname;var j=null;if(l.extn!=undefined){j=new e.PrivateExtension(l)}else{if(k=="subjectKeyIdentifier"){j=new e.SubjectKeyIdentifier(l)}else{if(k=="keyUsage"){j=new e.KeyUsage(l)}else{if(k=="subjectAltName"){j=new e.SubjectAltName(l)}else{if(k=="issuerAltName"){j=new e.IssuerAltName(l)}else{if(k=="basicConstraints"){j=new e.BasicConstraints(l)}else{if(k=="nameConstraints"){j=new e.NameConstraints(l)}else{if(k=="cRLDistributionPoints"){j=new e.CRLDistributionPoints(l)}else{if(k=="certificatePolicies"){j=new e.CertificatePolicies(l)}else{if(k=="policyMappings"){j=new e.PolicyMappings(l)}else{if(k=="policyConstraints"){j=new e.PolicyConstraints(l)}else{if(k=="inhibitAnyPolicy"){j=new e.InhibitAnyPolicy(l)}else{if(k=="authorityKeyIdentifier"){j=new e.AuthorityKeyIdentifier(l)}else{if(k=="extKeyUsage"){j=new e.ExtKeyUsage(l)}else{if(k=="authorityInfoAccess"){j=new e.AuthorityInfoAccess(l)}else{if(k=="cRLNumber"){j=new e.CRLNumber(l)}else{if(k=="cRLReason"){j=new e.CRLReason(l)}else{if(k=="ocspNonce"){j=new e.OCSPNonce(l)}else{if(k=="ocspNoCheck"){j=new e.OCSPNoCheck(l)}else{if(k=="adobeTimeStamp"){j=new e.AdobeTimeStamp(l)}else{if(k=="subjectDirectoryAttributes"){j=new e.SubjectDirectoryAttributes(l)}else{throw new Error("extension not supported:"+JSON.stringify(l))}}}}}}}}}}}}}}}}}}}}}if(j!=null){f.push(j)}}var g=new a({array:f});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!=undefined){this.setByParam(d)}};extendClass(KJUR.asn1.x509.Extensions,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Extension=function(d){KJUR.asn1.x509.Extension.superclass.constructor.call(this);var f=null,a=KJUR,e=a.asn1,h=e.DERObjectIdentifier,i=e.DEROctetString,b=e.DERBitString,g=e.DERBoolean,c=e.DERSequence;this.tohex=function(){var m=new h({oid:this.oid});var l=new i({hex:this.getExtnValueHex()});var k=new Array();k.push(m);if(this.critical){k.push(new g())}k.push(l);var j=new c({array:k});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};this.critical=false;if(d!==undefined){if(d.critical!==undefined){this.critical=d.critical}}};extendClass(KJUR.asn1.x509.Extension,KJUR.asn1.ASN1Object);KJUR.asn1.x509.KeyUsage=function(c){KJUR.asn1.x509.KeyUsage.superclass.constructor.call(this,c);var b=Error;var a={digitalSignature:0,nonRepudiation:1,keyEncipherment:2,dataEncipherment:3,keyAgreement:4,keyCertSign:5,cRLSign:6,encipherOnly:7,decipherOnly:8};this.getExtnValueHex=function(){var d=this.getBinValue();this.asn1ExtnValue=new KJUR.asn1.DERBitString({bin:d});return this.asn1ExtnValue.tohex()};this.getBinValue=function(){var d=this.params;if(typeof d!="object"||(typeof d.names!="object"&&typeof d.bin!="string")){throw new b("parameter not yet set")}if(d.names!=undefined){return namearraytobinstr(d.names,a)}else{if(d.bin!=undefined){return d.bin}else{throw new b("parameter not set properly")}}};this.oid="2.5.29.15";if(c!==undefined){this.params=c}};extendClass(KJUR.asn1.x509.KeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.BasicConstraints=function(g){KJUR.asn1.x509.BasicConstraints.superclass.constructor.call(this,g);var c=KJUR.asn1,e=c.DERBoolean,f=c.DERInteger,b=c.DERSequence;var a=false;var d=-1;this.getExtnValueHex=function(){var i=new Array();if(this.cA){i.push(new e())}if(this.pathLen>-1){i.push(new f({"int":this.pathLen}))}var h=new b({array:i});this.asn1ExtnValue=h;return this.asn1ExtnValue.tohex()};this.oid="2.5.29.19";this.cA=false;this.pathLen=-1;if(g!==undefined){if(g.cA!==undefined){this.cA=g.cA}if(g.pathLen!==undefined){this.pathLen=g.pathLen}}};extendClass(KJUR.asn1.x509.BasicConstraints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRLDistributionPoints=function(d){KJUR.asn1.x509.CRLDistributionPoints.superclass.constructor.call(this,d);var b=KJUR,a=b.asn1,c=a.x509;this.getExtnValueHex=function(){return this.asn1ExtnValue.tohex()};this.setByDPArray=function(e){var f=[];for(var g=0;g<e.length;g++){if(e[g] instanceof KJUR.asn1.ASN1Object){f.push(e[g])}else{var h=new c.DistributionPoint(e[g]);f.push(h)}}this.asn1ExtnValue=new a.DERSequence({array:f})};this.setByOneURI=function(f){var e=new c.DistributionPoint({fulluri:f});this.setByDPArray([e])};this.oid="2.5.29.31";if(d!==undefined){if(d.array!==undefined){this.setByDPArray(d.array)}else{if(d.uri!==undefined){this.setByOneURI(d.uri)}}}};extendClass(KJUR.asn1.x509.CRLDistributionPoints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.DistributionPoint=function(e){KJUR.asn1.x509.DistributionPoint.superclass.constructor.call(this);var a=null,c=KJUR,b=c.asn1,d=b.x509.DistributionPointName;this.tohex=function(){var f=new b.DERSequence();if(this.asn1DP!=null){var g=new b.DERTaggedObject({explicit:true,tag:"a0",obj:this.asn1DP});f.appendASN1Object(g)}this.hTLV=f.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){if(e.dpobj!==undefined){this.asn1DP=e.dpobj}else{if(e.dpname!==undefined){this.asn1DP=new d(e.dpname)}else{if(e.fulluri!==undefined){this.asn1DP=new d({full:[{uri:e.fulluri}]})}}}}};extendClass(KJUR.asn1.x509.DistributionPoint,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DistributionPointName=function(h){KJUR.asn1.x509.DistributionPointName.superclass.constructor.call(this);var g=null,d=null,a=null,f=null,c=KJUR,b=c.asn1,e=b.DERTaggedObject;this.tohex=function(){if(this.type!="full"){throw new Error("currently type shall be 'full': "+this.type)}this.asn1Obj=new e({explicit:false,tag:this.tag,obj:this.asn1V});this.hTLV=this.asn1Obj.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(h!==undefined){if(b.x509.GeneralNames.prototype.isPrototypeOf(h)){this.type="full";this.tag="a0";this.asn1V=h}else{if(h.full!==undefined){this.type="full";this.tag="a0";this.asn1V=new b.x509.GeneralNames(h.full)}else{throw new Error("This class supports GeneralNames only as argument")}}}};extendClass(KJUR.asn1.x509.DistributionPointName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.CertificatePolicies=function(f){KJUR.asn1.x509.CertificatePolicies.superclass.constructor.call(this,f);var c=KJUR,b=c.asn1,e=b.x509,a=b.DERSequence,d=e.PolicyInformation;this.params=null;this.getExtnValueHex=function(){var j=[];for(var h=0;h<this.params.array.length;h++){j.push(new d(this.params.array[h]))}var g=new a({array:j});this.asn1ExtnValue=g;return this.asn1ExtnValue.tohex()};this.oid="2.5.29.32";if(f!==undefined){this.params=f}};extendClass(KJUR.asn1.x509.CertificatePolicies,KJUR.asn1.x509.Extension);KJUR.asn1.x509.PolicyInformation=function(d){KJUR.asn1.x509.PolicyInformation.superclass.constructor.call(this,d);var c=KJUR.asn1,b=c.DERSequence,e=c.DERObjectIdentifier,a=c.x509.PolicyQualifierInfo;this.params=null;this.tohex=function(){if(this.params.policyoid===undefined&&this.params.array===undefined){throw new Error("parameter oid and array missing")}var f=[new e(this.params.policyoid)];if(this.params.array!==undefined){var j=[];for(var h=0;h<this.params.array.length;h++){j.push(new a(this.params.array[h]))}if(j.length>0){f.push(new b({array:j}))}}var g=new b({array:f});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!==undefined){this.params=d}};extendClass(KJUR.asn1.x509.PolicyInformation,KJUR.asn1.ASN1Object);KJUR.asn1.x509.PolicyQualifierInfo=function(e){KJUR.asn1.x509.PolicyQualifierInfo.superclass.constructor.call(this,e);var c=KJUR.asn1,b=c.DERSequence,d=c.DERIA5String,f=c.DERObjectIdentifier,a=c.x509.UserNotice;this.params=null;this.tohex=function(){if(this.params.cps!==undefined){var g=new b({array:[new f({oid:"1.3.6.1.5.5.7.2.1"}),new d({str:this.params.cps})]});return g.tohex()}if(this.params.unotice!=undefined){var g=new b({array:[new f({oid:"1.3.6.1.5.5.7.2.2"}),new a(this.params.unotice)]});return g.tohex()}};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.PolicyQualifierInfo,KJUR.asn1.ASN1Object);KJUR.asn1.x509.UserNotice=function(e){KJUR.asn1.x509.UserNotice.superclass.constructor.call(this,e);var a=KJUR.asn1.DERSequence,d=KJUR.asn1.DERInteger,c=KJUR.asn1.x509.DisplayText,b=KJUR.asn1.x509.NoticeReference;this.params=null;this.tohex=function(){var f=[];if(this.params.noticeref!==undefined){f.push(new b(this.params.noticeref))}if(this.params.exptext!==undefined){f.push(new c(this.params.exptext))}var g=new a({array:f});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.UserNotice,KJUR.asn1.ASN1Object);KJUR.asn1.x509.NoticeReference=function(d){KJUR.asn1.x509.NoticeReference.superclass.constructor.call(this,d);var a=KJUR.asn1.DERSequence,c=KJUR.asn1.DERInteger,b=KJUR.asn1.x509.DisplayText;this.params=null;this.tohex=function(){var f=[];if(this.params.org!==undefined){f.push(new b(this.params.org))}if(this.params.noticenum!==undefined){var h=[];var e=this.params.noticenum;for(var j=0;j<e.length;j++){h.push(new c(e[j]))}f.push(new a({array:h}))}if(f.length==0){throw new Error("parameter is empty")}var g=new a({array:f});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!==undefined){this.params=d}};extendClass(KJUR.asn1.x509.NoticeReference,KJUR.asn1.ASN1Object);KJUR.asn1.x509.DisplayText=function(a){KJUR.asn1.x509.DisplayText.superclass.constructor.call(this,a);this.hT="0c";if(a!==undefined){if(a.type==="ia5"){this.hT="16"}else{if(a.type==="vis"){this.hT="1a"}else{if(a.type==="bmp"){this.hT="1e"}}}}};extendClass(KJUR.asn1.x509.DisplayText,KJUR.asn1.DERAbstractString);KJUR.asn1.x509.PolicyMappings=function(e){KJUR.asn1.x509.PolicyMappings.superclass.constructor.call(this,e);var c=KJUR,b=c.asn1,d=b.x509,a=b.ASN1Util.newObject;this.params=null;this.getExtnValueHex=function(){var j=this.params;var f=[];for(var g=0;g<j.array.length;g++){var h=j.array[g];f.push({seq:[{oid:h[0]},{oid:h[1]}]})}this.asn1ExtnValue=a({seq:f});return this.asn1ExtnValue.tohex()};this.oid="2.5.29.33";if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.PolicyMappings,KJUR.asn1.x509.Extension);KJUR.asn1.x509.PolicyConstraints=function(e){KJUR.asn1.x509.PolicyConstraints.superclass.constructor.call(this,e);var c=KJUR,b=c.asn1,d=b.x509,a=b.ASN1Util.newObject;this.params=null;this.getExtnValueHex=function(){var g=this.params;var f=[];if(g.reqexp!=undefined){f.push({tag:{tagi:"80",obj:{"int":g.reqexp}}})}if(g.inhibit!=undefined){f.push({tag:{tagi:"81",obj:{"int":g.inhibit}}})}this.asn1ExtnValue=a({seq:f});return this.asn1ExtnValue.tohex()};this.oid="2.5.29.36";if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.PolicyConstraints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.InhibitAnyPolicy=function(e){KJUR.asn1.x509.InhibitAnyPolicy.superclass.constructor.call(this,e);var c=KJUR,b=c.asn1,d=b.x509,a=b.ASN1Util.newObject;this.params=null;this.getExtnValueHex=function(){this.asn1ExtnValue=a({"int":this.params.skip});return this.asn1ExtnValue.tohex()};this.oid="2.5.29.54";if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.InhibitAnyPolicy,KJUR.asn1.x509.Extension);KJUR.asn1.x509.NameConstraints=function(f){KJUR.asn1.x509.NameConstraints.superclass.constructor.call(this,f);var c=KJUR,b=c.asn1,e=b.x509,a=b.ASN1Util.newObject,d=e.GeneralSubtree;this.params=null;this.getExtnValueHex=function(){var l=this.params;var g=[];if(l.permit!=undefined&&l.permit.length!=undefined){var k=[];for(var h=0;h<l.permit.length;h++){k.push(new d(l.permit[h]))}g.push({tag:{tagi:"a0",obj:{seq:k}}})}if(l.exclude!=undefined&&l.exclude.length!=undefined){var j=[];for(var h=0;h<l.exclude.length;h++){j.push(new d(l.exclude[h]))}g.push({tag:{tagi:"a1",obj:{seq:j}}})}this.asn1ExtnValue=a({seq:g});return this.asn1ExtnValue.tohex()};this.oid="2.5.29.30";if(f!==undefined){this.params=f}};extendClass(KJUR.asn1.x509.NameConstraints,KJUR.asn1.x509.Extension);KJUR.asn1.x509.GeneralSubtree=function(e){KJUR.asn1.x509.GeneralSubtree.superclass.constructor.call(this);var b=KJUR.asn1,d=b.x509,c=d.GeneralName,a=b.ASN1Util.newObject;this.params=null;this.setByParam=function(f){this.params=f};this.tohex=function(){var h=this.params;var f=[new c(h)];if(h.min!=undefined){f.push({tag:{tagi:"80",obj:{"int":h.min}}})}if(h.max!=undefined){f.push({tag:{tagi:"81",obj:{"int":h.max}}})}var g=a({seq:f});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.setByParam(e)}};extendClass(KJUR.asn1.x509.GeneralSubtree,KJUR.asn1.ASN1Object);KJUR.asn1.x509.ExtKeyUsage=function(c){KJUR.asn1.x509.ExtKeyUsage.superclass.constructor.call(this,c);var b=KJUR,a=b.asn1;this.setPurposeArray=function(d){this.asn1ExtnValue=new a.DERSequence();for(var e=0;e<d.length;e++){var f=new a.DERObjectIdentifier(d[e]);this.asn1ExtnValue.appendASN1Object(f)}};this.getExtnValueHex=function(){return this.asn1ExtnValue.tohex()};this.oid="2.5.29.37";if(c!==undefined){if(c.array!==undefined){this.setPurposeArray(c.array)}}};extendClass(KJUR.asn1.x509.ExtKeyUsage,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityKeyIdentifier=function(f){KJUR.asn1.x509.AuthorityKeyIdentifier.superclass.constructor.call(this,f);var b=KJUR,a=b.asn1,d=a.DERTaggedObject,e=a.x509.GeneralNames,c=b.crypto.Util.isKey;this.asn1KID=null;this.asn1CertIssuer=null;this.asn1CertSN=null;this.getExtnValueHex=function(){var h=new Array();if(this.asn1KID){h.push(new d({explicit:false,tag:"80",obj:this.asn1KID}))}if(this.asn1CertIssuer){h.push(new d({explicit:false,tag:"a1",obj:new e([{dn:this.asn1CertIssuer}])}))}if(this.asn1CertSN){h.push(new d({explicit:false,tag:"82",obj:this.asn1CertSN}))}var g=new a.DERSequence({array:h});this.asn1ExtnValue=g;return this.asn1ExtnValue.tohex()};this.setKIDByParam=function(i){if(i.str!==undefined||i.hex!==undefined){this.asn1KID=new KJUR.asn1.DEROctetString(i)}else{if((typeof i==="object"&&KJUR.crypto.Util.isKey(i))||(typeof i==="string"&&i.indexOf("BEGIN ")!=-1)){var h=i;if(typeof i==="string"){h=KEYUTIL.getKey(i)}var g=KEYUTIL.getKeyID(h);this.asn1KID=new KJUR.asn1.DEROctetString({hex:g})}}};this.setCertIssuerByParam=function(g){if(g.str!==undefined||g.ldapstr!==undefined||g.hex!==undefined||g.certsubject!==undefined||g.certissuer!==undefined){this.asn1CertIssuer=new KJUR.asn1.x509.X500Name(g)}else{if(typeof g==="string"&&g.indexOf("BEGIN ")!=-1&&g.indexOf("CERTIFICATE")!=-1){this.asn1CertIssuer=new KJUR.asn1.x509.X500Name({certissuer:g})}}};this.setCertSNByParam=function(i){if(i.str!==undefined||i.bigint!==undefined||i.hex!==undefined){this.asn1CertSN=new KJUR.asn1.DERInteger(i)}else{if(typeof i==="string"&&i.indexOf("BEGIN ")!=-1&&i.indexOf("CERTIFICATE")){var g=new X509();g.readCertPEM(i);var h=g.getSerialNumberHex();this.asn1CertSN=new KJUR.asn1.DERInteger({hex:h})}}};this.oid="2.5.29.35";if(f!==undefined){if(f.kid!==undefined){this.setKIDByParam(f.kid)}if(f.issuer!==undefined){this.setCertIssuerByParam(f.issuer)}if(f.sn!==undefined){this.setCertSNByParam(f.sn)}if(f.issuersn!==undefined&&typeof f.issuersn==="string"&&f.issuersn.indexOf("BEGIN ")!=-1&&f.issuersn.indexOf("CERTIFICATE")){this.setCertSNByParam(f.issuersn);this.setCertIssuerByParam(f.issuersn)}}};extendClass(KJUR.asn1.x509.AuthorityKeyIdentifier,KJUR.asn1.x509.Extension);KJUR.asn1.x509.SubjectKeyIdentifier=function(d){KJUR.asn1.x509.SubjectKeyIdentifier.superclass.constructor.call(this,d);var b=KJUR,a=b.asn1,c=a.DEROctetString;this.asn1KID=null;this.getExtnValueHex=function(){this.asn1ExtnValue=this.asn1KID;return this.asn1ExtnValue.tohex()};this.setKIDByParam=function(g){if(g.str!==undefined||g.hex!==undefined){this.asn1KID=new c(g)}else{if((typeof g==="object"&&KJUR.crypto.Util.isKey(g))||(typeof g==="string"&&g.indexOf("BEGIN")!=-1)){var f=g;if(typeof g==="string"){f=KEYUTIL.getKey(g)}var e=KEYUTIL.getKeyID(f);this.asn1KID=new KJUR.asn1.DEROctetString({hex:e})}}};this.oid="2.5.29.14";if(d!==undefined){if(d.kid!==undefined){this.setKIDByParam(d.kid)}}};extendClass(KJUR.asn1.x509.SubjectKeyIdentifier,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AuthorityInfoAccess=function(a){KJUR.asn1.x509.AuthorityInfoAccess.superclass.constructor.call(this,a);this.setAccessDescriptionArray=function(k){var d=new Array(),b=KJUR,g=b.asn1,c=g.DERSequence,j=g.DERObjectIdentifier,l=g.x509.GeneralName;for(var f=0;f<k.length;f++){var e;var h=k[f];if(h.ocsp!==undefined){e=new c({array:[new j({oid:"1.3.6.1.5.5.7.48.1"}),new l({uri:h.ocsp})]})}else{if(h.caissuer!==undefined){e=new c({array:[new j({oid:"1.3.6.1.5.5.7.48.2"}),new l({uri:h.caissuer})]})}else{throw new Error("unknown AccessMethod parameter: "+JSON.stringify(h))}}d.push(e)}this.asn1ExtnValue=new c({array:d})};this.getExtnValueHex=function(){return this.asn1ExtnValue.tohex()};this.oid="1.3.6.1.5.5.7.1.1";if(a!==undefined){if(a.array!==undefined){this.setAccessDescriptionArray(a.array)}}};extendClass(KJUR.asn1.x509.AuthorityInfoAccess,KJUR.asn1.x509.Extension);KJUR.asn1.x509.SubjectAltName=function(a){KJUR.asn1.x509.SubjectAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b)};this.getExtnValueHex=function(){return this.asn1ExtnValue.tohex()};this.oid="2.5.29.17";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array)}}};extendClass(KJUR.asn1.x509.SubjectAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.IssuerAltName=function(a){KJUR.asn1.x509.IssuerAltName.superclass.constructor.call(this,a);this.setNameArray=function(b){this.asn1ExtnValue=new KJUR.asn1.x509.GeneralNames(b)};this.getExtnValueHex=function(){return this.asn1ExtnValue.tohex()};this.oid="2.5.29.18";if(a!==undefined){if(a.array!==undefined){this.setNameArray(a.array)}}};extendClass(KJUR.asn1.x509.IssuerAltName,KJUR.asn1.x509.Extension);KJUR.asn1.x509.SubjectDirectoryAttributes=function(e){KJUR.asn1.x509.SubjectDirectoryAttributes.superclass.constructor.call(this,e);var c=KJUR.asn1,a=c.DERSequence,b=c.ASN1Util.newObject,d=c.x509.OID.name2oid;this.params=null;this.getExtnValueHex=function(){var f=[];for(var j=0;j<this.params.array.length;j++){var k=this.params.array[j];var h={seq:[{oid:"1.2.3.4"},{set:[{utf8str:"DE"}]}]};if(k.attr=="dateOfBirth"){h.seq[0].oid=d(k.attr);h.seq[1].set[0]={gentime:k.str}}else{if(k.attr=="placeOfBirth"){h.seq[0].oid=d(k.attr);h.seq[1].set[0]={utf8str:k.str}}else{if(k.attr=="gender"){h.seq[0].oid=d(k.attr);h.seq[1].set[0]={prnstr:k.str}}else{if(k.attr=="countryOfCitizenship"){h.seq[0].oid=d(k.attr);h.seq[1].set[0]={prnstr:k.str}}else{if(k.attr=="countryOfResidence"){h.seq[0].oid=d(k.attr);h.seq[1].set[0]={prnstr:k.str}}else{throw new Error("unsupported attribute: "+k.attr)}}}}}f.push(new b(h))}var g=new a({array:f});this.asn1ExtnValue=g;return this.asn1ExtnValue.tohex()};this.oid="2.5.29.9";if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.x509.SubjectDirectoryAttributes,KJUR.asn1.x509.Extension);KJUR.asn1.x509.PrivateExtension=function(f){KJUR.asn1.x509.PrivateExtension.superclass.constructor.call(this,f);var c=KJUR,e=c.lang.String.isHex,b=c.asn1,d=b.x509.OID.name2oid,a=b.ASN1Util.newObject;this.params=null;this.setByParam=function(g){this.oid=d(g.extname);this.params=g};this.getExtnValueHex=function(){if(this.params.extname==undefined||this.params.extn==undefined){throw new Error("extname or extnhex not specified")}var h=this.params.extn;if(typeof h=="string"&&e(h)){return h}else{if(typeof h=="object"){try{return a(h).tohex()}catch(g){}}}throw new Error("unsupported extn value")};if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.x509.PrivateExtension,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRL=function(g){KJUR.asn1.x509.CRL.superclass.constructor.call(this);var c=KJUR,b=c.asn1,a=b.DERSequence,e=b.DERBitString,f=b.x509,d=f.AlgorithmIdentifier,h=f.TBSCertList;this.params=undefined;this.setByParam=function(i){this.params=i};this.sign=function(){var j=(new h(this.params)).tohex();var k=new KJUR.crypto.Signature({alg:this.params.sigalg});k.init(this.params.cakey);k.updateHex(j);var i=k.sign();this.params.sighex=i};this.getPEM=function(){return hextopem(this.tohex(),"X509 CRL")};this.tohex=function(){var k=this.params;if(k.tbsobj==undefined){k.tbsobj=new h(k)}if(k.sighex==undefined&&k.cakey!=undefined){this.sign()}if(k.sighex==undefined){throw new Error("sighex or cakey parameter not defined")}var i=[];i.push(k.tbsobj);i.push(new d({name:k.sigalg}));i.push(new e({hex:"00"+k.sighex}));var j=new a({array:i});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.params=g}};extendClass(KJUR.asn1.x509.CRL,KJUR.asn1.ASN1Object);KJUR.asn1.x509.TBSCertList=function(f){KJUR.asn1.x509.TBSCertList.superclass.constructor.call(this);var b=KJUR,i=b.asn1,h=i.DERInteger,g=i.DERSequence,c=i.DERTaggedObject,k=i.DERObjectIdentifier,d=i.x509,l=d.AlgorithmIdentifier,e=d.Time,j=d.Extensions,a=d.X500Name;this.params=null;this.setByParam=function(m){this.params=m};this.getRevCertSequence=function(){var m=[];var n=this.params.revcert;for(var o=0;o<n.length;o++){var p=[new h(n[o].sn),new e(n[o].date)];if(n[o].ext!=undefined){p.push(new j(n[o].ext))}m.push(new g({array:p}))}return new g({array:m})};this.tohex=function(){var n=[];var r=this.params;if(r.version!=undefined){var m=r.version-1;var p=new h({"int":m});n.push(p)}n.push(new l({name:r.sigalg}));n.push(new a(r.issuer));n.push(new e(r.thisupdate));if(r.nextupdate!=undefined){n.push(new e(r.nextupdate))}if(r.revcert!=undefined){n.push(this.getRevCertSequence())}if(r.ext!=undefined){var q=new j(r.ext);n.push(new c({tag:"a0",explicit:true,obj:q}))}var o=new g({array:n});return o.tohex()};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){this.setByParam(f)}};extendClass(KJUR.asn1.x509.TBSCertList,KJUR.asn1.ASN1Object);KJUR.asn1.x509.CRLEntry=function(e){KJUR.asn1.x509.CRLEntry.superclass.constructor.call(this);var d=null,c=null,b=KJUR,a=b.asn1;this.setCertSerial=function(f){this.sn=new a.DERInteger(f)};this.setRevocationDate=function(f){this.time=new a.x509.Time(f)};this.tohex=function(){var f=new a.DERSequence({array:[this.sn,this.time]});this.TLV=f.tohex();return this.TLV};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){if(e.time!==undefined){this.setRevocationDate(e.time)}if(e.sn!==undefined){this.setCertSerial(e.sn)}}};extendClass(KJUR.asn1.x509.CRLEntry,KJUR.asn1.ASN1Object);KJUR.asn1.x509.CRLNumber=function(a){KJUR.asn1.x509.CRLNumber.superclass.constructor.call(this,a);this.params=undefined;this.getExtnValueHex=function(){this.asn1ExtnValue=new KJUR.asn1.DERInteger(this.params.num);return this.asn1ExtnValue.tohex()};this.oid="2.5.29.20";if(a!=undefined){this.params=a}};extendClass(KJUR.asn1.x509.CRLNumber,KJUR.asn1.x509.Extension);KJUR.asn1.x509.CRLReason=function(a){KJUR.asn1.x509.CRLReason.superclass.constructor.call(this,a);this.params=undefined;this.getExtnValueHex=function(){this.asn1ExtnValue=new KJUR.asn1.DEREnumerated(this.params.code);return this.asn1ExtnValue.tohex()};this.oid="2.5.29.21";if(a!=undefined){this.params=a}};extendClass(KJUR.asn1.x509.CRLReason,KJUR.asn1.x509.Extension);KJUR.asn1.x509.OCSPNonce=function(a){KJUR.asn1.x509.OCSPNonce.superclass.constructor.call(this,a);this.params=undefined;this.getExtnValueHex=function(){this.asn1ExtnValue=new KJUR.asn1.DEROctetString(this.params);return this.asn1ExtnValue.tohex()};this.oid="1.3.6.1.5.5.7.48.1.2";if(a!=undefined){this.params=a}};extendClass(KJUR.asn1.x509.OCSPNonce,KJUR.asn1.x509.Extension);KJUR.asn1.x509.OCSPNoCheck=function(a){KJUR.asn1.x509.OCSPNoCheck.superclass.constructor.call(this,a);this.params=undefined;this.getExtnValueHex=function(){this.asn1ExtnValue=new KJUR.asn1.DERNull();return this.asn1ExtnValue.tohex()};this.oid="1.3.6.1.5.5.7.48.1.5";if(a!=undefined){this.params=a}};extendClass(KJUR.asn1.x509.OCSPNoCheck,KJUR.asn1.x509.Extension);KJUR.asn1.x509.AdobeTimeStamp=function(g){KJUR.asn1.x509.AdobeTimeStamp.superclass.constructor.call(this,g);var c=KJUR,b=c.asn1,f=b.DERInteger,d=b.DERBoolean,a=b.DERSequence,e=b.x509.GeneralName;this.params=null;this.getExtnValueHex=function(){var i=this.params;var h=[new f(1)];h.push(new e({uri:i.uri}));if(i.reqauth!=undefined){h.push(new d(i.reqauth))}this.asn1ExtnValue=new a({array:h});return this.asn1ExtnValue.tohex()};this.oid="1.2.840.113583.1.1.9.1";if(g!==undefined){this.setByParam(g)}};extendClass(KJUR.asn1.x509.AdobeTimeStamp,KJUR.asn1.x509.Extension);KJUR.asn1.x509.X500Name=function(f){KJUR.asn1.x509.X500Name.superclass.constructor.call(this);this.asn1Array=[];this.paramArray=[];this.sRule="utf8";var c=KJUR,b=c.asn1,e=b.x509,d=e.RDN,a=pemtohex;this.setByString=function(g,l){if(l!==undefined){this.sRule=l}var k=g.split("/");k.shift();var j=[];for(var m=0;m<k.length;m++){if(k[m].match(/^[^=]+=.+$/)){j.push(k[m])}else{var h=j.length-1;j[h]=j[h]+"/"+k[m]}}for(var m=0;m<j.length;m++){this.asn1Array.push(new d({str:j[m],rule:this.sRule}))}};this.setByLdapString=function(g,h){if(h!==undefined){this.sRule=h}var i=e.X500Name.ldapToCompat(g);this.setByString(i,h)};this.setByObject=function(j,i){if(i!==undefined){this.sRule=i}for(var g in j){if(j.hasOwnProperty(g)){var h=new d({str:g+"="+j[g],rule:this.sRule});this.asn1Array?this.asn1Array.push(h):this.asn1Array=[h]}}};this.setByParam=function(h){if(h.rule!==undefined){this.sRule=h.rule}if(h.array!==undefined){this.paramArray=h.array}else{if(h.str!==undefined){this.setByString(h.str)}else{if(h.ldapstr!==undefined){this.setByLdapString(h.ldapstr)}else{if(h.hex!==undefined){this.hTLV=h.hex}else{if(h.certissuer!==undefined){var g=new X509();g.readCertPEM(h.certissuer);this.hTLV=g.getIssuerHex()}else{if(h.certsubject!==undefined){var g=new X509();g.readCertPEM(h.certsubject);this.hTLV=g.getSubjectHex()}else{if(typeof h==="object"&&h.certsubject===undefined&&h.certissuer===undefined){this.setByObject(h)}}}}}}}};this.tohex=function(){if(typeof this.hTLV=="string"){return this.hTLV}if(this.asn1Array.length==0&&this.paramArray.length>0){for(var g=0;g<this.paramArray.length;g++){var k={array:this.paramArray[g]};if(this.sRule!="utf8"){k.rule=this.sRule}var h=new d(k);this.asn1Array.push(h)}}var j=new b.DERSequence({array:this.asn1Array});this.hTLV=j.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){this.setByParam(f)}};extendClass(KJUR.asn1.x509.X500Name,KJUR.asn1.ASN1Object);KJUR.asn1.x509.X500Name.compatToLDAP=function(d){if(d.substr(0,1)!=="/"){throw"malformed input"}var b="";d=d.substr(1);var c=d.split("/");c.reverse();c=c.map(function(a){return a.replace(/,/,"\\,")});return c.join(",")};KJUR.asn1.x509.X500Name.onelineToLDAP=function(a){return KJUR.asn1.x509.X500Name.compatToLDAP(a)};KJUR.asn1.x509.X500Name.ldapToCompat=function(g){var c=g.split(",");var e=false;var b=[];for(var f=0;c.length>0;f++){var h=c.shift();if(e===true){var d=b.pop();var j=(d+","+h).replace(/\\,/g,",");b.push(j);e=false}else{b.push(h)}if(h.substr(-1,1)==="\\"){e=true}}b=b.map(function(a){return a.replace("/","\\/")});b.reverse();return"/"+b.join("/")};KJUR.asn1.x509.X500Name.ldapToOneline=function(a){return KJUR.asn1.x509.X500Name.ldapToCompat(a)};KJUR.asn1.x509.RDN=function(b){KJUR.asn1.x509.RDN.superclass.constructor.call(this);this.asn1Array=[];this.paramArray=[];this.sRule="utf8";var a=KJUR.asn1.x509.AttributeTypeAndValue;this.setByParam=function(c){if(c.rule!==undefined){this.sRule=c.rule}if(c.str!==undefined){this.addByMultiValuedString(c.str)}if(c.array!==undefined){this.paramArray=c.array}};this.addByString=function(c){this.asn1Array.push(new KJUR.asn1.x509.AttributeTypeAndValue({str:c,rule:this.sRule}))};this.addByMultiValuedString=function(e){var c=KJUR.asn1.x509.RDN.parseString(e);for(var d=0;d<c.length;d++){this.addByString(c[d])}};this.tohex=function(){if(this.asn1Array.length==0&&this.paramArray.length>0){for(var d=0;d<this.paramArray.length;d++){var f=this.paramArray[d];if(f.rule!==undefined&&this.sRule!="utf8"){f.rule=this.sRule}var c=new a(f);this.asn1Array.push(c)}}var e=new KJUR.asn1.DERSet({array:this.asn1Array});this.TLV=e.tohex();return this.TLV};this.getEncodedHex=function(){return this.tohex()};if(b!==undefined){this.setByParam(b)}};extendClass(KJUR.asn1.x509.RDN,KJUR.asn1.ASN1Object);KJUR.asn1.x509.RDN.parseString=function(m){var j=m.split(/\+/);var h=false;var c=[];for(var g=0;j.length>0;g++){var k=j.shift();if(h===true){var f=c.pop();var d=(f+"+"+k).replace(/\\\+/g,"+");c.push(d);h=false}else{c.push(k)}if(k.substr(-1,1)==="\\"){h=true}}var l=false;var b=[];for(var g=0;c.length>0;g++){var k=c.shift();if(l===true){var e=b.pop();if(k.match(/"$/)){var d=(e+"+"+k).replace(/^([^=]+)="(.*)"$/,"$1=$2");b.push(d);l=false}else{b.push(e+"+"+k)}}else{b.push(k)}if(k.match(/^[^=]+="/)){l=true}}return b};KJUR.asn1.x509.AttributeTypeAndValue=function(c){KJUR.asn1.x509.AttributeTypeAndValue.superclass.constructor.call(this);this.sRule="utf8";this.sType=null;this.sValue=null;this.dsType=null;var a=KJUR,g=a.asn1,d=g.DERSequence,l=g.DERUTF8String,i=g.DERPrintableString,h=g.DERTeletexString,b=g.DERIA5String,e=g.DERVisibleString,k=g.DERBMPString,f=a.lang.String.isMail,j=a.lang.String.isPrintable;this.setByParam=function(o){if(o.rule!==undefined){this.sRule=o.rule}if(o.ds!==undefined){this.dsType=o.ds}if(o.value===undefined&&o.str!==undefined){var n=o.str;var m=n.match(/^([^=]+)=(.+)$/);if(m){this.sType=m[1];this.sValue=m[2]}else{throw new Error("malformed attrTypeAndValueStr: "+attrTypeAndValueStr)}}else{this.sType=o.type;this.sValue=o.value}};this.setByString=function(n,o){if(o!==undefined){this.sRule=o}var m=n.match(/^([^=]+)=(.+)$/);if(m){this.setByAttrTypeAndValueStr(m[1],m[2])}else{throw new Error("malformed attrTypeAndValueStr: "+attrTypeAndValueStr)}};this._getDsType=function(){var o=this.sType;var n=this.sValue;var m=this.sRule;if(m==="prn"){if(o=="CN"&&f(n)){return"ia5"}if(j(n)){return"prn"}return"utf8"}else{if(m==="utf8"){if(o=="CN"&&f(n)){return"ia5"}if(o=="C"){return"prn"}return"utf8"}}return"utf8"};this.setByAttrTypeAndValueStr=function(o,n,m){if(m!==undefined){this.sRule=m}this.sType=o;this.sValue=n};this.getValueObj=function(n,m){if(n=="utf8"){return new l({str:m})}if(n=="prn"){return new i({str:m})}if(n=="tel"){return new h({str:m})}if(n=="ia5"){return new b({str:m})}if(n=="vis"){return new e({str:m})}if(n=="bmp"){return new k({str:m})}throw new Error("unsupported directory string type: type="+n+" value="+m)};this.tohex=function(){if(this.dsType==null){this.dsType=this._getDsType()}var n=KJUR.asn1.x509.OID.atype2obj(this.sType);var m=this.getValueObj(this.dsType,this.sValue);var p=new d({array:[n,m]});this.TLV=p.tohex();return this.TLV};this.getEncodedHex=function(){return this.tohex()};if(c!==undefined){this.setByParam(c)}};extendClass(KJUR.asn1.x509.AttributeTypeAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.x509.SubjectPublicKeyInfo=function(f){KJUR.asn1.x509.SubjectPublicKeyInfo.superclass.constructor.call(this);var l=null,k=null,a=KJUR,j=a.asn1,i=j.DERInteger,b=j.DERBitString,m=j.DERObjectIdentifier,e=j.DERSequence,h=j.ASN1Util.newObject,d=j.x509,o=d.AlgorithmIdentifier,g=a.crypto,n=g.ECDSA,c=g.DSA;this.getASN1Object=function(){if(this.asn1AlgId==null||this.asn1SubjPKey==null){throw"algId and/or subjPubKey not set"}var p=new e({array:[this.asn1AlgId,this.asn1SubjPKey]});return p};this.tohex=function(){var p=this.getASN1Object();this.hTLV=p.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};this.setPubKey=function(q){try{if(q instanceof RSAKey){var u=h({seq:[{"int":{bigint:q.n}},{"int":{"int":q.e}}]});var s=u.tohex();this.asn1AlgId=new o({name:"rsaEncryption"});this.asn1SubjPKey=new b({hex:"00"+s})}}catch(p){}try{if(q instanceof KJUR.crypto.ECDSA){var r=new m({name:q.curveName});this.asn1AlgId=new o({name:"ecPublicKey",asn1params:r});this.asn1SubjPKey=new b({hex:"00"+q.pubKeyHex})}}catch(p){}try{if(q instanceof KJUR.crypto.DSA){var r=new h({seq:[{"int":{bigint:q.p}},{"int":{bigint:q.q}},{"int":{bigint:q.g}}]});this.asn1AlgId=new o({name:"dsa",asn1params:r});var t=new i({bigint:q.y});this.asn1SubjPKey=new b({hex:"00"+t.tohex()})}}catch(p){}};if(f!==undefined){this.setPubKey(f)}};extendClass(KJUR.asn1.x509.SubjectPublicKeyInfo,KJUR.asn1.ASN1Object);KJUR.asn1.x509.Time=function(f){KJUR.asn1.x509.Time.superclass.constructor.call(this);var e=null,a=null,d=KJUR,c=d.asn1,b=c.DERUTCTime,g=c.DERGeneralizedTime;this.params=null;this.type=null;this.setTimeParams=function(h){this.timeParams=h};this.setByParam=function(h){this.params=h};this.getType=function(h){if(h.match(/^[0-9]{12}Z$/)){return"utc"}if(h.match(/^[0-9]{14}Z$/)){return"gen"}if(h.match(/^[0-9]{12}\.[0-9]+Z$/)){return"utc"}if(h.match(/^[0-9]{14}\.[0-9]+Z$/)){return"gen"}return null};this.tohex=function(){var i=this.params;var h=null;if(typeof i=="string"){i={str:i}}if(i!=null&&i.str&&(i.type==null||i.type==undefined)){i.type=this.getType(i.str)}if(i!=null&&i.str){if(i.type=="utc"){h=new b(i.str)}if(i.type=="gen"){h=new g(i.str)}}else{if(this.type=="gen"){h=new g()}else{h=new b()}}if(h==null){throw new Error("wrong setting for Time")}this.TLV=h.tohex();return this.TLV};this.getEncodedHex=function(){return this.tohex()};if(f!=undefined){this.setByParam(f)}};KJUR.asn1.x509.Time_bak=function(f){KJUR.asn1.x509.Time_bak.superclass.constructor.call(this);var e=null,a=null,d=KJUR,c=d.asn1,b=c.DERUTCTime,g=c.DERGeneralizedTime;this.setTimeParams=function(h){this.timeParams=h};this.tohex=function(){var h=null;if(this.timeParams!=null){if(this.type=="utc"){h=new b(this.timeParams)}else{h=new g(this.timeParams)}}else{if(this.type=="utc"){h=new b()}else{h=new g()}}this.TLV=h.tohex();return this.TLV};this.getEncodedHex=function(){return this.tohex()};this.type="utc";if(f!==undefined){if(f.type!==undefined){this.type=f.type}else{if(f.str!==undefined){if(f.str.match(/^[0-9]{12}Z$/)){this.type="utc"}if(f.str.match(/^[0-9]{14}Z$/)){this.type="gen"}}}this.timeParams=f}};extendClass(KJUR.asn1.x509.Time,KJUR.asn1.ASN1Object);KJUR.asn1.x509.AlgorithmIdentifier=function(e){KJUR.asn1.x509.AlgorithmIdentifier.superclass.constructor.call(this);this.nameAlg=null;this.asn1Alg=null;this.asn1Params=null;this.paramEmpty=false;var b=KJUR,a=b.asn1,c=a.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;this.tohex=function(){if(this.nameAlg===null&&this.asn1Alg===null){throw new Error("algorithm not specified")}if(this.nameAlg!==null){var f=null;for(var h in c){if(h===this.nameAlg){f=c[h]}}if(f!==null){this.hTLV=f;return this.hTLV}}if(this.nameAlg!==null&&this.asn1Alg===null){this.asn1Alg=a.x509.OID.name2obj(this.nameAlg)}var g=[this.asn1Alg];if(this.asn1Params!==null){g.push(this.asn1Params)}var i=new a.DERSequence({array:g});this.hTLV=i.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){if(e.name!==undefined){this.nameAlg=e.name}if(e.asn1params!==undefined){this.asn1Params=e.asn1params}if(e.paramempty!==undefined){this.paramEmpty=e.paramempty}}if(this.asn1Params===null&&this.paramEmpty===false&&this.nameAlg!==null){if(this.nameAlg.name!==undefined){this.nameAlg=this.nameAlg.name}var d=this.nameAlg.toLowerCase();if(d.substr(-7,7)!=="withdsa"&&d.substr(-9,9)!=="withecdsa"){this.asn1Params=new a.DERNull()}}};extendClass(KJUR.asn1.x509.AlgorithmIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV={SHAwithRSAandMGF1:"300d06092a864886f70d01010a3000",SHA256withRSAandMGF1:"303d06092a864886f70d01010a3030a00d300b0609608648016503040201a11a301806092a864886f70d010108300b0609608648016503040201a203020120",SHA384withRSAandMGF1:"303d06092a864886f70d01010a3030a00d300b0609608648016503040202a11a301806092a864886f70d010108300b0609608648016503040202a203020130",SHA512withRSAandMGF1:"303d06092a864886f70d01010a3030a00d300b0609608648016503040203a11a301806092a864886f70d010108300b0609608648016503040203a203020140"};KJUR.asn1.x509.GeneralName=function(f){KJUR.asn1.x509.GeneralName.superclass.constructor.call(this);var l={rfc822:"81",dns:"82",dn:"a4",uri:"86",ip:"87",otherName:"a0"},b=KJUR,h=b.asn1,d=h.x509,a=d.X500Name,g=d.OtherName,e=h.DERIA5String,i=h.DERPrintableString,k=h.DEROctetString,c=h.DERTaggedObject,m=h.ASN1Object,j=Error;this.params=null;this.setByParam=function(n){this.params=n};this.tohex=function(){var p=this.params;var A,y,q;var y=false;if(p.other!==undefined){A="a0",q=new g(p.other)}else{if(p.rfc822!==undefined){A="81";q=new e({str:p.rfc822})}else{if(p.dns!==undefined){A="82";q=new e({str:p.dns})}else{if(p.dn!==undefined){A="a4";y=true;if(typeof p.dn==="string"){q=new a({str:p.dn})}else{if(p.dn instanceof KJUR.asn1.x509.X500Name){q=p.dn}else{q=new a(p.dn)}}}else{if(p.ldapdn!==undefined){A="a4";y=true;q=new a({ldapstr:p.ldapdn})}else{if(p.certissuer!==undefined||p.certsubj!==undefined){A="a4";y=true;var n,o;var z=null;if(p.certsubj!==undefined){n=false;o=p.certsubj}else{n=true;o=p.certissuer}if(o.match(/^[0-9A-Fa-f]+$/)){z==o}if(o.indexOf("-----BEGIN ")!=-1){z=pemtohex(o)}if(z==null){throw new Error("certsubj/certissuer not cert")}var w=new X509();w.hex=z;var s;if(n){s=w.getIssuerHex()}else{s=w.getSubjectHex()}q=new m();q.hTLV=s}else{if(p.uri!==undefined){A="86";q=new e({str:p.uri})}else{if(p.ip!==undefined){A="87";var v;var t=p.ip;try{if(t.match(/^[0-9a-f]+$/)){var r=t.length;if(r==8||r==16||r==32||r==64){v=t}else{throw"err"}}else{v=iptohex(t)}}catch(u){throw new j("malformed IP address: "+p.ip+":"+u.message)}q=new k({hex:v})}else{throw new j("improper params")}}}}}}}}var B=new c({tag:A,explicit:y,obj:q});return B.tohex()};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){this.setByParam(f)}};extendClass(KJUR.asn1.x509.GeneralName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.GeneralNames=function(d){KJUR.asn1.x509.GeneralNames.superclass.constructor.call(this);var a=null,c=KJUR,b=c.asn1;this.setByParamArray=function(g){for(var e=0;e<g.length;e++){var f=new b.x509.GeneralName(g[e]);this.asn1Array.push(f)}};this.tohex=function(){var e=new b.DERSequence({array:this.asn1Array});return e.tohex()};this.getEncodedHex=function(){return this.tohex()};this.asn1Array=new Array();if(typeof d!="undefined"){this.setByParamArray(d)}};extendClass(KJUR.asn1.x509.GeneralNames,KJUR.asn1.ASN1Object);KJUR.asn1.x509.OtherName=function(g){KJUR.asn1.x509.OtherName.superclass.constructor.call(this);var f=null,e=null,d=KJUR,c=d.asn1,h=c.DERObjectIdentifier,a=c.DERSequence,b=c.ASN1Util.newObject;this.params=null;this.setByParam=function(i){this.params=i};this.tohex=function(){var k=this.params;if(k.oid==undefined||k.value==undefined){throw new Error("oid or value not specified")}var l=new h({oid:k.oid});var i=b({tag:{tag:"a0",explicit:true,obj:k.value}});var j=new a({array:[l,i]});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!==undefined){this.setByParam(g)}};extendClass(KJUR.asn1.x509.OtherName,KJUR.asn1.ASN1Object);KJUR.asn1.x509.OID=new function(){var a=KJUR.asn1.DERObjectIdentifier;this.name2oidList={sha1:"1.3.14.3.2.26",sha256:"2.16.840.1.101.3.4.2.1",sha384:"2.16.840.1.101.3.4.2.2",sha512:"2.16.840.1.101.3.4.2.3",sha224:"2.16.840.1.101.3.4.2.4",md5:"1.2.840.113549.2.5",md2:"1.3.14.7.2.2.1",ripemd160:"1.3.36.3.2.1",MD2withRSA:"1.2.840.113549.1.1.2",MD4withRSA:"1.2.840.113549.1.1.3",MD5withRSA:"1.2.840.113549.1.1.4",SHA1withRSA:"1.2.840.113549.1.1.5","pkcs1-MGF":"1.2.840.113549.1.1.8",rsaPSS:"1.2.840.113549.1.1.10",SHA224withRSA:"1.2.840.113549.1.1.14",SHA256withRSA:"1.2.840.113549.1.1.11",SHA384withRSA:"1.2.840.113549.1.1.12",SHA512withRSA:"1.2.840.113549.1.1.13",SHA1withECDSA:"1.2.840.10045.4.1",SHA224withECDSA:"1.2.840.10045.4.3.1",SHA256withECDSA:"1.2.840.10045.4.3.2",SHA384withECDSA:"1.2.840.10045.4.3.3",SHA512withECDSA:"1.2.840.10045.4.3.4",dsa:"1.2.840.10040.4.1",SHA1withDSA:"1.2.840.10040.4.3",SHA224withDSA:"2.16.840.1.101.3.4.3.1",SHA256withDSA:"2.16.840.1.101.3.4.3.2",rsaEncryption:"1.2.840.113549.1.1.1",commonName:"2.5.4.3",countryName:"2.5.4.6",localityName:"2.5.4.7",stateOrProvinceName:"2.5.4.8",streetAddress:"2.5.4.9",organizationName:"2.5.4.10",organizationalUnitName:"2.5.4.11",domainComponent:"0.9.2342.19200300.100.1.25",userId:"0.9.2342.19200300.100.1.1",surname:"2.5.4.4",givenName:"2.5.4.42",title:"2.5.4.12",distinguishedName:"2.5.4.49",emailAddress:"1.2.840.113549.1.9.1",description:"2.5.4.13",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",uniqueIdentifier:"2.5.4.45",organizationIdentifier:"2.5.4.97",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3",subjectDirectoryAttributes:"2.5.29.9",subjectKeyIdentifier:"2.5.29.14",keyUsage:"2.5.29.15",subjectAltName:"2.5.29.17",issuerAltName:"2.5.29.18",basicConstraints:"2.5.29.19",cRLNumber:"2.5.29.20",cRLReason:"2.5.29.21",nameConstraints:"2.5.29.30",cRLDistributionPoints:"2.5.29.31",certificatePolicies:"2.5.29.32",anyPolicy:"2.5.29.32.0",policyMappings:"2.5.29.33",authorityKeyIdentifier:"2.5.29.35",policyConstraints:"2.5.29.36",extKeyUsage:"2.5.29.37",inhibitAnyPolicy:"2.5.29.54",authorityInfoAccess:"1.3.6.1.5.5.7.1.1",ocsp:"1.3.6.1.5.5.7.48.1",ocspBasic:"1.3.6.1.5.5.7.48.1.1",ocspNonce:"1.3.6.1.5.5.7.48.1.2",ocspNoCheck:"1.3.6.1.5.5.7.48.1.5",caIssuers:"1.3.6.1.5.5.7.48.2",anyExtendedKeyUsage:"2.5.29.37.0",serverAuth:"1.3.6.1.5.5.7.3.1",clientAuth:"1.3.6.1.5.5.7.3.2",codeSigning:"1.3.6.1.5.5.7.3.3",emailProtection:"1.3.6.1.5.5.7.3.4",timeStamping:"1.3.6.1.5.5.7.3.8",ocspSigning:"1.3.6.1.5.5.7.3.9",smtpUTF8Mailbox:"1.3.6.1.5.5.7.8.9",dateOfBirth:"1.3.6.1.5.5.7.9.1",placeOfBirth:"1.3.6.1.5.5.7.9.2",gender:"1.3.6.1.5.5.7.9.3",countryOfCitizenship:"1.3.6.1.5.5.7.9.4",countryOfResidence:"1.3.6.1.5.5.7.9.5",ecPublicKey:"1.2.840.10045.2.1","P-256":"1.2.840.10045.3.1.7",secp256r1:"1.2.840.10045.3.1.7",secp256k1:"1.3.132.0.10",secp384r1:"1.3.132.0.34",secp521r1:"1.3.132.0.35",pkcs5PBES2:"1.2.840.113549.1.5.13",pkcs5PBKDF2:"1.2.840.113549.1.5.12","des-EDE3-CBC":"1.2.840.113549.3.7",data:"1.2.840.113549.1.7.1","signed-data":"1.2.840.113549.1.7.2","enveloped-data":"1.2.840.113549.1.7.3","digested-data":"1.2.840.113549.1.7.5","encrypted-data":"1.2.840.113549.1.7.6","authenticated-data":"1.2.840.113549.1.9.16.1.2",tstinfo:"1.2.840.113549.1.9.16.1.4",signingCertificate:"1.2.840.113549.1.9.16.2.12",timeStampToken:"1.2.840.113549.1.9.16.2.14",signaturePolicyIdentifier:"1.2.840.113549.1.9.16.2.15",etsArchiveTimeStamp:"1.2.840.113549.1.9.16.2.27",signingCertificateV2:"1.2.840.113549.1.9.16.2.47",etsArchiveTimeStampV2:"1.2.840.113549.1.9.16.2.48",extensionRequest:"1.2.840.113549.1.9.14",contentType:"1.2.840.113549.1.9.3",messageDigest:"1.2.840.113549.1.9.4",signingTime:"1.2.840.113549.1.9.5",counterSignature:"1.2.840.113549.1.9.6",archiveTimeStampV3:"0.4.0.1733.2.4",pdfRevocationInfoArchival:"1.2.840.113583.1.1.8",adobeTimeStamp:"1.2.840.113583.1.1.9.1",};this.atype2oidList={CN:"2.5.4.3",L:"2.5.4.7",ST:"2.5.4.8",O:"2.5.4.10",OU:"2.5.4.11",C:"2.5.4.6",STREET:"2.5.4.9",DC:"0.9.2342.19200300.100.1.25",UID:"0.9.2342.19200300.100.1.1",SN:"2.5.4.4",T:"2.5.4.12",DN:"2.5.4.49",E:"1.2.840.113549.1.9.1",description:"2.5.4.13",businessCategory:"2.5.4.15",postalCode:"2.5.4.17",serialNumber:"2.5.4.5",uniqueIdentifier:"2.5.4.45",organizationIdentifier:"2.5.4.97",jurisdictionOfIncorporationL:"1.3.6.1.4.1.311.60.2.1.1",jurisdictionOfIncorporationSP:"1.3.6.1.4.1.311.60.2.1.2",jurisdictionOfIncorporationC:"1.3.6.1.4.1.311.60.2.1.3"};this.objCache={};this.name2obj=function(b){if(typeof this.objCache[b]!="undefined"){return this.objCache[b]}if(typeof this.name2oidList[b]=="undefined"){throw"Name of ObjectIdentifier not defined: "+b}var c=this.name2oidList[b];var d=new a({oid:c});this.objCache[b]=d;return d};this.atype2obj=function(b){if(this.objCache[b]!==undefined){return this.objCache[b]}var c;if(b.match(/^\d+\.\d+\.[0-9.]+$/)){c=b}else{if(this.atype2oidList[b]!==undefined){c=this.atype2oidList[b]}else{if(this.name2oidList[b]!==undefined){c=this.name2oidList[b]}else{throw new Error("AttributeType name undefined: "+b)}}}var d=new a({oid:c});this.objCache[b]=d;return d};this.registerOIDs=function(b){if(!this.checkOIDs(b)){return}for(var c in b){this.name2oidList[c]=b[c]}};this.checkOIDs=function(b){try{var d=Object.keys(b);if(d.length==0){return false}d.map(function(g,e,h){var f=this[g];if(!f.match(/^[0-2]\.[0-9.]+$/)){throw new Error("value is not OID")}},b);return true}catch(c){return false}}};KJUR.asn1.x509.OID.oid2name=function(b){var c=KJUR.asn1.x509.OID.name2oidList;for(var a in c){if(c[a]==b){return a}}return""};KJUR.asn1.x509.OID.oid2atype=function(b){var c=KJUR.asn1.x509.OID.atype2oidList;for(var a in c){if(c[a]==b){return a}}return b};KJUR.asn1.x509.OID.name2oid=function(a){if(a.match(/^[0-9.]+$/)){return a}var b=KJUR.asn1.x509.OID.name2oidList;if(b[a]===undefined){return""}return b[a]};KJUR.asn1.x509.X509Util={};KJUR.asn1.x509.X509Util.newCertPEM=function(e){var d=KJUR.asn1.x509,b=d.TBSCertificate,a=d.Certificate;var c=new a(e);return c.getPEM()};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.cms=="undefined"||!KJUR.asn1.cms){KJUR.asn1.cms={}}KJUR.asn1.cms.Attribute=function(f){var e=Error,d=KJUR,c=d.asn1,b=c.DERSequence,a=c.DERSet,g=c.DERObjectIdentifier;this.params=null;this.typeOid=null;this.setByParam=function(h){this.params=h};this.getValueArray=function(){throw new e("not yet implemented abstract")};this.tohex=function(){var j=new g({oid:this.typeOid});var h=new a({array:this.getValueArray()});var i=new b({array:[j,h]});return i.tohex()};this.getEncodedHex=function(){return this.tohex()}};extendClass(KJUR.asn1.cms.Attribute,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentType=function(c){var b=KJUR,a=b.asn1;a.cms.ContentType.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.3";this.getValueArray=function(){var d=new a.DERObjectIdentifier(this.params.type);return[d]};if(c!=undefined){this.setByParam(c)}};extendClass(KJUR.asn1.cms.ContentType,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.MessageDigest=function(e){var b=KJUR,a=b.asn1,c=a.DEROctetString,d=a.cms;d.MessageDigest.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.4";this.getValueArray=function(){var f=new c(this.params);return[f]};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cms.MessageDigest,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningTime=function(c){var b=KJUR,a=b.asn1;a.cms.SigningTime.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.5";this.getValueArray=function(){var d=new a.x509.Time(this.params);return[d]};if(c!=undefined){this.setByParam(c)}};extendClass(KJUR.asn1.cms.SigningTime,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.SigningCertificate=function(h){var e=Error,d=KJUR,c=d.asn1,b=c.DERSequence,g=c.cms,a=g.ESSCertID,f=d.crypto;g.SigningCertificate.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.16.2.12";this.getValueArray=function(){if(this.params==null||this.params==undefined||this.params.array==undefined){throw new e("parameter 'array' not specified")}var o=this.params.array;var k=[];for(var l=0;l<o.length;l++){var n=o[l];if(h.hasis==false&&(typeof n=="string"&&(n.indexOf("-----BEGIN")!=-1||ASN1HEX.isASN1HEX(n)))){n={cert:n}}if(n.hasis!=false&&h.hasis==false){n.hasis=false}k.push(new a(n))}var j=new b({array:k});var m=new b({array:[j]});return[m]};if(h!=undefined){this.setByParam(h)}};extendClass(KJUR.asn1.cms.SigningCertificate,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.ESSCertID=function(g){KJUR.asn1.cms.ESSCertID.superclass.constructor.call(this);var d=Error,c=KJUR,b=c.asn1,f=b.DEROctetString,a=b.DERSequence,e=b.cms.IssuerSerial;this.params=null;this.getCertHash=function(k,h){if(k.hash!=undefined){return k.hash}if(typeof k=="string"&&k.indexOf("-----BEGIN")==-1&&!ASN1HEX.isASN1HEX(k)){return k}var i;if(typeof k=="string"){i=k}else{if(k.cert!=undefined){i=k.cert}else{throw new d("hash nor cert unspecified")}}var j;if(i.indexOf("-----BEGIN")!=-1){j=pemtohex(i)}else{j=i}if(typeof k=="string"){if(k.indexOf("-----BEGIN")!=-1){j=pemtohex(k)}else{if(ASN1HEX.isASN1HEX(k)){j=k}}}var l;if(k.alg!=undefined){l=k.alg}else{if(h!=undefined){l=h}else{throw new d("hash alg unspecified")}}return c.crypto.Util.hashHex(j,l)};this.tohex=function(){var k=this.params;var j=this.getCertHash(k,"sha1");var h=[];h.push(new f({hex:j}));if((typeof k=="string"&&k.indexOf("-----BEGIN")!=-1)||(k.cert!=undefined&&k.hasis!=false)||(k.issuer!=undefined&&k.serial!=undefined)){h.push(new e(k))}var i=new a({array:h});return i.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cms.ESSCertID,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SigningCertificateV2=function(d){var h=Error,a=KJUR,g=a.asn1,e=g.DERSequence,b=g.x509,i=g.cms,c=i.ESSCertIDv2,f=a.crypto;i.SigningCertificateV2.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.16.2.47";this.getValueArray=function(){if(this.params==null||this.params==undefined||this.params.array==undefined){throw new h("parameter 'array' not specified")}var o=this.params.array;var l=[];for(var m=0;m<o.length;m++){var n=o[m];if((d.alg!=undefined||d.hasis==false)&&(typeof n=="string"&&(n.indexOf("-----BEGIN")!=-1||ASN1HEX.isASN1HEX(n)))){n={cert:n}}if(n.alg==undefined&&d.alg!=undefined){n.alg=d.alg}if(n.hasis!=false&&d.hasis==false){n.hasis=false}l.push(new c(n))}var k=new e({array:l});var j=new e({array:[k]});return[j]};if(d!=undefined){this.setByParam(d)}};extendClass(KJUR.asn1.cms.SigningCertificateV2,KJUR.asn1.cms.Attribute);KJUR.asn1.cms.ESSCertIDv2=function(h){KJUR.asn1.cms.ESSCertIDv2.superclass.constructor.call(this);var d=Error,c=KJUR,b=c.asn1,f=b.DEROctetString,a=b.DERSequence,e=b.cms.IssuerSerial,g=b.x509.AlgorithmIdentifier;this.params=null;this.tohex=function(){var l=this.params;var k=this.getCertHash(l,"sha256");var i=[];if(l.alg!=undefined&&l.alg!="sha256"){i.push(new g({name:l.alg}))}i.push(new f({hex:k}));if((typeof l=="string"&&l.indexOf("-----BEGIN")!=-1)||(l.cert!=undefined&&l.hasis!=false)||(l.issuer!=undefined&&l.serial!=undefined)){i.push(new e(l))}var j=new a({array:i});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};if(h!=undefined){this.setByParam(h)}};extendClass(KJUR.asn1.cms.ESSCertIDv2,KJUR.asn1.cms.ESSCertID);KJUR.asn1.cms.IssuerSerial=function(e){var i=Error,c=KJUR,h=c.asn1,g=h.DERInteger,f=h.DERSequence,j=h.cms,d=h.x509,a=d.GeneralNames,b=X509;j.IssuerSerial.superclass.constructor.call(this);this.setByParam=function(k){this.params=k};this.tohex=function(){var p=this.params;var l,r;if((typeof p=="string"&&p.indexOf("-----BEGIN")!=-1)||p.cert!=undefined){var n;if(p.cert!=undefined){n=p.cert}else{n=p}var k=new b();k.readCertPEM(n);l=k.getIssuer();r={hex:k.getSerialNumberHex()}}else{if(p.issuer!=undefined&&p.serial){l=p.issuer;r=p.serial}else{throw new i("cert or issuer and serial parameter not specified")}}var q=new a([{dn:l}]);var o=new g(r);var m=new f({array:[q,o]});return m.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cms.IssuerSerial,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignerIdentifier=function(f){var c=KJUR,i=c.asn1,h=i.DERInteger,g=i.DERSequence,l=i.cms,k=l.IssuerAndSerialNumber,d=l.SubjectKeyIdentifier,e=i.x509,a=e.X500Name,b=X509,j=Error;l.SignerIdentifier.superclass.constructor.call(this);this.params=null;this.tohex=function(){var o=this.params;if(o.type=="isssn"){var m=new k(o);return m.tohex()}else{if(o.type=="skid"){var n=new d(o);return n.tohex()}else{throw new Error("wrong property for isssn or skid")}}};this.getEncodedHex=function(){return this.tohex()};if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.cms.SignerIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.cms.IssuerAndSerialNumber=function(e){var c=KJUR,h=c.asn1,g=h.DERInteger,f=h.DERSequence,j=h.cms,d=h.x509,a=d.X500Name,b=X509,i=Error;j.IssuerAndSerialNumber.superclass.constructor.call(this);this.params=null;this.tohex=function(){var p=this.params;var l,r;if((typeof p=="string"&&p.indexOf("-----BEGIN")!=-1)||p.cert!=undefined){var n;if(p.cert!=undefined){n=p.cert}else{n=p}var k=new b();k.readCertPEM(n);l=k.getIssuer();r={hex:k.getSerialNumberHex()}}else{if(p.issuer!=undefined&&p.serial){l=p.issuer;r=p.serial}else{throw new i("cert or issuer and serial parameter not specified")}}var q=new a(l);var o=new g(r);var m=new f({array:[q,o]});return m.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(k){this.params=k};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cms.IssuerAndSerialNumber,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SubjectKeyIdentifier=function(g){var d=KJUR,k=d.asn1,i=k.DERInteger,h=k.DERSequence,j=k.ASN1Util.newObject,m=k.cms,f=m.IssuerAndSerialName,c=m.SubjectKeyIdentifier,e=k.x509,a=e.X500Name,b=X509,l=Error;m.SubjectKeyIdentifier.superclass.constructor.call(this);this.tohex=function(){var r=this.params;if(r.cert==undefined&&r.skid==undefined){throw new l("property cert nor skid undefined")}var q;if(r.cert!=undefined){var n=new b(r.cert);var o=n.getExtSubjectKeyIdentifier();q=o.kid.hex}else{if(r.skid!=undefined){q=r.skid}}var p=j({tag:{tage:"a0",obj:{octstr:{hex:q}}}});return p.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cms.SubjectKeyIdentifier,KJUR.asn1.ASN1Object);KJUR.asn1.cms.AttributeList=function(f){var d=Error,c=KJUR,b=c.asn1,a=b.DERSet,e=b.cms;e.AttributeList.superclass.constructor.call(this);this.params=null;this.hTLV=null;this.setByParam=function(g){this.params=g};this.tohex=function(){var o=this.params;if(this.hTLV!=null){return this.hTLV}var m=true;if(o.sortflag!=undefined){m=o.sortflag}var j=o.array;var g=[];for(var l=0;l<j.length;l++){var n=j[l];var k=n.attr;if(k=="contentType"){g.push(new e.ContentType(n))}else{if(k=="messageDigest"){g.push(new e.MessageDigest(n))}else{if(k=="signingTime"){g.push(new e.SigningTime(n))}else{if(k=="signingCertificate"){g.push(new e.SigningCertificate(n))}else{if(k=="signingCertificateV2"){g.push(new e.SigningCertificateV2(n))}else{if(k=="signaturePolicyIdentifier"){g.push(new KJUR.asn1.cades.SignaturePolicyIdentifier(n))}else{if(k=="signatureTimeStamp"||k=="timeStampToken"){g.push(new KJUR.asn1.cades.SignatureTimeStamp(n))}else{throw new d("unknown attr: "+k)}}}}}}}}var h=new a({array:g,sortflag:m});this.hTLV=h.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.cms.AttributeList,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignerInfo=function(q){var n=Error,r=KJUR,i=r.asn1,c=i.DERInteger,f=i.DEROctetString,h=i.DERSequence,m=i.DERTaggedObject,k=i.cms,p=k.SignerIdentifier,l=k.AttributeList,g=k.ContentType,e=k.EncapsulatedContentInfo,d=k.MessageDigest,j=k.SignedData,a=i.x509,s=a.AlgorithmIdentifier,b=r.crypto,o=KEYUTIL;k.SignerInfo.superclass.constructor.call(this);this.params=null;this.sign=function(){var y=this.params;var x=y.sigalg;var u=(new l(y.sattrs)).tohex();var v=o.getKey(y.signkey);var w=new b.Signature({alg:x});w.init(v);w.updateHex(u);var t=w.sign();y.sighex=t};this.tohex=function(){var w=this.params;var t=[];t.push(new c({"int":w.version}));t.push(new p(w.id));t.push(new s({name:w.hashalg}));if(w.sattrs!=undefined){var x=new l(w.sattrs);try{t.push(new m({tag:"a0",explicit:false,obj:x}))}catch(v){throw new n("si sattr error: "+v)}}if(w.sigalgfield!=undefined){t.push(new s({name:w.sigalgfield}))}else{t.push(new s({name:w.sigalg}))}if(w.sighex==undefined&&w.signkey!=undefined){this.sign()}t.push(new f({hex:w.sighex}));if(w.uattrs!=undefined){var x=new l(w.uattrs);try{t.push(new m({tag:"a1",explicit:false,obj:x}))}catch(v){throw new n("si uattr error: "+v)}}var u=new h({array:t});return u.tohex()};this.getEncodedHex=function(){return this.tohex()};if(q!=undefined){this.setByParam(q)}};extendClass(KJUR.asn1.cms.SignerInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.EncapsulatedContentInfo=function(g){var c=KJUR,b=c.asn1,e=b.DERTaggedObject,a=b.DERSequence,h=b.DERObjectIdentifier,d=b.DEROctetString,f=b.cms;f.EncapsulatedContentInfo.superclass.constructor.call(this);this.params=null;this.tohex=function(){var m=this.params;var i=[];i.push(new h(m.type));if(m.content!=undefined&&(m.content.hex!=undefined||m.content.str!=undefined)&&m.isDetached!=true){var k=new d(m.content);var l=new e({tag:"a0",explicit:true,obj:k});i.push(l)}var j=new a({array:i});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(i){this.params=i};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cms.EncapsulatedContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.ContentInfo=function(g){var c=KJUR,b=c.asn1,d=b.DERTaggedObject,a=b.DERSequence,h=b.DERObjectIdentifier,f=b.x509,e=f.OID.name2obj;KJUR.asn1.cms.ContentInfo.superclass.constructor.call(this);this.params=null;this.tohex=function(){var l=this.params;var i=[];i.push(new h(l.type));var k=new d({tag:"a0",explicit:true,obj:l.obj});i.push(k);var j=new a({array:i});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(i){this.params=i};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cms.ContentInfo,KJUR.asn1.ASN1Object);KJUR.asn1.cms.SignedData=function(e){var j=Error,a=KJUR,h=a.asn1,m=h.ASN1Object,g=h.DERInteger,p=h.DERSet,f=h.DERSequence,b=h.DERTaggedObject,o=h.cms,l=o.EncapsulatedContentInfo,d=o.SignerInfo,q=o.ContentInfo,k=o.CertificateSet,i=o.RevocationInfoChoices,c=h.x509,n=c.AlgorithmIdentifier;KJUR.asn1.cms.SignedData.superclass.constructor.call(this);this.params=null;this.checkAndFixParam=function(){var r=this.params;this._setDigestAlgs(r);this._setContentTypeByEContent(r);this._setMessageDigestByEContent(r);this._setSignerInfoVersion(r);this._setSignedDataVersion(r)};this._setDigestAlgs=function(v){var u={};var t=v.sinfos;for(var r=0;r<t.length;r++){var s=t[r];u[s.hashalg]=1}v.hashalgs=Object.keys(u).sort()};this._setContentTypeByEContent=function(w){var u=w.econtent.type;var v=w.sinfos;for(var r=0;r<v.length;r++){var t=v[r];var s=this._getAttrParamByName(t,"contentType");s.type=u}};this._setMessageDigestByEContent=function(r){var v=r.econtent;var y=r.econtent.type;var x=v.content.hex;if(x==undefined&&v.type=="data"&&v.content.str!=undefined){x=rstrtohex(v.content.str)}var A=r.sinfos;for(var u=0;u<A.length;u++){var t=A[u];var s=t.hashalg;var z=this._getAttrParamByName(t,"messageDigest");var w=KJUR.crypto.Util.hashHex(x,s);z.hex=w}};this._getAttrParamByName=function(t,s){var u=t.sattrs.array;for(var r=0;r<u.length;r++){if(u[r].attr==s){return u[r]}}};this._setSignerInfoVersion=function(v){var t=v.sinfos;for(var r=0;r<t.length;r++){var s=t[r];var u=1;if(s.id.type=="skid"){u=3}s.version=u}};this._setSignedDataVersion=function(s){var r=this._getSignedDataVersion(s);s.version=r};this._getSignedDataVersion=function(w){if(w.revinfos!=undefined){var r=w.revinfos;for(var t=0;t<r.length;t++){var s=r[t];if(s.ocsp!=undefined){return 5}}}var v=w.sinfos;for(var t=0;t<v.length;t++){var u=w.sinfos[t];if(u.version==3){return 3}}if(w.econtent.type!="data"){return 3}return 1};this.tohex=function(){var y=this.params;if(this.getEncodedHexPrepare!=undefined){this.getEncodedHexPrepare()}if(y.fixed!=true){this.checkAndFixParam()}var r=[];r.push(new g({"int":y.version}));var w=[];for(var v=0;v<y.hashalgs.length;v++){var t=y.hashalgs[v];w.push(new n({name:t}))}r.push(new p({array:w}));r.push(new l(y.econtent));if(y.certs!=undefined){r.push(new k(y.certs))}if(y.revinfos!=undefined){r.push(new i(y.revinfos))}var u=[];for(var v=0;v<y.sinfos.length;v++){var x=y.sinfos[v];u.push(new d(x))}r.push(new p({array:u}));var s=new f({array:r});return s.tohex()};this.getEncodedHex=function(){return this.tohex()};this.getContentInfo=function(){var r=new q({type:"signed-data",obj:this});return r};this.getContentInfoEncodedHex=function(){return this.getContentInfo().tohex()};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cms.SignedData,KJUR.asn1.ASN1Object);KJUR.asn1.cms.CertificateSet=function(f){KJUR.asn1.cms.CertificateSet.superclass.constructor.call(this);var c=Error,b=KJUR.asn1,e=b.DERTaggedObject,a=b.DERSet,d=b.ASN1Object;this.params=null;this.tohex=function(){var j=this.params;var p=[];var q;if(j instanceof Array){q=j}else{if(j.array!=undefined){q=j.array}else{throw new c("cert array not specified")}}for(var k=0;k<q.length;k++){var l=q[k];var n=pemtohex(l);var g=new d();g.hTLV=n;p.push(g)}var m={array:p};if(j.sortflag==false){m.sortflag=false}var o=new a(m);var h=new e({tag:"a0",explicit:false,obj:o});return h.tohex()};this.getEncodedHex=function(){return this.tohex()};if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.cms.CertificateSet,KJUR.asn1.ASN1Object);KJUR.asn1.cms.RevocationInfoChoices=function(a){KJUR.asn1.cms.RevocationInfoChoices.superclass.constructor.call(this);this.params=null;this.tohex=function(){var e=this.params;if(!e instanceof Array){throw new Error("params is not array")}var b=[];for(var c=0;c<e.length;c++){b.push(new KJUR.asn1.cms.RevocationInfoChoice(e[c]))}var d=KJUR.asn1.ASN1Util.newObject({tag:{tagi:"a1",obj:{set:b}}});return d.tohex()};this.getEncodedHex=function(){return this.tohex()};if(a!=undefined){this.setByParam(a)}};extendClass(KJUR.asn1.cms.RevocationInfoChoices,KJUR.asn1.ASN1Object);KJUR.asn1.cms.RevocationInfoChoice=function(a){KJUR.asn1.cms.RevocationInfoChoice.superclass.constructor.call(this);this.params=null;this.tohex=function(){var d=this.params;if(d.crl!=undefined&&typeof d.crl=="string"){var b=d.crl;if(d.crl.indexOf("-----BEGIN")!=-1){b=pemtohex(d.crl)}return b}else{if(d.ocsp!=undefined){var c=KJUR.asn1.ASN1Util.newObject({tag:{tagi:"a1",obj:new KJUR.asn1.cms.OtherRevocationFormat(d)}});return c.tohex()}else{throw new Error("property crl or ocsp undefined")}}};this.getEncodedHex=function(){return this.tohex()};if(a!=undefined){this.setByParam(a)}};extendClass(KJUR.asn1.cms.RevocationInfoChoice,KJUR.asn1.ASN1Object);KJUR.asn1.cms.OtherRevocationFormat=function(f){KJUR.asn1.cms.OtherRevocationFormat.superclass.constructor.call(this);var d=Error,c=KJUR,b=c.asn1,a=b.ASN1Util.newObject,e=c.lang.String.isHex;this.params=null;this.tohex=function(){var h=this.params;if(h.ocsp==undefined){throw new d("property ocsp not specified")}if(!e(h.ocsp)||!ASN1HEX.isASN1HEX(h.ocsp)){throw new d("ocsp value not ASN.1 hex string")}var g=a({seq:[{oid:"1.3.6.1.5.5.7.16.2"},{asn1:{tlv:h.ocsp}}]});return g.tohex()};this.getEncodedHex=function(){return this.tohex()};if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.cms.OtherRevocationFormat,KJUR.asn1.ASN1Object);KJUR.asn1.cms.CMSUtil=new function(){};KJUR.asn1.cms.CMSUtil.newSignedData=function(a){return new KJUR.asn1.cms.SignedData(a)};KJUR.asn1.cms.CMSUtil.verifySignedData=function(n){var C=KJUR,p=C.asn1,s=p.cms,D=s.SignerInfo,q=s.SignedData,y=s.SigningTime,b=s.SigningCertificate,d=s.SigningCertificateV2,A=p.cades,u=A.SignaturePolicyIdentifier,i=C.lang.String.isHex,v=ASN1HEX,h=v.getVbyList,a=v.getTLVbyList,t=v.getIdxbyList,z=v.getChildIdx,c=v.getTLV,B=v.oidname,j=C.crypto.Util.hashHex;if(n.cms===undefined&&!i(n.cms)){}var E=n.cms;var g=function(J,H){var G;for(var I=3;I<6;I++){G=t(J,0,[1,0,I]);if(G!==undefined){var F=J.substr(G,2);if(F==="a0"){H.certsIdx=G}if(F==="a1"){H.revinfosIdx=G}if(F==="31"){H.signerinfosIdx=G}}}};var l=function(I,F){var H=F.signerinfosIdx;if(H===undefined){return}var L=z(I,H);F.signerInfoIdxList=L;for(var G=0;G<L.length;G++){var K=L[G];var J={idx:K};k(I,J);F.signerInfos.push(J)}};var k=function(I,J){var F=J.idx;J.signerid_issuer1=a(I,F,[1,0],"30");J.signerid_serial1=h(I,F,[1,1],"02");J.hashalg=B(h(I,F,[2,0],"06"));var H=t(I,F,[3],"a0");J.idxSignedAttrs=H;f(I,J,H);var G=z(I,F);var K=G.length;if(K<6){throw"malformed SignerInfo"}J.sigalg=B(h(I,F,[K-2,0],"06"));J.sigval=h(I,F,[K-1],"04")};var f=function(L,M,F){var J=z(L,F);M.signedAttrIdxList=J;for(var K=0;K<J.length;K++){var I=J[K];var G=h(L,I,[0],"06");var H;if(G==="2a864886f70d010905"){H=hextoutf8(h(L,I,[1,0]));M.saSigningTime=H}else{if(G==="2a864886f70d010904"){H=h(L,I,[1,0],"04");M.saMessageDigest=H}}}};var w=function(G,F){if(h(G,0,[0],"06")!=="2a864886f70d010702"){return F}F.cmsType="signedData";F.econtent=h(G,0,[1,0,2,1,0]);g(G,F);F.signerInfos=[];l(G,F)};var o=function(J,F){var G=F.parse.signerInfos;var L=G.length;var K=true;for(var I=0;I<L;I++){var H=G[I];e(J,F,H,I);if(!H.isValid){K=false}}F.isValid=K};var x=function(F,Q,J,P){var N=Q.parse.certsIdx;var H;if(Q.certs===undefined){H=[];Q.certkeys=[];var K=z(F,N);for(var I=0;I<K.length;I++){var M=c(F,K[I]);var O=new X509();O.readCertHex(M);H[I]=O;Q.certkeys[I]=O.getPublicKey()}Q.certs=H}else{H=Q.certs}Q.cccc=H.length;Q.cccci=K.length;for(var I=0;I<H.length;I++){var L=O.getIssuerHex();var G=O.getSerialNumberHex();if(J.signerid_issuer1===L&&J.signerid_serial1===G){J.certkey_idx=I}}};var e=function(F,R,I,N){I.verifyDetail={};var Q=I.verifyDetail;var K=R.parse.econtent;var G=I.hashalg;var L=I.saMessageDigest;Q.validMessageDigest=false;if(j(K,G)===L){Q.validMessageDigest=true}x(F,R,I,N);Q.validSignatureValue=false;var H=I.sigalg;var M="31"+c(F,I.idxSignedAttrs).substr(2);I.signedattrshex=M;var J=R.certs[I.certkey_idx].getPublicKey();var P=new KJUR.crypto.Signature({alg:H});P.init(J);P.updateHex(M);var O=P.verify(I.sigval);Q.validSignatureValue_isValid=O;if(O===true){Q.validSignatureValue=true}I.isValid=false;if(Q.validMessageDigest&&Q.validSignatureValue){I.isValid=true}};var m=function(){};var r={isValid:false,parse:{}};w(E,r.parse);o(E,r);return r};KJUR.asn1.cms.CMSParser=function(){var g=Error,a=X509,h=new a(),l=ASN1HEX,i=l.getV,b=l.getTLV,f=l.getIdxbyList,c=l.getTLVbyList,d=l.getTLVbyListEx,e=l.getVbyList,k=l.getVbyListEx,j=l.getChildIdx;this.getCMSSignedData=function(m){var o=c(m,0,[1,0]);var n=this.getSignedData(o);return n};this.getSignedData=function(o){var q=j(o,0);var v={};var p=i(o,q[0]);var n=parseInt(p,16);v.version=n;var r=b(o,q[1]);v.hashalgs=this.getHashAlgArray(r);var t=b(o,q[2]);v.econtent=this.getEContent(t);var m=d(o,0,["[0]"]);if(m!=null){v.certs=this.getCertificateSet(m)}var u=d(o,0,["[1]"]);if(u!=null){}var s=d(o,0,[3]);v.sinfos=this.getSignerInfos(s);return v};this.getHashAlgArray=function(s){var q=j(s,0);var m=new a();var n=[];for(var r=0;r<q.length;r++){var p=b(s,q[r]);var o=m.getAlgorithmIdentifierName(p);n.push(o)}return n};this.getEContent=function(m){var n={};var p=e(m,0,[0]);var o=e(m,0,[1,0]);n.type=KJUR.asn1.x509.OID.oid2name(ASN1HEX.hextooidstr(p));n.content={hex:o};return n};this.getSignerInfos=function(p){var r=[];var m=j(p,0);for(var n=0;n<m.length;n++){var o=b(p,m[n]);var q=this.getSignerInfo(o);r.push(q)}return r};this.getSignerInfo=function(s){var y={};var u=j(s,0);var q=l.getInt(s,u[0],-1);if(q!=-1){y.version=q}var t=b(s,u[1]);var p=this.getIssuerAndSerialNumber(t);y.id=p;var z=b(s,u[2]);var n=h.getAlgorithmIdentifierName(z);y.hashalg=n;var w=d(s,0,["[0]"]);if(w!=null){var A=this.getAttributeList(w);y.sattrs=A}var m=d(s,0,[3]);var x=h.getAlgorithmIdentifierName(m);y.sigalg=x;var o=k(s,0,[4]);y.sighex=o;var r=d(s,0,["[1]"]);if(r!=null){var v=this.getAttributeList(r);y.uattrs=v}return y};this.getSignerIdentifier=function(m){if(m.substr(0,2)=="30"){return this.getIssuerAndSerialNumber(m)}else{throw new Error("SKID of signerIdentifier not supported")}};this.getIssuerAndSerialNumber=function(n){var o={type:"isssn"};var m=j(n,0);var p=b(n,m[0]);o.issuer=h.getX500Name(p);var q=i(n,m[1]);o.serial={hex:q};return o};this.getAttributeList=function(q){var m=[];var n=j(q,0);for(var o=0;o<n.length;o++){var p=b(q,n[o]);var r=this.getAttribute(p);m.push(r)}return{array:m}};this.getAttribute=function(p){var t={};var q=j(p,0);var o=l.getOID(p,q[0]);var m=KJUR.asn1.x509.OID.oid2name(o);t.attr=m;var r=b(p,q[1]);var u=j(r,0);if(u.length==1){t.valhex=b(r,u[0])}else{var s=[];for(var n=0;n<u.length;n++){s.push(b(r,u[n]))}t.valhex=s}if(m=="contentType"){this.setContentType(t)}else{if(m=="messageDigest"){this.setMessageDigest(t)}else{if(m=="signingTime"){this.setSigningTime(t)}else{if(m=="signingCertificate"){this.setSigningCertificate(t)}else{if(m=="signingCertificateV2"){this.setSigningCertificateV2(t)}else{if(m=="signaturePolicyIdentifier"){this.setSignaturePolicyIdentifier(t)}}}}}}return t};this.setContentType=function(m){var n=l.getOIDName(m.valhex,0,null);if(n!=null){m.type=n;delete m.valhex}};this.setSigningTime=function(o){var n=i(o.valhex,0);var m=hextoutf8(n);o.str=m;delete o.valhex};this.setMessageDigest=function(m){var n=i(m.valhex,0);m.hex=n;delete m.valhex};this.setSigningCertificate=function(n){var q=j(n.valhex,0);if(q.length>0){var m=b(n.valhex,q[0]);var p=j(m,0);var t=[];for(var o=0;o<p.length;o++){var s=b(m,p[o]);var u=this.getESSCertID(s);t.push(u)}n.array=t}if(q.length>1){var r=b(n.valhex,q[1]);n.polhex=r}delete n.valhex};this.setSignaturePolicyIdentifier=function(s){var q=j(s.valhex,0);if(q.length>0){var r=l.getOID(s.valhex,q[0]);s.oid=r}if(q.length>1){var m=new a();var t=j(s.valhex,q[1]);var p=b(s.valhex,t[0]);var o=m.getAlgorithmIdentifierName(p);s.alg=o;var n=i(s.valhex,t[1]);s.hash=n}delete s.valhex};this.setSigningCertificateV2=function(o){var s=j(o.valhex,0);if(s.length>0){var n=b(o.valhex,s[0]);var r=j(n,0);var u=[];for(var q=0;q<r.length;q++){var m=b(n,r[q]);var p=this.getESSCertIDv2(m);u.push(p)}o.array=u}if(s.length>1){var t=b(o.valhex,s[1]);o.polhex=t}delete o.valhex};this.getESSCertID=function(o){var p={};var n=j(o,0);if(n.length>0){var q=i(o,n[0]);p.hash=q}if(n.length>1){var m=b(o,n[1]);var r=this.getIssuerSerial(m);if(r.serial!=undefined){p.serial=r.serial}if(r.issuer!=undefined){p.issuer=r.issuer}}return p};this.getESSCertIDv2=function(q){var s={};var p=j(q,0);if(p.length<1||3<p.length){throw new g("wrong number of elements")}var r=0;if(q.substr(p[0],2)=="30"){var o=b(q,p[0]);s.alg=h.getAlgorithmIdentifierName(o);r++}else{s.alg="sha256"}var n=i(q,p[r]);s.hash=n;if(p.length>r+1){var m=b(q,p[r+1]);var t=this.getIssuerSerial(m);s.issuer=t.issuer;s.serial=t.serial}return s};this.getIssuerSerial=function(q){var r={};var n=j(q,0);var m=b(q,n[0]);var p=h.getGeneralNames(m);var o=p[0].dn;r.issuer=o;var s=i(q,n[1]);r.serial={hex:s};return r};this.getCertificateSet=function(p){var n=j(p,0);var m=[];for(var o=0;o<n.length;o++){var r=b(p,n[o]);if(r.substr(0,2)=="30"){var q=hextopem(r,"CERTIFICATE");m.push(q)}}return{array:m,sortflag:false}}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.tsp=="undefined"||!KJUR.asn1.tsp){KJUR.asn1.tsp={}}KJUR.asn1.tsp.TimeStampToken=function(d){var c=KJUR,b=c.asn1,a=b.tsp;a.TimeStampToken.superclass.constructor.call(this);this.params=null;this.getEncodedHexPrepare=function(){var e=new a.TSTInfo(this.params.econtent.content);this.params.econtent.content.hex=e.tohex()};if(d!=undefined){this.setByParam(d)}};extendClass(KJUR.asn1.tsp.TimeStampToken,KJUR.asn1.cms.SignedData);KJUR.asn1.tsp.TSTInfo=function(f){var m=Error,c=KJUR,j=c.asn1,g=j.DERSequence,i=j.DERInteger,l=j.DERBoolean,h=j.DERGeneralizedTime,n=j.DERObjectIdentifier,e=j.DERTaggedObject,k=j.tsp,d=k.MessageImprint,b=k.Accuracy,a=j.x509.X500Name,o=j.x509.GeneralName;k.TSTInfo.superclass.constructor.call(this);this.dVersion=new i({"int":1});this.dPolicy=null;this.dMessageImprint=null;this.dSerial=null;this.dGenTime=null;this.dAccuracy=null;this.dOrdering=null;this.dNonce=null;this.dTsa=null;this.tohex=function(){var p=[this.dVersion];if(this.dPolicy==null){throw new Error("policy shall be specified.")}p.push(this.dPolicy);if(this.dMessageImprint==null){throw new Error("messageImprint shall be specified.")}p.push(this.dMessageImprint);if(this.dSerial==null){throw new Error("serialNumber shall be specified.")}p.push(this.dSerial);if(this.dGenTime==null){throw new Error("genTime shall be specified.")}p.push(this.dGenTime);if(this.dAccuracy!=null){p.push(this.dAccuracy)}if(this.dOrdering!=null){p.push(this.dOrdering)}if(this.dNonce!=null){p.push(this.dNonce)}if(this.dTsa!=null){p.push(this.dTsa)}var q=new g({array:p});this.hTLV=q.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){if(typeof f.policy=="string"){if(!f.policy.match(/^[0-9.]+$/)){throw"policy shall be oid like 0.1.4.134"}this.dPolicy=new n({oid:f.policy})}if(f.messageImprint!==undefined){this.dMessageImprint=new d(f.messageImprint)}if(f.serial!==undefined){this.dSerial=new i(f.serial)}if(f.genTime!==undefined){this.dGenTime=new h(f.genTime)}if(f.accuracy!==undefined){this.dAccuracy=new b(f.accuracy)}if(f.ordering!==undefined&&f.ordering==true){this.dOrdering=new l()}if(f.nonce!==undefined){this.dNonce=new i(f.nonce)}if(f.tsa!==undefined){this.dTsa=new e({tag:"a0",explicit:true,obj:new o({dn:f.tsa})})}}};extendClass(KJUR.asn1.tsp.TSTInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.Accuracy=function(d){var c=KJUR,b=c.asn1,a=b.ASN1Util.newObject;b.tsp.Accuracy.superclass.constructor.call(this);this.params=null;this.tohex=function(){var f=this.params;var e=[];if(f.seconds!=undefined&&typeof f.seconds=="number"){e.push({"int":f.seconds})}if(f.millis!=undefined&&typeof f.millis=="number"){e.push({tag:{tagi:"80",obj:{"int":f.millis}}})}if(f.micros!=undefined&&typeof f.micros=="number"){e.push({tag:{tagi:"81",obj:{"int":f.micros}}})}return a({seq:e}).tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!=undefined){this.setByParam(d)}};extendClass(KJUR.asn1.tsp.Accuracy,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.MessageImprint=function(g){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.DEROctetString,f=b.x509,e=f.AlgorithmIdentifier;b.tsp.MessageImprint.superclass.constructor.call(this);this.params=null;this.tohex=function(){var k=this.params;var j=new e({name:k.alg});var h=new d({hex:k.hash});var i=new a({array:[j,h]});return i.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!==undefined){this.setByParam(g)}};extendClass(KJUR.asn1.tsp.MessageImprint,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampReq=function(c){var a=KJUR,f=a.asn1,d=f.DERSequence,e=f.DERInteger,h=f.DERBoolean,j=f.ASN1Object,i=f.DERObjectIdentifier,g=f.tsp,b=g.MessageImprint;g.TimeStampReq.superclass.constructor.call(this);this.params=null;this.tohex=function(){var m=this.params;var k=[];k.push(new e({"int":1}));if(m.messageImprint instanceof KJUR.asn1.ASN1Object){k.push(m.messageImprint)}else{k.push(new b(m.messageImprint))}if(m.policy!=undefined){k.push(new i(m.policy))}if(m.nonce!=undefined){k.push(new e(m.nonce))}if(m.certreq==true){k.push(new h())}var l=new d({array:k});return l.tohex()};this.getEncodedHex=function(){return this.tohex()};if(c!=undefined){this.setByParam(c)}};extendClass(KJUR.asn1.tsp.TimeStampReq,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.TimeStampResp=function(g){var e=KJUR,d=e.asn1,c=d.DERSequence,f=d.ASN1Object,a=d.tsp,b=a.PKIStatusInfo;a.TimeStampResp.superclass.constructor.call(this);this.params=null;this.tohex=function(){var j=this.params;var h=[];if(j.econtent!=undefined||j.tst!=undefined){if(j.statusinfo!=undefined){h.push(new b(j.statusinfo))}else{h.push(new b("granted"))}if(j.econtent!=undefined){h.push((new a.TimeStampToken(j)).getContentInfo())}else{if(j.tst instanceof d.ASN1Object){h.push(j.tst)}else{throw new Error("improper member tst value")}}}else{if(j.statusinfo!=undefined){h.push(new b(j.statusinfo))}else{throw new Error("parameter for token nor statusinfo not specified")}}var i=new c({array:h});return i.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.tsp.TimeStampResp,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatusInfo=function(d){var h=Error,a=KJUR,g=a.asn1,e=g.DERSequence,i=g.tsp,f=i.PKIStatus,c=i.PKIFreeText,b=i.PKIFailureInfo;i.PKIStatusInfo.superclass.constructor.call(this);this.params=null;this.tohex=function(){var l=this.params;var j=[];if(typeof l=="string"){j.push(new f(l))}else{if(l.status==undefined){throw new h("property 'status' unspecified")}j.push(new f(l.status));if(l.statusstr!=undefined){j.push(new c(l.statusstr))}if(l.failinfo!=undefined){j.push(new b(l.failinfo))}}var k=new e({array:j});return k.tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!=undefined){this.setByParam(d)}};extendClass(KJUR.asn1.tsp.PKIStatusInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIStatus=function(g){var e=Error,d=KJUR,c=d.asn1,f=c.DERInteger,b=c.tsp;b.PKIStatus.superclass.constructor.call(this);var a={granted:0,grantedWithMods:1,rejection:2,waiting:3,revocationWarning:4,revocationNotification:5};this.params=null;this.tohex=function(){var k=this.params;var h,j;if(typeof k=="string"){try{j=a[k]}catch(i){throw new e("undefined name: "+k)}}else{if(typeof k=="number"){j=k}else{throw new e("unsupported params")}}return(new f({"int":j})).tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.tsp.PKIStatus,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFreeText=function(g){var f=Error,e=KJUR,d=e.asn1,b=d.DERSequence,c=d.DERUTF8String,a=d.tsp;a.PKIFreeText.superclass.constructor.call(this);this.params=null;this.tohex=function(){var l=this.params;if(!l instanceof Array){throw new f("wrong params: not array")}var h=[];for(var k=0;k<l.length;k++){h.push(new c({str:l[k]}))}var j=new b({array:h});return j.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.tsp.PKIFreeText,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.PKIFailureInfo=function(h){var f=Error,e=KJUR,d=e.asn1,g=d.DERBitString,b=d.tsp,c=b.PKIFailureInfo;var a={badAlg:0,badRequest:2,badDataFormat:5,timeNotAvailable:14,unacceptedPolicy:15,unacceptedExtension:16,addInfoNotAvailable:17,systemFailure:25};c.superclass.constructor.call(this);this.params=null;this.getBinValue=function(){var n=this.params;var m=0;if(typeof n=="number"&&0<=n&&n<=25){m|=1<<n;var k=m.toString(2);var l="";for(var j=k.length-1;j>=0;j--){l+=k[j]}return l}else{if(typeof n=="string"&&a[n]!=undefined){return namearraytobinstr([n],a)}else{if(typeof n=="object"&&n.length!=undefined){return namearraytobinstr(n,a)}else{throw new f("wrong params")}}}return};this.tohex=function(){var j=this.params;var i=this.getBinValue();return(new g({bin:i})).tohex()};this.getEncodedHex=function(){return this.tohex()};if(h!=undefined){this.setByParam(h)}};extendClass(KJUR.asn1.tsp.PKIFailureInfo,KJUR.asn1.ASN1Object);KJUR.asn1.tsp.AbstractTSAAdapter=function(a){this.getTSTHex=function(c,b){throw"not implemented yet"}};KJUR.asn1.tsp.SimpleTSAAdapter=function(e){var d=KJUR,c=d.asn1,a=c.tsp,b=d.crypto.Util.hashHex;a.SimpleTSAAdapter.superclass.constructor.call(this);this.params=null;this.serial=0;this.getTSTHex=function(g,f){var i=b(g,f);this.params.econtent.content.messageImprint={alg:f,hash:i};this.params.econtent.content.serial={"int":this.serial++};var h=Math.floor(Math.random()*1000000000);this.params.econtent.content.nonce={"int":h};var j=new a.TimeStampToken(this.params);return j.getContentInfoEncodedHex()};if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.tsp.SimpleTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.FixedTSAAdapter=function(e){var d=KJUR,c=d.asn1,a=c.tsp,b=d.crypto.Util.hashHex;a.FixedTSAAdapter.superclass.constructor.call(this);this.params=null;this.getTSTHex=function(g,f){var h=b(g,f);this.params.econtent.content.messageImprint={alg:f,hash:h};var i=new a.TimeStampToken(this.params);return i.getContentInfoEncodedHex()};if(e!==undefined){this.params=e}};extendClass(KJUR.asn1.tsp.FixedTSAAdapter,KJUR.asn1.tsp.AbstractTSAAdapter);KJUR.asn1.tsp.TSPUtil=new function(){};KJUR.asn1.tsp.TSPUtil.newTimeStampToken=function(a){return new KJUR.asn1.tsp.TimeStampToken(a)};KJUR.asn1.tsp.TSPUtil.parseTimeStampReq=function(a){var b=new KJUR.asn1.tsp.TSPParser();return b.getTimeStampReq(a)};KJUR.asn1.tsp.TSPUtil.parseMessageImprint=function(a){var b=new KJUR.asn1.tsp.TSPParser();return b.getMessageImprint(a)};KJUR.asn1.tsp.TSPParser=function(){var e=Error,a=X509,f=new a(),k=ASN1HEX,g=k.getV,b=k.getTLV,d=k.getIdxbyList,c=k.getTLVbyListEx,i=k.getChildIdx;var j=["granted","grantedWithMods","rejection","waiting","revocationWarning","revocationNotification"];var h={0:"badAlg",2:"badRequest",5:"badDataFormat",14:"timeNotAvailable",15:"unacceptedPolicy",16:"unacceptedExtension",17:"addInfoNotAvailable",25:"systemFailure"};this.getResponse=function(n){var l=i(n,0);if(l.length==1){return this.getPKIStatusInfo(b(n,l[0]))}else{if(l.length>1){var o=this.getPKIStatusInfo(b(n,l[0]));var m=b(n,l[1]);var p=this.getToken(m);p.statusinfo=o;return p}}};this.getToken=function(m){var l=new KJUR.asn1.cms.CMSParser;var n=l.getCMSSignedData(m);this.setTSTInfo(n);return n};this.setTSTInfo=function(l){var o=l.econtent;if(o.type=="tstinfo"){var n=o.content.hex;var m=this.getTSTInfo(n);o.content=m}};this.getTSTInfo=function(r){var x={};var s=i(r,0);var p=g(r,s[1]);x.policy=hextooid(p);var o=b(r,s[2]);x.messageImprint=this.getMessageImprint(o);var u=g(r,s[3]);x.serial={hex:u};var y=g(r,s[4]);x.genTime={str:hextoutf8(y)};var q=0;if(s.length>5&&r.substr(s[5],2)=="30"){var v=b(r,s[5]);x.accuracy=this.getAccuracy(v);q++}if(s.length>5+q&&r.substr(s[5+q],2)=="01"){var z=g(r,s[5+q]);if(z=="ff"){x.ordering=true}q++}if(s.length>5+q&&r.substr(s[5+q],2)=="02"){var n=g(r,s[5+q]);x.nonce={hex:n};q++}if(s.length>5+q&&r.substr(s[5+q],2)=="a0"){var m=b(r,s[5+q]);m="30"+m.substr(2);pGeneralNames=f.getGeneralNames(m);var t=pGeneralNames[0].dn;x.tsa=t;q++}if(s.length>5+q&&r.substr(s[5+q],2)=="a1"){var l=b(r,s[5+q]);l="30"+l.substr(2);var w=f.getExtParamArray(l);x.ext=w;q++}return x};this.getAccuracy=function(q){var r={};var o=i(q,0);for(var p=0;p<o.length;p++){var m=q.substr(o[p],2);var l=g(q,o[p]);var n=parseInt(l,16);if(m=="02"){r.seconds=n}else{if(m=="80"){r.millis=n}else{if(m=="81"){r.micros=n}}}}return r};this.getMessageImprint=function(n){if(n.substr(0,2)!="30"){throw new Error("head of messageImprint hex shall be x30")}var s={};var l=i(n,0);var t=d(n,0,[0,0]);var o=g(n,t);var p=k.hextooidstr(o);var r=KJUR.asn1.x509.OID.oid2name(p);if(r==""){throw new Error("hashAlg name undefined: "+p)}var m=r;var q=d(n,0,[1]);s.alg=m;s.hash=g(n,q);return s};this.getPKIStatusInfo=function(o){var t={};var r=i(o,0);var n=0;try{var l=g(o,r[0]);var p=parseInt(l,16);t.status=j[p]}catch(s){}if(r.length>1&&o.substr(r[1],2)=="30"){var m=b(o,r[1]);t.statusstr=this.getPKIFreeText(m);n++}if(r.length>n&&o.substr(r[1+n],2)=="03"){var q=b(o,r[1+n]);t.failinfo=this.getPKIFailureInfo(q)}return t};this.getPKIFreeText=function(n){var o=[];var l=i(n,0);for(var m=0;m<l.length;m++){o.push(k.getString(n,l[m]))}return o};this.getPKIFailureInfo=function(l){var m=k.getInt(l,0);if(h[m]!=undefined){return h[m]}else{return m}};this.getTimeStampReq=function(q){var p={};p.certreq=false;var s=i(q,0);if(s.length<2){throw new Error("TimeStampReq must have at least 2 items")}var n=b(q,s[1]);p.messageImprint=KJUR.asn1.tsp.TSPUtil.parseMessageImprint(n);for(var o=2;o<s.length;o++){var m=s[o];var l=q.substr(m,2);if(l=="06"){var r=g(q,m);p.policy=k.hextooidstr(r)}if(l=="02"){p.nonce=g(q,m)}if(l=="01"){p.certreq=true}}return p}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.cades=="undefined"||!KJUR.asn1.cades){KJUR.asn1.cades={}}KJUR.asn1.cades.SignaturePolicyIdentifier=function(e){var c=KJUR,b=c.asn1,a=b.cades,d=a.SignaturePolicyId;a.SignaturePolicyIdentifier.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.16.2.15";this.params=null;this.getValueArray=function(){return[new d(this.params)]};this.setByParam=function(f){this.params=f};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cades.SignaturePolicyIdentifier,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.SignaturePolicyId=function(e){var a=KJUR,g=a.asn1,f=g.DERSequence,i=g.DERObjectIdentifier,d=g.x509,j=d.AlgorithmIdentifier,c=g.cades,h=c.SignaturePolicyId,b=c.OtherHashAlgAndValue;h.superclass.constructor.call(this);this.params=null;this.tohex=function(){var m=this.params;var k=[];k.push(new i(m.oid));k.push(new b(m));var l=new f({array:k});return l.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(k){this.params=k};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cades.SignaturePolicyId,KJUR.asn1.ASN1Object);KJUR.asn1.cades.OtherHashAlgAndValue=function(e){var h=Error,a=KJUR,g=a.asn1,f=g.DERSequence,i=g.DEROctetString,d=g.x509,j=d.AlgorithmIdentifier,c=g.cades,b=c.OtherHashAlgAndValue;b.superclass.constructor.call(this);this.params=null;this.tohex=function(){var o=this.params;if(o.alg==undefined){throw new h("property 'alg' not specified")}if(o.hash==undefined&&o.cert==undefined){throw new h("property 'hash' nor 'cert' not specified")}var m=null;if(o.hash!=undefined){m=o.hash}else{if(o.cert!=undefined){if(typeof o.cert!="string"){throw new h("cert not string")}var n=o.cert;if(o.cert.indexOf("-----BEGIN")!=-1){n=pemtohex(o.cert)}m=KJUR.crypto.Util.hashHex(n,o.alg)}}var k=[];k.push(new j({name:o.alg}));k.push(new i({hex:m}));var l=new f({array:k});return l.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cades.OtherHashAlgAndValue,KJUR.asn1.ASN1Object);KJUR.asn1.cades.OtherHashValue=function(g){KJUR.asn1.cades.OtherHashValue.superclass.constructor.call(this);var d=Error,c=KJUR,f=c.lang.String.isHex,b=c.asn1,e=b.DEROctetString,a=c.crypto.Util.hashHex;this.params=null;this.tohex=function(){var j=this.params;if(j.hash==undefined&&j.cert==undefined){throw new d("hash or cert not specified")}var h=null;if(j.hash!=undefined){h=j.hash}else{if(j.cert!=undefined){if(typeof j.cert!="string"){throw new d("cert not string")}var i=j.cert;if(j.cert.indexOf("-----BEGIN")!=-1){i=pemtohex(j.cert)}h=KJUR.crypto.Util.hashHex(i,"sha1")}}return(new e({hex:h})).tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cades.OtherHashValue,KJUR.asn1.ASN1Object);KJUR.asn1.cades.SignatureTimeStamp=function(h){var d=Error,c=KJUR,f=c.lang.String.isHex,b=c.asn1,e=b.ASN1Object,g=b.x509,a=b.cades;a.SignatureTimeStamp.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.16.2.14";this.params=null;this.getValueArray=function(){var l=this.params;if(l.tst!=undefined){if(f(l.tst)){var j=new e();j.hTLV=l.tst;return[j]}else{if(l.tst instanceof e){return[l.tst]}else{throw new d("params.tst has wrong value")}}}else{if(l.res!=undefined){var k=l.res;if(k instanceof e){k=k.tohex()}if(typeof k!="string"||(!f(k))){throw new d("params.res has wrong value")}var i=ASN1HEX.getTLVbyList(k,0,[1]);var j=new e();j.hTLV=l.tst;return[j]}}};if(h!=null){this.setByParam(h)}};extendClass(KJUR.asn1.cades.SignatureTimeStamp,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.CompleteCertificateRefs=function(h){var f=Error,e=KJUR,d=e.asn1,b=d.DERSequence,c=d.cades,a=c.OtherCertID,g=e.lang.String.isHex;c.CompleteCertificateRefs.superclass.constructor.call(this);this.typeOid="1.2.840.113549.1.9.16.2.21";this.params=null;this.getValueArray=function(){var o=this.params;var k=[];for(var m=0;m<o.array.length;m++){var n=o.array[m];if(typeof n=="string"){if(n.indexOf("-----BEGIN")!=-1){n={cert:n}}else{if(g(n)){n={hash:n}}else{throw new f("unsupported value: "+n)}}}if(o.alg!=undefined&&n.alg==undefined){n.alg=o.alg}if(o.hasis!=undefined&&n.hasis==undefined){n.hasis=o.hasis}var j=new a(n);k.push(j)}var l=new b({array:k});return[l]};if(h!=undefined){this.setByParam(h)}};extendClass(KJUR.asn1.cades.CompleteCertificateRefs,KJUR.asn1.cms.Attribute);KJUR.asn1.cades.OtherCertID=function(e){var a=KJUR,h=a.asn1,f=h.DERSequence,i=h.cms,g=i.IssuerSerial,c=h.cades,d=c.OtherHashValue,b=c.OtherHashAlgAndValue;c.OtherCertID.superclass.constructor.call(this);this.params=e;this.tohex=function(){var n=this.params;if(typeof n=="string"){if(n.indexOf("-----BEGIN")!=-1){n={cert:n}}else{if(_isHex(n)){n={hash:n}}}}var j=[];var m=null;if(n.alg!=undefined){m=new b(n)}else{m=new d(n)}j.push(m);if((n.cert!=undefined&&n.hasis==true)||(n.issuer!=undefined&&n.serial!=undefined)){var l=new g(n);j.push(l)}var k=new f({array:j});return k.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!=undefined){this.setByParam(e)}};extendClass(KJUR.asn1.cades.OtherCertID,KJUR.asn1.ASN1Object);KJUR.asn1.cades.OtherHash=function(g){var i=Error,a=KJUR,h=a.asn1,j=h.cms,c=h.cades,b=c.OtherHashAlgAndValue,e=c.OtherHashValue,d=a.crypto.Util.hashHex,f=a.lang.String.isHex;c.OtherHash.superclass.constructor.call(this);this.params=null;this.tohex=function(){var l=this.params;if(typeof l=="string"){if(l.indexOf("-----BEGIN")!=-1){l={cert:l}}else{if(f(l)){l={hash:l}}}}var k=null;if(l.alg!=undefined){k=new b(l)}else{k=new e(l)}return k.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!=undefined){this.setByParam(g)}};extendClass(KJUR.asn1.cades.OtherHash,KJUR.asn1.ASN1Object);KJUR.asn1.cades.CAdESUtil=new function(){};KJUR.asn1.cades.CAdESUtil.parseSignedDataForAddingUnsigned=function(a){var c=new KJUR.asn1.cms.CMSParser();var b=c.getCMSSignedData(a);return b};KJUR.asn1.cades.CAdESUtil.parseSignerInfoForAddingUnsigned=function(g,q,c){var p=ASN1HEX,s=p.getChildIdx,a=p.getTLV,l=p.getV,v=KJUR,h=v.asn1,n=h.ASN1Object,j=h.cms,k=j.AttributeList,w=j.SignerInfo;var o={};var t=s(g,q);if(t.length!=6){throw"not supported items for SignerInfo (!=6)"}var d=t.shift();o.version=a(g,d);var e=t.shift();o.si=a(g,e);var m=t.shift();o.digalg=a(g,m);var f=t.shift();o.sattrs=a(g,f);var i=t.shift();o.sigalg=a(g,i);var b=t.shift();o.sig=a(g,b);o.sigval=l(g,b);var u=null;o.obj=new w();u=new n();u.hTLV=o.version;o.obj.dCMSVersion=u;u=new n();u.hTLV=o.si;o.obj.dSignerIdentifier=u;u=new n();u.hTLV=o.digalg;o.obj.dDigestAlgorithm=u;u=new n();u.hTLV=o.sattrs;o.obj.dSignedAttrs=u;u=new n();u.hTLV=o.sigalg;o.obj.dSigAlg=u;u=new n();u.hTLV=o.sig;o.obj.dSig=u;o.obj.dUnsignedAttrs=new k();return o};
if(typeof KJUR.asn1.csr=="undefined"||!KJUR.asn1.csr){KJUR.asn1.csr={}}KJUR.asn1.csr.CertificationRequest=function(g){var d=KJUR,c=d.asn1,e=c.DERBitString,b=c.DERSequence,a=c.csr,f=c.x509,h=a.CertificationRequestInfo;a.CertificationRequest.superclass.constructor.call(this);this.setByParam=function(i){this.params=i};this.sign=function(){var j=(new h(this.params)).tohex();var k=new KJUR.crypto.Signature({alg:this.params.sigalg});k.init(this.params.sbjprvkey);k.updateHex(j);var i=k.sign();this.params.sighex=i};this.getPEM=function(){return hextopem(this.tohex(),"CERTIFICATE REQUEST")};this.tohex=function(){var l=this.params;var j=new KJUR.asn1.csr.CertificationRequestInfo(this.params);var m=new KJUR.asn1.x509.AlgorithmIdentifier({name:l.sigalg});if(l.sighex==undefined&&l.sbjprvkey!=undefined){this.sign()}if(l.sighex==undefined){throw new Error("sighex or sbjprvkey parameter not defined")}var k=new e({hex:"00"+l.sighex});var i=new b({array:[j,m,k]});return i.tohex()};this.getEncodedHex=function(){return this.tohex()};if(g!==undefined){this.setByParam(g)}};extendClass(KJUR.asn1.csr.CertificationRequest,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CertificationRequestInfo=function(f){var b=KJUR,j=b.asn1,c=j.DERBitString,g=j.DERSequence,i=j.DERInteger,p=j.DERUTF8String,d=j.DERTaggedObject,h=j.ASN1Util.newObject,n=j.csr,e=j.x509,a=e.X500Name,l=e.Extensions,o=e.SubjectPublicKeyInfo,k=n.AttributeList;n.CertificationRequestInfo.superclass.constructor.call(this);this.params=null;this.setByParam=function(q){if(q!=undefined){this.params=q}};this.tohex=function(){var v=this.params;var r=[];r.push(new i({"int":0}));r.push(new a(v.subject));r.push(new o(KEYUTIL.getKey(v.sbjpubkey)));if(v.attrs!=undefined){var u=m(v.attrs);var t=h({tag:{tage:"a0",obj:u}});r.push(t)}else{if(v.extreq!=undefined){var q=new l(v.extreq);var t=h({tag:{tage:"a0",obj:{seq:[{oid:"1.2.840.113549.1.9.14"},{set:[q]}]}}});r.push(t)}else{r.push(new d({tag:"a0",explicit:false,obj:new p({str:""})}))}}var s=new g({array:r});return s.tohex()};this.getEncodedHex=function(){return this.tohex()};function m(s){var w=Error,v=KJUR.asn1.x509.Extensions;var y=[];for(var u=0;u<s.length;u++){var r=s[u];var x=r.attr;if(x=="extensionRequest"){var t=new v(r.ext);var q={seq:[{oid:"1.2.840.113549.1.9.14"},{set:[t]}]};y.push(q)}else{if(x=="unstructuredName"){var q={seq:[{oid:"1.2.840.113549.1.9.2"},{set:r.names}]};y.push(q)}else{if(x=="challengePassword"){var q={seq:[{oid:"1.2.840.113549.1.9.7"},{set:[{utf8str:r.password}]}]};y.push(q)}else{throw new w("unknown CSR attribute")}}}}return{set:y}}if(f!=undefined){this.setByParam(f)}};extendClass(KJUR.asn1.csr.CertificationRequestInfo,KJUR.asn1.ASN1Object);KJUR.asn1.csr.AttributeList=function(b){function a(c){}};extendClass(KJUR.asn1.csr.AttributeList,KJUR.asn1.ASN1Object);KJUR.asn1.csr.CSRUtil=new function(){};KJUR.asn1.csr.CSRUtil.newCSRPEM=function(e){var b=KEYUTIL,a=KJUR.asn1.csr;var c=new a.CertificationRequest(e);var d=c.getPEM();return d};KJUR.asn1.csr.CSRUtil.getParam=function(d,a){var m=ASN1HEX,i=m.getV,j=m.getIdxbyList,b=m.getTLVbyList,o=m.getTLVbyListEx,n=m.getVbyListEx;var l=function(u){var t=j(u,0,[0,3,0,0],"06");if(i(u,t)!="2a864886f70d01090e"){return null}return b(u,0,[0,3,0,1,0],"30")};var g={};if(d.indexOf("-----BEGIN CERTIFICATE REQUEST")==-1){throw new Error("argument is not PEM file")}var e=pemtohex(d,"CERTIFICATE REQUEST");if(a){g.tbs=b(e,0,[0])}try{var p=o(e,0,[0,1]);if(p=="3000"){g.subject={}}else{var f=new X509();g.subject=f.getX500Name(p)}}catch(q){}var k=o(e,0,[0,2]);var r=KEYUTIL.getKey(k,null,"pkcs8pub");g.sbjpubkey=KEYUTIL.getPEM(r,"PKCS8PUB");var c=l(e);var f=new X509();if(c!=null){g.extreq=f.getExtParamArray(c)}try{var h=o(e,0,[1],"30");var f=new X509();g.sigalg=f.getAlgorithmIdentifierName(h)}catch(q){}try{var s=n(e,0,[2]);g.sighex=s}catch(q){}return g};KJUR.asn1.csr.CSRUtil.verifySignature=function(b){try{var c=null;if(typeof b=="string"&&b.indexOf("-----BEGIN CERTIFICATE REQUEST")!=-1){c=KJUR.asn1.csr.CSRUtil.getParam(b,true)}else{if(typeof b=="object"&&b.sbjpubkey!=undefined&&b.sigalg!=undefined&&b.sighex!=undefined&&b.tbs!=undefined){c=b}}if(c==null){return false}var d=new KJUR.crypto.Signature({alg:c.sigalg});d.init(c.sbjpubkey);d.updateHex(c.tbs);return d.verify(c.sighex)}catch(a){alert(a);return false}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.asn1=="undefined"||!KJUR.asn1){KJUR.asn1={}}if(typeof KJUR.asn1.ocsp=="undefined"||!KJUR.asn1.ocsp){KJUR.asn1.ocsp={}}KJUR.asn1.ocsp.DEFAULT_HASH="sha1";KJUR.asn1.ocsp.OCSPResponse=function(e){KJUR.asn1.ocsp.OCSPResponse.superclass.constructor.call(this);var a=KJUR.asn1.DEREnumerated,b=KJUR.asn1.ASN1Util.newObject,c=KJUR.asn1.ocsp.ResponseBytes;var d=["successful","malformedRequest","internalError","tryLater","_not_used_","sigRequired","unauthorized"];this.params=null;this._getStatusCode=function(){var f=this.params.resstatus;if(typeof f=="number"){return f}if(typeof f!="string"){return -1}return d.indexOf(f)};this.setByParam=function(f){this.params=f};this.tohex=function(){var h=this.params;var g=this._getStatusCode();if(g==-1){throw new Error("responseStatus not supported: "+h.resstatus)}if(g!=0){return b({seq:[{"enum":{"int":g}}]}).tohex()}var f=new c(h);return b({seq:[{"enum":{"int":0}},{tag:{tag:"a0",explicit:true,obj:f}}]}).tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.setByParam(e)}};extendClass(KJUR.asn1.ocsp.OCSPResponse,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.ResponseBytes=function(e){KJUR.asn1.ocsp.ResponseBytes.superclass.constructor.call(this);var b=KJUR.asn1,a=b.DERSequence,f=b.DERObjectIdentifier,c=b.DEROctetString,d=b.ocsp.BasicOCSPResponse;this.params=null;this.setByParam=function(g){this.params=g};this.tohex=function(){var j=this.params;if(j.restype!="ocspBasic"){throw new Error("not supported responseType: "+j.restype)}var i=new d(j);var g=[];g.push(new f({name:"ocspBasic"}));g.push(new c({hex:i.tohex()}));var h=new a({array:g});return h.tohex()};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.setByParam(e)}};extendClass(KJUR.asn1.ocsp.ResponseBytes,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.BasicOCSPResponse=function(d){KJUR.asn1.ocsp.BasicOCSPResponse.superclass.constructor.call(this);var i=Error,g=KJUR.asn1,j=g.ASN1Object,e=g.DERSequence,f=g.DERGeneralizedTime,c=g.DERTaggedObject,b=g.DERBitString,h=g.x509.Extensions,k=g.x509.AlgorithmIdentifier,l=g.ocsp,a=l.ResponderID;_SingleResponseList=l.SingleResponseList,_ResponseData=l.ResponseData;this.params=null;this.setByParam=function(m){this.params=m};this.sign=function(){var o=this.params;var m=o.tbsresp.tohex();var n=new KJUR.crypto.Signature({alg:o.sigalg});n.init(o.reskey);n.updateHex(m);o.sighex=n.sign()};this.tohex=function(){var t=this.params;if(t.tbsresp==undefined){t.tbsresp=new _ResponseData(t)}if(t.sighex==undefined&&t.reskey!=undefined){this.sign()}var n=[];n.push(t.tbsresp);n.push(new k({name:t.sigalg}));n.push(new b({hex:"00"+t.sighex}));if(t.certs!=undefined&&t.certs.length!=undefined){var m=[];for(var q=0;q<t.certs.length;q++){var s=t.certs[q];var r=null;if(ASN1HEX.isASN1HEX(s)){r=s}else{if(s.match(/-----BEGIN/)){r=pemtohex(s)}else{throw new i("certs["+q+"] not hex or PEM")}}m.push(new j({tlv:r}))}var p=new e({array:m});n.push(new c({tag:"a0",explicit:true,obj:p}))}var o=new e({array:n});return o.tohex()};this.getEncodedHex=function(){return this.tohex()};if(d!==undefined){this.setByParam(d)}};extendClass(KJUR.asn1.ocsp.BasicOCSPResponse,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.ResponseData=function(c){KJUR.asn1.ocsp.ResponseData.superclass.constructor.call(this);var h=Error,f=KJUR.asn1,d=f.DERSequence,e=f.DERGeneralizedTime,b=f.DERTaggedObject,g=f.x509.Extensions,i=f.ocsp,a=i.ResponderID;_SingleResponseList=i.SingleResponseList;this.params=null;this.tohex=function(){var m=this.params;if(m.respid!=undefined){new h("respid not specified")}if(m.prodat!=undefined){new h("prodat not specified")}if(m.array!=undefined){new h("array not specified")}var j=[];j.push(new a(m.respid));j.push(new e(m.prodat));j.push(new _SingleResponseList(m.array));if(m.ext!=undefined){var l=new g(m.ext);j.push(new b({tag:"a1",explicit:true,obj:l}))}var k=new d({array:j});return k.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(j){this.params=j};if(c!==undefined){this.setByParam(c)}};extendClass(KJUR.asn1.ocsp.ResponseData,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.ResponderID=function(g){KJUR.asn1.ocsp.ResponderID.superclass.constructor.call(this);var d=KJUR,c=d.asn1,b=c.ASN1Util.newObject,f=c.x509.X500Name,e=d.lang.String.isHex,a=Error;this.params=null;this.tohex=function(){var m=this.params;if(m.key!=undefined){var l=null;if(typeof m.key=="string"){if(e(m.key)){l=m.key}if(m.key.match(/-----BEGIN CERTIFICATE/)){var h=new X509(m.key);var k=h.getExtSubjectKeyIdentifier();if(k!=null){l=k.kid.hex}}}else{if(m.key instanceof X509){var k=m.key.getExtSubjectKeyIdentifier();if(k!=null){l=k.kid.hex}}}if(l==null){throw new a("wrong key member value")}var j=b({tag:{tag:"a2",explicit:true,obj:{octstr:{hex:l}}}});return j.tohex()}else{if(m.name!=undefined){var i=null;if(typeof m.name=="string"&&m.name.match(/-----BEGIN CERTIFICATE/)){var h=new X509(m.name);i=h.getSubject()}else{if(m.name instanceof X509){i=m.name.getSubject()}else{if(typeof m.name=="object"&&(m.name.array!=undefined||m.name.str!=undefined)){i=m.name}}}if(i==null){throw new a("wrong name member value")}var j=b({tag:{tag:"a1",explicit:true,obj:new f(i)}});return j.tohex()}}throw new a("key or name not specified")};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(h){this.params=h};if(g!==undefined){this.setByParam(g)}};extendClass(KJUR.asn1.ocsp.ResponderID,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.SingleResponseList=function(d){KJUR.asn1.ocsp.SingleResponseList.superclass.constructor.call(this);var c=KJUR.asn1,b=c.DERSequence,a=c.ocsp.SingleResponse;this.params=null;this.tohex=function(){var h=this.params;if(typeof h!="object"||h.length==undefined){throw new Error("params not specified properly")}var e=[];for(var g=0;g<h.length;g++){e.push(new a(h[g]))}var f=new b({array:e});return f.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(e){this.params=e};if(d!==undefined){this.setByParam(d)}};extendClass(KJUR.asn1.ocsp.SingleResponseList,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.SingleResponse=function(e){var k=Error,a=KJUR,i=a.asn1,f=i.DERSequence,g=i.DERGeneralizedTime,b=i.DERTaggedObject,l=i.ocsp,h=l.CertID,c=l.CertStatus,d=i.x509,j=d.Extensions;l.SingleResponse.superclass.constructor.call(this);this.params=null;this.tohex=function(){var q=this.params;var n=[];if(q.certid==undefined){throw new k("certid unspecified")}if(q.status==undefined){throw new k("status unspecified")}if(q.thisupdate==undefined){throw new k("thisupdate unspecified")}n.push(new h(q.certid));n.push(new c(q.status));n.push(new g(q.thisupdate));if(q.nextupdate!=undefined){var m=new g(q.nextupdate);n.push(new b({tag:"a0",explicit:true,obj:m}))}if(q.ext!=undefined){var p=new j(q.ext);n.push(new b({tag:"a1",explicit:true,obj:p}))}var o=new f({array:n});return o.tohex()};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(m){this.params=m};if(e!==undefined){this.setByParam(e)}};extendClass(KJUR.asn1.ocsp.SingleResponse,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.CertID=function(e){var b=KJUR,i=b.asn1,l=i.DEROctetString,h=i.DERInteger,f=i.DERSequence,d=i.x509,m=d.AlgorithmIdentifier,n=i.ocsp,k=n.DEFAULT_HASH,g=b.crypto,c=g.Util.hashHex,a=X509,o=ASN1HEX,j=o.getVbyList;n.CertID.superclass.constructor.call(this);this.DEFAULT_HASH="sha1";this.params=null;this.setByValue=function(s,r,p,q){if(q==undefined){q=this.DEFAULT_HASH}this.params={alg:q,issname:s,isskey:r,sbjsn:p}};this.setByCert=function(p,q,r){if(r==undefined){r=this.DEFAULT_HASH}this.params={alg:r,issuerCert:p,subjectCert:q,}};this.getParamByCerts=function(y,x,t){if(t==undefined){t=this.DEFAULT_HASH}var q=new a(y);var v=new a(x);var s=c(q.getSubjectHex(),t);var u=q.getPublicKeyHex();var p=c(j(u,0,[1],"03",true),t);var w=v.getSerialNumberHex();var r={alg:t,issname:s,isskey:p,sbjsn:w};return r};this.tohex=function(){if(typeof this.params!="object"){throw new Error("params not set")}var s=this.params;var u,r,y,q;if(s.alg==undefined){q=this.DEFAULT_HASH}else{q=s.alg}if(s.issuerCert!=undefined&&s.subjectCert!=undefined){var t=this.getParamByCerts(s.issuerCert,s.subjectCert,q);u=t.issname;r=t.isskey;y=t.sbjsn}else{if(s.issname!=undefined&&s.isskey!=undefined&&s.sbjsn!=undefined){u=s.issname;r=s.isskey;y=s.sbjsn}else{throw new Error("required param members not defined")}}var A=new m({name:q});var v=new l({hex:u});var x=new l({hex:r});var w=new h({hex:y});var z=new f({array:[A,v,x,w]});this.hTLV=z.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){this.setByParam(e)}};extendClass(KJUR.asn1.ocsp.CertID,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.CertStatus=function(a){KJUR.asn1.ocsp.CertStatus.superclass.constructor.call(this);this.params=null;this.tohex=function(){var d=this.params;if(d.status=="good"){return"8000"}if(d.status=="unknown"){return"8200"}if(d.status=="revoked"){var c=[{gentime:{str:d.time}}];if(d.reason!=undefined){c.push({tag:{tag:"a0",explicit:true,obj:{"enum":{"int":d.reason}}}})}var b={tag:"a1",explicit:false,obj:{seq:c}};return KJUR.asn1.ASN1Util.newObject({tag:b}).tohex()}throw new Error("bad status")};this.getEncodedHex=function(){return this.tohex()};this.setByParam=function(b){this.params=b};if(a!==undefined){this.setByParam(a)}};extendClass(KJUR.asn1.ocsp.CertStatus,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.Request=function(f){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.Request.superclass.constructor.call(this);this.dReqCert=null;this.dExt=null;this.tohex=function(){var g=[];if(this.dReqCert===null){throw"reqCert not set"}g.push(this.dReqCert);var h=new a({array:g});this.hTLV=h.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(typeof f!=="undefined"){var e=new d.CertID(f);this.dReqCert=e}};extendClass(KJUR.asn1.ocsp.Request,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.TBSRequest=function(e){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.TBSRequest.superclass.constructor.call(this);this.version=0;this.dRequestorName=null;this.dRequestList=[];this.dRequestExt=null;this.setRequestListByParam=function(h){var f=[];for(var g=0;g<h.length;g++){var j=new d.Request(h[0]);f.push(j)}this.dRequestList=f};this.tohex=function(){var f=[];if(this.version!==0){throw"not supported version: "+this.version}if(this.dRequestorName!==null){throw"requestorName not supported"}var h=new a({array:this.dRequestList});f.push(h);if(this.dRequestExt!==null){throw"requestExtensions not supported"}var g=new a({array:f});this.hTLV=g.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(e!==undefined){if(e.reqList!==undefined){this.setRequestListByParam(e.reqList)}}};extendClass(KJUR.asn1.ocsp.TBSRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPRequest=function(f){var c=KJUR,b=c.asn1,a=b.DERSequence,d=b.ocsp;d.OCSPRequest.superclass.constructor.call(this);this.dTbsRequest=null;this.dOptionalSignature=null;this.tohex=function(){var g=[];if(this.dTbsRequest!==null){g.push(this.dTbsRequest)}else{throw"tbsRequest not set"}if(this.dOptionalSignature!==null){throw"optionalSignature not supported"}var h=new a({array:g});this.hTLV=h.tohex();return this.hTLV};this.getEncodedHex=function(){return this.tohex()};if(f!==undefined){if(f.reqList!==undefined){var e=new d.TBSRequest(f);this.dTbsRequest=e}}};extendClass(KJUR.asn1.ocsp.OCSPRequest,KJUR.asn1.ASN1Object);KJUR.asn1.ocsp.OCSPUtil={};KJUR.asn1.ocsp.OCSPUtil.getRequestHex=function(a,b,h){var d=KJUR,c=d.asn1,e=c.ocsp;if(h===undefined){h=e.DEFAULT_HASH}var g={alg:h,issuerCert:a,subjectCert:b};var f=new e.OCSPRequest({reqList:[g]});return f.tohex()};KJUR.asn1.ocsp.OCSPUtil.getOCSPResponseInfo=function(b){var m=ASN1HEX,c=m.getVbyList,k=m.getVbyListEx,e=m.getIdxbyList,d=m.getIdxbyListEx,g=m.getV;var n={};try{var j=k(b,0,[0],"0a");n.responseStatus=parseInt(j,16)}catch(f){}if(n.responseStatus!==0){return n}try{var i=e(b,0,[1,0,1,0,0,2,0,1]);if(b.substr(i,2)==="80"){n.certStatus="good"}else{if(b.substr(i,2)==="a1"){n.certStatus="revoked";n.revocationTime=hextoutf8(c(b,i,[0]))}else{if(b.substr(i,2)==="82"){n.certStatus="unknown"}}}}catch(f){}try{var a=e(b,0,[1,0,1,0,0,2,0,2]);n.thisUpdate=hextoutf8(g(b,a))}catch(f){}try{var l=e(b,0,[1,0,1,0,0,2,0,3]);if(b.substr(l,2)==="a0"){n.nextUpdate=hextoutf8(c(b,l,[0]))}}catch(f){}return n};KJUR.asn1.ocsp.OCSPParser=function(){var g=Error,a=X509,h=new a(),l=ASN1HEX,i=l.getV,b=l.getTLV,f=l.getIdxbyList,e=l.getVbyList,c=l.getTLVbyList,k=l.getVbyListEx,d=l.getTLVbyListEx,j=l.getChildIdx;this.getOCSPRequest=function(o){var n=j(o,0);if(n.length!=1&&n.length!=2){throw new g("wrong number elements: "+n.length)}var m=this.getTBSRequest(b(o,n[0]));return m};this.getTBSRequest=function(o){var m={};var n=d(o,0,[0],"30");m.array=this.getRequestList(n);var p=d(o,0,["[2]",0],"30");if(p!=null){m.ext=h.getExtParamArray(p)}return m};this.getRequestList=function(p){var m=[];var n=j(p,0);for(var o=0;o<n.length;o++){var p=b(p,n[o]);m.push(this.getRequest(p))}return m};this.getRequest=function(n){var m=j(n,0);if(m.length!=1&&m.length!=2){throw new g("wrong number elements: "+m.length)}var p=this.getCertID(b(n,m[0]));if(m.length==2){var o=f(n,0,[1,0]);p.ext=h.getExtParamArray(b(n,o))}return p};this.getCertID=function(p){var o=j(p,0);if(o.length!=4){throw new g("wrong number elements: "+o.length)}var n=new a();var m={};m.alg=n.getAlgorithmIdentifierName(b(p,o[0]));m.issname=i(p,o[1]);m.isskey=i(p,o[2]);m.sbjsn=i(p,o[3]);return m};this.getOCSPResponse=function(r){var o=j(r,0);var m;var q=i(r,o[0]);var p=parseInt(q);if(o.length==1){return{resstatus:p}}var n=c(r,0,[1,0]);m=this.getResponseBytes(n);m.resstatus=p;return m};this.getResponseBytes=function(p){var o=j(p,0);var n;var q=c(p,0,[1,0]);n=this.getBasicOCSPResponse(q);var m=i(p,o[0]);n.restype=KJUR.asn1.x509.OID.oid2name(hextooid(m));return n};this.getBasicOCSPResponse=function(q){var t=j(q,0);var v;v=this.getResponseData(b(q,t[0]));var u=new X509();v.alg=u.getAlgorithmIdentifierName(b(q,t[1]));var n=i(q,t[2]);v.sighex=n.substr(2);var m=k(q,0,["[0]"]);if(m!=null){var r=j(m,0);var o=[];for(var p=0;p<r.length;p++){var s=b(m,r[p]);o.push(s)}v.certs=o}return v};this.getResponseData=function(q){var p=j(q,0);var r=p.length;var o={};var n=0;if(q.substr(p[0],2)=="a0"){n++}o.respid=this.getResponderID(b(q,p[n++]));var t=i(q,p[n++]);o.prodat=hextoutf8(t);o.array=this.getSingleResponseList(b(q,p[n++]));if(q.substr(p[r-1],2)=="a1"){var s=c(q,p[r-1],[0]);var m=new X509();o.ext=m.getExtParamArray(s)}return o};this.getResponderID=function(o){var n={};if(o.substr(0,2)=="a2"){var p=e(o,0,[0]);n.key=p}if(o.substr(0,2)=="a1"){var q=c(o,0,[0]);var m=new X509();n.name=m.getX500Name(q)}return n};this.getSingleResponseList=function(q){var n=j(q,0);var m=[];for(var o=0;o<n.length;o++){var r=this.getSingleResponse(b(q,n[o]));m.push(r)}return m};this.getSingleResponse=function(p){var t=j(p,0);var v={};var r=this.getCertID(b(p,t[0]));v.certid=r;var u=this.getCertStatus(b(p,t[1]));v.status=u;if(p.substr(t[2],2)=="18"){var q=i(p,t[2]);v.thisupdate=hextoutf8(q)}for(var o=3;o<t.length;o++){if(p.substr(t[o],2)=="a0"){var m=e(p,t[o],[0],"18");v.nextupdate=hextoutf8(m)}if(p.substr(t[o],2)=="a1"){var s=new X509();var n=c(p,0,[o,0]);v.ext=s.getExtParamArray(n)}}return v};this.getCertStatus=function(p){var m={};if(p=="8000"){return{status:"good"}}if(p=="8200"){return{status:"unknown"}}if(p.substr(0,2)=="a1"){m.status="revoked";var o=e(p,0,[0]);var n=hextoutf8(o);m.time=n}return m}};
var KJUR;if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.lang=="undefined"||!KJUR.lang){KJUR.lang={}}KJUR.lang.String=function(){};function Base64x(){}function stoBA(d){var b=new Array();for(var c=0;c<d.length;c++){b[c]=d.charCodeAt(c)}return b}function BAtos(b){var d="";for(var c=0;c<b.length;c++){d=d+String.fromCharCode(b[c])}return d}function BAtohex(b){var e="";for(var d=0;d<b.length;d++){var c=b[d].toString(16);if(c.length==1){c="0"+c}e=e+c}return e}function stohex(a){return BAtohex(stoBA(a))}function stob64(a){return hex2b64(stohex(a))}function stob64u(a){return b64tob64u(hex2b64(stohex(a)))}function b64utos(a){return BAtos(b64toBA(b64utob64(a)))}function b64tob64u(a){a=a.replace(/\=/g,"");a=a.replace(/\+/g,"-");a=a.replace(/\//g,"_");return a}function b64utob64(a){if(a.length%4==2){a=a+"=="}else{if(a.length%4==3){a=a+"="}}a=a.replace(/-/g,"+");a=a.replace(/_/g,"/");return a}function hextob64u(a){if(a.length%2==1){a="0"+a}return b64tob64u(hex2b64(a))}function b64utohex(a){return b64tohex(b64utob64(a))}var utf8tob64u,b64utoutf8;if(typeof Buffer==="function"){utf8tob64u=function(a){return b64tob64u(Buffer.from(a,"utf8").toString("base64"))};b64utoutf8=function(a){return Buffer.from(b64utob64(a),"base64").toString("utf8")}}else{utf8tob64u=function(a){return hextob64u(uricmptohex(encodeURIComponentAll(a)))};b64utoutf8=function(a){return decodeURIComponent(hextouricmp(b64utohex(a)))}}function utf8tob64(a){return hex2b64(uricmptohex(encodeURIComponentAll(a)))}function b64toutf8(a){return decodeURIComponent(hextouricmp(b64tohex(a)))}function utf8tohex(a){return uricmptohex(encodeURIComponentAll(a)).toLowerCase()}function hextoutf8(b){try{return decodeURIComponent(hextouricmp(b))}catch(a){return null}}function iso88591hextoutf8(a){return hextoutf8(iso88591hextoutf8hex(a))}function utf8toiso88591hex(a){return utf8hextoiso88591hex(utf8tohex(a))}function iso88591hextoutf8hex(e){var c=e.match(/.{1,2}/g);var b=[];for(var d=0;d<c.length;d++){var f=parseInt(c[d],16);if(161<=f&&f<=191){b.push("c2");b.push(c[d])}else{if(192<=f&&f<=255){b.push("c3");b.push((f-64).toString(16))}else{b.push(c[d])}}}return b.join("")}function utf8hextoiso88591hex(f){var c=f.match(/.{1,2}/g);var b=[];for(var e=0;e<c.length;e++){if(c[e]=="c2"){e++;b.push(c[e])}else{if(c[e]=="c3"){e++;var d=c[e];var g=parseInt(c[e],16)+64;b.push(g.toString(16))}else{b.push(c[e])}}}return b.join("")}function hextorstr(c){var b="";for(var a=0;a<c.length-1;a+=2){b+=String.fromCharCode(parseInt(c.substr(a,2),16))}return b}function rstrtohex(c){var a="";for(var b=0;b<c.length;b++){a+=("0"+c.charCodeAt(b).toString(16)).slice(-2)}return a}function hextob64(a){return hex2b64(a)}function hextob64nl(a){return foldnl(hextob64(a),64)}function foldnl(a,b){return a.replace(new RegExp("(.{"+b+"})","g"),"$1\r\n")}function b64nltohex(b){var a=b.replace(/[^0-9A-Za-z\/+=]*/g,"");var c=b64tohex(a);return c}function b64topem(b,a){return"-----BEGIN "+a+"-----\r\n"+foldnl(b,64)+"\r\n-----END "+a+"-----\r\n"}function hextopem(a,b){return"-----BEGIN "+b+"-----\r\n"+foldnl(hextob64(a),64)+"\r\n-----END "+b+"-----\r\n"}function pemtohex(a,b){if(a.indexOf("-----BEGIN ")==-1){throw new Error("can't find PEM header")}if(b!==undefined){a=a.replace(new RegExp("^[^]*-----BEGIN "+b+"-----"),"");a=a.replace(new RegExp("-----END "+b+"-----[^]*$"),"")}else{a=a.replace(/^[^]*-----BEGIN [^-]+-----/,"");a=a.replace(/-----END [^-]+-----[^]*$/,"")}return b64nltohex(a)}function pemtob64(a){if(a.indexOf("-----BEGIN ")==-1||a.indexOf("-----END ")==-1){return null}a=a.replace(/^[\s\S]*?-----BEGIN [^-]+-----/m,"");a=a.replace(/-----END [\s\S]+$/m,"");a=a.replace(/\s+/g,"");return(a.match(/^[0-9a-zA-Z+/=]+$/))?a:null}function hextoArrayBuffer(d){if(d.length%2!=0){throw"input is not even length"}if(d.match(/^[0-9A-Fa-f]+$/)==null){throw"input is not hexadecimal"}var b=new ArrayBuffer(d.length/2);var a=new DataView(b);for(var c=0;c<d.length/2;c++){a.setUint8(c,parseInt(d.substr(c*2,2),16))}return b}function ArrayBuffertohex(b){var d="";var a=new DataView(b);for(var c=0;c<b.byteLength;c++){d+=("00"+a.getUint8(c).toString(16)).slice(-2)}return d}function zulutomsec(n){var l,j,m,e,f,i,b,k;var a,h,g,c;n=timetogen(n);c=n.match(/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/);if(c){l=parseInt(c[1]);j=parseInt(c[2])-1;m=parseInt(c[3]);e=parseInt(c[4]);f=parseInt(c[5]);i=parseInt(c[6]);b=0;h=c[7];if(h!==""){g=(h.substr(1)+"00").substr(0,3);b=parseInt(g)}return Date.UTC(l,j,m,e,f,i,b)}throw new Error("unsupported zulu format: "+n)}function msectozulu(b){var h=new Date(b),i=("0000"+h.getUTCFullYear()).slice(-4),c=("00"+(h.getUTCMonth()+1)).slice(-2),j=("00"+h.getUTCDate()).slice(-2),e=("00"+h.getUTCHours()).slice(-2),f=("00"+h.getUTCMinutes()).slice(-2),g=("00"+h.getUTCSeconds()).slice(-2),a=("000"+h.getUTCMilliseconds()).slice(-3);a=a.replace(/0+$/,"");a=(a!="")?"."+a:a;return i+c+j+e+f+g+a+"Z"}function zulutosec(a){return Math.round(zulutomsec(a)/1000)}function zulutodate(a){return new Date(zulutomsec(a))}function datetozulu(g,e,f){var b;var a=g.getUTCFullYear();if(e){if(a<1950||2049<a){throw"not proper year for UTCTime: "+a}b=(""+a).slice(-2)}else{b=("000"+a).slice(-4)}b+=("0"+(g.getUTCMonth()+1)).slice(-2);b+=("0"+g.getUTCDate()).slice(-2);b+=("0"+g.getUTCHours()).slice(-2);b+=("0"+g.getUTCMinutes()).slice(-2);b+=("0"+g.getUTCSeconds()).slice(-2);if(f){var c=g.getUTCMilliseconds();if(c!==0){c=("00"+c).slice(-3);c=c.replace(/0+$/g,"");b+="."+c}}b+="Z";return b}function timetogen(a){if(a.match(/^[0-9]{12}Z$/)||a.match(/^[0-9]{12}[.][0-9]*Z$/)){return(a.match(/^[0-4]/))?"20"+a:"19"+a}return a}function uricmptohex(a){return a.replace(/%/g,"")}function hextouricmp(a){return a.replace(/(..)/g,"%$1")}function ipv6tohex(g){var b="malformed IPv6 address";if(!g.match(/^[0-9A-Fa-f:]+$/)){throw b}g=g.toLowerCase();var d=g.split(":").length-1;if(d<2){throw b}var e=":".repeat(7-d+2);g=g.replace("::",e);var c=g.split(":");if(c.length!=8){throw b}for(var f=0;f<8;f++){c[f]=("0000"+c[f]).slice(-4)}return c.join("")}function hextoipv6(d){if(!d.match(/^[0-9A-Fa-f]{32}$/)){throw new Error("malformed IPv6 address: "+d)}d=d.toLowerCase();var b=d.match(/.{1,4}/g);b=b.map(function(a){return a.replace(/^0+/,"")});b=b.map(function(a){return a==""?"0":a});d=":"+b.join(":")+":";var c=d.match(/:(0:){2,}/g);if(c==null){return d.slice(1,-1)}var e=c.sort().slice(-1)[0];d=d.replace(e.substr(0,e.length-1),":");if(d.substr(0,2)!="::"){d=d.substr(1)}if(d.substr(-2,2)!="::"){d=d.substr(0,d.length-1)}return d}function hextoip(b){var c=new Error("malformed hex value");if(!b.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/)){throw c}if(b.length==8){var d;try{d=parseInt(b.substr(0,2),16)+"."+parseInt(b.substr(2,2),16)+"."+parseInt(b.substr(4,2),16)+"."+parseInt(b.substr(6,2),16);return d}catch(a){throw c}}else{if(b.length==16){try{return hextoip(b.substr(0,8))+"/"+ipprefixlen(b.substr(8))}catch(a){throw c}}else{if(b.length==32){return hextoipv6(b)}else{if(b.length==64){try{return hextoipv6(b.substr(0,32))+"/"+ipprefixlen(b.substr(32))}catch(a){throw c}return}else{return b}}}}}function ipprefixlen(c){var d=new Error("malformed mask");var a;try{a=new BigInteger(c,16).toString(2)}catch(b){throw d}if(!a.match(/^1*0*$/)){throw d}return a.replace(/0+$/,"").length}function iptohex(g){var j=new Error("malformed IP address");g=g.toLowerCase(g);if(!g.match(/^[0-9a-f.:/]+$/)){throw j}if(g.match(/^[0-9.]+$/)){var b=g.split(".");if(b.length!==4){throw j}var h="";try{for(var f=0;f<4;f++){var k=parseInt(b[f]);h+=("0"+k.toString(16)).slice(-2)}return h}catch(e){throw j}}else{if(g.match(/^[0-9.]+\/[0-9]+$/)){var c=g.split("/");return iptohex(c[0])+ipnetmask(parseInt(c[1]),32)}else{if(g.match(/^[0-9a-f:]+$/)&&g.indexOf(":")!==-1){return ipv6tohex(g)}else{if(g.match(/^[0-9a-f:]+\/[0-9]+$/)&&g.indexOf(":")!==-1){var c=g.split("/");return ipv6tohex(c[0])+ipnetmask(parseInt(c[1]),128)}else{throw j}}}}}function ipnetmask(d,c){if(c==32&&d==0){return"00000000"}if(c==128&&d==0){return"00000000000000000000000000000000"}var a=Array(d+1).join("1")+Array(c-d+1).join("0");return new BigInteger(a,2).toString(16)}function ucs2hextoutf8(d){function e(f){var h=parseInt(f.substr(0,2),16);var a=parseInt(f.substr(2),16);if(h==0&a<128){return String.fromCharCode(a)}if(h<8){var j=192|((h&7)<<3)|((a&192)>>6);var i=128|(a&63);return hextoutf8(j.toString(16)+i.toString(16))}var j=224|((h&240)>>4);var i=128|((h&15)<<2)|((a&192)>>6);var g=128|(a&63);return hextoutf8(j.toString(16)+i.toString(16)+g.toString(16))}var c=d.match(/.{4}/g);var b=c.map(e);return b.join("")}function encodeURIComponentAll(a){var d=encodeURIComponent(a);var b="";for(var c=0;c<d.length;c++){if(d[c]=="%"){b=b+d.substr(c,3);c=c+2}else{b=b+"%"+stohex(d[c])}}return b}function newline_toUnix(a){a=a.replace(/\r\n/mg,"\n");return a}function newline_toDos(a){a=a.replace(/\r\n/mg,"\n");a=a.replace(/\n/mg,"\r\n");return a}KJUR.lang.String.isInteger=function(a){if(a.match(/^[0-9]+$/)){return true}else{if(a.match(/^-[0-9]+$/)){return true}else{return false}}};KJUR.lang.String.isHex=function(a){return ishex(a)};function ishex(a){if(a.length%2==0&&(a.match(/^[0-9a-f]+$/)||a.match(/^[0-9A-F]+$/))){return true}else{return false}}KJUR.lang.String.isBase64=function(a){a=a.replace(/\s+/g,"");if(a.match(/^[0-9A-Za-z+\/]+={0,3}$/)&&a.length%4==0){return true}else{return false}};KJUR.lang.String.isBase64URL=function(a){if(a.match(/[+/=]/)){return false}a=b64utob64(a);return KJUR.lang.String.isBase64(a)};function isBase64URLDot(a){if(a.match(/^[0-9A-Za-z-_.]+$/)){return true}return false}KJUR.lang.String.isIntegerArray=function(a){a=a.replace(/\s+/g,"");if(a.match(/^\[[0-9,]+\]$/)){return true}else{return false}};KJUR.lang.String.isPrintable=function(a){if(a.match(/^[0-9A-Za-z '()+,-./:=?]*$/)!==null){return true}return false};KJUR.lang.String.isIA5=function(a){if(a.match(/^[\x20-\x21\x23-\x7f]*$/)!==null){return true}return false};KJUR.lang.String.isMail=function(a){if(a.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/)!==null){return true}return false};function hextoposhex(a){if(a.length%2==1){return"0"+a}if(a.substr(0,1)>"7"){return"00"+a}return a}function intarystrtohex(b){b=b.replace(/^\s*\[\s*/,"");b=b.replace(/\s*\]\s*$/,"");b=b.replace(/\s*/g,"");try{var c=b.split(/,/).map(function(g,e,h){var f=parseInt(g);if(f<0||255<f){throw"integer not in range 0-255"}var d=("00"+f.toString(16)).slice(-2);return d}).join("");return c}catch(a){throw"malformed integer array string: "+a}}var strdiffidx=function(c,a){var d=c.length;if(c.length>a.length){d=a.length}for(var b=0;b<d;b++){if(c.charCodeAt(b)!=a.charCodeAt(b)){return b}}if(c.length!=a.length){return d}return -1};function oidtohex(g){var f=function(a){var l=a.toString(16);if(l.length==1){l="0"+l}return l};var e=function(p){var o="";var l=parseInt(p,10);var a=l.toString(2);var m=7-a.length%7;if(m==7){m=0}var r="";for(var n=0;n<m;n++){r+="0"}a=r+a;for(var n=0;n<a.length-1;n+=7){var q=a.substr(n,7);if(n!=a.length-7){q="1"+q}o+=f(parseInt(q,2))}return o};try{if(!g.match(/^[0-9.]+$/)){return null}var j="";var b=g.split(".");var k=parseInt(b[0],10)*40+parseInt(b[1],10);j+=f(k);b.splice(0,2);for(var d=0;d<b.length;d++){j+=e(b[d])}return j}catch(c){return null}}function hextooid(g){if(!ishex(g)){return null}try{var m=[];var p=g.substr(0,2);var e=parseInt(p,16);m[0]=new String(Math.floor(e/40));m[1]=new String(e%40);var n=g.substr(2);var l=[];for(var f=0;f<n.length/2;f++){l.push(parseInt(n.substr(f*2,2),16))}var k=[];var d="";for(var f=0;f<l.length;f++){if(l[f]&128){d=d+strpad((l[f]&127).toString(2),7)}else{d=d+strpad((l[f]&127).toString(2),7);k.push(new String(parseInt(d,2)));d=""}}var o=m.join(".");if(k.length>0){o=o+"."+k.join(".")}return o}catch(j){return null}}var strpad=function(c,b,a){if(a==undefined){a="0"}if(c.length>=b){return c}return new Array(b-c.length+1).join(a)+c};function bitstrtoint(e){if(e.length%2!=0){return -1}e=e.toLowerCase();if(e.match(/^[0-9a-f]+$/)==null){return -1}try{var a=e.substr(0,2);if(a=="00"){return parseInt(e.substr(2),16)}var b=parseInt(a,16);if(b>7){return -1}var g=e.substr(2);var d=parseInt(g,16).toString(2);if(d=="0"){d="00000000"}d=d.slice(0,0-b);var f=parseInt(d,2);if(f==NaN){return -1}return f}catch(c){return -1}}function inttobitstr(e){if(typeof e!="number"){return null}if(e<0){return null}var c=Number(e).toString(2);var b=8-c.length%8;if(b==8){b=0}c=c+strpad("",b,"0");var d=parseInt(c,2).toString(16);if(d.length%2==1){d="0"+d}var a="0"+b;return a+d}function bitstrtobinstr(g){if(typeof g!="string"){return null}if(g.length%2!=0){return null}if(!g.match(/^[0-9a-f]+$/)){return null}try{var c=parseInt(g.substr(0,2),16);if(c<0||7<c){return null}var j=g.substr(2);var f="";for(var e=0;e<j.length;e+=2){var b=j.substr(e,2);var a=parseInt(b,16).toString(2);a=("0000000"+a).slice(-8);f+=a}return f.substr(0,f.length-c)}catch(d){return null}}function binstrtobitstr(b){if(typeof b!="string"){return null}if(b.match(/^[01]+$/)==null){return null}try{var c=parseInt(b,2);return inttobitstr(c)}catch(a){return null}}function namearraytobinstr(e,g){var f=0;for(var a=0;a<e.length;a++){f|=1<<g[e[a]]}var b=f.toString(2);var c="";for(var a=b.length-1;a>=0;a--){c+=b[a]}return c}function aryval(e,c,d){if(typeof e!="object"){return undefined}var c=String(c).split(".");for(var b=0;b<c.length&&e;b++){var a=c[b];if(a.match(/^[0-9]+$/)){a=parseInt(a)}e=e[a]}return e||e===false?e:d}function extendClass(c,a){var b=function(){};b.prototype=a.prototype;c.prototype=new b();c.prototype.constructor=c;c.superclass=a.prototype;if(a.prototype.constructor==Object.prototype.constructor){a.prototype.constructor=a}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414",};this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHAwithRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa",};this.CRYPTOJSMESSAGEDIGESTNAME={md5:CryptoJS.algo.MD5,sha1:CryptoJS.algo.SHA1,sha224:CryptoJS.algo.SHA224,sha256:CryptoJS.algo.SHA256,sha384:CryptoJS.algo.SHA384,sha512:CryptoJS.algo.SHA512,ripemd160:CryptoJS.algo.RIPEMD160};this.getDigestInfoHex=function(a,b){if(typeof this.DIGESTINFOHEAD[b]=="undefined"){throw"alg not supported in Util.DIGESTINFOHEAD: "+b}return this.DIGESTINFOHEAD[b]+a};this.getPaddedDigestInfoHex=function(h,a,j){var c=this.getDigestInfoHex(h,a);var d=j/4;if(c.length+22>d){throw"key is too short for SigAlg: keylen="+j+","+a}var b="0001";var k="00"+c;var g="";var l=d-b.length-k.length;for(var f=0;f<l;f+=2){g+="ff"}var e=b+g+k;return e};this.hashString=function(a,c){var b=new KJUR.crypto.MessageDigest({alg:c});return b.digestString(a)};this.hashHex=function(b,c){var a=new KJUR.crypto.MessageDigest({alg:c});return a.digestHex(b)};this.sha1=function(a){return this.hashString(a,"sha1")};this.sha256=function(a){return this.hashString(a,"sha256")};this.sha256Hex=function(a){return this.hashHex(a,"sha256")};this.sha512=function(a){return this.hashString(a,"sha512")};this.sha512Hex=function(a){return this.hashHex(a,"sha512")};this.isKey=function(a){if(a instanceof RSAKey||a instanceof KJUR.crypto.DSA||a instanceof KJUR.crypto.ECDSA){return true}else{return false}}};KJUR.crypto.Util.md5=function(a){var b=new KJUR.crypto.MessageDigest({alg:"md5",prov:"cryptojs"});return b.digestString(a)};KJUR.crypto.Util.ripemd160=function(a){var b=new KJUR.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"});return b.digestString(a)};KJUR.crypto.Util.SECURERANDOMGEN=new SecureRandom();KJUR.crypto.Util.getRandomHexOfNbytes=function(b){var a=new Array(b);KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a);return BAtohex(a)};KJUR.crypto.Util.getRandomBigIntegerOfNbytes=function(a){return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a),16)};KJUR.crypto.Util.getRandomHexOfNbits=function(d){var c=d%8;var a=(d-c)/8;var b=new Array(a+1);KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b);b[0]=(((255<<c)&255)^255)&b[0];return BAtohex(b)};KJUR.crypto.Util.getRandomBigIntegerOfNbits=function(a){return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a),16)};KJUR.crypto.Util.getRandomBigIntegerZeroToMax=function(b){var a=b.bitLength();while(1){var c=KJUR.crypto.Util.getRandomBigIntegerOfNbits(a);if(b.compareTo(c)!=-1){return c}}};KJUR.crypto.Util.getRandomBigIntegerMinToMax=function(e,b){var c=e.compareTo(b);if(c==1){throw"biMin is greater than biMax"}if(c==0){return e}var a=b.subtract(e);var d=KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a);return d.add(e)};KJUR.crypto.MessageDigest=function(c){var b=null;var a=null;var d=null;this.setAlgAndProvider=function(g,f){g=KJUR.crypto.MessageDigest.getCanonicalAlgName(g);if(g!==null&&f===undefined){f=KJUR.crypto.Util.DEFAULTPROVIDER[g]}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&f=="cryptojs"){try{this.md=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(h){var i=CryptoJS.enc.Hex.parse(h);this.md.update(i)};this.digest=function(){var h=this.md.finalize();return h.toString(CryptoJS.enc.Hex)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}if(":sha256:".indexOf(g)!=-1&&f=="sjcl"){try{this.md=new sjcl.hash.sha256()}catch(e){throw"setAlgAndProvider hash alg set fail alg="+g+"/"+e}this.updateString=function(h){this.md.update(h)};this.updateHex=function(i){var h=sjcl.codec.hex.toBits(i);this.md.update(h)};this.digest=function(){var h=this.md.finalize();return sjcl.codec.hex.fromBits(h)};this.digestString=function(h){this.updateString(h);return this.digest()};this.digestHex=function(h){this.updateHex(h);return this.digest()}}};this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName};this.digestHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName};if(c!==undefined){if(c.alg!==undefined){this.algName=c.alg;if(c.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.MessageDigest.getCanonicalAlgName=function(a){if(typeof a==="string"){a=a.toLowerCase();a=a.replace(/-/,"")}return a};KJUR.crypto.MessageDigest.getHashLength=function(c){var b=KJUR.crypto.MessageDigest;var a=b.getCanonicalAlgName(c);if(b.HASHLENGTH[a]===undefined){throw"not supported algorithm: "+c}return b.HASHLENGTH[a]};KJUR.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20};KJUR.crypto.Mac=function(d){var f=null;var c=null;var a=null;var e=null;var b=null;this.setAlgAndProvider=function(k,i){k=k.toLowerCase();if(k==null){k="hmacsha1"}k=k.toLowerCase();if(k.substr(0,4)!="hmac"){throw"setAlgAndProvider unsupported HMAC alg: "+k}if(i===undefined){i=KJUR.crypto.Util.DEFAULTPROVIDER[k]}this.algProv=k+"/"+i;var g=k.substr(4);if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g)!=-1&&i=="cryptojs"){try{var j=KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g];this.mac=CryptoJS.algo.HMAC.create(j,this.pass)}catch(h){throw"setAlgAndProvider hash alg set fail hashAlg="+g+"/"+h}this.updateString=function(l){this.mac.update(l)};this.updateHex=function(l){var m=CryptoJS.enc.Hex.parse(l);this.mac.update(m)};this.doFinal=function(){var l=this.mac.finalize();return l.toString(CryptoJS.enc.Hex)};this.doFinalString=function(l){this.updateString(l);return this.doFinal()};this.doFinalHex=function(l){this.updateHex(l);return this.doFinal()}}};this.updateString=function(g){throw"updateString(str) not supported for this alg/prov: "+this.algProv};this.updateHex=function(g){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv};this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv};this.doFinalString=function(g){throw"digestString(str) not supported for this alg/prov: "+this.algProv};this.doFinalHex=function(g){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv};this.setPassword=function(h){if(typeof h=="string"){var g=h;if(h.length%2==1||!h.match(/^[0-9A-Fa-f]+$/)){g=rstrtohex(h)}this.pass=CryptoJS.enc.Hex.parse(g);return}if(typeof h!="object"){throw"KJUR.crypto.Mac unsupported password type: "+h}var g=null;if(h.hex!==undefined){if(h.hex.length%2!=0||!h.hex.match(/^[0-9A-Fa-f]+$/)){throw"Mac: wrong hex password: "+h.hex}g=h.hex}if(h.utf8!==undefined){g=utf8tohex(h.utf8)}if(h.rstr!==undefined){g=rstrtohex(h.rstr)}if(h.b64!==undefined){g=b64tohex(h.b64)}if(h.b64u!==undefined){g=b64utohex(h.b64u)}if(g==null){throw"KJUR.crypto.Mac unsupported password type: "+h}this.pass=CryptoJS.enc.Hex.parse(g)};if(d!==undefined){if(d.pass!==undefined){this.setPassword(d.pass)}if(d.alg!==undefined){this.algName=d.alg;if(d.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}this.setAlgAndProvider(this.algName,this.provName)}}};KJUR.crypto.Signature=function(o){var q=null;var n=null;var r=null;var c=null;var l=null;var d=null;var k=null;var h=null;var p=null;var e=null;var b=-1;var g=null;var j=null;var a=null;var i=null;var f=null;this._setAlgNames=function(){var s=this.algName.match(/^(.+)with(.+)$/);if(s){this.mdAlgName=s[1].toLowerCase();this.pubkeyAlgName=s[2].toLowerCase();if(this.pubkeyAlgName=="rsaandmgf1"&&this.mdAlgName=="sha"){this.mdAlgName="sha1"}}};this._zeroPaddingOfSignature=function(x,w){var v="";var t=w/4-x.length;for(var u=0;u<t;u++){v=v+"0"}return v+x};this.setAlgAndProvider=function(u,t){this._setAlgNames();if(t!="cryptojs/jsrsa"){throw new Error("provider not supported: "+t)}if(":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)!=-1){try{this.md=new KJUR.crypto.MessageDigest({alg:this.mdAlgName})}catch(s){throw new Error("setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+s)}this.init=function(w,x){var y=null;try{if(x===undefined){y=KEYUTIL.getKey(w)}else{y=KEYUTIL.getKey(w,x)}}catch(v){throw"init failed:"+v}if(y.isPrivate===true){this.prvKey=y;this.state="SIGN"}else{if(y.isPublic===true){this.pubKey=y;this.state="VERIFY"}else{throw"init failed.:"+y}}};this.updateString=function(v){this.md.updateString(v)};this.updateHex=function(v){this.md.updateHex(v)};this.sign=function(){this.sHashHex=this.md.digest();if(this.prvKey===undefined&&this.ecprvhex!==undefined&&this.eccurvename!==undefined&&KJUR.crypto.ECDSA!==undefined){this.prvKey=new KJUR.crypto.ECDSA({curve:this.eccurvename,prv:this.ecprvhex})}if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName==="rsaandmgf1"){this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen)}else{if(this.prvKey instanceof RSAKey&&this.pubkeyAlgName==="rsa"){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName)}else{if(this.prvKey instanceof KJUR.crypto.ECDSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{if(this.prvKey instanceof KJUR.crypto.DSA){this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}else{throw"Signature: unsupported private key alg: "+this.pubkeyAlgName}}}}return this.hSign};this.signString=function(v){this.updateString(v);return this.sign()};this.signHex=function(v){this.updateHex(v);return this.sign()};this.verify=function(v){this.sHashHex=this.md.digest();if(this.pubKey===undefined&&this.ecpubhex!==undefined&&this.eccurvename!==undefined&&KJUR.crypto.ECDSA!==undefined){this.pubKey=new KJUR.crypto.ECDSA({curve:this.eccurvename,pub:this.ecpubhex})}if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName==="rsaandmgf1"){return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,v,this.mdAlgName,this.pssSaltLen)}else{if(this.pubKey instanceof RSAKey&&this.pubkeyAlgName==="rsa"){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(KJUR.crypto.ECDSA!==undefined&&this.pubKey instanceof KJUR.crypto.ECDSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{if(KJUR.crypto.DSA!==undefined&&this.pubKey instanceof KJUR.crypto.DSA){return this.pubKey.verifyWithMessageHash(this.sHashHex,v)}else{throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}}}}}};this.init=function(s,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName};this.updateString=function(s){throw"updateString(str) not supported for this alg:prov="+this.algProvName};this.updateHex=function(s){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName};this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName};this.signString=function(s){throw"digestString(str) not supported for this alg:prov="+this.algProvName};this.signHex=function(s){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName};this.verify=function(s){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName};this.initParams=o;if(o!==undefined){if(o.alg!==undefined){this.algName=o.alg;if(o.prov===undefined){this.provName=KJUR.crypto.Util.DEFAULTPROVIDER[this.algName]}else{this.provName=o.prov}this.algProvName=this.algName+":"+this.provName;this.setAlgAndProvider(this.algName,this.provName);this._setAlgNames()}if(o.psssaltlen!==undefined){this.pssSaltLen=o.psssaltlen}if(o.prvkeypem!==undefined){if(o.prvkeypas!==undefined){throw"both prvkeypem and prvkeypas parameters not supported"}else{try{var q=KEYUTIL.getKey(o.prvkeypem);this.init(q)}catch(m){throw"fatal error to load pem private key: "+m}}}}};KJUR.crypto.Cipher=function(a){};KJUR.crypto.Cipher.encrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPublic){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.encrypt(e)}if(c==="RSAOAEP"){return f.encryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.encryptOAEP(e,"sha"+b[1])}throw"Cipher.encrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.encrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.decrypt=function(e,f,d){if(f instanceof RSAKey&&f.isPrivate){var c=KJUR.crypto.Cipher.getAlgByKeyAndName(f,d);if(c==="RSA"){return f.decrypt(e)}if(c==="RSAOAEP"){return f.decryptOAEP(e,"sha1")}var b=c.match(/^RSAOAEP(\d+)$/);if(b!==null){return f.decryptOAEP(e,"sha"+b[1])}throw"Cipher.decrypt: unsupported algorithm for RSAKey: "+d}else{throw"Cipher.decrypt: unsupported key or algorithm"}};KJUR.crypto.Cipher.getAlgByKeyAndName=function(b,a){if(b instanceof RSAKey){if(":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a)!=-1){return a}if(a===null||a===undefined){return"RSA"}throw"getAlgByKeyAndName: not supported algorithm name for RSAKey: "+a}throw"getAlgByKeyAndName: not supported algorithm name: "+a};KJUR.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040022":"secp384r1","2b81040023":"secp521r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA",}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.ECDSA=function(e){var g="secp256r1";var p=null;var b=null;var i=null;var j=Error,f=BigInteger,h=ECPointFp,m=KJUR.crypto.ECDSA,c=KJUR.crypto.ECParameterDB,d=m.getName,q=ASN1HEX,n=q.getVbyListEx,k=q.isASN1HEX;var a=new SecureRandom();var o=null;this.type="EC";this.isPrivate=false;this.isPublic=false;function l(x,t,w,s){var r=Math.max(t.bitLength(),s.bitLength());var y=x.add2D(w);var v=x.curve.getInfinity();for(var u=r-1;u>=0;--u){v=v.twice2D();v.z=f.ONE;if(t.testBit(u)){if(s.testBit(u)){v=v.add2D(y)}else{v=v.add2D(x)}}else{if(s.testBit(u)){v=v.add2D(w)}}}return v}this.getBigRandom=function(r){return new f(r.bitLength(),a).mod(r.subtract(f.ONE)).add(f.ONE)};this.setNamedCurve=function(r){this.ecparams=c.getByName(r);this.prvKeyHex=null;this.pubKeyHex=null;this.curveName=r};this.setPrivateKeyHex=function(r){this.isPrivate=true;this.prvKeyHex=r};this.setPublicKeyHex=function(r){this.isPublic=true;this.pubKeyHex=r};this.getPublicKeyXYHex=function(){var t=this.pubKeyHex;if(t.substr(0,2)!=="04"){throw"this method supports uncompressed format(04) only"}var s=this.ecparams.keycharlen;if(t.length!==2+s*2){throw"malformed public key hex length"}var r={};r.x=t.substr(2,s);r.y=t.substr(2+s);return r};this.getShortNISTPCurveName=function(){var r=this.curveName;if(r==="secp256r1"||r==="NIST P-256"||r==="P-256"||r==="prime256v1"){return"P-256"}if(r==="secp384r1"||r==="NIST P-384"||r==="P-384"){return"P-384"}if(r==="secp521r1"||r==="NIST P-521"||r==="P-521"){return"P-521"}return null};this.generateKeyPairHex=function(){var s=this.ecparams.n;var u=this.getBigRandom(s);var r=this.ecparams.keycharlen;var t=("0000000000"+u.toString(16)).slice(-r);this.setPrivateKeyHex(t);var v=this.generatePublicKeyHex();return{ecprvhex:t,ecpubhex:v}};this.generatePublicKeyHex=function(){var u=new f(this.prvKeyHex,16);var w=this.ecparams.G.multiply(u);var t=w.getX().toBigInteger();var s=w.getY().toBigInteger();var r=this.ecparams.keycharlen;var y=("0000000000"+t.toString(16)).slice(-r);var v=("0000000000"+s.toString(16)).slice(-r);var x="04"+y+v;this.setPublicKeyHex(x);return x};this.signWithMessageHash=function(r){return this.signHex(r,this.prvKeyHex)};this.signHex=function(x,u){var A=new f(u,16);var v=this.ecparams.n;var z=new f(x.substring(0,this.ecparams.keycharlen),16);do{var w=this.getBigRandom(v);var B=this.ecparams.G;var y=B.multiply(w);var t=y.getX().toBigInteger().mod(v)}while(t.compareTo(f.ZERO)<=0);var C=w.modInverse(v).multiply(z.add(A.multiply(t))).mod(v);return m.biRSSigToASN1Sig(t,C)};this.sign=function(w,B){var z=B;var u=this.ecparams.n;var y=f.fromByteArrayUnsigned(w);do{var v=this.getBigRandom(u);var A=this.ecparams.G;var x=A.multiply(v);var t=x.getX().toBigInteger().mod(u)}while(t.compareTo(BigInteger.ZERO)<=0);var C=v.modInverse(u).multiply(y.add(z.multiply(t))).mod(u);return this.serializeSig(t,C)};this.verifyWithMessageHash=function(s,r){return this.verifyHex(s,r,this.pubKeyHex)};this.verifyHex=function(v,y,u){try{var t,B;var w=m.parseSigHex(y);t=w.r;B=w.s;var x=h.decodeFromHex(this.ecparams.curve,u);var z=new f(v.substring(0,this.ecparams.keycharlen),16);return this.verifyRaw(z,t,B,x)}catch(A){return false}};this.verify=function(z,A,u){var w,t;if(Bitcoin.Util.isArray(A)){var y=this.parseSig(A);w=y.r;t=y.s}else{if("object"===typeof A&&A.r&&A.s){w=A.r;t=A.s}else{throw"Invalid value for signature"}}var v;if(u instanceof ECPointFp){v=u}else{if(Bitcoin.Util.isArray(u)){v=h.decodeFrom(this.ecparams.curve,u)}else{throw"Invalid format for pubkey value, must be byte array or ECPointFp"}}var x=f.fromByteArrayUnsigned(z);return this.verifyRaw(x,w,t,v)};this.verifyRaw=function(z,t,E,y){var x=this.ecparams.n;var D=this.ecparams.G;if(t.compareTo(f.ONE)<0||t.compareTo(x)>=0){return false}if(E.compareTo(f.ONE)<0||E.compareTo(x)>=0){return false}var A=E.modInverse(x);var w=z.multiply(A).mod(x);var u=t.multiply(A).mod(x);var B=D.multiply(w).add(y.multiply(u));var C=B.getX().toBigInteger().mod(x);return C.equals(t)};this.serializeSig=function(v,u){var w=v.toByteArraySigned();var t=u.toByteArraySigned();var x=[];x.push(2);x.push(w.length);x=x.concat(w);x.push(2);x.push(t.length);x=x.concat(t);x.unshift(x.length);x.unshift(48);return x};this.parseSig=function(y){var x;if(y[0]!=48){throw new Error("Signature not a valid DERSequence")}x=2;if(y[x]!=2){throw new Error("First element in signature must be a DERInteger")}var w=y.slice(x+2,x+2+y[x+1]);x+=2+y[x+1];if(y[x]!=2){throw new Error("Second element in signature must be a DERInteger")}var t=y.slice(x+2,x+2+y[x+1]);x+=2+y[x+1];var v=f.fromByteArrayUnsigned(w);var u=f.fromByteArrayUnsigned(t);return{r:v,s:u}};this.parseSigCompact=function(w){if(w.length!==65){throw"Signature has the wrong length"}var t=w[0]-27;if(t<0||t>7){throw"Invalid signature type"}var x=this.ecparams.n;var v=f.fromByteArrayUnsigned(w.slice(1,33)).mod(x);var u=f.fromByteArrayUnsigned(w.slice(33,65)).mod(x);return{r:v,s:u,i:t}};this.readPKCS5PrvKeyHex=function(u){if(k(u)===false){throw new Error("not ASN.1 hex string")}var r,t,v;try{r=n(u,0,["[0]",0],"06");t=n(u,0,[1],"04");try{v=n(u,0,["[1]",0],"03")}catch(s){}}catch(s){throw new Error("malformed PKCS#1/5 plain ECC private key")}this.curveName=d(r);if(this.curveName===undefined){throw"unsupported curve name"}this.setNamedCurve(this.curveName);this.setPublicKeyHex(v);this.setPrivateKeyHex(t);this.isPublic=false};this.readPKCS8PrvKeyHex=function(v){if(k(v)===false){throw new j("not ASN.1 hex string")}var t,r,u,w;try{t=n(v,0,[1,0],"06");r=n(v,0,[1,1],"06");u=n(v,0,[2,0,1],"04");try{w=n(v,0,[2,0,"[1]",0],"03")}catch(s){}}catch(s){throw new j("malformed PKCS#8 plain ECC private key")}this.curveName=d(r);if(this.curveName===undefined){throw new j("unsupported curve name")}this.setNamedCurve(this.curveName);this.setPublicKeyHex(w);this.setPrivateKeyHex(u);this.isPublic=false};this.readPKCS8PubKeyHex=function(u){if(k(u)===false){throw new j("not ASN.1 hex string")}var t,r,v;try{t=n(u,0,[0,0],"06");r=n(u,0,[0,1],"06");v=n(u,0,[1],"03")}catch(s){throw new j("malformed PKCS#8 ECC public key")}this.curveName=d(r);if(this.curveName===null){throw new j("unsupported curve name")}this.setNamedCurve(this.curveName);this.setPublicKeyHex(v)};this.readCertPubKeyHex=function(t,v){if(k(t)===false){throw new j("not ASN.1 hex string")}var r,u;try{r=n(t,0,[0,5,0,1],"06");u=n(t,0,[0,5,1],"03")}catch(s){throw new j("malformed X.509 certificate ECC public key")}this.curveName=d(r);if(this.curveName===null){throw new j("unsupported curve name")}this.setNamedCurve(this.curveName);this.setPublicKeyHex(u)};if(e!==undefined){if(e.curve!==undefined){this.curveName=e.curve}}if(this.curveName===undefined){this.curveName=g}this.setNamedCurve(this.curveName);if(e!==undefined){if(e.prv!==undefined){this.setPrivateKeyHex(e.prv)}if(e.pub!==undefined){this.setPublicKeyHex(e.pub)}}};KJUR.crypto.ECDSA.parseSigHex=function(a){var b=KJUR.crypto.ECDSA.parseSigHexInHexRS(a);var d=new BigInteger(b.r,16);var c=new BigInteger(b.s,16);return{r:d,s:c}};KJUR.crypto.ECDSA.parseSigHexInHexRS=function(f){var j=ASN1HEX,i=j.getChildIdx,g=j.getV;j.checkStrictDER(f,0);if(f.substr(0,2)!="30"){throw new Error("signature is not a ASN.1 sequence")}var h=i(f,0);if(h.length!=2){throw new Error("signature shall have two elements")}var e=h[0];var d=h[1];if(f.substr(e,2)!="02"){throw new Error("1st item not ASN.1 integer")}if(f.substr(d,2)!="02"){throw new Error("2nd item not ASN.1 integer")}var c=g(f,e);var b=g(f,d);return{r:c,s:b}};KJUR.crypto.ECDSA.asn1SigToConcatSig=function(d){var e=KJUR.crypto.ECDSA.parseSigHexInHexRS(d);var b=e.r;var a=e.s;if(b.length>=130&&b.length<=134){if(b.length%2!=0){throw Error("unknown ECDSA sig r length error")}if(a.length%2!=0){throw Error("unknown ECDSA sig s length error")}if(b.substr(0,2)=="00"){b=b.substr(2)}if(a.substr(0,2)=="00"){a=a.substr(2)}var c=Math.max(b.length,a.length);b=("000000"+b).slice(-c);a=("000000"+a).slice(-c);return b+a}if(b.substr(0,2)=="00"&&(b.length%32)==2){b=b.substr(2)}if(a.substr(0,2)=="00"&&(a.length%32)==2){a=a.substr(2)}if((b.length%32)==30){b="00"+b}if((a.length%32)==30){a="00"+a}if(b.length%32!=0){throw Error("unknown ECDSA sig r length error")}if(a.length%32!=0){throw Error("unknown ECDSA sig s length error")}return b+a};KJUR.crypto.ECDSA.concatSigToASN1Sig=function(a){if(a.length%4!=0){throw Error("unknown ECDSA concatinated r-s sig length error")}var c=a.substr(0,a.length/2);var b=a.substr(a.length/2);return KJUR.crypto.ECDSA.hexRSSigToASN1Sig(c,b)};KJUR.crypto.ECDSA.hexRSSigToASN1Sig=function(b,a){var d=new BigInteger(b,16);var c=new BigInteger(a,16);return KJUR.crypto.ECDSA.biRSSigToASN1Sig(d,c)};KJUR.crypto.ECDSA.biRSSigToASN1Sig=function(f,d){var c=KJUR.asn1;var b=new c.DERInteger({bigint:f});var a=new c.DERInteger({bigint:d});var e=new c.DERSequence({array:[b,a]});return e.tohex()};KJUR.crypto.ECDSA.getName=function(a){if(a==="2b8104001f"){return"secp192k1"}if(a==="2a8648ce3d030107"){return"secp256r1"}if(a==="2b8104000a"){return"secp256k1"}if(a==="2b81040021"){return"secp224r1"}if(a==="2b81040022"){return"secp384r1"}if(a==="2b81040023"){return"secp521r1"}if("|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(a)!==-1){return"secp256r1"}if("|secp256k1|".indexOf(a)!==-1){return"secp256k1"}if("|secp224r1|NIST P-224|P-224|".indexOf(a)!==-1){return"secp224r1"}if("|secp384r1|NIST P-384|P-384|".indexOf(a)!==-1){return"secp384r1"}if("|secp521r1|NIST P-521|P-521|".indexOf(a)!==-1){return"secp521r1"}return null};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.ECParameterDB=new function(){var b={};var c={};function a(d){return new BigInteger(d,16)}this.getByName=function(e){var d=e;if(typeof c[d]!="undefined"){d=c[e]}if(typeof b[d]!="undefined"){return b[d]}throw"unregistered EC curve name: "+d};this.regist=function(A,l,o,g,m,e,j,f,k,u,d,x){b[A]={};var s=a(o);var z=a(g);var y=a(m);var t=a(e);var w=a(j);var r=new ECCurveFp(s,z,y);var q=r.decodePointHex("04"+f+k);b[A]["name"]=A;b[A]["keylen"]=l;b[A]["keycharlen"]=Math.ceil(l/8)*2;b[A]["curve"]=r;b[A]["G"]=q;b[A]["n"]=t;b[A]["h"]=w;b[A]["oid"]=d;b[A]["info"]=x;for(var v=0;v<u.length;v++){c[u[v]]=A}}};KJUR.crypto.ECParameterDB.regist("secp128r1",128,"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC","E87579C11079F43DD824993C2CEE5ED3","FFFFFFFE0000000075A30D1B9038A115","1","161FF7528B899B2D0C28607CA52C5B86","CF5AC8395BAFEB13C02DA292DDED7A83",[],"","secp128r1 : SECG curve over a 128 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160k1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73","0","7","0100000000000000000001B8FA16DFAB9ACA16B6B3","1","3B4C382CE37AA192A4019E763036F4F5DD4D7EBB","938CF935318FDCED6BC28286531733C3F03C4FEE",[],"","secp160k1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp160r1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC","1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45","0100000000000000000001F4C8F927AED3CA752257","1","4A96B5688EF573284664698968C38BB913CBFC82","23A628553168947D59DCC912042351377AC5FB32",[],"","secp160r1 : SECG curve over a 160 bit prime field");KJUR.crypto.ECParameterDB.regist("secp192k1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37","0","3","FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D","1","DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D","9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D",[]);KJUR.crypto.ECParameterDB.regist("secp192r1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC","64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1","FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831","1","188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012","07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",[]);KJUR.crypto.ECParameterDB.regist("secp224r1",224,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE","B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4","FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D","1","B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21","BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",[]);KJUR.crypto.ECParameterDB.regist("secp256k1",256,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F","0","7","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141","1","79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798","483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",[]);KJUR.crypto.ECParameterDB.regist("secp256r1",256,"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC","5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B","FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551","1","6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296","4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",["NIST P-256","P-256","prime256v1"]);KJUR.crypto.ECParameterDB.regist("secp384r1",384,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC","B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973","1","AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7","3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f",["NIST P-384","P-384"]);KJUR.crypto.ECParameterDB.regist("secp521r1",521,"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC","051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409","1","00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66","011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650",["NIST P-521","P-521"]);
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.crypto=="undefined"||!KJUR.crypto){KJUR.crypto={}}KJUR.crypto.DSA=function(){var b=ASN1HEX,e=b.getVbyList,d=b.getVbyListEx,a=b.isASN1HEX,c=BigInteger;this.p=null;this.q=null;this.g=null;this.y=null;this.x=null;this.type="DSA";this.isPrivate=false;this.isPublic=false;this.setPrivate=function(j,i,h,k,f){this.isPrivate=true;this.p=j;this.q=i;this.g=h;this.y=k;this.x=f};this.setPrivateHex=function(i,g,k,n,o){var h,f,j,l,m;h=new BigInteger(i,16);f=new BigInteger(g,16);j=new BigInteger(k,16);if(typeof n==="string"&&n.length>1){l=new BigInteger(n,16)}else{l=null}m=new BigInteger(o,16);this.setPrivate(h,f,j,l,m)};this.setPublic=function(i,h,f,j){this.isPublic=true;this.p=i;this.q=h;this.g=f;this.y=j;this.x=null};this.setPublicHex=function(k,j,i,l){var g,f,m,h;g=new BigInteger(k,16);f=new BigInteger(j,16);m=new BigInteger(i,16);h=new BigInteger(l,16);this.setPublic(g,f,m,h)};this.signWithMessageHash=function(j){var i=this.p;var h=this.q;var m=this.g;var o=this.y;var t=this.x;var l=KJUR.crypto.Util.getRandomBigIntegerMinToMax(BigInteger.ONE.add(BigInteger.ONE),h.subtract(BigInteger.ONE));var u=j.substr(0,h.bitLength()/4);var n=new BigInteger(u,16);var f=(m.modPow(l,i)).mod(h);var w=(l.modInverse(h).multiply(n.add(t.multiply(f)))).mod(h);var v=KJUR.asn1.ASN1Util.jsonToASN1HEX({seq:[{"int":{bigint:f}},{"int":{bigint:w}}]});return v};this.verifyWithMessageHash=function(m,l){var j=this.p;var h=this.q;var o=this.g;var u=this.y;var n=this.parseASN1Signature(l);var f=n[0];var C=n[1];var B=m.substr(0,h.bitLength()/4);var t=new BigInteger(B,16);if(BigInteger.ZERO.compareTo(f)>0||f.compareTo(h)>0){throw"invalid DSA signature"}if(BigInteger.ZERO.compareTo(C)>=0||C.compareTo(h)>0){throw"invalid DSA signature"}var x=C.modInverse(h);var k=t.multiply(x).mod(h);var i=f.multiply(x).mod(h);var A=o.modPow(k,j).multiply(u.modPow(i,j)).mod(j).mod(h);return A.compareTo(f)==0};this.parseASN1Signature=function(f){try{var i=new c(d(f,0,[0],"02"),16);var h=new c(d(f,0,[1],"02"),16);return[i,h]}catch(g){throw new Error("malformed ASN.1 DSA signature")}};this.readPKCS5PrvKeyHex=function(j){var k,i,g,l,m;if(a(j)===false){throw new Error("not ASN.1 hex string")}try{k=d(j,0,[1],"02");i=d(j,0,[2],"02");g=d(j,0,[3],"02");l=d(j,0,[4],"02");m=d(j,0,[5],"02")}catch(f){throw new Error("malformed PKCS#1/5 plain DSA private key")}this.setPrivateHex(k,i,g,l,m)};this.readPKCS8PrvKeyHex=function(j){var k,i,g,l;if(a(j)===false){throw new Error("not ASN.1 hex string")}try{k=d(j,0,[1,1,0],"02");i=d(j,0,[1,1,1],"02");g=d(j,0,[1,1,2],"02");l=d(j,0,[2,0],"02")}catch(f){throw new Error("malformed PKCS#8 plain DSA private key")}this.setPrivateHex(k,i,g,null,l)};this.readPKCS8PubKeyHex=function(j){var k,i,g,l;if(a(j)===false){throw new Error("not ASN.1 hex string")}try{k=d(j,0,[0,1,0],"02");i=d(j,0,[0,1,1],"02");g=d(j,0,[0,1,2],"02");l=d(j,0,[1,0],"02")}catch(f){throw new Error("malformed PKCS#8 DSA public key")}this.setPublicHex(k,i,g,l)};this.readCertPubKeyHex=function(j,m){var k,i,g,l;if(a(j)===false){throw new Error("not ASN.1 hex string")}try{k=d(j,0,[0,5,0,1,0],"02");i=d(j,0,[0,5,0,1,1],"02");g=d(j,0,[0,5,0,1,2],"02");l=d(j,0,[0,5,1,0],"02")}catch(f){throw new Error("malformed X.509 certificate DSA public key")}this.setPublicHex(k,i,g,l)}};
var KEYUTIL=function(){var d=function(p,r,q){return k(CryptoJS.AES,p,r,q)};var e=function(p,r,q){return k(CryptoJS.TripleDES,p,r,q)};var a=function(p,r,q){return k(CryptoJS.DES,p,r,q)};var k=function(s,x,u,q){var r=CryptoJS.enc.Hex.parse(x);var w=CryptoJS.enc.Hex.parse(u);var p=CryptoJS.enc.Hex.parse(q);var t={};t.key=w;t.iv=p;t.ciphertext=r;var v=s.decrypt(t,w,{iv:p});return CryptoJS.enc.Hex.stringify(v)};var l=function(p,r,q){return g(CryptoJS.AES,p,r,q)};var o=function(p,r,q){return g(CryptoJS.TripleDES,p,r,q)};var f=function(p,r,q){return g(CryptoJS.DES,p,r,q)};var g=function(t,y,v,q){var s=CryptoJS.enc.Hex.parse(y);var x=CryptoJS.enc.Hex.parse(v);var p=CryptoJS.enc.Hex.parse(q);var w=t.encrypt(s,x,{iv:p});var r=CryptoJS.enc.Hex.parse(w.toString());var u=CryptoJS.enc.Base64.stringify(r);return u};var i={"AES-256-CBC":{proc:d,eproc:l,keylen:32,ivlen:16},"AES-192-CBC":{proc:d,eproc:l,keylen:24,ivlen:16},"AES-128-CBC":{proc:d,eproc:l,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:e,eproc:o,keylen:24,ivlen:8},"DES-CBC":{proc:a,eproc:f,keylen:8,ivlen:8}};var c=function(p){return i[p]["proc"]};var m=function(p){var r=CryptoJS.lib.WordArray.random(p);var q=CryptoJS.enc.Hex.stringify(r);return q};var n=function(v){var w={};var q=v.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));if(q){w.cipher=q[1];w.ivsalt=q[2]}var p=v.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));if(p){w.type=p[1]}var u=-1;var x=0;if(v.indexOf("\r\n\r\n")!=-1){u=v.indexOf("\r\n\r\n");x=2}if(v.indexOf("\n\n")!=-1){u=v.indexOf("\n\n");x=1}var t=v.indexOf("-----END");if(u!=-1&&t!=-1){var r=v.substring(u+x*2,t-x);r=r.replace(/\s+/g,"");w.data=r}return w};var j=function(q,y,p){var v=p.substring(0,16);var t=CryptoJS.enc.Hex.parse(v);var r=CryptoJS.enc.Utf8.parse(y);var u=i[q]["keylen"]+i[q]["ivlen"];var x="";var w=null;for(;;){var s=CryptoJS.algo.MD5.create();if(w!=null){s.update(w)}s.update(r);s.update(t);w=s.finalize();x=x+CryptoJS.enc.Hex.stringify(w);if(x.length>=u*2){break}}var z={};z.keyhex=x.substr(0,i[q]["keylen"]*2);z.ivhex=x.substr(i[q]["keylen"]*2,i[q]["ivlen"]*2);return z};var b=function(p,v,r,w){var s=CryptoJS.enc.Base64.parse(p);var q=CryptoJS.enc.Hex.stringify(s);var u=i[v]["proc"];var t=u(q,r,w);return t};var h=function(p,s,q,u){var r=i[s]["eproc"];var t=r(p,q,u);return t};return{version:"1.0.0",parsePKCS5PEM:function(p){return n(p)},getKeyAndUnusedIvByPasscodeAndIvsalt:function(q,p,r){return j(q,p,r)},decryptKeyB64:function(p,r,q,s){return b(p,r,q,s)},getDecryptedKeyHex:function(y,x){var q=n(y);var t=q.type;var r=q.cipher;var p=q.ivsalt;var s=q.data;var w=j(r,x,p);var v=w.keyhex;var u=b(s,r,v,p);return u},getEncryptedPKCS5PEMFromPrvKeyHex:function(x,s,A,t,r){var p="";if(typeof t=="undefined"||t==null){t="AES-256-CBC"}if(typeof i[t]=="undefined"){throw new Error("KEYUTIL unsupported algorithm: "+t)}if(typeof r=="undefined"||r==null){var v=i[t]["ivlen"];var u=m(v);r=u.toUpperCase()}var z=j(t,A,r);var y=z.keyhex;var w=h(s,t,y,r);var q=w.replace(/(.{64})/g,"$1\r\n");var p="-----BEGIN "+x+" PRIVATE KEY-----\r\n";p+="Proc-Type: 4,ENCRYPTED\r\n";p+="DEK-Info: "+t+","+r+"\r\n";p+="\r\n";p+=q;p+="\r\n-----END "+x+" PRIVATE KEY-----\r\n";return p},parseHexOfEncryptedPKCS8:function(y){var B=ASN1HEX;var z=B.getChildIdx;var w=B.getV;var t={};var r=z(y,0);if(r.length!=2){throw new Error("malformed format: SEQUENCE(0).items != 2: "+r.length)}t.ciphertext=w(y,r[1]);var A=z(y,r[0]);if(A.length!=2){throw new Error("malformed format: SEQUENCE(0.0).items != 2: "+A.length)}if(w(y,A[0])!="2a864886f70d01050d"){throw new Error("this only supports pkcs5PBES2")}var p=z(y,A[1]);if(A.length!=2){throw new Error("malformed format: SEQUENCE(0.0.1).items != 2: "+p.length)}var q=z(y,p[1]);if(q.length!=2){throw new Error("malformed format: SEQUENCE(0.0.1.1).items != 2: "+q.length)}if(w(y,q[0])!="2a864886f70d0307"){throw"this only supports TripleDES"}t.encryptionSchemeAlg="TripleDES";t.encryptionSchemeIV=w(y,q[1]);var s=z(y,p[0]);if(s.length!=2){throw new Error("malformed format: SEQUENCE(0.0.1.0).items != 2: "+s.length)}if(w(y,s[0])!="2a864886f70d01050c"){throw new Error("this only supports pkcs5PBKDF2")}var x=z(y,s[1]);if(x.length<2){throw new Error("malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+x.length)}t.pbkdf2Salt=w(y,x[0]);var u=w(y,x[1]);try{t.pbkdf2Iter=parseInt(u,16)}catch(v){throw new Error("malformed format pbkdf2Iter: "+u)}return t},getPBKDF2KeyHexFromParam:function(u,p){var t=CryptoJS.enc.Hex.parse(u.pbkdf2Salt);var q=u.pbkdf2Iter;var s=CryptoJS.PBKDF2(p,t,{keySize:192/32,iterations:q});var r=CryptoJS.enc.Hex.stringify(s);return r},_getPlainPKCS8HexFromEncryptedPKCS8PEM:function(x,y){var r=pemtohex(x,"ENCRYPTED PRIVATE KEY");var p=this.parseHexOfEncryptedPKCS8(r);var u=KEYUTIL.getPBKDF2KeyHexFromParam(p,y);var v={};v.ciphertext=CryptoJS.enc.Hex.parse(p.ciphertext);var t=CryptoJS.enc.Hex.parse(u);var s=CryptoJS.enc.Hex.parse(p.encryptionSchemeIV);var w=CryptoJS.TripleDES.decrypt(v,t,{iv:s});var q=CryptoJS.enc.Hex.stringify(w);return q},getKeyFromEncryptedPKCS8PEM:function(s,q){var p=this._getPlainPKCS8HexFromEncryptedPKCS8PEM(s,q);var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},parsePlainPrivatePKCS8Hex:function(s){var v=ASN1HEX;var u=v.getChildIdx;var t=v.getV;var q={};q.algparam=null;if(s.substr(0,2)!="30"){throw new Error("malformed plain PKCS8 private key(code:001)")}var r=u(s,0);if(r.length<3){throw new Error("malformed plain PKCS8 private key(code:002)")}if(s.substr(r[1],2)!="30"){throw new Error("malformed PKCS8 private key(code:003)")}var p=u(s,r[1]);if(p.length!=2){throw new Error("malformed PKCS8 private key(code:004)")}if(s.substr(p[0],2)!="06"){throw new Error("malformed PKCS8 private key(code:005)")}q.algoid=t(s,p[0]);if(s.substr(p[1],2)=="06"){q.algparam=t(s,p[1])}if(s.substr(r[2],2)!="04"){throw new Error("malformed PKCS8 private key(code:006)")}q.keyidx=v.getVidx(s,r[2]);return q},getKeyFromPlainPrivatePKCS8PEM:function(q){var p=pemtohex(q,"PRIVATE KEY");var r=this.getKeyFromPlainPrivatePKCS8Hex(p);return r},getKeyFromPlainPrivatePKCS8Hex:function(p){var q=this.parsePlainPrivatePKCS8Hex(p);var r;if(q.algoid=="2a864886f70d010101"){r=new RSAKey()}else{if(q.algoid=="2a8648ce380401"){r=new KJUR.crypto.DSA()}else{if(q.algoid=="2a8648ce3d0201"){r=new KJUR.crypto.ECDSA()}else{throw new Error("unsupported private key algorithm")}}}r.readPKCS8PrvKeyHex(p);return r},_getKeyFromPublicPKCS8Hex:function(q){var p;var r=ASN1HEX.getVbyList(q,0,[0,0],"06");if(r==="2a864886f70d010101"){p=new RSAKey()}else{if(r==="2a8648ce380401"){p=new KJUR.crypto.DSA()}else{if(r==="2a8648ce3d0201"){p=new KJUR.crypto.ECDSA()}else{throw new Error("unsupported PKCS#8 public key hex")}}}p.readPKCS8PubKeyHex(q);return p},parsePublicRawRSAKeyHex:function(r){var u=ASN1HEX;var t=u.getChildIdx;var s=u.getV;var p={};if(r.substr(0,2)!="30"){throw new Error("malformed RSA key(code:001)")}var q=t(r,0);if(q.length!=2){throw new Error("malformed RSA key(code:002)")}if(r.substr(q[0],2)!="02"){throw new Error("malformed RSA key(code:003)")}p.n=s(r,q[0]);if(r.substr(q[1],2)!="02"){throw new Error("malformed RSA key(code:004)")}p.e=s(r,q[1]);return p},parsePublicPKCS8Hex:function(t){var v=ASN1HEX;var u=v.getChildIdx;var s=v.getV;var q={};q.algparam=null;var r=u(t,0);if(r.length!=2){throw new Error("outer DERSequence shall have 2 elements: "+r.length)}var w=r[0];if(t.substr(w,2)!="30"){throw new Error("malformed PKCS8 public key(code:001)")}var p=u(t,w);if(p.length!=2){throw new Error("malformed PKCS8 public key(code:002)")}if(t.substr(p[0],2)!="06"){throw new Error("malformed PKCS8 public key(code:003)")}q.algoid=s(t,p[0]);if(t.substr(p[1],2)=="06"){q.algparam=s(t,p[1])}else{if(t.substr(p[1],2)=="30"){q.algparam={};q.algparam.p=v.getVbyList(t,p[1],[0],"02");q.algparam.q=v.getVbyList(t,p[1],[1],"02");q.algparam.g=v.getVbyList(t,p[1],[2],"02")}}if(t.substr(r[1],2)!="03"){throw new Error("malformed PKCS8 public key(code:004)")}q.key=s(t,r[1]).substr(2);return q},}}();KEYUTIL.getKey=function(l,k,n){var G=ASN1HEX,L=G.getChildIdx,v=G.getV,d=G.getVbyList,c=KJUR.crypto,i=c.ECDSA,C=c.DSA,w=RSAKey,M=pemtohex,F=KEYUTIL;if(typeof w!="undefined"&&l instanceof w){return l}if(typeof i!="undefined"&&l instanceof i){return l}if(typeof C!="undefined"&&l instanceof C){return l}if(l.curve!==undefined&&l.xy!==undefined&&l.d===undefined){return new i({pub:l.xy,curve:l.curve})}if(l.curve!==undefined&&l.d!==undefined){return new i({prv:l.d,curve:l.curve})}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d===undefined){var P=new w();P.setPublic(l.n,l.e);return P}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p!==undefined&&l.q!==undefined&&l.dp!==undefined&&l.dq!==undefined&&l.co!==undefined&&l.qi===undefined){var P=new w();P.setPrivateEx(l.n,l.e,l.d,l.p,l.q,l.dp,l.dq,l.co);return P}if(l.kty===undefined&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p===undefined){var P=new w();P.setPrivate(l.n,l.e,l.d);return P}if(l.p!==undefined&&l.q!==undefined&&l.g!==undefined&&l.y!==undefined&&l.x===undefined){var P=new C();P.setPublic(l.p,l.q,l.g,l.y);return P}if(l.p!==undefined&&l.q!==undefined&&l.g!==undefined&&l.y!==undefined&&l.x!==undefined){var P=new C();P.setPrivate(l.p,l.q,l.g,l.y,l.x);return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d===undefined){var P=new w();P.setPublic(b64utohex(l.n),b64utohex(l.e));return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined&&l.p!==undefined&&l.q!==undefined&&l.dp!==undefined&&l.dq!==undefined&&l.qi!==undefined){var P=new w();P.setPrivateEx(b64utohex(l.n),b64utohex(l.e),b64utohex(l.d),b64utohex(l.p),b64utohex(l.q),b64utohex(l.dp),b64utohex(l.dq),b64utohex(l.qi));return P}if(l.kty==="RSA"&&l.n!==undefined&&l.e!==undefined&&l.d!==undefined){var P=new w();P.setPrivate(b64utohex(l.n),b64utohex(l.e),b64utohex(l.d));return P}if(l.kty==="EC"&&l.crv!==undefined&&l.x!==undefined&&l.y!==undefined&&l.d===undefined){var j=new i({curve:l.crv});var t=j.ecparams.keycharlen;var B=("0000000000"+b64utohex(l.x)).slice(-t);var z=("0000000000"+b64utohex(l.y)).slice(-t);var u="04"+B+z;j.setPublicKeyHex(u);return j}if(l.kty==="EC"&&l.crv!==undefined&&l.x!==undefined&&l.y!==undefined&&l.d!==undefined){var j=new i({curve:l.crv});var t=j.ecparams.keycharlen;var B=("0000000000"+b64utohex(l.x)).slice(-t);var z=("0000000000"+b64utohex(l.y)).slice(-t);var u="04"+B+z;var b=("0000000000"+b64utohex(l.d)).slice(-t);j.setPublicKeyHex(u);j.setPrivateKeyHex(b);return j}if(n==="pkcs5prv"){var J=l,G=ASN1HEX,N,P;N=L(J,0);if(N.length===9){P=new w();P.readPKCS5PrvKeyHex(J)}else{if(N.length===6){P=new C();P.readPKCS5PrvKeyHex(J)}else{if(N.length>2&&J.substr(N[1],2)==="04"){P=new i();P.readPKCS5PrvKeyHex(J)}else{throw new Error("unsupported PKCS#1/5 hexadecimal key")}}}return P}if(n==="pkcs8prv"){var P=F.getKeyFromPlainPrivatePKCS8Hex(l);return P}if(n==="pkcs8pub"){return F._getKeyFromPublicPKCS8Hex(l)}if(n==="x509pub"){return X509.getPublicKeyFromCertHex(l)}if(l.indexOf("-END CERTIFICATE-",0)!=-1||l.indexOf("-END X509 CERTIFICATE-",0)!=-1||l.indexOf("-END TRUSTED CERTIFICATE-",0)!=-1){return X509.getPublicKeyFromCertPEM(l)}if(l.indexOf("-END PUBLIC KEY-")!=-1){var O=pemtohex(l,"PUBLIC KEY");return F._getKeyFromPublicPKCS8Hex(O)}if(l.indexOf("-END RSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")==-1){var m=M(l,"RSA PRIVATE KEY");return F.getKey(m,null,"pkcs5prv")}if(l.indexOf("-END DSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")==-1){var I=M(l,"DSA PRIVATE KEY");var E=d(I,0,[1],"02");var D=d(I,0,[2],"02");var K=d(I,0,[3],"02");var r=d(I,0,[4],"02");var s=d(I,0,[5],"02");var P=new C();P.setPrivate(new BigInteger(E,16),new BigInteger(D,16),new BigInteger(K,16),new BigInteger(r,16),new BigInteger(s,16));return P}if(l.indexOf("-END EC PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")==-1){var m=M(l,"EC PRIVATE KEY");return F.getKey(m,null,"pkcs5prv")}if(l.indexOf("-END PRIVATE KEY-")!=-1){return F.getKeyFromPlainPrivatePKCS8PEM(l)}if(l.indexOf("-END RSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var o=F.getDecryptedKeyHex(l,k);var H=new RSAKey();H.readPKCS5PrvKeyHex(o);return H}if(l.indexOf("-END EC PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var I=F.getDecryptedKeyHex(l,k);var P=d(I,0,[1],"04");var f=d(I,0,[2,0],"06");var A=d(I,0,[3,0],"03").substr(2);var e="";if(KJUR.crypto.OID.oidhex2name[f]!==undefined){e=KJUR.crypto.OID.oidhex2name[f]}else{throw new Error("undefined OID(hex) in KJUR.crypto.OID: "+f)}var j=new i({curve:e});j.setPublicKeyHex(A);j.setPrivateKeyHex(P);j.isPublic=false;return j}if(l.indexOf("-END DSA PRIVATE KEY-")!=-1&&l.indexOf("4,ENCRYPTED")!=-1){var I=F.getDecryptedKeyHex(l,k);var E=d(I,0,[1],"02");var D=d(I,0,[2],"02");var K=d(I,0,[3],"02");var r=d(I,0,[4],"02");var s=d(I,0,[5],"02");var P=new C();P.setPrivate(new BigInteger(E,16),new BigInteger(D,16),new BigInteger(K,16),new BigInteger(r,16),new BigInteger(s,16));return P}if(l.indexOf("-END ENCRYPTED PRIVATE KEY-")!=-1){return F.getKeyFromEncryptedPKCS8PEM(l,k)}throw new Error("not supported argument")};KEYUTIL.generateKeypair=function(a,c){if(a=="RSA"){var b=c;var h=new RSAKey();h.generate(b,"10001");h.isPrivate=true;h.isPublic=true;var f=new RSAKey();var e=h.n.toString(16);var i=h.e.toString(16);f.setPublic(e,i);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{if(a=="EC"){var d=c;var g=new KJUR.crypto.ECDSA({curve:d});var j=g.generateKeyPairHex();var h=new KJUR.crypto.ECDSA({curve:d});h.setPublicKeyHex(j.ecpubhex);h.setPrivateKeyHex(j.ecprvhex);h.isPrivate=true;h.isPublic=false;var f=new KJUR.crypto.ECDSA({curve:d});f.setPublicKeyHex(j.ecpubhex);f.isPrivate=false;f.isPublic=true;var k={};k.prvKeyObj=h;k.pubKeyObj=f;return k}else{throw new Error("unknown algorithm: "+a)}}};KEYUTIL.getPEM=function(b,D,y,m,q,j){var F=KJUR,k=F.asn1,z=k.DERObjectIdentifier,f=k.DERInteger,l=k.ASN1Util.newObject,a=k.x509,C=a.SubjectPublicKeyInfo,e=F.crypto,u=e.DSA,r=e.ECDSA,n=RSAKey;function A(s){var H=l({seq:[{"int":0},{"int":{bigint:s.n}},{"int":s.e},{"int":{bigint:s.d}},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.dmp1}},{"int":{bigint:s.dmq1}},{"int":{bigint:s.coeff}}]});return H}function B(H){var s=l({seq:[{"int":1},{octstr:{hex:H.prvKeyHex}},{tag:["a0",true,{oid:{name:H.curveName}}]},{tag:["a1",true,{bitstr:{hex:"00"+H.pubKeyHex}}]}]});return s}function x(s){var H=l({seq:[{"int":0},{"int":{bigint:s.p}},{"int":{bigint:s.q}},{"int":{bigint:s.g}},{"int":{bigint:s.y}},{"int":{bigint:s.x}}]});return H}if(((n!==undefined&&b instanceof n)||(u!==undefined&&b instanceof u)||(r!==undefined&&b instanceof r))&&b.isPublic==true&&(D===undefined||D=="PKCS8PUB")){var E=new C(b);var w=E.tohex();return hextopem(w,"PUBLIC KEY")}if(D=="PKCS1PRV"&&n!==undefined&&b instanceof n&&(y===undefined||y==null)&&b.isPrivate==true){var E=A(b);var w=E.tohex();return hextopem(w,"RSA PRIVATE KEY")}if(D=="PKCS1PRV"&&r!==undefined&&b instanceof r&&(y===undefined||y==null)&&b.isPrivate==true){var i=new z({name:b.curveName});var v=i.tohex();var h=B(b);var t=h.tohex();var p="";p+=hextopem(v,"EC PARAMETERS");p+=hextopem(t,"EC PRIVATE KEY");return p}if(D=="PKCS1PRV"&&u!==undefined&&b instanceof u&&(y===undefined||y==null)&&b.isPrivate==true){var E=x(b);var w=E.tohex();return hextopem(w,"DSA PRIVATE KEY")}if(D=="PKCS5PRV"&&n!==undefined&&b instanceof n&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=A(b);var w=E.tohex();if(m===undefined){m="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",w,y,m,j)}if(D=="PKCS5PRV"&&r!==undefined&&b instanceof r&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=B(b);var w=E.tohex();if(m===undefined){m="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("EC",w,y,m,j)}if(D=="PKCS5PRV"&&u!==undefined&&b instanceof u&&(y!==undefined&&y!=null)&&b.isPrivate==true){var E=x(b);var w=E.tohex();if(m===undefined){m="DES-EDE3-CBC"}return this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA",w,y,m,j)}var o=function(H,s){var J=c(H,s);var I=new l({seq:[{seq:[{oid:{name:"pkcs5PBES2"}},{seq:[{seq:[{oid:{name:"pkcs5PBKDF2"}},{seq:[{octstr:{hex:J.pbkdf2Salt}},{"int":J.pbkdf2Iter}]}]},{seq:[{oid:{name:"des-EDE3-CBC"}},{octstr:{hex:J.encryptionSchemeIV}}]}]}]},{octstr:{hex:J.ciphertext}}]});return I.tohex()};var c=function(O,P){var I=100;var N=CryptoJS.lib.WordArray.random(8);var M="DES-EDE3-CBC";var s=CryptoJS.lib.WordArray.random(8);var J=CryptoJS.PBKDF2(P,N,{keySize:192/32,iterations:I});var K=CryptoJS.enc.Hex.parse(O);var L=CryptoJS.TripleDES.encrypt(K,J,{iv:s})+"";var H={};H.ciphertext=L;H.pbkdf2Salt=CryptoJS.enc.Hex.stringify(N);H.pbkdf2Iter=I;H.encryptionSchemeAlg=M;H.encryptionSchemeIV=CryptoJS.enc.Hex.stringify(s);return H};if(D=="PKCS8PRV"&&n!=undefined&&b instanceof n&&b.isPrivate==true){var g=A(b);var d=g.tohex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"rsaEncryption"}},{"null":true}]},{octstr:{hex:d}}]});var w=E.tohex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}if(D=="PKCS8PRV"&&r!==undefined&&b instanceof r&&b.isPrivate==true){var G={seq:[{"int":1},{octstr:{hex:b.prvKeyHex}}]};if(typeof b.pubKeyHex=="string"){G.seq.push({tag:["a1",true,{bitstr:{hex:"00"+b.pubKeyHex}}]})}var g=new l(G);var d=g.tohex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"ecPublicKey"}},{oid:{name:b.curveName}}]},{octstr:{hex:d}}]});var w=E.tohex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}if(D=="PKCS8PRV"&&u!==undefined&&b instanceof u&&b.isPrivate==true){var g=new f({bigint:b.x});var d=g.tohex();var E=l({seq:[{"int":0},{seq:[{oid:{name:"dsa"}},{seq:[{"int":{bigint:b.p}},{"int":{bigint:b.q}},{"int":{bigint:b.g}}]}]},{octstr:{hex:d}}]});var w=E.tohex();if(y===undefined||y==null){return hextopem(w,"PRIVATE KEY")}else{var t=o(w,y);return hextopem(t,"ENCRYPTED PRIVATE KEY")}}throw new Error("unsupported object nor format")};KEYUTIL.getKeyFromCSRPEM=function(b){var a=pemtohex(b,"CERTIFICATE REQUEST");var c=KEYUTIL.getKeyFromCSRHex(a);return c};KEYUTIL.getKeyFromCSRHex=function(a){var c=KEYUTIL.parseCSRHex(a);var b=KEYUTIL.getKey(c.p8pubkeyhex,null,"pkcs8pub");return b};KEYUTIL.parseCSRHex=function(d){var i=ASN1HEX;var f=i.getChildIdx;var c=i.getTLV;var b={};var g=d;if(g.substr(0,2)!="30"){throw new Error("malformed CSR(code:001)")}var e=f(g,0);if(e.length<1){throw new Error("malformed CSR(code:002)")}if(g.substr(e[0],2)!="30"){throw new Error("malformed CSR(code:003)")}var a=f(g,e[0]);if(a.length<3){throw new Error("malformed CSR(code:004)")}b.p8pubkeyhex=c(g,a[2]);return b};KEYUTIL.getKeyID=function(f){var c=KEYUTIL;var e=ASN1HEX;if(typeof f==="string"&&f.indexOf("BEGIN ")!=-1){f=c.getKey(f)}var d=pemtohex(c.getPEM(f));var b=e.getIdxbyList(d,0,[1]);var a=e.getV(d,b).substring(2);return KJUR.crypto.Util.hashHex(a,"sha1")};KEYUTIL.getJWK=function(d,h,g,b,f){var i;var k={};var e;var c=KJUR.crypto.Util.hashHex;if(typeof d=="string"){i=KEYUTIL.getKey(d);if(d.indexOf("CERTIFICATE")!=-1){e=pemtohex(d)}}else{if(typeof d=="object"){if(d instanceof X509){i=d.getPublicKey();e=d.hex}else{i=d}}else{throw new Error("unsupported keyinfo type")}}if(i instanceof RSAKey&&i.isPrivate){k.kty="RSA";k.n=hextob64u(i.n.toString(16));k.e=hextob64u(i.e.toString(16));k.d=hextob64u(i.d.toString(16));k.p=hextob64u(i.p.toString(16));k.q=hextob64u(i.q.toString(16));k.dp=hextob64u(i.dmp1.toString(16));k.dq=hextob64u(i.dmq1.toString(16));k.qi=hextob64u(i.coeff.toString(16))}else{if(i instanceof RSAKey&&i.isPublic){k.kty="RSA";k.n=hextob64u(i.n.toString(16));k.e=hextob64u(i.e.toString(16))}else{if(i instanceof KJUR.crypto.ECDSA&&i.isPrivate){var a=i.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"&&a!=="P-521"){throw new Error("unsupported curve name for JWT: "+a)}var j=i.getPublicKeyXYHex();k.kty="EC";k.crv=a;k.x=hextob64u(j.x);k.y=hextob64u(j.y);k.d=hextob64u(i.prvKeyHex)}else{if(i instanceof KJUR.crypto.ECDSA&&i.isPublic){var a=i.getShortNISTPCurveName();if(a!=="P-256"&&a!=="P-384"&&a!=="P-521"){throw new Error("unsupported curve name for JWT: "+a)}var j=i.getPublicKeyXYHex();k.kty="EC";k.crv=a;k.x=hextob64u(j.x);k.y=hextob64u(j.y)}}}}if(k.kty==undefined){throw new Error("unsupported keyinfo")}if((!i.isPrivate)&&h!=true){k.kid=KJUR.jws.JWS.getJWKthumbprint(k)}if(e!=undefined&&g!=true){k.x5c=[hex2b64(e)]}if(e!=undefined&&b!=true){k.x5t=b64tob64u(hex2b64(c(e,"sha1")))}if(e!=undefined&&f!=true){k["x5t#S256"]=b64tob64u(hex2b64(c(e,"sha256")))}return k};KEYUTIL.getJWKFromKey=function(a){return KEYUTIL.getJWK(a,true,true,true,true)};
RSAKey.getPosArrayOfChildrenFromHex=function(a){return ASN1HEX.getChildIdx(a,0)};RSAKey.getHexValueArrayOfChildrenFromHex=function(f){var n=ASN1HEX;var i=n.getV;var k=RSAKey.getPosArrayOfChildrenFromHex(f);var e=i(f,k[0]);var j=i(f,k[1]);var b=i(f,k[2]);var c=i(f,k[3]);var h=i(f,k[4]);var g=i(f,k[5]);var m=i(f,k[6]);var l=i(f,k[7]);var d=i(f,k[8]);var k=new Array();k.push(e,j,b,c,h,g,m,l,d);return k};RSAKey.prototype.readPrivateKeyFromPEMString=function(d){var c=pemtohex(d);var b=RSAKey.getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])};RSAKey.prototype.readPKCS5PrvKeyHex=function(c){var b=RSAKey.getHexValueArrayOfChildrenFromHex(c);this.setPrivateEx(b[1],b[2],b[3],b[4],b[5],b[6],b[7],b[8])};RSAKey.prototype.readPKCS8PrvKeyHex=function(e){var c,i,k,b,a,f,d,j;var m=ASN1HEX;var l=m.getVbyListEx;if(m.isASN1HEX(e)===false){throw new Error("not ASN.1 hex string")}try{c=l(e,0,[2,0,1],"02");i=l(e,0,[2,0,2],"02");k=l(e,0,[2,0,3],"02");b=l(e,0,[2,0,4],"02");a=l(e,0,[2,0,5],"02");f=l(e,0,[2,0,6],"02");d=l(e,0,[2,0,7],"02");j=l(e,0,[2,0,8],"02")}catch(g){throw new Error("malformed PKCS#8 plain RSA private key")}this.setPrivateEx(c,i,k,b,a,f,d,j)};RSAKey.prototype.readPKCS5PubKeyHex=function(c){var e=ASN1HEX;var b=e.getV;if(e.isASN1HEX(c)===false){throw new Error("keyHex is not ASN.1 hex string")}var a=e.getChildIdx(c,0);if(a.length!==2||c.substr(a[0],2)!=="02"||c.substr(a[1],2)!=="02"){throw new Error("wrong hex for PKCS#5 public key")}var f=b(c,a[0]);var d=b(c,a[1]);this.setPublic(f,d)};RSAKey.prototype.readPKCS8PubKeyHex=function(b){var c=ASN1HEX;if(c.isASN1HEX(b)===false){throw new Error("not ASN.1 hex string")}if(c.getTLVbyListEx(b,0,[0,0])!=="06092a864886f70d010101"){throw new Error("not PKCS8 RSA public key")}var a=c.getTLVbyListEx(b,0,[1,0]);this.readPKCS5PubKeyHex(a)};RSAKey.prototype.readCertPubKeyHex=function(b,d){var a,c;a=new X509();a.readCertHex(b);c=a.getPublicKeyHex();this.readPKCS8PubKeyHex(c)};
var _RE_HEXDECONLY=new RegExp("[^0-9a-f]","gi");function _rsasign_getHexPaddedDigestInfoForString(d,e,a){var b=function(f){return KJUR.crypto.Util.hashString(f,a)};var c=b(d);return KJUR.crypto.Util.getPaddedDigestInfoHex(c,a,e)}function _zeroPaddingOfSignature(e,d){var c="";var a=d/4-e.length;for(var b=0;b<a;b++){c=c+"0"}return c+e}RSAKey.prototype.sign=function(d,a){var b=function(e){return KJUR.crypto.Util.hashString(e,a)};var c=b(d);return this.signWithMessageHash(c,a)};RSAKey.prototype.signWithMessageHash=function(e,c){var f=KJUR.crypto.Util.getPaddedDigestInfoHex(e,c,this.n.bitLength());var b=parseBigInt(f,16);var d=this.doPrivate(b);var a=d.toString(16);return _zeroPaddingOfSignature(a,this.n.bitLength())};function pss_mgf1_str(c,a,e){var b="",d=0;while(b.length<a){b+=hextorstr(e(rstrtohex(c+String.fromCharCode.apply(String,[(d&4278190080)>>24,(d&16711680)>>16,(d&65280)>>8,d&255]))));d+=1}return b}RSAKey.prototype.signPSS=function(e,a,d){var c=function(f){return KJUR.crypto.Util.hashHex(f,a)};var b=c(rstrtohex(e));if(d===undefined){d=-1}return this.signWithMessageHashPSS(b,a,d)};RSAKey.prototype.signWithMessageHashPSS=function(l,a,k){var b=hextorstr(l);var g=b.length;var m=this.n.bitLength()-1;var c=Math.ceil(m/8);var d;var o=function(i){return KJUR.crypto.Util.hashHex(i,a)};if(k===-1||k===undefined){k=g}else{if(k===-2){k=c-g-2}else{if(k<-2){throw new Error("invalid salt length")}}}if(c<(g+k+2)){throw new Error("data too long")}var f="";if(k>0){f=new Array(k);new SecureRandom().nextBytes(f);f=String.fromCharCode.apply(String,f)}var n=hextorstr(o(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+b+f)));var j=[];for(d=0;d<c-k-g-2;d+=1){j[d]=0}var e=String.fromCharCode.apply(String,j)+"\x01"+f;var h=pss_mgf1_str(n,e.length,o);var q=[];for(d=0;d<e.length;d+=1){q[d]=e.charCodeAt(d)^h.charCodeAt(d)}var p=(65280>>(8*c-m))&255;q[0]&=~p;for(d=0;d<g;d++){q.push(n.charCodeAt(d))}q.push(188);return _zeroPaddingOfSignature(this.doPrivate(new BigInteger(q)).toString(16),this.n.bitLength())};function _rsasign_getDecryptSignatureBI(a,d,c){var b=new RSAKey();b.setPublic(d,c);var e=b.doPublic(a);return e}function _rsasign_getHexDigestInfoFromSig(a,c,b){var e=_rsasign_getDecryptSignatureBI(a,c,b);var d=e.toString(16).replace(/^1f+00/,"");return d}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(f){for(var e in KJUR.crypto.Util.DIGESTINFOHEAD){var d=KJUR.crypto.Util.DIGESTINFOHEAD[e];var b=d.length;if(f.substring(0,b)==d){var c=[e,f.substring(b)];return c}}return[]}RSAKey.prototype.verify=function(f,l){l=l.toLowerCase();if(l.match(/^[0-9a-f]+$/)==null){return false}var b=parseBigInt(l,16);var k=this.n.bitLength();if(b.bitLength()>k){return false}var j=this.doPublic(b);var i=j.toString(16);if(i.length+3!=k/4){return false}var e=i.replace(/^1f+00/,"");var g=_rsasign_getAlgNameAndHashFromHexDisgestInfo(e);if(g.length==0){return false}var d=g[0];var h=g[1];var a=function(m){return KJUR.crypto.Util.hashString(m,d)};var c=a(f);return(h==c)};RSAKey.prototype.verifyWithMessageHash=function(e,a){if(a.length!=Math.ceil(this.n.bitLength()/4)){return false}var b=parseBigInt(a,16);if(b.bitLength()>this.n.bitLength()){return 0}var h=this.doPublic(b);var g=h.toString(16).replace(/^1f+00/,"");var c=_rsasign_getAlgNameAndHashFromHexDisgestInfo(g);if(c.length==0){return false}var d=c[0];var f=c[1];return(f==e)};RSAKey.prototype.verifyPSS=function(c,b,a,f){var e=function(g){return KJUR.crypto.Util.hashHex(g,a)};var d=e(rstrtohex(c));if(f===undefined){f=-1}return this.verifyWithMessageHashPSS(d,b,a,f)};RSAKey.prototype.verifyWithMessageHashPSS=function(f,s,l,c){if(s.length!=Math.ceil(this.n.bitLength()/4)){return false}var k=new BigInteger(s,16);var r=function(i){return KJUR.crypto.Util.hashHex(i,l)};var j=hextorstr(f);var h=j.length;var g=this.n.bitLength()-1;var m=Math.ceil(g/8);var q;if(c===-1||c===undefined){c=h}else{if(c===-2){c=m-h-2}else{if(c<-2){throw new Error("invalid salt length")}}}if(m<(h+c+2)){throw new Error("data too long")}var a=this.doPublic(k).toByteArray();for(q=0;q<a.length;q+=1){a[q]&=255}while(a.length<m){a.unshift(0)}if(a[m-1]!==188){throw new Error("encoded message does not end in 0xbc")}a=String.fromCharCode.apply(String,a);var d=a.substr(0,m-h-1);var e=a.substr(d.length,h);var p=(65280>>(8*m-g))&255;if((d.charCodeAt(0)&p)!==0){throw new Error("bits beyond keysize not zero")}var n=pss_mgf1_str(e,d.length,r);var o=[];for(q=0;q<d.length;q+=1){o[q]=d.charCodeAt(q)^n.charCodeAt(q)}o[0]&=~p;var b=m-h-c-2;for(q=0;q<b;q+=1){if(o[q]!==0){throw new Error("leftmost octets not zero")}}if(o[b]!==1){throw new Error("0x01 marker not found")}return e===hextorstr(r(rstrtohex("\x00\x00\x00\x00\x00\x00\x00\x00"+j+String.fromCharCode.apply(String,o.slice(-c)))))};RSAKey.SALT_LEN_HLEN=-1;RSAKey.SALT_LEN_MAX=-2;RSAKey.SALT_LEN_RECOVER=-2;
function X509(v){var o=ASN1HEX,s=o.getChildIdx,k=o.getV,y=o.dump,j=o.parse,b=o.getTLV,c=o.getVbyList,p=o.getVbyListEx,a=o.getTLVbyList,q=o.getTLVbyListEx,l=o.getIdxbyList,f=o.getIdxbyListEx,n=o.getVidx,x=o.getInt,u=o.oidname,r=o.hextooidstr,d=X509,w=pemtohex,g,m=Error;try{g=KJUR.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV}catch(t){}this.HEX2STAG={"0c":"utf8","13":"prn","16":"ia5","1a":"vis","1e":"bmp"};this.hex=null;this.version=0;this.foffset=0;this.aExtInfo=null;this.getVersion=function(){if(this.hex===null||this.version!==0){return this.version}var A=a(this.hex,0,[0,0]);if(A.substr(0,2)=="a0"){var B=a(A,0,[0]);var z=x(B,0);if(z<0||2<z){throw new Error("malformed version field")}this.version=z+1;return this.version}else{this.version=1;this.foffset=-1;return 1}};this.getSerialNumberHex=function(){return p(this.hex,0,[0,0],"02")};this.getSignatureAlgorithmField=function(){var z=q(this.hex,0,[0,1]);return this.getAlgorithmIdentifierName(z)};this.getAlgorithmIdentifierName=function(z){for(var A in g){if(z===g[A]){return A}}return u(p(z,0,[0],"06"))};this.getIssuer=function(A,z){return this.getX500Name(this.getIssuerHex(),A,z)};this.getIssuerHex=function(){return a(this.hex,0,[0,3+this.foffset],"30")};this.getIssuerString=function(){var z=this.getIssuer();return z.str};this.getSubject=function(A,z){return this.getX500Name(this.getSubjectHex(),A,z)};this.getSubjectHex=function(){return a(this.hex,0,[0,5+this.foffset],"30")};this.getSubjectString=function(){var z=this.getSubject();return z.str};this.getNotBefore=function(){var z=c(this.hex,0,[0,4+this.foffset,0]);z=z.replace(/(..)/g,"%$1");z=decodeURIComponent(z);return z};this.getNotAfter=function(){var z=c(this.hex,0,[0,4+this.foffset,1]);z=z.replace(/(..)/g,"%$1");z=decodeURIComponent(z);return z};this.getPublicKeyHex=function(){return this.getSPKI()};this.getSPKI=function(){return a(this.hex,0,[0,6+this.foffset],"30")};this.getSPKIValue=function(){var z=this.getSPKI();if(z==null){return null}return c(z,0,[1],"03",true)};this.getPublicKeyIdx=function(){return l(this.hex,0,[0,6+this.foffset],"30")};this.getPublicKeyContentIdx=function(){var z=this.getPublicKeyIdx();return l(this.hex,z,[1,0],"30")};this.getPublicKey=function(){return KEYUTIL.getKey(this.getPublicKeyHex(),null,"pkcs8pub")};this.getSignatureAlgorithmName=function(){var z=a(this.hex,0,[1],"30");return this.getAlgorithmIdentifierName(z)};this.getSignatureValueHex=function(){return c(this.hex,0,[2],"03",true)};this.verifySignature=function(B){var C=this.getSignatureAlgorithmField();var z=this.getSignatureValueHex();var A=a(this.hex,0,[0],"30");var D=new KJUR.crypto.Signature({alg:C});D.init(B);D.updateHex(A);return D.verify(z)};this.parseExt=function(I){var B,z,D;if(I===undefined){D=this.hex;if(this.version!==3){return -1}B=l(D,0,[0,7,0],"30");z=s(D,B)}else{D=pemtohex(I);var E=l(D,0,[0,3,0,0],"06");if(k(D,E)!="2a864886f70d01090e"){this.aExtInfo=new Array();return}B=l(D,0,[0,3,0,1,0],"30");z=s(D,B);this.hex=D}this.aExtInfo=new Array();for(var C=0;C<z.length;C++){var G={};G.critical=false;var F=s(D,z[C]);var A=0;if(F.length===3){G.critical=true;A=1}G.oid=o.hextooidstr(c(D,z[C],[0],"06"));var H=l(D,z[C],[1+A]);G.vidx=n(D,H);this.aExtInfo.push(G)}};this.getExtInfo=function(B){var z=this.aExtInfo;var C=B;if(!B.match(/^[0-9.]+$/)){C=KJUR.asn1.x509.OID.name2oid(B)}if(C===""){return undefined}for(var A=0;A<z.length;A++){if(z[A].oid===C){return z[A]}}return undefined};this.getCriticalExtV=function(C,z,B){if(z!=undefined){return[z,B]}var A=this.getExtInfo(C);if(A==undefined){return[null,null]}return[b(this.hex,A.vidx),A.critical]};this.getExtBasicConstraints=function(A,E){if(A===undefined&&E===undefined){var C=this.getExtInfo("basicConstraints");if(C===undefined){return undefined}A=b(this.hex,C.vidx);E=C.critical}var z={extname:"basicConstraints"};if(E){z.critical=true}if(A==="3000"){return z}if(A==="30030101ff"){z.cA=true;return z}if(A.substr(0,12)==="30060101ff02"){var D=k(A,10);var B=parseInt(D,16);z.cA=true;z.pathLen=B;return z}throw new Error("hExtV parse error: "+A)};this.getExtNameConstraints=function(I,G){var A=this.getCriticalExtV("nameConstraints",I,G);I=A[0];G=A[1];if(I==null){return undefined}var K={extname:"nameConstraints"};if(G){K.critical=true}var F=s(I,0);for(var D=0;D<F.length;D++){var E=[];var B=s(I,F[D]);for(var C=0;C<B.length;C++){var H=b(I,B[C]);var z=this.getGeneralSubtree(H);E.push(z)}var J=I.substr(F[D],2);if(J=="a0"){K.permit=E}else{if(J=="a1"){K.exclude=E}}}return K};this.getGeneralSubtree=function(F){var D=s(F,0);var C=D.length;if(C<1||2<C){throw new Error("wrong num elements")}var B=this.getGeneralName(b(F,D[0]));for(var E=1;E<C;E++){var A=F.substr(D[E],2);var z=k(F,D[E]);var G=parseInt(z,16);if(A=="80"){B.min=G}if(A=="81"){B.max=G}}return B};this.getExtKeyUsage=function(A,C){var B=this.getCriticalExtV("keyUsage",A,C);A=B[0];C=B[1];if(A==null){return undefined}var z={extname:"keyUsage"};if(C){z.critical=true}z.names=this.getExtKeyUsageString(A).split(",");return z};this.getExtKeyUsageBin=function(A){if(A===undefined){var B=this.getExtInfo("keyUsage");if(B===undefined){return""}A=b(this.hex,B.vidx)}if(A.length!=8&&A.length!=10){throw new Error("malformed key usage value: "+A)}var z="000000000000000"+parseInt(A.substr(6),16).toString(2);if(A.length==8){z=z.slice(-8)}if(A.length==10){z=z.slice(-16)}z=z.replace(/0+$/,"");if(z==""){z="0"}return z};this.getExtKeyUsageString=function(B){var C=this.getExtKeyUsageBin(B);var z=new Array();for(var A=0;A<C.length;A++){if(C.substr(A,1)=="1"){z.push(X509.KEYUSAGE_NAME[A])}}return z.join(",")};this.getExtSubjectKeyIdentifier=function(B,D){if(B===undefined&&D===undefined){var C=this.getExtInfo("subjectKeyIdentifier");if(C===undefined){return undefined}B=b(this.hex,C.vidx);D=C.critical}var z={extname:"subjectKeyIdentifier"};if(D){z.critical=true}var A=k(B,0);z.kid={hex:A};return z};this.getExtAuthorityKeyIdentifier=function(F,D){if(F===undefined&&D===undefined){var z=this.getExtInfo("authorityKeyIdentifier");if(z===undefined){return undefined}F=b(this.hex,z.vidx);D=z.critical}var G={extname:"authorityKeyIdentifier"};if(D){G.critical=true}var E=s(F,0);for(var A=0;A<E.length;A++){var H=F.substr(E[A],2);if(H==="80"){G.kid={hex:k(F,E[A])}}if(H==="a1"){var C=b(F,E[A]);var B=this.getGeneralNames(C);G.issuer=B[0]["dn"]}if(H==="82"){G.sn={hex:k(F,E[A])}}}return G};this.getExtExtKeyUsage=function(C,E){if(C===undefined&&E===undefined){var D=this.getExtInfo("extKeyUsage");if(D===undefined){return undefined}C=b(this.hex,D.vidx);E=D.critical}var z={extname:"extKeyUsage",array:[]};if(E){z.critical=true}var A=s(C,0);for(var B=0;B<A.length;B++){z.array.push(u(k(C,A[B])))}return z};this.getExtExtKeyUsageName=function(){var D=this.getExtInfo("extKeyUsage");if(D===undefined){return D}var z=new Array();var C=b(this.hex,D.vidx);if(C===""){return z}var A=s(C,0);for(var B=0;B<A.length;B++){z.push(u(k(C,A[B])))}return z};this.getExtSubjectAltName=function(A,C){if(A===undefined&&C===undefined){var B=this.getExtInfo("subjectAltName");if(B===undefined){return undefined}A=b(this.hex,B.vidx);C=B.critical}var z={extname:"subjectAltName",array:[]};if(C){z.critical=true}z.array=this.getGeneralNames(A);return z};this.getExtIssuerAltName=function(A,C){if(A===undefined&&C===undefined){var B=this.getExtInfo("issuerAltName");if(B===undefined){return undefined}A=b(this.hex,B.vidx);C=B.critical}var z={extname:"issuerAltName",array:[]};if(C){z.critical=true}z.array=this.getGeneralNames(A);return z};this.getGeneralNames=function(D){var B=s(D,0);var z=[];for(var C=0;C<B.length;C++){var A=this.getGeneralName(b(D,B[C]));if(A!==undefined){z.push(A)}}return z};this.getGeneralName=function(A){var z=A.substr(0,2);var C=k(A,0);var B=hextorstr(C);if(z=="81"){return{rfc822:B}}if(z=="82"){return{dns:B}}if(z=="86"){return{uri:B}}if(z=="87"){return{ip:hextoip(C)}}if(z=="a4"){return{dn:this.getX500Name(C)}}if(z=="a0"){return{other:this.getOtherName(A)}}return undefined};this.getExtSubjectAltName2=function(){var D,G,F;var E=this.getExtInfo("subjectAltName");if(E===undefined){return E}var z=new Array();var C=b(this.hex,E.vidx);var A=s(C,0);for(var B=0;B<A.length;B++){F=C.substr(A[B],2);D=k(C,A[B]);if(F==="81"){G=hextoutf8(D);z.push(["MAIL",G])}if(F==="82"){G=hextoutf8(D);z.push(["DNS",G])}if(F==="84"){G=X509.hex2dn(D,0);z.push(["DN",G])}if(F==="86"){G=hextoutf8(D);z.push(["URI",G])}if(F==="87"){G=hextoip(D);z.push(["IP",G])}}return z};this.getExtCRLDistributionPoints=function(D,F){if(D===undefined&&F===undefined){var E=this.getExtInfo("cRLDistributionPoints");if(E===undefined){return undefined}D=b(this.hex,E.vidx);F=E.critical}var A={extname:"cRLDistributionPoints",array:[]};if(F){A.critical=true}var B=s(D,0);for(var C=0;C<B.length;C++){var z=b(D,B[C]);A.array.push(this.getDistributionPoint(z))}return A};this.getDistributionPoint=function(E){var B={};var C=s(E,0);for(var D=0;D<C.length;D++){var A=E.substr(C[D],2);var z=b(E,C[D]);if(A=="a0"){B.dpname=this.getDistributionPointName(z)}}return B};this.getDistributionPointName=function(E){var B={};var C=s(E,0);for(var D=0;D<C.length;D++){var A=E.substr(C[D],2);var z=b(E,C[D]);if(A=="a0"){B.full=this.getGeneralNames(z)}}return B};this.getExtCRLDistributionPointsURI=function(){var D=this.getExtCRLDistributionPoints();if(D==undefined){return D}var A=D.array;var z=[];for(var C=0;C<A.length;C++){try{if(A[C].dpname.full[0].uri!=undefined){z.push(A[C].dpname.full[0].uri)}}catch(B){}}return z};this.getExtAIAInfo=function(){var D=this.getExtInfo("authorityInfoAccess");if(D===undefined){return D}var z={ocsp:[],caissuer:[]};var A=s(this.hex,D.vidx);for(var B=0;B<A.length;B++){var E=c(this.hex,A[B],[0],"06");var C=c(this.hex,A[B],[1],"86");if(E==="2b06010505073001"){z.ocsp.push(hextoutf8(C))}if(E==="2b06010505073002"){z.caissuer.push(hextoutf8(C))}}return z};this.getExtAuthorityInfoAccess=function(G,E){if(G===undefined&&E===undefined){var z=this.getExtInfo("authorityInfoAccess");if(z===undefined){return undefined}G=b(this.hex,z.vidx);E=z.critical}var H={extname:"authorityInfoAccess",array:[]};if(E){H.critical=true}var F=s(G,0);for(var A=0;A<F.length;A++){var D=p(G,F[A],[0],"06");var B=c(G,F[A],[1],"86");var C=hextoutf8(B);if(D=="2b06010505073001"){H.array.push({ocsp:C})}else{if(D=="2b06010505073002"){H.array.push({caissuer:C})}else{throw new Error("unknown method: "+D)}}}return H};this.getExtCertificatePolicies=function(D,G){if(D===undefined&&G===undefined){var F=this.getExtInfo("certificatePolicies");if(F===undefined){return undefined}D=b(this.hex,F.vidx);G=F.critical}var z={extname:"certificatePolicies",array:[]};if(G){z.critical=true}var A=s(D,0);for(var B=0;B<A.length;B++){var E=b(D,A[B]);var C=this.getPolicyInformation(E);z.array.push(C)}return z};this.getPolicyInformation=function(D){var z={};var F=c(D,0,[0],"06");z.policyoid=u(F);var G=f(D,0,[1],"30");if(G!=-1){z.array=[];var A=s(D,G);for(var B=0;B<A.length;B++){var E=b(D,A[B]);var C=this.getPolicyQualifierInfo(E);z.array.push(C)}}return z};this.getOtherName=function(B){var z={};var A=s(B,0);var D=c(B,A[0],[],"06");var C=c(B,A[1],[]);z.oid=u(D);z.value=j(C);return z};this.getPolicyQualifierInfo=function(A){var z={};var B=c(A,0,[0],"06");if(B==="2b06010505070201"){var D=p(A,0,[1],"16");z.cps=hextorstr(D)}else{if(B==="2b06010505070202"){var C=a(A,0,[1],"30");z.unotice=this.getUserNotice(C)}}return z};this.getUserNotice=function(B){var D=null;var z={};try{D=o.parse(B);var C=this._asn1ToUnotice(D);return C}catch(A){return undefined}};this._asn1ToUnotice=function(E){try{var z={};var A=aryval(E,"seq");for(var C=0;C<A.length;C++){var D=this._asn1ToNoticeRef(A[C]);if(D!=undefined){z.noticeref=D}var F=this.asn1ToDisplayText(A[C]);if(F!=undefined){z.exptext=F}}if(Object.keys(z).length>0){return z}return undefined}catch(B){return undefined}};this._asn1ToNoticeRef=function(F){try{var A={};var B=aryval(F,"seq");for(var D=0;D<B.length;D++){var E=this._asn1ToNoticeNum(B[D]);if(E!=undefined){A.noticenum=E}var z=this.asn1ToDisplayText(B[D]);if(z!=undefined){A.org=z}}if(Object.keys(A).length>0){return A}return undefined}catch(C){return undefined}};this._asn1ToNoticeNum=function(E){try{var A=aryval(E,"seq");var z=[];for(var C=0;C<A.length;C++){var D=A[C];z.push(parseInt(aryval(D,"int.hex"),16))}return z}catch(B){return undefined}};this.getDisplayText=function(A){var B={"0c":"utf8","16":"ia5","1a":"vis","1e":"bmp"};var z={};z.type=B[A.substr(0,2)];z.str=hextorstr(k(A,0));return z};this.asn1ToDisplayText=function(z){if(z.utf8str!=undefined){return{type:"utf8",str:z.utf8str.str}}if(z.ia5str!=undefined){return{type:"ia5",str:z.ia5str.str}}if(z.visstr!=undefined){return{type:"vis",str:z.visstr.str}}if(z.bmpstr!=undefined){return{type:"bmp",str:z.bmpstr.str}}if(z.prnstr!=undefined){return{type:"prn",str:z.prnstr.str}}return undefined};this.getExtPolicyMappings=function(G,E){var z=this.getCriticalExtV("policyMappings",G,E);G=z[0];E=z[1];if(G==null){return undefined}var I={extname:"policyMappings"};if(E){I.critical=true}try{var A=j(G);var B=A.seq;var F=[];for(var C=0;C<B.length;C++){var H=B[C].seq;F.push([H[0].oid,H[1].oid])}I.array=F}catch(D){throw new m("malformed policyMappings")}return I};this.getExtPolicyConstraints=function(G,D){var z=this.getCriticalExtV("policyConstraints",G,D);G=z[0];D=z[1];if(G==null){return undefined}var H={extname:"policyConstraints"};if(D){H.critical=true}var A=j(G);try{var F=A.seq;for(var B=0;B<F.length;B++){var E=F[B].tag;if(E.explicit!=false){continue}if(E.tag=="80"){H.reqexp=parseInt(E.hex,16)}if(E.tag=="81"){H.inhibit=parseInt(E.hex,16)}}}catch(C){return new m("malformed policyConstraints value")}return H};this.getExtInhibitAnyPolicy=function(A,D){var C=this.getCriticalExtV("inhibitAnyPolicy",A,D);A=C[0];D=C[1];if(A==null){return undefined}var z={extname:"inhibitAnyPolicy"};if(D){z.critical=true}var B=x(A,0);if(B==-1){return new m("wrong value")}z.skip=B;return z};this.getExtCRLNumber=function(A,B){var z={extname:"cRLNumber"};if(B){z.critical=true}if(A.substr(0,2)=="02"){z.num={hex:k(A,0)};return z}throw new m("hExtV parse error: "+A)};this.getExtCRLReason=function(A,B){var z={extname:"cRLReason"};if(B){z.critical=true}if(A.substr(0,2)=="0a"){z.code=parseInt(k(A,0),16);return z}throw new Error("hExtV parse error: "+A)};this.getExtOcspNonce=function(A,C){var z={extname:"ocspNonce"};if(C){z.critical=true}var B=k(A,0);z.hex=B;return z};this.getExtOcspNoCheck=function(A,B){var z={extname:"ocspNoCheck"};if(B){z.critical=true}return z};this.getExtAdobeTimeStamp=function(C,F){if(C===undefined&&F===undefined){var E=this.getExtInfo("adobeTimeStamp");if(E===undefined){return undefined}C=b(this.hex,E.vidx);F=E.critical}var z={extname:"adobeTimeStamp"};if(F){z.critical=true}var B=s(C,0);if(B.length>1){var G=b(C,B[1]);var A=this.getGeneralName(G);if(A.uri!=undefined){z.uri=A.uri}}if(B.length>2){var D=b(C,B[2]);if(D=="0101ff"){z.reqauth=true}if(D=="010100"){z.reqauth=false}}return z};var e=function(E){var z={};try{var B=E.seq[0].oid;var D=KJUR.asn1.x509.OID.name2oid(B);z.type=KJUR.asn1.x509.OID.oid2atype(D);var A=E.seq[1];if(A.utf8str!=undefined){z.ds="utf8";z.value=A.utf8str.str}else{if(A.numstr!=undefined){z.ds="num";z.value=A.numstr.str}else{if(A.telstr!=undefined){z.ds="tel";z.value=A.telstr.str}else{if(A.prnstr!=undefined){z.ds="prn";z.value=A.prnstr.str}else{if(A.ia5str!=undefined){z.ds="ia5";z.value=A.ia5str.str}else{if(A.visstr!=undefined){z.ds="vis";z.value=A.visstr.str}else{if(A.bmpstr!=undefined){z.ds="bmp";z.value=A.bmpstr.str}else{throw"error"}}}}}}}return z}catch(C){throw new Erorr("improper ASN.1 parsed AttrTypeAndValue")}};var i=function(A){try{return A.set.map(function(B){return e(B)})}catch(z){throw new Error("improper ASN.1 parsed RDN: "+z)}};var h=function(A){try{return A.seq.map(function(B){return i(B)})}catch(z){throw new Error("improper ASN.1 parsed X500Name: "+z)}};this.getX500NameRule=function(z){var G=true;var K=true;var J=false;var A="";var D="";var M=null;var H=[];for(var C=0;C<z.length;C++){var E=z[C];for(var B=0;B<E.length;B++){H.push(E[B])}}for(var C=0;C<H.length;C++){var L=H[C];var N=L.ds;var I=L.value;var F=L.type;A+=":"+N;if(N!="prn"&&N!="utf8"&&N!="ia5"){return"mixed"}if(N=="ia5"){if(F!="CN"){return"mixed"}else{if(!KJUR.lang.String.isMail(I)){return"mixed"}else{continue}}}if(F=="C"){if(N=="prn"){continue}else{return"mixed"}}D+=":"+N;if(M==null){M=N}else{if(M!==N){return"mixed"}}}if(M==null){return"prn"}else{return M}};this.getAttrTypeAndValue=function(z){var A=j(z);return e(A)};this.getRDN=function(z){var A=j(z);return i(A)};this.getX500NameArray=function(z){var A=j(z);return h(A)};this.getX500Name=function(C,E,D){var A=this.getX500NameArray(C);var B=this.dnarraytostr(A);var z={str:B};z.array=A;if(D==true){z.hex=C}if(E==true){z.canon=this.c14nRDNArray(A)}return z};this.readCertPEM=function(z){this.readCertHex(w(z))};this.readCertHex=function(z){this.hex=z;this.getVersion();try{l(this.hex,0,[0,7],"a3");this.parseExt()}catch(A){}};this.getParam=function(A){var z={};if(A==undefined){A={}}z.version=this.getVersion();z.serial={hex:this.getSerialNumberHex()};z.sigalg=this.getSignatureAlgorithmField();z.issuer=this.getIssuer(A.dncanon,A.dnhex);z.notbefore=this.getNotBefore();z.notafter=this.getNotAfter();z.subject=this.getSubject(A.dncanon,A.dnhex);z.sbjpubkey=hextopem(this.getPublicKeyHex(),"PUBLIC KEY");if(this.aExtInfo!=undefined&&this.aExtInfo.length>0){z.ext=this.getExtParamArray()}z.sighex=this.getSignatureValueHex();if(A.tbshex==true){z.tbshex=a(this.hex,0,[0])}if(A.nodnarray==true){delete z.issuer.array;delete z.subject.array}return z};this.getExtParamArray=function(A){if(A==undefined){var C=f(this.hex,0,[0,"[3]"]);if(C!=-1){A=q(this.hex,0,[0,"[3]",0],"30")}}var z=[];var B=s(A,0);for(var D=0;D<B.length;D++){var F=b(A,B[D]);var E=this.getExtParam(F);if(E!=null){z.push(E)}}return z};this.getExtParam=function(A){var H={};var C=s(A,0);var D=C.length;if(D!=2&&D!=3){throw new Error("wrong number elements in Extension: "+D+" "+A)}var B=r(c(A,0,[0],"06"));var F=false;if(D==3&&a(A,0,[1])=="0101ff"){F=true}var G=a(A,0,[D-1,0]);var E=undefined;if(B=="2.5.29.14"){E=this.getExtSubjectKeyIdentifier(G,F)}else{if(B=="2.5.29.15"){E=this.getExtKeyUsage(G,F)}else{if(B=="2.5.29.17"){E=this.getExtSubjectAltName(G,F)}else{if(B=="2.5.29.18"){E=this.getExtIssuerAltName(G,F)}else{if(B=="2.5.29.19"){E=this.getExtBasicConstraints(G,F)}else{if(B=="2.5.29.30"){E=this.getExtNameConstraints(G,F)}else{if(B=="2.5.29.31"){E=this.getExtCRLDistributionPoints(G,F)}else{if(B=="2.5.29.32"){E=this.getExtCertificatePolicies(G,F)}else{if(B=="2.5.29.33"){E=this.getExtPolicyMappings(G,F)}else{if(B=="2.5.29.35"){E=this.getExtAuthorityKeyIdentifier(G,F)}else{if(B=="2.5.29.36"){E=this.getExtPolicyConstraints(G,F)}else{if(B=="2.5.29.37"){E=this.getExtExtKeyUsage(G,F)}else{if(B=="2.5.29.54"){E=this.getExtInhibitAnyPolicy(G,F)}else{if(B=="1.3.6.1.5.5.7.1.1"){E=this.getExtAuthorityInfoAccess(G,F)}else{if(B=="2.5.29.20"){E=this.getExtCRLNumber(G,F)}else{if(B=="2.5.29.21"){E=this.getExtCRLReason(G,F)}else{if(B=="1.3.6.1.5.5.7.48.1.2"){E=this.getExtOcspNonce(G,F)}else{if(B=="1.3.6.1.5.5.7.48.1.5"){E=this.getExtOcspNoCheck(G,F)}else{if(B=="1.2.840.113583.1.1.9.1"){E=this.getExtAdobeTimeStamp(G,F)}else{if(X509.EXT_PARSER[B]!=undefined){E=X509.EXT_PARSER[B](B,F,G)}}}}}}}}}}}}}}}}}}}}if(E!=undefined){return E}var z={extname:B,extn:G};if(F){z.critical=true}return z};this.findExt=function(A,B){for(var z=0;z<A.length;z++){if(A[z].extname==B){return A[z]}}return null};this.updateExtCDPFullURI=function(D,z){var C=this.findExt(D,"cRLDistributionPoints");if(C==null){return}if(C.array==undefined){return}var F=C.array;for(var B=0;B<F.length;B++){if(F[B].dpname==undefined){continue}if(F[B].dpname.full==undefined){continue}var G=F[B].dpname.full;for(var A=0;A<G.length;A++){var E=G[B];if(E.uri==undefined){continue}E.uri=z}}};this.updateExtAIAOCSP=function(D,A){var C=this.findExt(D,"authorityInfoAccess");if(C==null){return}if(C.array==undefined){return}var z=C.array;for(var B=0;B<z.length;B++){if(z[B].ocsp!=undefined){z[B].ocsp=A}}};this.updateExtAIACAIssuer=function(D,A){var C=this.findExt(D,"authorityInfoAccess");if(C==null){return}if(C.array==undefined){return}var z=C.array;for(var B=0;B<z.length;B++){if(z[B].caissuer!=undefined){z[B].caissuer=A}}};this.dnarraytostr=function(B){function z(C){return C.map(function(D){return A(D).replace(/\+/,"\\+")}).join("+")}function A(C){return C.type+"="+C.value}return"/"+B.map(function(C){return z(C).replace(/\//,"\\/")}).join("/")};this.setCanonicalizedDN=function(A){var C;if(A.str!=undefined&&A.array==undefined){var B=new KJUR.asn1.x509.X500Name({str:A.str});var z=B.tohex();C=this.getX500NameArray(z)}else{C=A.array}if(A.canon==undefined){A.canon=this.c14nRDNArray(C)}};this.c14nRDNArray=function(G){var A=[];for(var C=0;C<G.length;C++){var E=G[C];var z=[];for(var B=0;B<E.length;B++){var D=E[B];var F=D.value;F=F.replace(/^\s*/,"");F=F.replace(/\s*$/,"");F=F.replace(/\s+/g," ");F=F.toLowerCase();z.push(D.type.toLowerCase()+"="+F)}A.push(z.join("+"))}return"/"+A.join("/")};this.getInfo=function(){var A=function(W){var ac="";var U="    ";var Y="\n";var Z=W.array;for(var X=0;X<Z.length;X++){var V=Z[X];if(V.dn!=undefined){ac+=U+"dn: "+V.dn.str+Y}if(V.ip!=undefined){ac+=U+"ip: "+V.ip+Y}if(V.rfc822!=undefined){ac+=U+"rfc822: "+V.rfc822+Y}if(V.dns!=undefined){ac+=U+"dns: "+V.dns+Y}if(V.uri!=undefined){ac+=U+"uri: "+V.uri+Y}if(V.other!=undefined){var ab=V.other.oid;var aa=JSON.stringify(V.other.value).replace(/\"/g,"");ac+=U+"other: "+ab+"="+aa+Y}}ac=ac.replace(/\n$/,"");return ac};var H=function(aa){var Y="";var U=aa.array;for(var X=0;X<U.length;X++){var Z=U[X];Y+="    policy oid: "+Z.policyoid+"\n";if(Z.array===undefined){continue}for(var W=0;W<Z.array.length;W++){var V=Z.array[W];if(V.cps!==undefined){Y+="    cps: "+V.cps+"\n"}}}return Y};var K=function(Y){var X="";var U=Y.array;for(var W=0;W<U.length;W++){var Z=U[W];try{if(Z.dpname.full[0].uri!==undefined){X+="    "+Z.dpname.full[0].uri+"\n"}}catch(V){}try{if(Z.dname.full[0].dn.hex!==undefined){X+="    "+X509.hex2dn(Z.dpname.full[0].dn.hex)+"\n"}}catch(V){}}return X};var I=function(Y){var X="";var U=Y.array;for(var V=0;V<U.length;V++){var W=U[V];if(W.caissuer!==undefined){X+="    caissuer: "+W.caissuer+"\n"}if(W.ocsp!==undefined){X+="    ocsp: "+W.ocsp+"\n"}}return X};var B=X509;var M,L,T;M="Basic Fields\n";M+="  serial number: "+this.getSerialNumberHex()+"\n";M+="  signature algorithm: "+this.getSignatureAlgorithmField()+"\n";M+="  issuer: "+this.getIssuerString()+"\n";M+="  notBefore: "+this.getNotBefore()+"\n";M+="  notAfter: "+this.getNotAfter()+"\n";M+="  subject: "+this.getSubjectString()+"\n";M+="  subject public key info: \n";L=this.getPublicKey();M+="    key algorithm: "+L.type+"\n";if(L.type==="RSA"){M+="    n="+hextoposhex(L.n.toString(16)).substr(0,16)+"...\n";M+="    e="+hextoposhex(L.e.toString(16))+"\n"}T=this.aExtInfo;if(T!==undefined&&T!==null){M+="X509v3 Extensions:\n";for(var P=0;P<T.length;P++){var R=T[P];var z=KJUR.asn1.x509.OID.oid2name(R.oid);if(z===""){z=R.oid}var O="";if(R.critical===true){O="CRITICAL"}M+="  "+z+" "+O+":\n";if(z==="basicConstraints"){var C=this.getExtBasicConstraints();if(C.cA===undefined){M+="    {}\n"}else{M+="    cA=true";if(C.pathLen!==undefined){M+=", pathLen="+C.pathLen}M+="\n"}}else{if(z=="policyMappings"){var S=this.getExtPolicyMappings().array;var G=S.map(function(U){var V=U;return V[0]+":"+V[1]}).join(", ");M+="    "+G+"\n"}else{if(z=="policyConstraints"){var N=this.getExtPolicyConstraints();M+="    ";if(N.reqexp!=undefined){M+=" reqexp="+N.reqexp}if(N.inhibit!=undefined){M+=" inhibit="+N.inhibit}M+="\n"}else{if(z=="inhibitAnyPolicy"){var N=this.getExtInhibitAnyPolicy();M+="    skip="+N.skip+"\n"}else{if(z=="keyUsage"){M+="    "+this.getExtKeyUsageString()+"\n"}else{if(z=="subjectKeyIdentifier"){M+="    "+this.getExtSubjectKeyIdentifier().kid.hex+"\n"}else{if(z=="authorityKeyIdentifier"){var D=this.getExtAuthorityKeyIdentifier();if(D.kid!==undefined){M+="    kid="+D.kid.hex+"\n"}}else{if(z=="extKeyUsage"){var Q=this.getExtExtKeyUsage().array;M+="    "+Q.join(", ")+"\n"}else{if(z=="subjectAltName"){var E=A(this.getExtSubjectAltName());M+=E+"\n"}else{if(z=="cRLDistributionPoints"){var J=this.getExtCRLDistributionPoints();M+=K(J)}else{if(z=="authorityInfoAccess"){var F=this.getExtAuthorityInfoAccess();M+=I(F)}else{if(z=="certificatePolicies"){M+=H(this.getExtCertificatePolicies())}}}}}}}}}}}}}}M+="signature algorithm: "+this.getSignatureAlgorithmName()+"\n";M+="signature: "+this.getSignatureValueHex().substr(0,16)+"...\n";return M};if(typeof v=="string"){if(v.indexOf("-----BEGIN")!=-1){this.readCertPEM(v)}else{if(KJUR.lang.String.isHex(v)){this.readCertHex(v)}}}}X509.EXT_PARSER={};X509.registExtParser=function(b,a){X509.EXT_PARSER[b]=a};X509.hex2dn=function(e,b){if(b===undefined){b=0}var a=new X509();var c=ASN1HEX.getTLV(e,b);var d=a.getX500Name(e);return d.str};X509.hex2rdn=function(f,b){if(b===undefined){b=0}if(f.substr(b,2)!=="31"){throw new Error("malformed RDN")}var c=new Array();var d=ASN1HEX.getChildIdx(f,b);for(var e=0;e<d.length;e++){c.push(X509.hex2attrTypeValue(f,d[e]))}c=c.map(function(a){return a.replace("+","\\+")});return c.join("+")};X509.hex2attrTypeValue=function(d,i){var j=ASN1HEX;var h=j.getV;if(i===undefined){i=0}if(d.substr(i,2)!=="30"){throw new Error("malformed attribute type and value")}var g=j.getChildIdx(d,i);if(g.length!==2||d.substr(g[0],2)!=="06"){"malformed attribute type and value"}var b=h(d,g[0]);var f=KJUR.asn1.ASN1Util.oidHexToInt(b);var e=KJUR.asn1.x509.OID.oid2atype(f);var a=h(d,g[1]);var c=hextorstr(a);return e+"="+c};X509.getPublicKeyFromCertHex=function(b){var a=new X509();a.readCertHex(b);return a.getPublicKey()};X509.getPublicKeyFromCertPEM=function(b){var a=new X509();a.readCertPEM(b);return a.getPublicKey()};X509.getPublicKeyInfoPropOfCertPEM=function(c){var e=ASN1HEX;var g=e.getVbyList;var b={};var a,f,d;b.algparam=null;a=new X509();a.readCertPEM(c);f=a.getPublicKeyHex();b.keyhex=g(f,0,[1],"03").substr(2);b.algoid=g(f,0,[0,0],"06");if(b.algoid==="2a8648ce3d0201"){b.algparam=g(f,0,[0,1],"06")}return b};X509.KEYUSAGE_NAME=["digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly"];
var X509CRL=function(e){var a=KJUR,f=a.lang.String.isHex,m=ASN1HEX,k=m.getV,b=m.getTLV,h=m.getVbyList,c=m.getTLVbyList,d=m.getTLVbyListEx,i=m.getIdxbyList,g=m.getIdxbyListEx,l=m.getChildIdx,j=new X509();this.hex=null;this.posSigAlg=null;this.posRevCert=null;this.parsed=null;this._setPos=function(){var o=i(this.hex,0,[0,0]);var n=this.hex.substr(o,2);if(n=="02"){this.posSigAlg=1}else{if(n=="30"){this.posSigAlg=0}else{throw new Error("malformed 1st item of TBSCertList: "+n)}}var s=i(this.hex,0,[0,this.posSigAlg+3]);var r=this.hex.substr(s,2);if(r=="17"||r=="18"){var q,p;q=i(this.hex,0,[0,this.posSigAlg+4]);this.posRevCert=null;if(q!=-1){p=this.hex.substr(q,2);if(p=="30"){this.posRevCert=this.posSigAlg+4}}}else{if(r=="30"){this.posRevCert=this.posSigAlg+3}else{if(r=="a0"){this.posRevCert=null}else{throw new Error("malformed nextUpdate or revCert tag: "+r)}}}};this.getVersion=function(){if(this.posSigAlg==0){return null}return parseInt(h(this.hex,0,[0,0],"02"),16)+1};this.getSignatureAlgorithmField=function(){var n=c(this.hex,0,[0,this.posSigAlg],"30");return j.getAlgorithmIdentifierName(n)};this.getIssuer=function(){return j.getX500Name(this.getIssuerHex())};this.getIssuerHex=function(){return c(this.hex,0,[0,this.posSigAlg+1],"30")};this.getThisUpdate=function(){var n=h(this.hex,0,[0,this.posSigAlg+2]);return result=hextorstr(n)};this.getNextUpdate=function(){var o=i(this.hex,0,[0,this.posSigAlg+3]);var n=this.hex.substr(o,2);if(n!="17"&&n!="18"){return null}return hextorstr(k(this.hex,o))};this.getRevCertArray=function(){if(this.posRevCert==null){return null}var o=[];var n=i(this.hex,0,[0,this.posRevCert]);var p=l(this.hex,n);for(var q=0;q<p.length;q++){var r=b(this.hex,p[q]);o.push(this.getRevCert(r))}return o};this.getRevCert=function(p){var o={};var n=l(p,0);o.sn={hex:h(p,0,[0],"02")};o.date=hextorstr(h(p,0,[1]));if(n.length==3){o.ext=j.getExtParamArray(c(p,0,[2]))}return o};this.findRevCert=function(p){var n=new X509(p);var o=n.getSerialNumberHex();return this.findRevCertBySN(o)};this.findRevCertBySN=function(o){if(this.parsed==null){this.getParam()}if(this.parsed.revcert==null){return null}var n=this.parsed.revcert;for(var p=0;p<n.length;p++){if(o==n[p].sn.hex){return n[p]}}return null};this.getSignatureValueHex=function(){return h(this.hex,0,[2],"03",true)};this.verifySignature=function(o){var p=this.getSignatureAlgorithmField();var n=this.getSignatureValueHex();var q=c(this.hex,0,[0],"30");var r=new KJUR.crypto.Signature({alg:p});r.init(o);r.updateHex(q);return r.verify(n)};this.getParam=function(r){var n={};var p=this.getVersion();if(p!=null){n.version=p}n.sigalg=this.getSignatureAlgorithmField();n.issuer=this.getIssuer();n.thisupdate=this.getThisUpdate();var q=this.getNextUpdate();if(q!=null){n.nextupdate=q}var t=this.getRevCertArray();if(t!=null){n.revcert=t}var s=g(this.hex,0,[0,"[0]"]);if(s!=-1){var o=d(this.hex,0,[0,"[0]",0]);n.ext=j.getExtParamArray(o)}n.sighex=this.getSignatureValueHex();this.parsed=n;if(typeof r=="object"){if(r.tbshex==true){n.tbshex=c(this.hex,0,[0])}if(r.nodnarray==true){delete n.issuer.array}}return n};if(typeof e=="string"){if(f(e)){this.hex=e}else{if(e.match(/-----BEGIN X509 CRL/)){this.hex=pemtohex(e)}}this._setPos()}};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={}}KJUR.jws.JWS=function(){var b=KJUR,a=b.jws.JWS,c=a.isSafeJSONString;this.parseJWS=function(g,j){if((this.parsedJWS!==undefined)&&(j||(this.parsedJWS.sigvalH!==undefined))){return}var i=g.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);if(i==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}var k=i[1];var e=i[2];var l=i[3];var n=k+"."+e;this.parsedJWS={};this.parsedJWS.headB64U=k;this.parsedJWS.payloadB64U=e;this.parsedJWS.sigvalB64U=l;this.parsedJWS.si=n;if(!j){var h=b64utohex(l);var f=parseBigInt(h,16);this.parsedJWS.sigvalH=h;this.parsedJWS.sigvalBI=f}var d=b64utoutf8(k);var m=b64utoutf8(e);this.parsedJWS.headS=d;this.parsedJWS.payloadS=m;if(!c(d,this.parsedJWS,"headP")){throw"malformed JSON string for JWS Head: "+d}}};KJUR.jws.JWS.sign=function(j,w,z,A,a){var x=KJUR,n=x.jws,r=n.JWS,h=r.readSafeJSONString,q=r.isSafeJSONString,d=x.crypto,l=d.ECDSA,p=d.Mac,c=d.Signature,u=JSON;var t,k,o;if(typeof w!="string"&&typeof w!="object"){throw"spHeader must be JSON string or object: "+w}if(typeof w=="object"){k=w;t=u.stringify(k)}if(typeof w=="string"){t=w;if(!q(t)){throw"JWS Head is not safe JSON string: "+t}k=h(t)}o=z;if(typeof z=="object"){o=u.stringify(z)}if((j==""||j==null)&&k.alg!==undefined){j=k.alg}if((j!=""&&j!=null)&&k.alg===undefined){k.alg=j;t=u.stringify(k)}if(j!==k.alg){throw"alg and sHeader.alg doesn't match: "+j+"!="+k.alg}var s=null;if(r.jwsalg2sigalg[j]===undefined){throw"unsupported alg name: "+j}else{s=r.jwsalg2sigalg[j]}var e=utf8tob64u(t);var m=utf8tob64u(o);var b=e+"."+m;var y="";if(s.substr(0,4)=="Hmac"){if(A===undefined){throw"mac key shall be specified for HS* alg"}var i=new p({alg:s,prov:"cryptojs",pass:A});i.updateString(b);y=i.doFinal()}else{if(s.indexOf("withECDSA")!=-1){var f=new c({alg:s});f.init(A,a);f.updateString(b);var g=f.sign();y=KJUR.crypto.ECDSA.asn1SigToConcatSig(g)}else{if(s!="none"){var f=new c({alg:s});f.init(A,a);f.updateString(b);y=f.sign()}}}var v=hextob64u(y);return b+"."+v};KJUR.jws.JWS.verify=function(w,B,n){var x=KJUR,q=x.jws,t=q.JWS,i=t.readSafeJSONString,e=x.crypto,p=e.ECDSA,s=e.Mac,d=e.Signature,m;if(typeof RSAKey!==undefined){m=RSAKey}if(!isBase64URLDot(w)){return false}var y=w.split(".");if(y.length!==3){return false}var f=y[0];var r=y[1];var c=f+"."+r;var A=b64utohex(y[2]);var l=i(b64utoutf8(y[0]));var k=null;var z=null;if(l.alg===undefined){throw"algorithm not specified in header"}else{k=l.alg;z=k.substr(0,2)}if(n!=null&&Object.prototype.toString.call(n)==="[object Array]"&&n.length>0){var b=":"+n.join(":")+":";if(b.indexOf(":"+k+":")==-1){throw"algorithm '"+k+"' not accepted in the list"}}if(k!="none"&&B===null){throw"key shall be specified to verify."}if(typeof B=="string"&&B.indexOf("-----BEGIN ")!=-1){B=KEYUTIL.getKey(B)}if(z=="RS"||z=="PS"){if(!(B instanceof m)){throw"key shall be a RSAKey obj for RS* and PS* algs"}}if(z=="ES"){if(!(B instanceof p)){throw"key shall be a ECDSA obj for ES* algs"}}if(k=="none"){}var u=null;if(t.jwsalg2sigalg[l.alg]===undefined){throw"unsupported alg name: "+k}else{u=t.jwsalg2sigalg[k]}if(u=="none"){throw"not supported"}else{if(u.substr(0,4)=="Hmac"){var o=null;if(B===undefined){throw"hexadecimal key shall be specified for HMAC"}var j=new s({alg:u,pass:B});j.updateString(c);o=j.doFinal();return A==o}else{if(u.indexOf("withECDSA")!=-1){var h=null;try{h=p.concatSigToASN1Sig(A)}catch(v){return false}var g=new d({alg:u});g.init(B);g.updateString(c);return g.verify(h)}else{var g=new d({alg:u});g.init(B);g.updateString(c);return g.verify(A)}}}};KJUR.jws.JWS.parse=function(g){var c=g.split(".");var b={};var f,e,d;if(c.length!=2&&c.length!=3){throw"malformed sJWS: wrong number of '.' splitted elements"}f=c[0];e=c[1];if(c.length==3){d=c[2]}b.headerObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f));b.payloadObj=KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e));b.headerPP=JSON.stringify(b.headerObj,null,"  ");if(b.payloadObj==null){b.payloadPP=b64utoutf8(e)}else{b.payloadPP=JSON.stringify(b.payloadObj,null,"  ")}if(d!==undefined){b.sigHex=b64utohex(d)}return b};KJUR.jws.JWS.verifyJWT=function(e,l,r){var d=KJUR,j=d.jws,o=j.JWS,n=o.readSafeJSONString,p=o.inArray,f=o.includedArray;if(!isBase64URLDot(e)){return false}var k=e.split(".");if(k.length!=3){return false}var c=k[0];var i=k[1];var q=c+"."+i;var m=b64utohex(k[2]);var h=n(b64utoutf8(c));var g=n(b64utoutf8(i));if(h.alg===undefined){return false}if(r.alg===undefined){throw"acceptField.alg shall be specified"}if(!p(h.alg,r.alg)){return false}if(g.iss!==undefined&&typeof r.iss==="object"){if(!p(g.iss,r.iss)){return false}}if(g.sub!==undefined&&typeof r.sub==="object"){if(!p(g.sub,r.sub)){return false}}if(g.aud!==undefined&&typeof r.aud==="object"){if(typeof g.aud=="string"){if(!p(g.aud,r.aud)){return false}}else{if(typeof g.aud=="object"){if(!f(g.aud,r.aud)){return false}}}}var b=j.IntDate.getNow();if(r.verifyAt!==undefined&&typeof r.verifyAt==="number"){b=r.verifyAt}if(r.gracePeriod===undefined||typeof r.gracePeriod!=="number"){r.gracePeriod=0}if(g.exp!==undefined&&typeof g.exp=="number"){if(g.exp+r.gracePeriod<b){return false}}if(g.nbf!==undefined&&typeof g.nbf=="number"){if(b<g.nbf-r.gracePeriod){return false}}if(g.iat!==undefined&&typeof g.iat=="number"){if(b<g.iat-r.gracePeriod){return false}}if(g.jti!==undefined&&r.jti!==undefined){if(g.jti!==r.jti){return false}}if(!o.verify(e,l,r.alg)){return false}return true};KJUR.jws.JWS.includedArray=function(b,a){var c=KJUR.jws.JWS.inArray;if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var d=0;d<b.length;d++){if(!c(b[d],a)){return false}}return true};KJUR.jws.JWS.inArray=function(d,b){if(b===null){return false}if(typeof b!=="object"){return false}if(typeof b.length!=="number"){return false}for(var c=0;c<b.length;c++){if(b[c]==d){return true}}return false};KJUR.jws.JWS.jwsalg2sigalg={HS256:"HmacSHA256",HS384:"HmacSHA384",HS512:"HmacSHA512",RS256:"SHA256withRSA",RS384:"SHA384withRSA",RS512:"SHA512withRSA",ES256:"SHA256withECDSA",ES384:"SHA384withECDSA",ES512:"SHA512withECDSA",PS256:"SHA256withRSAandMGF1",PS384:"SHA384withRSAandMGF1",PS512:"SHA512withRSAandMGF1",none:"none",};KJUR.jws.JWS.isSafeJSONString=function(c,b,d){var e=null;try{e=jsonParse(c);if(typeof e!="object"){return 0}if(e.constructor===Array){return 0}if(b){b[d]=e}return 1}catch(a){return 0}};KJUR.jws.JWS.readSafeJSONString=function(b){var c=null;try{c=jsonParse(b);if(typeof c!="object"){return null}if(c.constructor===Array){return null}return c}catch(a){return null}};KJUR.jws.JWS.getEncodedSignatureValueFromJWS=function(b){var a=b.match(/^[^.]+\.[^.]+\.([^.]+)$/);if(a==null){throw"JWS signature is not a form of 'Head.Payload.SigValue'."}return a[1]};KJUR.jws.JWS.getJWKthumbprint=function(d){if(d.kty!=="RSA"&&d.kty!=="EC"&&d.kty!=="oct"){throw"unsupported algorithm for JWK Thumprint"}var a="{";if(d.kty==="RSA"){if(typeof d.n!="string"||typeof d.e!="string"){throw"wrong n and e value for RSA key"}a+='"e":"'+d.e+'",';a+='"kty":"'+d.kty+'",';a+='"n":"'+d.n+'"}'}else{if(d.kty==="EC"){if(typeof d.crv!="string"||typeof d.x!="string"||typeof d.y!="string"){throw"wrong crv, x and y value for EC key"}a+='"crv":"'+d.crv+'",';a+='"kty":"'+d.kty+'",';a+='"x":"'+d.x+'",';a+='"y":"'+d.y+'"}'}else{if(d.kty==="oct"){if(typeof d.k!="string"){throw"wrong k value for oct(symmetric) key"}a+='"kty":"'+d.kty+'",';a+='"k":"'+d.k+'"}'}}}var b=rstrtohex(a);var c=KJUR.crypto.Util.hashHex(b,"sha256");var e=hextob64u(c);return e};KJUR.jws.IntDate={};KJUR.jws.IntDate.get=function(c){var b=KJUR.jws.IntDate,d=b.getNow,a=b.getZulu;if(c=="now"){return d()}else{if(c=="now + 1hour"){return d()+60*60}else{if(c=="now + 1day"){return d()+60*60*24}else{if(c=="now + 1month"){return d()+60*60*24*30}else{if(c=="now + 1year"){return d()+60*60*24*365}else{if(c.match(/Z$/)){return a(c)}else{if(c.match(/^[0-9]+$/)){return parseInt(c)}}}}}}}throw"unsupported format: "+c};KJUR.jws.IntDate.getZulu=function(a){return zulutosec(a)};KJUR.jws.IntDate.getNow=function(){var a=~~(new Date()/1000);return a};KJUR.jws.IntDate.intDate2UTCString=function(a){var b=new Date(a*1000);return b.toUTCString()};KJUR.jws.IntDate.intDate2Zulu=function(e){var i=new Date(e*1000),h=("0000"+i.getUTCFullYear()).slice(-4),g=("00"+(i.getUTCMonth()+1)).slice(-2),b=("00"+i.getUTCDate()).slice(-2),a=("00"+i.getUTCHours()).slice(-2),c=("00"+i.getUTCMinutes()).slice(-2),f=("00"+i.getUTCSeconds()).slice(-2);return h+g+b+a+c+f+"Z"};
if(typeof KJUR=="undefined"||!KJUR){KJUR={}}if(typeof KJUR.jws=="undefined"||!KJUR.jws){KJUR.jws={}}KJUR.jws.JWSJS=function(){var c=KJUR,b=c.jws,a=b.JWS,d=a.readSafeJSONString;this.aHeader=[];this.sPayload="";this.aSignature=[];this.init=function(){this.aHeader=[];this.sPayload=undefined;this.aSignature=[]};this.initWithJWS=function(f){this.init();var e=f.split(".");if(e.length!=3){throw"malformed input JWS"}this.aHeader.push(e[0]);this.sPayload=e[1];this.aSignature.push(e[2])};this.addSignature=function(e,h,m,k){if(this.sPayload===undefined||this.sPayload===null){throw"there's no JSON-JS signature to add."}var l=this.aHeader.length;if(this.aHeader.length!=this.aSignature.length){throw"aHeader.length != aSignature.length"}try{var f=KJUR.jws.JWS.sign(e,h,this.sPayload,m,k);var j=f.split(".");var n=j[0];var g=j[2];this.aHeader.push(j[0]);this.aSignature.push(j[2])}catch(i){if(this.aHeader.length>l){this.aHeader.pop()}if(this.aSignature.length>l){this.aSignature.pop()}throw"addSignature failed: "+i}};this.verifyAll=function(h){if(this.aHeader.length!==h.length||this.aSignature.length!==h.length){return false}for(var g=0;g<h.length;g++){var f=h[g];if(f.length!==2){return false}var e=this.verifyNth(g,f[0],f[1]);if(e===false){return false}}return true};this.verifyNth=function(f,j,g){if(this.aHeader.length<=f||this.aSignature.length<=f){return false}var h=this.aHeader[f];var k=this.aSignature[f];var l=h+"."+this.sPayload+"."+k;var e=false;try{e=a.verify(l,j,g)}catch(i){return false}return e};this.readJWSJS=function(g){if(typeof g==="string"){var f=d(g);if(f==null){throw"argument is not safe JSON object string"}this.aHeader=f.headers;this.sPayload=f.payload;this.aSignature=f.signatures}else{try{if(g.headers.length>0){this.aHeader=g.headers}else{throw"malformed header"}if(typeof g.payload==="string"){this.sPayload=g.payload}else{throw"malformed signatures"}if(g.signatures.length>0){this.aSignature=g.signatures}else{throw"malformed signatures"}}catch(e){throw"malformed JWS-JS JSON object: "+e}}};this.getJSON=function(){return{headers:this.aHeader,payload:this.sPayload,signatures:this.aSignature}};this.isEmpty=function(){if(this.aHeader.length==0){return 1}return 0}};
exports.SecureRandom = SecureRandom;
exports.rng_seed_time = rng_seed_time;

exports.BigInteger = BigInteger;
exports.RSAKey = RSAKey;
exports.ECDSA = KJUR.crypto.ECDSA;
exports.DSA = KJUR.crypto.DSA;
exports.Signature = KJUR.crypto.Signature;
exports.MessageDigest = KJUR.crypto.MessageDigest;
exports.Mac = KJUR.crypto.Mac;
exports.Cipher = KJUR.crypto.Cipher;
exports.KEYUTIL = KEYUTIL;
exports.ASN1HEX = ASN1HEX;
exports.X509 = X509;
exports.X509CRL = X509CRL;
exports.CryptoJS = CryptoJS;

// ext/base64.js
exports.b64tohex = b64tohex;
exports.b64toBA = b64toBA;

// ext/ec*.js
exports.ECFieldElementFp = ECFieldElementFp;
exports.ECPointFp = ECPointFp;
exports.ECCurveFp = ECCurveFp;

// base64x.js
exports.stoBA = stoBA;
exports.BAtos = BAtos;
exports.BAtohex = BAtohex;
exports.stohex = stohex;
exports.stob64 = stob64;
exports.stob64u = stob64u;
exports.b64utos = b64utos;
exports.b64tob64u = b64tob64u;
exports.b64utob64 = b64utob64;
exports.hex2b64 = hex2b64;
exports.hextob64u = hextob64u;
exports.b64utohex = b64utohex;
exports.utf8tob64u = utf8tob64u;
exports.b64utoutf8 = b64utoutf8;
exports.utf8tob64 = utf8tob64;
exports.b64toutf8 = b64toutf8;
exports.utf8tohex = utf8tohex;
exports.hextoutf8 = hextoutf8;
exports.hextorstr = hextorstr;
exports.rstrtohex = rstrtohex;
exports.hextob64 = hextob64;
exports.hextob64nl = hextob64nl;
exports.b64nltohex = b64nltohex;
exports.hextopem = hextopem;
exports.pemtohex = pemtohex;
exports.hextoArrayBuffer = hextoArrayBuffer;
exports.ArrayBuffertohex = ArrayBuffertohex;
exports.zulutomsec = zulutomsec;
exports.msectozulu = msectozulu;
exports.zulutosec = zulutosec;
exports.zulutodate = zulutodate;
exports.datetozulu = datetozulu;
exports.uricmptohex = uricmptohex;
exports.hextouricmp = hextouricmp;
exports.ipv6tohex = ipv6tohex;
exports.hextoipv6 = hextoipv6;
exports.hextoip = hextoip;
exports.iptohex = iptohex;
exports.ucs2hextoutf8 = ucs2hextoutf8;
exports.encodeURIComponentAll = encodeURIComponentAll;
exports.newline_toUnix = newline_toUnix;
exports.newline_toDos = newline_toDos;
exports.hextoposhex = hextoposhex;
exports.intarystrtohex = intarystrtohex;
exports.strdiffidx = strdiffidx;
exports.oidtohex = oidtohex;
exports.hextooid = hextooid;
exports.strpad = strpad;
exports.bitstrtoint = bitstrtoint;
exports.inttobitstr = inttobitstr;
exports.bitstrtobinstr = bitstrtobinstr;
exports.binstrtobitstr = binstrtobitstr;
exports.isBase64URLDot = isBase64URLDot;
exports.namearraytobinstr = namearraytobinstr;
exports.extendClass = extendClass;
exports.foldnl = foldnl;
exports.b64topem = b64topem;
exports.pemtob64 = pemtob64;
exports.timeogen = timetogen;
exports.aryval = aryval;

// name spaces
exports.KJUR = KJUR;
exports.crypto = KJUR.crypto;
exports.asn1 = KJUR.asn1;
exports.jws = KJUR.jws;
exports.lang = KJUR.lang;

exports.VERSION = VERSION;
exports.VERSION_FULL = VERSION_FULL;




}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":561}],397:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":455,"./_root":492}],398:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":462,"./_hashDelete":463,"./_hashGet":464,"./_hashHas":465,"./_hashSet":466}],399:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":475,"./_listCacheDelete":476,"./_listCacheGet":477,"./_listCacheHas":478,"./_listCacheSet":479}],400:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":455,"./_root":492}],401:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":480,"./_mapCacheDelete":481,"./_mapCacheGet":482,"./_mapCacheHas":483,"./_mapCacheSet":484}],402:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":455,"./_root":492}],403:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":455,"./_root":492}],404:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":399,"./_stackClear":496,"./_stackDelete":497,"./_stackGet":498,"./_stackHas":499,"./_stackSet":500}],405:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":492}],406:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":492}],407:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":455,"./_root":492}],408:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],409:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],410:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],411:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":435,"./_isIndex":470,"./isArguments":506,"./isArray":507,"./isBuffer":510,"./isTypedArray":518}],412:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],413:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;

},{"./_baseAssignValue":418,"./eq":504}],414:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":418,"./eq":504}],415:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":504}],416:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":444,"./keys":519}],417:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":444,"./keysIn":520}],418:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":450}],419:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isMap = require('./isMap'),
    isObject = require('./isObject'),
    isSet = require('./isSet'),
    keys = require('./keys'),
    keysIn = require('./keysIn');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":404,"./_arrayEach":409,"./_assignValue":414,"./_baseAssign":416,"./_baseAssignIn":417,"./_cloneBuffer":438,"./_copyArray":443,"./_copySymbols":445,"./_copySymbolsIn":446,"./_getAllKeys":452,"./_getAllKeysIn":453,"./_getTag":460,"./_initCloneArray":467,"./_initCloneByTag":468,"./_initCloneObject":469,"./isArray":507,"./isBuffer":510,"./isMap":513,"./isObject":514,"./isSet":517,"./keys":519,"./keysIn":520}],420:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":514}],421:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":449}],422:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":412,"./isArray":507}],423:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":405,"./_getRawTag":457,"./_objectToString":489}],424:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":423,"./isObjectLike":515}],425:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

},{"./_getTag":460,"./isObjectLike":515}],426:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":473,"./_toSource":501,"./isFunction":511,"./isObject":514}],427:[function(require,module,exports){
var getTag = require('./_getTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

},{"./_getTag":460,"./isObjectLike":515}],428:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":423,"./isLength":512,"./isObjectLike":515}],429:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":474,"./_nativeKeys":486}],430:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":474,"./_nativeKeysIn":487,"./isObject":514}],431:[function(require,module,exports){
var Stack = require('./_Stack'),
    assignMergeValue = require('./_assignMergeValue'),
    baseFor = require('./_baseFor'),
    baseMergeDeep = require('./_baseMergeDeep'),
    isObject = require('./isObject'),
    keysIn = require('./keysIn'),
    safeGet = require('./_safeGet');

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;

},{"./_Stack":404,"./_assignMergeValue":413,"./_baseFor":421,"./_baseMergeDeep":432,"./_safeGet":493,"./isObject":514,"./keysIn":520}],432:[function(require,module,exports){
var assignMergeValue = require('./_assignMergeValue'),
    cloneBuffer = require('./_cloneBuffer'),
    cloneTypedArray = require('./_cloneTypedArray'),
    copyArray = require('./_copyArray'),
    initCloneObject = require('./_initCloneObject'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLikeObject = require('./isArrayLikeObject'),
    isBuffer = require('./isBuffer'),
    isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isPlainObject = require('./isPlainObject'),
    isTypedArray = require('./isTypedArray'),
    safeGet = require('./_safeGet'),
    toPlainObject = require('./toPlainObject');

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;

},{"./_assignMergeValue":413,"./_cloneBuffer":438,"./_cloneTypedArray":442,"./_copyArray":443,"./_initCloneObject":469,"./_safeGet":493,"./isArguments":506,"./isArray":507,"./isArrayLikeObject":509,"./isBuffer":510,"./isFunction":511,"./isObject":514,"./isPlainObject":516,"./isTypedArray":518,"./toPlainObject":524}],433:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":491,"./_setToString":494,"./identity":505}],434:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":450,"./constant":503,"./identity":505}],435:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],436:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],437:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":406}],438:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":492}],439:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":437}],440:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],441:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":405}],442:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":437}],443:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],444:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":414,"./_baseAssignValue":418}],445:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":444,"./_getSymbols":458}],446:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":444,"./_getSymbolsIn":459}],447:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":492}],448:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":433,"./_isIterateeCall":471}],449:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],450:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":455}],451:[function(require,module,exports){
(function (global){(function (){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],452:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":422,"./_getSymbols":458,"./keys":519}],453:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":422,"./_getSymbolsIn":459,"./keysIn":520}],454:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":472}],455:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":426,"./_getValue":461}],456:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":490}],457:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":405}],458:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":410,"./stubArray":522}],459:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":412,"./_getPrototype":456,"./_getSymbols":458,"./stubArray":522}],460:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":397,"./_Map":400,"./_Promise":402,"./_Set":403,"./_WeakMap":407,"./_baseGetTag":423,"./_toSource":501}],461:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],462:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":485}],463:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],464:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":485}],465:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":485}],466:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":485}],467:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],468:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":437,"./_cloneDataView":439,"./_cloneRegExp":440,"./_cloneSymbol":441,"./_cloneTypedArray":442}],469:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":420,"./_getPrototype":456,"./_isPrototype":474}],470:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],471:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":470,"./eq":504,"./isArrayLike":508,"./isObject":514}],472:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],473:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":447}],474:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],475:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],476:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":415}],477:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":415}],478:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":415}],479:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":415}],480:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":398,"./_ListCache":399,"./_Map":400}],481:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":454}],482:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":454}],483:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":454}],484:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":454}],485:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":455}],486:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":490}],487:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],488:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":451}],489:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],490:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],491:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":408}],492:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":451}],493:[function(require,module,exports){
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;

},{}],494:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":434,"./_shortOut":495}],495:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],496:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":399}],497:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],498:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],499:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],500:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":399,"./_Map":400,"./_MapCache":401}],501:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],502:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":419}],503:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],504:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],505:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],506:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":424,"./isObjectLike":515}],507:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],508:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":511,"./isLength":512}],509:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":508,"./isObjectLike":515}],510:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":492,"./stubFalse":523}],511:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":423,"./isObject":514}],512:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],513:[function(require,module,exports){
var baseIsMap = require('./_baseIsMap'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;

},{"./_baseIsMap":425,"./_baseUnary":436,"./_nodeUtil":488}],514:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],515:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],516:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":423,"./_getPrototype":456,"./isObjectLike":515}],517:[function(require,module,exports){
var baseIsSet = require('./_baseIsSet'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;

},{"./_baseIsSet":427,"./_baseUnary":436,"./_nodeUtil":488}],518:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":428,"./_baseUnary":436,"./_nodeUtil":488}],519:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":411,"./_baseKeys":429,"./isArrayLike":508}],520:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":411,"./_baseKeysIn":430,"./isArrayLike":508}],521:[function(require,module,exports){
var baseMerge = require('./_baseMerge'),
    createAssigner = require('./_createAssigner');

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;

},{"./_baseMerge":431,"./_createAssigner":448}],522:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],523:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],524:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;

},{"./_copyObject":444,"./keysIn":520}],525:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],526:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":564}],527:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],528:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],529:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":561}],530:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":529}],531:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":530,"inherits":394,"safe-buffer":529}],532:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":530,"inherits":394,"safe-buffer":529}],533:[function(require,module,exports){
var defaultPlayerName = 'Player Name';

var adjectives = ["Black","White","Gray","Brown","Red","Pink","Crimson","Carnelian","Orange","Yellow","Ivory","Cream","Green","Viridian","Aquamarine","Cyan","Blue","Cerulean","Azure","Indigo","Navy","Violet","Purple","Lavender","Magenta","Rainbow","Iridescent","Spectrum","Prism","Bold","Vivid","Pale","Clear","Glass","Translucent","Misty","Dark","Light","Gold","Silver","Copper","Bronze","Steel","Iron","Brass","Mercury","Zinc","Chrome","Platinum","Titanium","Nickel","Lead","Pewter","Rust","Metal","Stone","Quartz","Granite","Marble","Alabaster","Agate","Jasper","Pebble","Pyrite","Crystal","Geode","Obsidian","Mica","Flint","Sand","Gravel","Boulder","Basalt","Ruby","Beryl","Scarlet","Citrine","Sulpher","Topaz","Amber","Emerald","Malachite","Jade","Abalone","Lapis","Sapphire","Diamond","Peridot","Gem","Jewel","Bevel","Coral","Jet","Ebony","Wood","Tree","Cherry","Maple","Cedar","Branch","Bramble","Rowan","Ash","Fir","Pine","Cactus","Alder","Grove","Forest","Jungle","Palm","Bush","Mulberry","Juniper","Vine","Ivy","Rose","Lily","Tulip","Daffodil","Honeysuckle","Fuschia","Hazel","Walnut","Almond","Lime","Lemon","Apple","Blossom","Bloom","Crocus","Rose","Buttercup","Dandelion","Iris","Carnation","Fern","Root","Branch","Leaf","Seed","Flower","Petal","Pollen","Orchid","Mangrove","Cypress","Sequoia","Sage","Heather","Snapdragon","Daisy","Mountain","Hill","Alpine","Chestnut","Valley","Glacier","Forest","Grove","Glen","Tree","Thorn","Stump","Desert","Canyon","Dune","Oasis","Mirage","Well","Spring","Meadow","Field","Prairie","Grass","Tundra","Island","Shore","Sand","Shell","Surf","Wave","Foam","Tide","Lake","River","Brook","Stream","Pool","Pond","Sun","Sprinkle","Shade","Shadow","Rain","Cloud","Storm","Hail","Snow","Sleet","Thunder","Lightning","Wind","Hurricane","Typhoon","Dawn","Sunrise","Morning","Noon","Twilight","Evening","Sunset","Midnight","Night","Sky","Star","Stellar","Comet","Nebula","Quasar","Solar","Lunar","Planet","Meteor","Sprout","Pear","Plum","Kiwi","Berry","Apricot","Peach","Mango","Pineapple","Coconut","Olive","Ginger","Root","Plain","Fancy","Stripe","Spot","Speckle","Spangle","Ring","Band","Blaze","Paint","Pinto","Shade","Tabby","Brindle","Patch","Calico","Checker","Dot","Pattern","Glitter","Glimmer","Shimmer","Dull","Dust","Dirt","Glaze","Scratch","Quick","Swift","Fast","Slow","Clever","Fire","Flicker","Flash","Spark","Ember","Coal","Flame","Chocolate","Vanilla","Sugar","Spice","Cake","Pie","Cookie","Candy","Caramel","Spiral","Round","Jelly","Square","Narrow","Long","Short","Small","Tiny","Big","Giant","Great","Atom","Peppermint","Mint","Butter","Fringe","Rag","Quilt","Truth","Lie","Holy","Curse","Noble","Sly","Brave","Shy","Lava","Foul","Leather","Fantasy","Keen","Luminous","Feather","Sticky","Gossamer","Cotton","Rattle","Silk","Satin","Cord","Denim","Flannel","Plaid","Wool","Linen","Silent","Flax","Weak","Valiant","Fierce","Gentle","Rhinestone","Splash","North","South","East","West","Summer","Winter","Autumn","Spring","Season","Equinox","Solstice","Paper","Motley","Torch","Ballistic","Rampant","Shag","Freckle","Wild","Free","Chain","Sheer","Crazy","Mad","Candle","Ribbon","Lace","Notch","Wax","Shine","Shallow","Deep","Bubble","Harvest","Fluff","Venom","Boom","Slash","Rune","Cold","Quill","Love","Hate","Garnet","Zircon","Power","Bone","Void","Horn","Glory","Cyber","Nova","Hot","Helix","Cosmic","Quark","Quiver","Holly","Clover","Polar","Regal","Ripple","Ebony","Wheat","Phantom","Dew","Chisel","Crack","Chatter","Laser","Foil","Tin","Clever","Treasure","Maze","Twisty","Curly","Fortune","Fate","Destiny","Cute","Slime","Ink","Disco","Plume","Time","Psychadelic","Relic","Fossil","Water","Savage","Ancient","Rapid","Road","Trail","Stitch","Button","Bow","Nimble","Zest","Sour","Bitter","Phase","Fan","Frill","Plump","Pickle","Mud","Puddle","Pond","River","Spring","Stream","Battle","Arrow","Plume","Roan","Pitch","Tar","Cat","Dog","Horse","Lizard","Bird","Fish","Saber","Scythe","Sharp","Soft","Razor","Neon","Dandy","Weed","Swamp","Marsh","Bog","Peat","Moor","Muck","Mire","Grave","Fair","Just","Brick","Puzzle","Skitter","Prong","Fork","Dent","Dour","Warp","Luck","Coffee","Split","Chip","Hollow","Heavy","Legend","Hickory","Mesquite","Nettle","Rogue","Charm","Prickle","Bead","Sponge","Whip","Bald","Frost","Fog","Oil","Veil","Cliff","Volcano","Rift","Maze","Proud","Dew","Mirror","Shard","Salt","Pepper","Honey","Thread","Bristle","Ripple","Glow","Zenith"];

var nouns = ["head","crest","crown","tooth","fang","horn","frill","skull","bone","tongue","throat","voice","nose","snout","chin","eye","sight","seer","speaker","singer","song","chanter","howler","chatter","shrieker","shriek","jaw","bite","biter","neck","shoulder","fin","wing","arm","lifter","grasp","grabber","hand","paw","foot","finger","toe","thumb","talon","palm","touch","racer","runner","hoof","fly","flier","swoop","roar","hiss","hisser","snarl","dive","diver","rib","chest","back","ridge","leg","legs","tail","beak","walker","lasher","swisher","carver","kicker","roarer","crusher","spike","shaker","charger","hunter","weaver","crafter","binder","scribe","muse","snap","snapper","slayer","stalker","track","tracker","scar","scarer","fright","killer","death","doom","healer","saver","friend","foe","guardian","thunder","lightning","cloud","storm","forger","scale","hair","braid","nape","belly","thief","stealer","reaper","giver","taker","dancer","player","gambler","twister","turner","painter","dart","drifter","sting","stinger","venom","spur","ripper","swallow","devourer","knight","lady","lord","queen","king","master","mistress","prince","princess","duke","dutchess","samurai","ninja","knave","slave","servant","sage","wizard","witch","warlock","warrior","jester","paladin","bard","trader","sword","shield","knife","dagger","arrow","bow","fighter","bane","follower","leader","scourge","watcher","cat","panther","tiger","cougar","puma","jaguar","ocelot","lynx","lion","leopard","ferret","weasel","wolverine","bear","raccoon","dog","wolf","kitten","puppy","cub","fox","hound","terrier","coyote","hyena","jackal","pig","horse","donkey","stallion","mare","zebra","antelope","gazelle","deer","buffalo","bison","boar","elk","whale","dolphin","shark","fish","minnow","salmon","ray","fisher","otter","gull","duck","goose","crow","raven","bird","eagle","raptor","hawk","falcon","moose","heron","owl","stork","crane","sparrow","robin","parrot","cockatoo","carp","lizard","gecko","iguana","snake","python","viper","boa","condor","vulture","spider","fly","scorpion","heron","oriole","toucan","bee","wasp","hornet","rabbit","bunny","hare","brow","mustang","ox","piper","soarer","flasher","moth","mask","hide","hero","antler","chill","chiller","gem","ogre","myth","elf","fairy","pixie","dragon","griffin","unicorn","pegasus","sprite","fancier","chopper","slicer","skinner","butterfly","legend","wanderer","rover","raver","loon","lancer","glass","glazer","flame","crystal","lantern","lighter","cloak","bell","ringer","keeper","centaur","bolt","catcher","whimsey","quester","rat","mouse","serpent","wyrm","gargoyle","thorn","whip","rider","spirit","sentry","bat","beetle","burn","cowl","stone","gem","collar","mark","grin","scowl","spear","razor","edge","seeker","jay","ape","monkey","gorilla","koala","kangaroo","yak","sloth","ant","roach","weed","seed","eater","razor","shirt","face","goat","mind","shift","rider","face","mole","vole","pirate","llama","stag","bug","cap","boot","drop","hugger","sargent","snagglefoot","carpet","curtain"];

function randomNoun(generator){
    generator = generator || Math.random;

    return nouns[Math.floor(generator()*nouns.length)];
}

function randomAdjective(generator){
    generator = generator || Math.random;

    return adjectives[Math.floor(generator()*adjectives.length)];
}

function generateStupidName(generator){
    var noun1 = randomNoun(generator);
    var noun2 = randomNoun(generator);
    noun2 = noun2.substr(0, 1).toUpperCase() + noun2.substr(1);
    var adjective = randomAdjective(generator);
    return adjective + noun1 + ' ' + noun2;
}

module.exports = generateStupidName;
module.exports.randomNoun = randomNoun;
module.exports.randomAdjective = randomAdjective;

},{}],534:[function(require,module,exports){
"use strict";
/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = void 0;
function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
}
exports.Backoff = Backoff;
/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */
Backoff.prototype.duration = function () {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
};
/**
 * Reset the number of attempts.
 *
 * @api public
 */
Backoff.prototype.reset = function () {
    this.attempts = 0;
};
/**
 * Set the minimum duration
 *
 * @api public
 */
Backoff.prototype.setMin = function (min) {
    this.ms = min;
};
/**
 * Set the maximum duration
 *
 * @api public
 */
Backoff.prototype.setMax = function (max) {
    this.max = max;
};
/**
 * Set the jitter
 *
 * @api public
 */
Backoff.prototype.setJitter = function (jitter) {
    this.jitter = jitter;
};

},{}],535:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.connect = exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;
const url_js_1 = require("./url.js");
const manager_js_1 = require("./manager.js");
Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_js_1.Manager; } });
const socket_js_1 = require("./socket.js");
Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_js_1.Socket; } });
const debug_1 = __importDefault(require("debug")); // debug()
const debug = debug_1.default("socket.io-client"); // debug()
/**
 * Managers cache.
 */
const cache = {};
function lookup(uri, opts) {
    if (typeof uri === "object") {
        opts = uri;
        uri = undefined;
    }
    opts = opts || {};
    const parsed = url_js_1.url(uri, opts.path || "/socket.io");
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew ||
        opts["force new connection"] ||
        false === opts.multiplex ||
        sameNamespace;
    let io;
    if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
    }
    else {
        if (!cache[id]) {
            debug("new io instance for %s", source);
            cache[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache[id];
    }
    if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
    }
    return io.socket(parsed.path, opts);
}
exports.io = lookup;
exports.connect = lookup;
exports.default = lookup;
// so that "lookup" can be used both as a function (e.g. `io(...)`) and as a
// namespace (e.g. `io.connect(...)`), for backward compatibility
Object.assign(lookup, {
    Manager: manager_js_1.Manager,
    Socket: socket_js_1.Socket,
    io: lookup,
    connect: lookup,
});
/**
 * Protocol version.
 *
 * @public
 */
var socket_io_parser_1 = require("socket.io-parser");
Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });

module.exports = lookup;

},{"./manager.js":536,"./socket.js":538,"./url.js":539,"debug":346,"socket.io-parser":541}],536:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Manager = void 0;
const engine_io_client_1 = require("engine.io-client");
const socket_js_1 = require("./socket.js");
const parser = __importStar(require("socket.io-parser"));
const on_js_1 = require("./on.js");
const backo2_js_1 = require("./contrib/backo2.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = debug_1.default("socket.io-client:manager"); // debug()
class Manager extends component_emitter_1.Emitter {
    constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
            opts = uri;
            uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        engine_io_client_1.installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_js_1.Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor(),
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
            this.open();
    }
    reconnection(v) {
        if (!arguments.length)
            return this._reconnection;
        this._reconnection = !!v;
        return this;
    }
    reconnectionAttempts(v) {
        if (v === undefined)
            return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
    }
    reconnectionDelay(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
    }
    randomizationFactor(v) {
        var _a;
        if (v === undefined)
            return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
    }
    reconnectionDelayMax(v) {
        var _a;
        if (v === undefined)
            return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
    }
    timeout(v) {
        if (!arguments.length)
            return this._timeout;
        this._timeout = v;
        return this;
    }
    /**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @private
     */
    maybeReconnectOnOpen() {
        // Only try to reconnect if it's the first time we're connecting
        if (!this._reconnecting &&
            this._reconnection &&
            this.backoff.attempts === 0) {
            // keeps reconnection from firing twice for the same reconnection loop
            this.reconnect();
        }
    }
    /**
     * Sets the current transport `socket`.
     *
     * @param {Function} fn - optional, callback
     * @return self
     * @public
     */
    open(fn) {
        debug("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
            return this;
        debug("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        // emit `open`
        const openSubDestroy = on_js_1.on(socket, "open", function () {
            self.onopen();
            fn && fn();
        });
        // emit `error`
        const errorSub = on_js_1.on(socket, "error", (err) => {
            debug("error");
            self.cleanup();
            self._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
                fn(err);
            }
            else {
                // Only do this if there is no fn to handle the error
                self.maybeReconnectOnOpen();
            }
        });
        if (false !== this._timeout) {
            const timeout = this._timeout;
            debug("connect attempt will timeout after %d", timeout);
            if (timeout === 0) {
                openSubDestroy(); // prevents a race condition with the 'open' event
            }
            // set timer
            const timer = this.setTimeoutFn(() => {
                debug("connect attempt timed out after %d", timeout);
                openSubDestroy();
                socket.close();
                // @ts-ignore
                socket.emit("error", new Error("timeout"));
            }, timeout);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
    }
    /**
     * Alias for open()
     *
     * @return self
     * @public
     */
    connect(fn) {
        return this.open(fn);
    }
    /**
     * Called upon transport open.
     *
     * @private
     */
    onopen() {
        debug("open");
        // clear old subs
        this.cleanup();
        // mark as open
        this._readyState = "open";
        this.emitReserved("open");
        // add new subs
        const socket = this.engine;
        this.subs.push(on_js_1.on(socket, "ping", this.onping.bind(this)), on_js_1.on(socket, "data", this.ondata.bind(this)), on_js_1.on(socket, "error", this.onerror.bind(this)), on_js_1.on(socket, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    /**
     * Called upon a ping.
     *
     * @private
     */
    onping() {
        this.emitReserved("ping");
    }
    /**
     * Called with data.
     *
     * @private
     */
    ondata(data) {
        try {
            this.decoder.add(data);
        }
        catch (e) {
            this.onclose("parse error", e);
        }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */
    ondecoded(packet) {
        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a "parse error"
        engine_io_client_1.nextTick(() => {
            this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
    }
    /**
     * Called upon socket error.
     *
     * @private
     */
    onerror(err) {
        debug("error", err);
        this.emitReserved("error", err);
    }
    /**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @public
     */
    socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
            socket = new socket_js_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
        }
        else if (this._autoConnect && !socket.active) {
            socket.connect();
        }
        return socket;
    }
    /**
     * Called upon a socket close.
     *
     * @param socket
     * @private
     */
    _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
            const socket = this.nsps[nsp];
            if (socket.active) {
                debug("socket %s is still active, skipping close", nsp);
                return;
            }
        }
        this._close();
    }
    /**
     * Writes a packet.
     *
     * @param packet
     * @private
     */
    _packet(packet) {
        debug("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
        }
    }
    /**
     * Clean up transport subscriptions and packet buffer.
     *
     * @private
     */
    cleanup() {
        debug("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
    }
    /**
     * Close the current socket.
     *
     * @private
     */
    _close() {
        debug("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
        if (this.engine)
            this.engine.close();
    }
    /**
     * Alias for close()
     *
     * @private
     */
    disconnect() {
        return this._close();
    }
    /**
     * Called upon engine close.
     *
     * @private
     */
    onclose(reason, description) {
        debug("closed due to %s", reason);
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
        }
    }
    /**
     * Attempt a reconnection.
     *
     * @private
     */
    reconnect() {
        if (this._reconnecting || this.skipReconnect)
            return this;
        const self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
        }
        else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer = this.setTimeoutFn(() => {
                if (self.skipReconnect)
                    return;
                debug("attempting reconnect");
                this.emitReserved("reconnect_attempt", self.backoff.attempts);
                // check again for the case socket closed in above events
                if (self.skipReconnect)
                    return;
                self.open((err) => {
                    if (err) {
                        debug("reconnect attempt error");
                        self._reconnecting = false;
                        self.reconnect();
                        this.emitReserved("reconnect_error", err);
                    }
                    else {
                        debug("reconnect success");
                        self.onreconnect();
                    }
                });
            }, delay);
            if (this.opts.autoUnref) {
                timer.unref();
            }
            this.subs.push(function subDestroy() {
                clearTimeout(timer);
            });
        }
    }
    /**
     * Called upon successful reconnect.
     *
     * @private
     */
    onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
    }
}
exports.Manager = Manager;

},{"./contrib/backo2.js":534,"./on.js":537,"./socket.js":538,"@socket.io/component-emitter":311,"debug":346,"engine.io-client":354,"socket.io-parser":541}],537:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = void 0;
function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
        obj.off(ev, fn);
    };
}
exports.on = on;

},{}],538:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Socket = void 0;
const socket_io_parser_1 = require("socket.io-parser");
const on_js_1 = require("./on.js");
const component_emitter_1 = require("@socket.io/component-emitter");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = debug_1.default("socket.io-client:socket"); // debug()
/**
 * Internal events.
 * These events can't be emitted by the user.
 */
const RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
    newListener: 1,
    removeListener: 1,
});
/**
 * A Socket is the fundamental class for interacting with the server.
 *
 * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.
 *
 * @example
 * const socket = io();
 *
 * socket.on("connect", () => {
 *   console.log("connected");
 * });
 *
 * // send an event to the server
 * socket.emit("foo", "bar");
 *
 * socket.on("foobar", () => {
 *   // an event was received from the server
 * });
 *
 * // upon disconnection
 * socket.on("disconnect", (reason) => {
 *   console.log(`disconnected due to ${reason}`);
 * });
 */
class Socket extends component_emitter_1.Emitter {
    /**
     * `Socket` constructor.
     */
    constructor(io, nsp, opts) {
        super();
        /**
         * Whether the socket is currently connected to the server.
         *
         * @example
         * const socket = io();
         *
         * socket.on("connect", () => {
         *   console.log(socket.connected); // true
         * });
         *
         * socket.on("disconnect", () => {
         *   console.log(socket.connected); // false
         * });
         */
        this.connected = false;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted by the server.
         */
        this.recovered = false;
        /**
         * Buffer for packets received before the CONNECT packet
         */
        this.receiveBuffer = [];
        /**
         * Buffer for packets that will be sent once the socket is connected
         */
        this.sendBuffer = [];
        /**
         * The queue of packets to be sent with retry in case of failure.
         *
         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.
         * @private
         */
        this._queue = [];
        /**
         * A sequence to generate the ID of the {@link QueuedPacket}.
         * @private
         */
        this._queueSeq = 0;
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
            this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect)
            this.open();
    }
    /**
     * Whether the socket is currently disconnected
     *
     * @example
     * const socket = io();
     *
     * socket.on("connect", () => {
     *   console.log(socket.disconnected); // false
     * });
     *
     * socket.on("disconnect", () => {
     *   console.log(socket.disconnected); // true
     * });
     */
    get disconnected() {
        return !this.connected;
    }
    /**
     * Subscribe to open, close and packet events
     *
     * @private
     */
    subEvents() {
        if (this.subs)
            return;
        const io = this.io;
        this.subs = [
            on_js_1.on(io, "open", this.onopen.bind(this)),
            on_js_1.on(io, "packet", this.onpacket.bind(this)),
            on_js_1.on(io, "error", this.onerror.bind(this)),
            on_js_1.on(io, "close", this.onclose.bind(this)),
        ];
    }
    /**
     * Whether the Socket will try to reconnect when its Manager connects or reconnects.
     *
     * @example
     * const socket = io();
     *
     * console.log(socket.active); // true
     *
     * socket.on("disconnect", (reason) => {
     *   if (reason === "io server disconnect") {
     *     // the disconnection was initiated by the server, you need to manually reconnect
     *     console.log(socket.active); // false
     *   }
     *   // else the socket will automatically try to reconnect
     *   console.log(socket.active); // true
     * });
     */
    get active() {
        return !!this.subs;
    }
    /**
     * "Opens" the socket.
     *
     * @example
     * const socket = io({
     *   autoConnect: false
     * });
     *
     * socket.connect();
     */
    connect() {
        if (this.connected)
            return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
            this.io.open(); // ensure open
        if ("open" === this.io._readyState)
            this.onopen();
        return this;
    }
    /**
     * Alias for {@link connect()}.
     */
    open() {
        return this.connect();
    }
    /**
     * Sends a `message` event.
     *
     * This method mimics the WebSocket.send() method.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
     *
     * @example
     * socket.send("hello");
     *
     * // this is equivalent to
     * socket.emit("message", "hello");
     *
     * @return self
     */
    send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
    }
    /**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @example
     * socket.emit("hello", "world");
     *
     * // all serializable datastructures are supported (no need to call JSON.stringify)
     * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
     *
     * // with an acknowledgement from the server
     * socket.emit("hello", "world", (val) => {
     *   // ...
     * });
     *
     * @return self
     */
    emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(args);
            return this;
        }
        const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args,
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        // event ack callback
        if ("function" === typeof args[args.length - 1]) {
            const id = this.ids++;
            debug("emitting packet with ack id %d", id);
            const ack = args.pop();
            this._registerAckCallback(id, ack);
            packet.id = id;
        }
        const isTransportWritable = this.io.engine &&
            this.io.engine.transport &&
            this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
        }
        else if (this.connected) {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        }
        else {
            this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
    }
    /**
     * @private
     */
    _registerAckCallback(id, ack) {
        var _a;
        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
        if (timeout === undefined) {
            this.acks[id] = ack;
            return;
        }
        // @ts-ignore
        const timer = this.io.setTimeoutFn(() => {
            delete this.acks[id];
            for (let i = 0; i < this.sendBuffer.length; i++) {
                if (this.sendBuffer[i].id === id) {
                    debug("removing packet with ack id %d from the buffer", id);
                    this.sendBuffer.splice(i, 1);
                }
            }
            debug("event with ack id %d has timed out after %d ms", id, timeout);
            ack.call(this, new Error("operation has timed out"));
        }, timeout);
        this.acks[id] = (...args) => {
            // @ts-ignore
            this.io.clearTimeoutFn(timer);
            ack.apply(this, [null, ...args]);
        };
    }
    /**
     * Emits an event and waits for an acknowledgement
     *
     * @example
     * // without timeout
     * const response = await socket.emitWithAck("hello", "world");
     *
     * // with a specific timeout
     * try {
     *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
     * } catch (err) {
     *   // the server did not acknowledge the event in the given delay
     * }
     *
     * @return a Promise that will be fulfilled when the server acknowledges the event
     */
    emitWithAck(ev, ...args) {
        // the timeout flag is optional
        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;
        return new Promise((resolve, reject) => {
            args.push((arg1, arg2) => {
                if (withErr) {
                    return arg1 ? reject(arg1) : resolve(arg2);
                }
                else {
                    return resolve(arg1);
                }
            });
            this.emit(ev, ...args);
        });
    }
    /**
     * Add the packet to the queue.
     * @param args
     * @private
     */
    _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
            ack = args.pop();
        }
        const packet = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args,
            flags: Object.assign({ fromQueue: true }, this.flags),
        };
        args.push((err, ...responseArgs) => {
            if (packet !== this._queue[0]) {
                // the packet has already been acknowledged
                return;
            }
            const hasError = err !== null;
            if (hasError) {
                if (packet.tryCount > this._opts.retries) {
                    debug("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
                    this._queue.shift();
                    if (ack) {
                        ack(err);
                    }
                }
            }
            else {
                debug("packet [%d] was successfully sent", packet.id);
                this._queue.shift();
                if (ack) {
                    ack(null, ...responseArgs);
                }
            }
            packet.pending = false;
            return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
    }
    /**
     * Send the first packet of the queue, and wait for an acknowledgement from the server.
     * @param force - whether to resend a packet that has not been acknowledged yet
     *
     * @private
     */
    _drainQueue(force = false) {
        debug("draining queue");
        if (!this.connected || this._queue.length === 0) {
            return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
            debug("packet [%d] has already been sent and is waiting for an ack", packet.id);
            return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug("sending packet [%d] (try n°%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
    }
    /**
     * Sends a packet.
     *
     * @param packet
     * @private
     */
    packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
    }
    /**
     * Called upon engine `open`.
     *
     * @private
     */
    onopen() {
        debug("transport is open - connecting");
        if (typeof this.auth == "function") {
            this.auth((data) => {
                this._sendConnectPacket(data);
            });
        }
        else {
            this._sendConnectPacket(this.auth);
        }
    }
    /**
     * Sends a CONNECT packet to initiate the Socket.IO session.
     *
     * @param data
     * @private
     */
    _sendConnectPacket(data) {
        this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: this._pid
                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)
                : data,
        });
    }
    /**
     * Called upon engine or manager `error`.
     *
     * @param err
     * @private
     */
    onerror(err) {
        if (!this.connected) {
            this.emitReserved("connect_error", err);
        }
    }
    /**
     * Called upon engine `close`.
     *
     * @param reason
     * @param description
     * @private
     */
    onclose(reason, description) {
        debug("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
    }
    /**
     * Called with socket packet.
     *
     * @param packet
     * @private
     */
    onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
            return;
        switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
                if (packet.data && packet.data.sid) {
                    this.onconnect(packet.data.sid, packet.data.pid);
                }
                else {
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
            case socket_io_parser_1.PacketType.EVENT:
            case socket_io_parser_1.PacketType.BINARY_EVENT:
                this.onevent(packet);
                break;
            case socket_io_parser_1.PacketType.ACK:
            case socket_io_parser_1.PacketType.BINARY_ACK:
                this.onack(packet);
                break;
            case socket_io_parser_1.PacketType.DISCONNECT:
                this.ondisconnect();
                break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
                this.destroy();
                const err = new Error(packet.data.message);
                // @ts-ignore
                err.data = packet.data.data;
                this.emitReserved("connect_error", err);
                break;
        }
    }
    /**
     * Called upon a server event.
     *
     * @param packet
     * @private
     */
    onevent(packet) {
        const args = packet.data || [];
        debug("emitting event %j", args);
        if (null != packet.id) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
        }
        if (this.connected) {
            this.emitEvent(args);
        }
        else {
            this.receiveBuffer.push(Object.freeze(args));
        }
    }
    emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, args);
            }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
            this._lastOffset = args[args.length - 1];
        }
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @private
     */
    ack(id) {
        const self = this;
        let sent = false;
        return function (...args) {
            // prevent double callbacks
            if (sent)
                return;
            sent = true;
            debug("sending ack %j", args);
            self.packet({
                type: socket_io_parser_1.PacketType.ACK,
                id: id,
                data: args,
            });
        };
    }
    /**
     * Called upon a server acknowlegement.
     *
     * @param packet
     * @private
     */
    onack(packet) {
        const ack = this.acks[packet.id];
        if ("function" === typeof ack) {
            debug("calling ack %s with %j", packet.id, packet.data);
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
        }
        else {
            debug("bad ack %s", packet.id);
        }
    }
    /**
     * Called upon server connect.
     *
     * @private
     */
    onconnect(id, pid) {
        debug("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid; // defined only if connection state recovery is enabled
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
    }
    /**
     * Emit buffered events (received and emitted).
     *
     * @private
     */
    emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
            this.notifyOutgoingListeners(packet);
            this.packet(packet);
        });
        this.sendBuffer = [];
    }
    /**
     * Called upon server disconnect.
     *
     * @private
     */
    ondisconnect() {
        debug("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
    }
    /**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @private
     */
    destroy() {
        if (this.subs) {
            // clean subscriptions to avoid reconnections
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = undefined;
        }
        this.io["_destroy"](this);
    }
    /**
     * Disconnects the socket manually. In that case, the socket will not try to reconnect.
     *
     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
     *
     * @example
     * const socket = io();
     *
     * socket.on("disconnect", (reason) => {
     *   // console.log(reason); prints "io client disconnect"
     * });
     *
     * socket.disconnect();
     *
     * @return self
     */
    disconnect() {
        if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        // remove socket from pool
        this.destroy();
        if (this.connected) {
            // fire events
            this.onclose("io client disconnect");
        }
        return this;
    }
    /**
     * Alias for {@link disconnect()}.
     *
     * @return self
     */
    close() {
        return this.disconnect();
    }
    /**
     * Sets the compress flag.
     *
     * @example
     * socket.compress(false).emit("hello");
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     */
    compress(compress) {
        this.flags.compress = compress;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
     * ready to send messages.
     *
     * @example
     * socket.volatile.emit("hello"); // the server may or may not receive it
     *
     * @returns self
     */
    get volatile() {
        this.flags.volatile = true;
        return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the server:
     *
     * @example
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the server did not acknowledge the event in the given delay
     *   }
     * });
     *
     * @returns self
     */
    timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @example
     * socket.onAny((event, ...args) => {
     *   console.log(`got ${event}`);
     * });
     *
     * @param listener
     */
    onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @example
     * socket.prependAny((event, ...args) => {
     *   console.log(`got event ${event}`);
     * });
     *
     * @param listener
     */
    prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`got event ${event}`);
     * }
     *
     * socket.onAny(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAny(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAny();
     *
     * @param listener
     */
    offAny(listener) {
        if (!this._anyListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAny() {
        return this._anyListeners || [];
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.onAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * Note: acknowledgements sent to the server are not included.
     *
     * @example
     * socket.prependAnyOutgoing((event, ...args) => {
     *   console.log(`sent event ${event}`);
     * });
     *
     * @param listener
     */
    prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @example
     * const catchAllListener = (event, ...args) => {
     *   console.log(`sent event ${event}`);
     * }
     *
     * socket.onAnyOutgoing(catchAllListener);
     *
     * // remove a specific listener
     * socket.offAnyOutgoing(catchAllListener);
     *
     * // or remove all listeners
     * socket.offAnyOutgoing();
     *
     * @param [listener] - the catch-all listener (optional)
     */
    offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
            return this;
        }
        if (listener) {
            const listeners = this._anyOutgoingListeners;
            for (let i = 0; i < listeners.length; i++) {
                if (listener === listeners[i]) {
                    listeners.splice(i, 1);
                    return this;
                }
            }
        }
        else {
            this._anyOutgoingListeners = [];
        }
        return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     */
    listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
    }
    /**
     * Notify the listeners for each packet sent
     *
     * @param packet
     *
     * @private
     */
    notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const listeners = this._anyOutgoingListeners.slice();
            for (const listener of listeners) {
                listener.apply(this, packet.data);
            }
        }
    }
}
exports.Socket = Socket;

},{"./on.js":537,"@socket.io/component-emitter":311,"debug":346,"socket.io-parser":541}],539:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.url = void 0;
const engine_io_client_1 = require("engine.io-client");
const debug_1 = __importDefault(require("debug")); // debug()
const debug = debug_1.default("socket.io-client:url"); // debug()
/**
 * URL parser.
 *
 * @param uri - url
 * @param path - the request path of the connection
 * @param loc - An object meant to mimic window.location.
 *        Defaults to window.location.
 * @public
 */
function url(uri, path = "", loc) {
    let obj = uri;
    // default to window.location
    loc = loc || (typeof location !== "undefined" && location);
    if (null == uri)
        uri = loc.protocol + "//" + loc.host;
    // relative path support
    if (typeof uri === "string") {
        if ("/" === uri.charAt(0)) {
            if ("/" === uri.charAt(1)) {
                uri = loc.protocol + uri;
            }
            else {
                uri = loc.host + uri;
            }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if ("undefined" !== typeof loc) {
                uri = loc.protocol + "//" + uri;
            }
            else {
                uri = "https://" + uri;
            }
        }
        // parse
        debug("parse %s", uri);
        obj = engine_io_client_1.parse(uri);
    }
    // make sure we treat `localhost:80` and `localhost` equally
    if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
        }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    // define unique id
    obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
    // define href
    obj.href =
        obj.protocol +
            "://" +
            host +
            (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
}
exports.url = url;

},{"debug":346,"engine.io-client":354}],540:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconstructPacket = exports.deconstructPacket = void 0;
const is_binary_js_1 = require("./is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */
function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return { packet: pack, buffers: buffers };
}
exports.deconstructPacket = deconstructPacket;
function _deconstructPacket(data, buffers) {
    if (!data)
        return data;
    if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
    }
    else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
    }
    else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                newData[key] = _deconstructPacket(data[key], buffers);
            }
        }
        return newData;
    }
    return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */
function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    delete packet.attachments; // no longer useful
    return packet;
}
exports.reconstructPacket = reconstructPacket;
function _reconstructPacket(data, buffers) {
    if (!data)
        return data;
    if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === "number" &&
            data.num >= 0 &&
            data.num < buffers.length;
        if (isIndexValid) {
            return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        }
        else {
            throw new Error("illegal attachments");
        }
    }
    else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
        }
    }
    else if (typeof data === "object") {
        for (const key in data) {
            if (Object.prototype.hasOwnProperty.call(data, key)) {
                data[key] = _reconstructPacket(data[key], buffers);
            }
        }
    }
    return data;
}

},{"./is-binary.js":542}],541:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
const component_emitter_1 = require("@socket.io/component-emitter");
const binary_js_1 = require("./binary.js");
const is_binary_js_1 = require("./is-binary.js");
const debug_1 = require("debug"); // debug()
const debug = (0, debug_1.default)("socket.io-parser"); // debug()
/**
 * Protocol version.
 *
 * @public
 */
exports.protocol = 5;
var PacketType;
(function (PacketType) {
    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType[PacketType["EVENT"] = 2] = "EVENT";
    PacketType[PacketType["ACK"] = 3] = "ACK";
    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */
class Encoder {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(replacer) {
        this.replacer = replacer;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(obj) {
        debug("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if ((0, is_binary_js_1.hasBinary)(obj)) {
                return this.encodeAsBinary({
                    type: obj.type === PacketType.EVENT
                        ? PacketType.BINARY_EVENT
                        : PacketType.BINARY_ACK,
                    nsp: obj.nsp,
                    data: obj.data,
                    id: obj.id,
                });
            }
        }
        return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(obj) {
        // first is type
        let str = "" + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT ||
            obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && "/" !== obj.nsp) {
            str += obj.nsp + ",";
        }
        // immediately followed by the id
        if (null != obj.id) {
            str += obj.id;
        }
        // json data
        if (null != obj.data) {
            str += JSON.stringify(obj.data, this.replacer);
        }
        debug("encoded %j as %s", obj, str);
        return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
    }
}
exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */
class Decoder extends component_emitter_1.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(reviver) {
        super();
        this.reviver = reviver;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(obj) {
        let packet;
        if (typeof obj === "string") {
            if (this.reconstructor) {
                throw new Error("got plaintext data when reconstructing a packet");
            }
            packet = this.decodeString(obj);
            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
                // binary packet's json
                this.reconstructor = new BinaryReconstructor(packet);
                // no attachments, labeled binary but no binary data to follow
                if (packet.attachments === 0) {
                    super.emitReserved("decoded", packet);
                }
            }
            else {
                // non-binary full packet
                super.emitReserved("decoded", packet);
            }
        }
        else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
            // raw binary data
            if (!this.reconstructor) {
                throw new Error("got binary data when not reconstructing a packet");
            }
            else {
                packet = this.reconstructor.takeBinaryData(obj);
                if (packet) {
                    // received final buffer
                    this.reconstructor = null;
                    super.emitReserved("decoded", packet);
                }
            }
        }
        else {
            throw new Error("Unknown type: " + obj);
        }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(str) {
        let i = 0;
        // look up type
        const p = {
            type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
            throw new Error("unknown packet type " + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT ||
            p.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) { }
            const buf = str.substring(start, i);
            if (buf != Number(buf) || str.charAt(i) !== "-") {
                throw new Error("Illegal attachments");
            }
            p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ("/" === str.charAt(i + 1)) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if ("," === c)
                    break;
                if (i === str.length)
                    break;
            }
            p.nsp = str.substring(start, i);
        }
        else {
            p.nsp = "/";
        }
        // look up id
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
            const start = i + 1;
            while (++i) {
                const c = str.charAt(i);
                if (null == c || Number(c) != c) {
                    --i;
                    break;
                }
                if (i === str.length)
                    break;
            }
            p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
            const payload = this.tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p.type, payload)) {
                p.data = payload;
            }
            else {
                throw new Error("invalid payload");
            }
        }
        debug("decoded %s as %j", str, p);
        return p;
    }
    tryParse(str) {
        try {
            return JSON.parse(str, this.reviver);
        }
        catch (e) {
            return false;
        }
    }
    static isPayloadValid(type, payload) {
        switch (type) {
            case PacketType.CONNECT:
                return typeof payload === "object";
            case PacketType.DISCONNECT:
                return payload === undefined;
            case PacketType.CONNECT_ERROR:
                return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
                return Array.isArray(payload) && payload.length > 0;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
                return Array.isArray(payload);
        }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
        if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
        }
    }
}
exports.Decoder = Decoder;
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */
class BinaryReconstructor {
    constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
            // done with buffer list
            const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
        }
        return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
    }
}

},{"./binary.js":540,"./is-binary.js":542,"@socket.io/component-emitter":311,"debug":346}],542:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasBinary = exports.isBinary = void 0;
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
    return typeof ArrayBuffer.isView === "function"
        ? ArrayBuffer.isView(obj)
        : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" ||
    (typeof Blob !== "undefined" &&
        toString.call(Blob) === "[object BlobConstructor]");
const withNativeFile = typeof File === "function" ||
    (typeof File !== "undefined" &&
        toString.call(File) === "[object FileConstructor]");
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */
function isBinary(obj) {
    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File));
}
exports.isBinary = isBinary;
function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
        return false;
    }
    if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
                return true;
            }
        }
        return false;
    }
    if (isBinary(obj)) {
        return true;
    }
    if (obj.toJSON &&
        typeof obj.toJSON === "function" &&
        arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
            return true;
        }
    }
    return false;
}
exports.hasBinary = hasBinary;

},{}],543:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"querystringify":527,"requires-port":528}],544:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "v1", {
  enumerable: true,
  get: function () {
    return _v.default;
  }
});
Object.defineProperty(exports, "v3", {
  enumerable: true,
  get: function () {
    return _v2.default;
  }
});
Object.defineProperty(exports, "v4", {
  enumerable: true,
  get: function () {
    return _v3.default;
  }
});
Object.defineProperty(exports, "v5", {
  enumerable: true,
  get: function () {
    return _v4.default;
  }
});
Object.defineProperty(exports, "NIL", {
  enumerable: true,
  get: function () {
    return _nil.default;
  }
});
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _version.default;
  }
});
Object.defineProperty(exports, "validate", {
  enumerable: true,
  get: function () {
    return _validate.default;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
});
Object.defineProperty(exports, "parse", {
  enumerable: true,
  get: function () {
    return _parse.default;
  }
});

var _v = _interopRequireDefault(require("./v1.js"));

var _v2 = _interopRequireDefault(require("./v3.js"));

var _v3 = _interopRequireDefault(require("./v4.js"));

var _v4 = _interopRequireDefault(require("./v5.js"));

var _nil = _interopRequireDefault(require("./nil.js"));

var _version = _interopRequireDefault(require("./version.js"));

var _validate = _interopRequireDefault(require("./validate.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./nil.js":546,"./parse.js":547,"./stringify.js":551,"./v1.js":552,"./v3.js":553,"./v4.js":555,"./v5.js":556,"./validate.js":557,"./version.js":558}],545:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';

  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));

  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

var _default = md5;
exports.default = _default;
},{}],546:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports.default = _default;
},{}],547:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports.default = _default;
},{"./validate.js":557}],548:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports.default = _default;
},{}],549:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);

function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}
},{}],550:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);

  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);

    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }

    M[i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);

    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }

    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }

    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];

    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

var _default = sha1;
exports.default = _default;
},{}],551:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports.default = _default;
},{"./validate.js":557}],552:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports.default = _default;
},{"./rng.js":549,"./stringify.js":551}],553:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _md = _interopRequireDefault(require("./md5.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports.default = _default;
},{"./md5.js":545,"./v35.js":554}],554:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(require("./stringify.js"));

var _parse = _interopRequireDefault(require("./parse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
},{"./parse.js":547,"./stringify.js":551}],555:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rng = _interopRequireDefault(require("./rng.js"));

var _stringify = _interopRequireDefault(require("./stringify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports.default = _default;
},{"./rng.js":549,"./stringify.js":551}],556:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _v = _interopRequireDefault(require("./v35.js"));

var _sha = _interopRequireDefault(require("./sha1.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports.default = _default;
},{"./sha1.js":550,"./v35.js":554}],557:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
},{"./regex.js":548}],558:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
},{"./validate.js":557}],559:[function(require,module,exports){
/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */

const CONTAINER_ID = "containerId";
const LINE_NUMBER_KEY = "lineNumber";
const COLUMN_NUMBER_KEY = "columnNumber";
// eslint-disable-next-line @typescript-eslint/no-var-requires
const tinyliciousClient = require("@fluidframework/tinylicious-client");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const fluid = require("fluid-framework");

async function loadContainer(
    vscode,
    // tinyliciousClient,
    // fluid,
    id,
    line,
    column
) {
    console.log("VSCODE WEBVIEW Inside loadContainer with ", id);
    console.log(`VSCODE WEBVIEW Line: ${line}`);
    console.log(`VSCODE WEBVIEW Column: ${column}`);

    const config = {
        connection: { port: 7070, domain: "http://localhost" },
    };

    const clientProps = {
        connection: config,
    };

    console.log("VSCODE WEBVIEW clientProps: ", clientProps);
    const { TinyliciousClient } = tinyliciousClient;

    console.log("VSCODE WEBVIEW loaded the tiny client object");
    const tinyClient = new TinyliciousClient(clientProps);

    console.log("VSCODE WEBVIEW tiny client created");

    const { SharedMap } = fluid;

    const containerSchema = {
        initialObjects: { position: SharedMap },
    };

    console.log("VSCODE WEBVIEW containerschema creates");

    try {
        const { container } = await tinyClient.getContainer(
            id,
            containerSchema
        );
        const map = container.initialObjects.position;
        const activeEditor = vscode.window.activeTextEditor;

        // Update active editor cursor location based on the container parameters
        if (activeEditor) {
            const newPosition = new vscode.Position(
                map.get(LINE_NUMBER_KEY),
                map.get(COLUMN_NUMBER_KEY)
            ); // line 3, column 1
            const newSelection = new vscode.Selection(newPosition, newPosition);
            activeEditor.selection = newSelection;
            console.log(
                "VSCODE WEBVIEW New position updated to existing values",
                line,
                column
            );
        }
    } catch (error) {
        console.log(`Error retrieving container: ${error}`);
        console.log(`Creating new container`);

        const { container } = await tinyClient.createContainer(containerSchema);
        const map = container.initialObjects.position;
        map.set(LINE_NUMBER_KEY, line);
        map.set(COLUMN_NUMBER_KEY, column);
        const containerId = await container.attach();
        map.set(CONTAINER_ID, containerId);
        console.log("VSCODE WEBVIEW Sending message back");

        // Send a message to the extension
        await vscode.postMessage({
            containerId: containerId,
            lineNumber: line,
            columnNumber: column,
        });
        console.log(
            "VSCODE WEBVIEW New position updated to new values",
            containerId,
            line,
            column
        );
    }
    // })
    // .catch((error) => {
    //     console.error(error);
    // });
}

function runFluidApp() {
    console.log(`VSCODE WEBVIEW  Running script`);

    // eslint-disable-next-line no-undef
    const vscode = acquireVsCodeApi();

    // require.config({
    //     paths: {
    //         "@fluidframework/tinylicious-client":
    //             "https://unpkg.com/@fluidframework/tinylicious-client@1.3.6/dist/index",
    //         "fluid-framework":
    //             "https://unpkg.com/fluid-framework@1.3.6/dist/index",
    //     },
    // });

    // require([
    //     "@fluidframework/tinylicious-client",
    //     "fluid-framework",
    // ], async function (tinyliciousClient, fluid) {
    console.log("VSCODE WEBVIEW init require module");

    // Listen for messages from the extension
    // eslint-disable-next-line no-undef
    window.addEventListener("message", async (event) => {
        const message = event.data;

        console.log(
            `VSCODE WEBVIEW Received greeting from extension: ${JSON.stringify(
                message
            )}`
        );

        // const { TinyliciousClient } = tinyliciousClient;
        await loadContainer(
            vscode,
            // tinyliciousClient,
            // fluid,
            message.containerId,
            message.lineNumber,
            message.columnNumber
        );
    });
    // });
}

runFluidApp();

},{"@fluidframework/tinylicious-client":287,"fluid-framework":372}],560:[function(require,module,exports){
arguments[4][343][0].apply(exports,arguments)
},{"dup":343}],561:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":560,"buffer":561,"ieee754":563}],562:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],563:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],564:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],565:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],566:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],567:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],568:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":566,"./encode":567}],569:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":570,"punycode":565,"querystring":568}],570:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}]},{},[559]);
